/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, 
Carleton University, Canada
All rights reserved.

Released under New BSD License.
Details at:
   https://svn.gcrc.carleton.ca/nunaliit2/trunk/sdk/license.txt
*/

"use strict";

var nunaliit2;
(function(){
// Define here instead of n2.core.js
if( typeof nunaliit2 !== 'function' ){
	nunaliit2 = function(){};
	if( typeof window !== 'undefined' ){
		window.nunaliit2 = nunaliit2;
	};
};
if( typeof nunaliit2.coreScriptName === 'undefined' ){
	nunaliit2.coreScriptName = 'nunaliit2-debug-il.js';
};
})();

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/handlebars.js

/*!

 handlebars v4.0.5

Copyright (C) 2011-2015 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Handlebars"] = factory();
	else
		root["Handlebars"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _handlebarsRuntime = __webpack_require__(2);

	var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

	// Compiler imports

	var _handlebarsCompilerAst = __webpack_require__(21);

	var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

	var _handlebarsCompilerBase = __webpack_require__(22);

	var _handlebarsCompilerCompiler = __webpack_require__(27);

	var _handlebarsCompilerJavascriptCompiler = __webpack_require__(28);

	var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

	var _handlebarsCompilerVisitor = __webpack_require__(25);

	var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

	var _handlebarsNoConflict = __webpack_require__(20);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	var _create = _handlebarsRuntime2['default'].create;
	function create() {
	  var hb = _create();

	  hb.compile = function (input, options) {
	    return _handlebarsCompilerCompiler.compile(input, options, hb);
	  };
	  hb.precompile = function (input, options) {
	    return _handlebarsCompilerCompiler.precompile(input, options, hb);
	  };

	  hb.AST = _handlebarsCompilerAst2['default'];
	  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
	  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
	  hb.Parser = _handlebarsCompilerBase.parser;
	  hb.parse = _handlebarsCompilerBase.parse;

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst.Visitor = _handlebarsCompilerVisitor2['default'];

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _handlebarsBase = __webpack_require__(4);

	var base = _interopRequireWildcard(_handlebarsBase);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)

	var _handlebarsSafeString = __webpack_require__(18);

	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

	var _handlebarsException = __webpack_require__(6);

	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

	var _handlebarsUtils = __webpack_require__(5);

	var Utils = _interopRequireWildcard(_handlebarsUtils);

	var _handlebarsRuntime = __webpack_require__(19);

	var runtime = _interopRequireWildcard(_handlebarsRuntime);

	var _handlebarsNoConflict = __webpack_require__(20);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();

	  Utils.extend(hb, base);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};

	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }

	    newObj["default"] = obj;
	    return newObj;
	  }
	};

	exports.__esModule = true;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;

	var _utils = __webpack_require__(5);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _helpers = __webpack_require__(7);

	var _decorators = __webpack_require__(15);

	var _logger = __webpack_require__(17);

	var _logger2 = _interopRequireDefault(_logger);

	var VERSION = '4.0.5';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 7;

	exports.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};

	  _helpers.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      _utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (_utils.toString.call(name) === objectType) {
	      _utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      _utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};

	var log = _logger2['default'].log;

	exports.log = log;
	exports.createFrame = _utils.createFrame;
	exports.logger = _logger2['default'];

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	  if (loc) {
	    line = loc.start.line;
	    column = loc.start.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  if (loc) {
	    this.lineNumber = line;
	    this.column = column;
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;

	var _helpersBlockHelperMissing = __webpack_require__(8);

	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

	var _helpersEach = __webpack_require__(9);

	var _helpersEach2 = _interopRequireDefault(_helpersEach);

	var _helpersHelperMissing = __webpack_require__(10);

	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

	var _helpersIf = __webpack_require__(11);

	var _helpersIf2 = _interopRequireDefault(_helpersIf);

	var _helpersLog = __webpack_require__(12);

	var _helpersLog2 = _interopRequireDefault(_helpersLog);

	var _helpersLookup = __webpack_require__(13);

	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

	var _helpersWith = __webpack_require__(14);

	var _helpersWith2 = _interopRequireDefault(_helpersWith);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (_utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = _utils.createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && typeof context === 'object') {
	      if (_utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else {
	        var priorKey = undefined;

	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey !== undefined) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (_utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }

	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;

	    instance.log.apply(instance, args);
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field) {
	    return obj && obj[field];
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!_utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }

	      return fn(context, {
	        data: data,
	        blockParams: _utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;

	var _decoratorsInline = __webpack_require__(16);

	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function (context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = _utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }

	    props.partials[options.args[0]] = options.fn;

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',

	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }

	    return level;
	  },

	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);

	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      if (!console[method]) {
	        // eslint-disable-line no-console
	        method = 'log';
	      }

	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }

	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports['default'] = logger;
	module.exports = exports['default'];

/***/ },
/* 18 */
/***/ function(module, exports) {

	// Build out our basic SafeString type
	'use strict';

	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;

	var _utils = __webpack_require__(5);

	var Utils = _interopRequireWildcard(_utils);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _base = __webpack_require__(4);

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;

	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }

	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }

	      return obj;
	    },

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);

	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = container.merge(options.decorators, env.decorators);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context !== depths[0]) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    options.data = _base.createFrame(options.data);
	    partialBlock = options.data['partial-block'] = options.fn;

	    if (partialBlock.partials) {
	      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
	    }
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}

/***/ },
/* 20 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';

	exports.__esModule = true;

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var AST = {
	  // Public API used to evaluate derived attributes regarding AST nodes
	  helpers: {
	    // a mustache is definitely a helper if:
	    // * it is an eligible helper, and
	    // * it has at least one parameter or hash segment
	    helperExpression: function helperExpression(node) {
	      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
	    },

	    scopedId: function scopedId(path) {
	      return (/^\.|this\b/.test(path.original)
	      );
	    },

	    // an ID is simple if it only has one part, and that part is not
	    // `..` or `this`.
	    simpleId: function simpleId(path) {
	      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
	    }
	  }
	};

	// Must be exported as an object rather than the root of the module as the jison lexer
	// must modify the object to operate properly.
	exports['default'] = AST;
	module.exports = exports['default'];

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	exports.__esModule = true;
	exports.parse = parse;

	var _parser = __webpack_require__(23);

	var _parser2 = _interopRequireDefault(_parser);

	var _whitespaceControl = __webpack_require__(24);

	var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

	var _helpers = __webpack_require__(26);

	var Helpers = _interopRequireWildcard(_helpers);

	var _utils = __webpack_require__(5);

	exports.parser = _parser2['default'];

	var yy = {};
	_utils.extend(yy, Helpers);

	function parse(input, options) {
	  // Just return if an already-compiled AST was passed in.
	  if (input.type === 'Program') {
	    return input;
	  }

	  _parser2['default'].yy = yy;

	  // Altering the shared object here, but this is ok as parser is a sync operation
	  yy.locInfo = function (locInfo) {
	    return new yy.SourceLocation(options && options.srcName, locInfo);
	  };

	  var strip = new _whitespaceControl2['default'](options);
	  return strip.accept(_parser2['default'].parse(input));
	}

/***/ },
/* 23 */
/***/ function(module, exports) {

	/* istanbul ignore next */
	/* Jison generated parser */
	"use strict";

	var handlebars = (function () {
	    var parser = { trace: function trace() {},
	        yy: {},
	        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
	        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
	        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
	        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
	        /**/) {

	            var $0 = $$.length - 1;
	            switch (yystate) {
	                case 1:
	                    return $$[$0 - 1];
	                    break;
	                case 2:
	                    this.$ = yy.prepareProgram($$[$0]);
	                    break;
	                case 3:
	                    this.$ = $$[$0];
	                    break;
	                case 4:
	                    this.$ = $$[$0];
	                    break;
	                case 5:
	                    this.$ = $$[$0];
	                    break;
	                case 6:
	                    this.$ = $$[$0];
	                    break;
	                case 7:
	                    this.$ = $$[$0];
	                    break;
	                case 8:
	                    this.$ = $$[$0];
	                    break;
	                case 9:
	                    this.$ = {
	                        type: 'CommentStatement',
	                        value: yy.stripComment($$[$0]),
	                        strip: yy.stripFlags($$[$0], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 10:
	                    this.$ = {
	                        type: 'ContentStatement',
	                        original: $$[$0],
	                        value: $$[$0],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 11:
	                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 12:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
	                    break;
	                case 13:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
	                    break;
	                case 14:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
	                    break;
	                case 15:
	                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 16:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 17:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 18:
	                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
	                    break;
	                case 19:
	                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
	                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
	                    program.chained = true;

	                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

	                    break;
	                case 20:
	                    this.$ = $$[$0];
	                    break;
	                case 21:
	                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
	                    break;
	                case 22:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 23:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 24:
	                    this.$ = {
	                        type: 'PartialStatement',
	                        name: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        indent: '',
	                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 25:
	                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 26:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
	                    break;
	                case 27:
	                    this.$ = $$[$0];
	                    break;
	                case 28:
	                    this.$ = $$[$0];
	                    break;
	                case 29:
	                    this.$ = {
	                        type: 'SubExpression',
	                        path: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 30:
	                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 31:
	                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 32:
	                    this.$ = yy.id($$[$0 - 1]);
	                    break;
	                case 33:
	                    this.$ = $$[$0];
	                    break;
	                case 34:
	                    this.$ = $$[$0];
	                    break;
	                case 35:
	                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 36:
	                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
	                    break;
	                case 37:
	                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
	                    break;
	                case 38:
	                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
	                    break;
	                case 39:
	                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
	                    break;
	                case 40:
	                    this.$ = $$[$0];
	                    break;
	                case 41:
	                    this.$ = $$[$0];
	                    break;
	                case 42:
	                    this.$ = yy.preparePath(true, $$[$0], this._$);
	                    break;
	                case 43:
	                    this.$ = yy.preparePath(false, $$[$0], this._$);
	                    break;
	                case 44:
	                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
	                    break;
	                case 45:
	                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
	                    break;
	                case 46:
	                    this.$ = [];
	                    break;
	                case 47:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 48:
	                    this.$ = [$$[$0]];
	                    break;
	                case 49:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 50:
	                    this.$ = [];
	                    break;
	                case 51:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 58:
	                    this.$ = [];
	                    break;
	                case 59:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 64:
	                    this.$ = [];
	                    break;
	                case 65:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 70:
	                    this.$ = [];
	                    break;
	                case 71:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 78:
	                    this.$ = [];
	                    break;
	                case 79:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 82:
	                    this.$ = [];
	                    break;
	                case 83:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 86:
	                    this.$ = [];
	                    break;
	                case 87:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 90:
	                    this.$ = [];
	                    break;
	                case 91:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 94:
	                    this.$ = [];
	                    break;
	                case 95:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 98:
	                    this.$ = [$$[$0]];
	                    break;
	                case 99:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 100:
	                    this.$ = [$$[$0]];
	                    break;
	                case 101:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	            }
	        },
	        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
	        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
	        parseError: function parseError(str, hash) {
	            throw new Error(str);
	        },
	        parse: function parse(input) {
	            var self = this,
	                stack = [0],
	                vstack = [null],
	                lstack = [],
	                table = this.table,
	                yytext = "",
	                yylineno = 0,
	                yyleng = 0,
	                recovering = 0,
	                TERROR = 2,
	                EOF = 1;
	            this.lexer.setInput(input);
	            this.lexer.yy = this.yy;
	            this.yy.lexer = this.lexer;
	            this.yy.parser = this;
	            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
	            var yyloc = this.lexer.yylloc;
	            lstack.push(yyloc);
	            var ranges = this.lexer.options && this.lexer.options.ranges;
	            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
	            function popStack(n) {
	                stack.length = stack.length - 2 * n;
	                vstack.length = vstack.length - n;
	                lstack.length = lstack.length - n;
	            }
	            function lex() {
	                var token;
	                token = self.lexer.lex() || 1;
	                if (typeof token !== "number") {
	                    token = self.symbols_[token] || token;
	                }
	                return token;
	            }
	            var symbol,
	                preErrorSymbol,
	                state,
	                action,
	                a,
	                r,
	                yyval = {},
	                p,
	                len,
	                newState,
	                expected;
	            while (true) {
	                state = stack[stack.length - 1];
	                if (this.defaultActions[state]) {
	                    action = this.defaultActions[state];
	                } else {
	                    if (symbol === null || typeof symbol == "undefined") {
	                        symbol = lex();
	                    }
	                    action = table[state] && table[state][symbol];
	                }
	                if (typeof action === "undefined" || !action.length || !action[0]) {
	                    var errStr = "";
	                    if (!recovering) {
	                        expected = [];
	                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
	                            expected.push("'" + this.terminals_[p] + "'");
	                        }
	                        if (this.lexer.showPosition) {
	                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
	                        } else {
	                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
	                        }
	                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
	                    }
	                }
	                if (action[0] instanceof Array && action.length > 1) {
	                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
	                }
	                switch (action[0]) {
	                    case 1:
	                        stack.push(symbol);
	                        vstack.push(this.lexer.yytext);
	                        lstack.push(this.lexer.yylloc);
	                        stack.push(action[1]);
	                        symbol = null;
	                        if (!preErrorSymbol) {
	                            yyleng = this.lexer.yyleng;
	                            yytext = this.lexer.yytext;
	                            yylineno = this.lexer.yylineno;
	                            yyloc = this.lexer.yylloc;
	                            if (recovering > 0) recovering--;
	                        } else {
	                            symbol = preErrorSymbol;
	                            preErrorSymbol = null;
	                        }
	                        break;
	                    case 2:
	                        len = this.productions_[action[1]][1];
	                        yyval.$ = vstack[vstack.length - len];
	                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
	                        if (ranges) {
	                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	                        }
	                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
	                        if (typeof r !== "undefined") {
	                            return r;
	                        }
	                        if (len) {
	                            stack = stack.slice(0, -1 * len * 2);
	                            vstack = vstack.slice(0, -1 * len);
	                            lstack = lstack.slice(0, -1 * len);
	                        }
	                        stack.push(this.productions_[action[1]][0]);
	                        vstack.push(yyval.$);
	                        lstack.push(yyval._$);
	                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	                        stack.push(newState);
	                        break;
	                    case 3:
	                        return true;
	                }
	            }
	            // return true;  // unreachable
	        }
	    };
	    /* Jison generated lexer */
	    var lexer = (function () {
	        var lexer = { EOF: 1,
	            parseError: function parseError(str, hash) {
	                if (this.yy.parser) {
	                    this.yy.parser.parseError(str, hash);
	                } else {
	                    throw new Error(str);
	                }
	            },
	            setInput: function setInput(input) {
	                this._input = input;
	                this._more = this._less = this.done = false;
	                this.yylineno = this.yyleng = 0;
	                this.yytext = this.matched = this.match = '';
	                this.conditionStack = ['INITIAL'];
	                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
	                if (this.options.ranges) this.yylloc.range = [0, 0];
	                this.offset = 0;
	                return this;
	            },
	            input: function input() {
	                var ch = this._input[0];
	                this.yytext += ch;
	                this.yyleng++;
	                this.offset++;
	                this.match += ch;
	                this.matched += ch;
	                var lines = ch.match(/(?:\r\n?|\n).*/g);
	                if (lines) {
	                    this.yylineno++;
	                    this.yylloc.last_line++;
	                } else {
	                    this.yylloc.last_column++;
	                }
	                if (this.options.ranges) this.yylloc.range[1]++;

	                this._input = this._input.slice(1);
	                return ch;
	            },
	            unput: function unput(ch) {
	                var len = ch.length;
	                var lines = ch.split(/(?:\r\n?|\n)/g);

	                this._input = ch + this._input;
	                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	                //this.yyleng -= len;
	                this.offset -= len;
	                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	                this.match = this.match.substr(0, this.match.length - 1);
	                this.matched = this.matched.substr(0, this.matched.length - 1);

	                if (lines.length - 1) this.yylineno -= lines.length - 1;
	                var r = this.yylloc.range;

	                this.yylloc = { first_line: this.yylloc.first_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.first_column,
	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	                };

	                if (this.options.ranges) {
	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	                }
	                return this;
	            },
	            more: function more() {
	                this._more = true;
	                return this;
	            },
	            less: function less(n) {
	                this.unput(this.match.slice(n));
	            },
	            pastInput: function pastInput() {
	                var past = this.matched.substr(0, this.matched.length - this.match.length);
	                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	            },
	            upcomingInput: function upcomingInput() {
	                var next = this.match;
	                if (next.length < 20) {
	                    next += this._input.substr(0, 20 - next.length);
	                }
	                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	            },
	            showPosition: function showPosition() {
	                var pre = this.pastInput();
	                var c = new Array(pre.length + 1).join("-");
	                return pre + this.upcomingInput() + "\n" + c + "^";
	            },
	            next: function next() {
	                if (this.done) {
	                    return this.EOF;
	                }
	                if (!this._input) this.done = true;

	                var token, match, tempMatch, index, col, lines;
	                if (!this._more) {
	                    this.yytext = '';
	                    this.match = '';
	                }
	                var rules = this._currentRules();
	                for (var i = 0; i < rules.length; i++) {
	                    tempMatch = this._input.match(this.rules[rules[i]]);
	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                        match = tempMatch;
	                        index = i;
	                        if (!this.options.flex) break;
	                    }
	                }
	                if (match) {
	                    lines = match[0].match(/(?:\r\n?|\n).*/g);
	                    if (lines) this.yylineno += lines.length;
	                    this.yylloc = { first_line: this.yylloc.last_line,
	                        last_line: this.yylineno + 1,
	                        first_column: this.yylloc.last_column,
	                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
	                    this.yytext += match[0];
	                    this.match += match[0];
	                    this.matches = match;
	                    this.yyleng = this.yytext.length;
	                    if (this.options.ranges) {
	                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
	                    }
	                    this._more = false;
	                    this._input = this._input.slice(match[0].length);
	                    this.matched += match[0];
	                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
	                    if (this.done && this._input) this.done = false;
	                    if (token) return token;else return;
	                }
	                if (this._input === "") {
	                    return this.EOF;
	                } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
	                }
	            },
	            lex: function lex() {
	                var r = this.next();
	                if (typeof r !== 'undefined') {
	                    return r;
	                } else {
	                    return this.lex();
	                }
	            },
	            begin: function begin(condition) {
	                this.conditionStack.push(condition);
	            },
	            popState: function popState() {
	                return this.conditionStack.pop();
	            },
	            _currentRules: function _currentRules() {
	                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	            },
	            topState: function topState() {
	                return this.conditionStack[this.conditionStack.length - 2];
	            },
	            pushState: function begin(condition) {
	                this.begin(condition);
	            } };
	        lexer.options = {};
	        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
	        /**/) {

	            function strip(start, end) {
	                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
	            }

	            var YYSTATE = YY_START;
	            switch ($avoiding_name_collisions) {
	                case 0:
	                    if (yy_.yytext.slice(-2) === "\\\\") {
	                        strip(0, 1);
	                        this.begin("mu");
	                    } else if (yy_.yytext.slice(-1) === "\\") {
	                        strip(0, 1);
	                        this.begin("emu");
	                    } else {
	                        this.begin("mu");
	                    }
	                    if (yy_.yytext) return 15;

	                    break;
	                case 1:
	                    return 15;
	                    break;
	                case 2:
	                    this.popState();
	                    return 15;

	                    break;
	                case 3:
	                    this.begin('raw');return 15;
	                    break;
	                case 4:
	                    this.popState();
	                    // Should be using `this.topState()` below, but it currently
	                    // returns the second top instead of the first top. Opened an
	                    // issue about it at https://github.com/zaach/jison/issues/291
	                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
	                        return 15;
	                    } else {
	                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
	                        return 'END_RAW_BLOCK';
	                    }

	                    break;
	                case 5:
	                    return 15;
	                    break;
	                case 6:
	                    this.popState();
	                    return 14;

	                    break;
	                case 7:
	                    return 65;
	                    break;
	                case 8:
	                    return 68;
	                    break;
	                case 9:
	                    return 19;
	                    break;
	                case 10:
	                    this.popState();
	                    this.begin('raw');
	                    return 23;

	                    break;
	                case 11:
	                    return 55;
	                    break;
	                case 12:
	                    return 60;
	                    break;
	                case 13:
	                    return 29;
	                    break;
	                case 14:
	                    return 47;
	                    break;
	                case 15:
	                    this.popState();return 44;
	                    break;
	                case 16:
	                    this.popState();return 44;
	                    break;
	                case 17:
	                    return 34;
	                    break;
	                case 18:
	                    return 39;
	                    break;
	                case 19:
	                    return 51;
	                    break;
	                case 20:
	                    return 48;
	                    break;
	                case 21:
	                    this.unput(yy_.yytext);
	                    this.popState();
	                    this.begin('com');

	                    break;
	                case 22:
	                    this.popState();
	                    return 14;

	                    break;
	                case 23:
	                    return 48;
	                    break;
	                case 24:
	                    return 73;
	                    break;
	                case 25:
	                    return 72;
	                    break;
	                case 26:
	                    return 72;
	                    break;
	                case 27:
	                    return 87;
	                    break;
	                case 28:
	                    // ignore whitespace
	                    break;
	                case 29:
	                    this.popState();return 54;
	                    break;
	                case 30:
	                    this.popState();return 33;
	                    break;
	                case 31:
	                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
	                    break;
	                case 32:
	                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
	                    break;
	                case 33:
	                    return 85;
	                    break;
	                case 34:
	                    return 82;
	                    break;
	                case 35:
	                    return 82;
	                    break;
	                case 36:
	                    return 83;
	                    break;
	                case 37:
	                    return 84;
	                    break;
	                case 38:
	                    return 81;
	                    break;
	                case 39:
	                    return 75;
	                    break;
	                case 40:
	                    return 77;
	                    break;
	                case 41:
	                    return 72;
	                    break;
	                case 42:
	                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
	                    break;
	                case 43:
	                    return 'INVALID';
	                    break;
	                case 44:
	                    return 5;
	                    break;
	            }
	        };
	        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
	        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
	        return lexer;
	    })();
	    parser.lexer = lexer;
	    function Parser() {
	        this.yy = {};
	    }Parser.prototype = parser;parser.Parser = Parser;
	    return new Parser();
	})();exports.__esModule = true;
	exports['default'] = handlebars;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _visitor = __webpack_require__(25);

	var _visitor2 = _interopRequireDefault(_visitor);

	function WhitespaceControl() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  this.options = options;
	}
	WhitespaceControl.prototype = new _visitor2['default']();

	WhitespaceControl.prototype.Program = function (program) {
	  var doStandalone = !this.options.ignoreStandalone;

	  var isRoot = !this.isRootSeen;
	  this.isRootSeen = true;

	  var body = program.body;
	  for (var i = 0, l = body.length; i < l; i++) {
	    var current = body[i],
	        strip = this.accept(current);

	    if (!strip) {
	      continue;
	    }

	    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
	        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
	        openStandalone = strip.openStandalone && _isPrevWhitespace,
	        closeStandalone = strip.closeStandalone && _isNextWhitespace,
	        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

	    if (strip.close) {
	      omitRight(body, i, true);
	    }
	    if (strip.open) {
	      omitLeft(body, i, true);
	    }

	    if (doStandalone && inlineStandalone) {
	      omitRight(body, i);

	      if (omitLeft(body, i)) {
	        // If we are on a standalone node, save the indent info for partials
	        if (current.type === 'PartialStatement') {
	          // Pull out the whitespace from the final line
	          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
	        }
	      }
	    }
	    if (doStandalone && openStandalone) {
	      omitRight((current.program || current.inverse).body);

	      // Strip out the previous content node if it's whitespace only
	      omitLeft(body, i);
	    }
	    if (doStandalone && closeStandalone) {
	      // Always strip the next node
	      omitRight(body, i);

	      omitLeft((current.inverse || current.program).body);
	    }
	  }

	  return program;
	};

	WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
	  this.accept(block.program);
	  this.accept(block.inverse);

	  // Find the inverse program that is involed with whitespace stripping.
	  var program = block.program || block.inverse,
	      inverse = block.program && block.inverse,
	      firstInverse = inverse,
	      lastInverse = inverse;

	  if (inverse && inverse.chained) {
	    firstInverse = inverse.body[0].program;

	    // Walk the inverse chain to find the last inverse that is actually in the chain.
	    while (lastInverse.chained) {
	      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
	    }
	  }

	  var strip = {
	    open: block.openStrip.open,
	    close: block.closeStrip.close,

	    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
	    // so our parent can determine if we actually are standalone
	    openStandalone: isNextWhitespace(program.body),
	    closeStandalone: isPrevWhitespace((firstInverse || program).body)
	  };

	  if (block.openStrip.close) {
	    omitRight(program.body, null, true);
	  }

	  if (inverse) {
	    var inverseStrip = block.inverseStrip;

	    if (inverseStrip.open) {
	      omitLeft(program.body, null, true);
	    }

	    if (inverseStrip.close) {
	      omitRight(firstInverse.body, null, true);
	    }
	    if (block.closeStrip.open) {
	      omitLeft(lastInverse.body, null, true);
	    }

	    // Find standalone else statments
	    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
	      omitLeft(program.body);
	      omitRight(firstInverse.body);
	    }
	  } else if (block.closeStrip.open) {
	    omitLeft(program.body, null, true);
	  }

	  return strip;
	};

	WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
	  return mustache.strip;
	};

	WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
	  /* istanbul ignore next */
	  var strip = node.strip || {};
	  return {
	    inlineStandalone: true,
	    open: strip.open,
	    close: strip.close
	  };
	};

	function isPrevWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = body.length;
	  }

	  // Nodes that end with newlines are considered whitespace (but are special
	  // cased for strip operations)
	  var prev = body[i - 1],
	      sibling = body[i - 2];
	  if (!prev) {
	    return isRoot;
	  }

	  if (prev.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
	  }
	}
	function isNextWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = -1;
	  }

	  var next = body[i + 1],
	      sibling = body[i + 2];
	  if (!next) {
	    return isRoot;
	  }

	  if (next.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
	  }
	}

	// Marks the node to the right of the position as omitted.
	// I.e. {{foo}}' ' will mark the ' ' node as omitted.
	//
	// If i is undefined, then the first child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitRight(body, i, multiple) {
	  var current = body[i == null ? 0 : i + 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
	    return;
	  }

	  var original = current.value;
	  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
	  current.rightStripped = current.value !== original;
	}

	// Marks the node to the left of the position as omitted.
	// I.e. ' '{{foo}} will mark the ' ' node as omitted.
	//
	// If i is undefined then the last child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitLeft(body, i, multiple) {
	  var current = body[i == null ? body.length - 1 : i - 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
	    return;
	  }

	  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
	  var original = current.value;
	  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
	  current.leftStripped = current.value !== original;
	  return current.leftStripped;
	}

	exports['default'] = WhitespaceControl;
	module.exports = exports['default'];

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	function Visitor() {
	  this.parents = [];
	}

	Visitor.prototype = {
	  constructor: Visitor,
	  mutating: false,

	  // Visits a given value. If mutating, will replace the value if necessary.
	  acceptKey: function acceptKey(node, name) {
	    var value = this.accept(node[name]);
	    if (this.mutating) {
	      // Hacky sanity check: This may have a few false positives for type for the helper
	      // methods but will generally do the right thing without a lot of overhead.
	      if (value && !Visitor.prototype[value.type]) {
	        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
	      }
	      node[name] = value;
	    }
	  },

	  // Performs an accept operation with added sanity check to ensure
	  // required keys are not removed.
	  acceptRequired: function acceptRequired(node, name) {
	    this.acceptKey(node, name);

	    if (!node[name]) {
	      throw new _exception2['default'](node.type + ' requires ' + name);
	    }
	  },

	  // Traverses a given array. If mutating, empty respnses will be removed
	  // for child elements.
	  acceptArray: function acceptArray(array) {
	    for (var i = 0, l = array.length; i < l; i++) {
	      this.acceptKey(array, i);

	      if (!array[i]) {
	        array.splice(i, 1);
	        i--;
	        l--;
	      }
	    }
	  },

	  accept: function accept(object) {
	    if (!object) {
	      return;
	    }

	    /* istanbul ignore next: Sanity code */
	    if (!this[object.type]) {
	      throw new _exception2['default']('Unknown type: ' + object.type, object);
	    }

	    if (this.current) {
	      this.parents.unshift(this.current);
	    }
	    this.current = object;

	    var ret = this[object.type](object);

	    this.current = this.parents.shift();

	    if (!this.mutating || ret) {
	      return ret;
	    } else if (ret !== false) {
	      return object;
	    }
	  },

	  Program: function Program(program) {
	    this.acceptArray(program.body);
	  },

	  MustacheStatement: visitSubExpression,
	  Decorator: visitSubExpression,

	  BlockStatement: visitBlock,
	  DecoratorBlock: visitBlock,

	  PartialStatement: visitPartial,
	  PartialBlockStatement: function PartialBlockStatement(partial) {
	    visitPartial.call(this, partial);

	    this.acceptKey(partial, 'program');
	  },

	  ContentStatement: function ContentStatement() /* content */{},
	  CommentStatement: function CommentStatement() /* comment */{},

	  SubExpression: visitSubExpression,

	  PathExpression: function PathExpression() /* path */{},

	  StringLiteral: function StringLiteral() /* string */{},
	  NumberLiteral: function NumberLiteral() /* number */{},
	  BooleanLiteral: function BooleanLiteral() /* bool */{},
	  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
	  NullLiteral: function NullLiteral() /* literal */{},

	  Hash: function Hash(hash) {
	    this.acceptArray(hash.pairs);
	  },
	  HashPair: function HashPair(pair) {
	    this.acceptRequired(pair, 'value');
	  }
	};

	function visitSubExpression(mustache) {
	  this.acceptRequired(mustache, 'path');
	  this.acceptArray(mustache.params);
	  this.acceptKey(mustache, 'hash');
	}
	function visitBlock(block) {
	  visitSubExpression.call(this, block);

	  this.acceptKey(block, 'program');
	  this.acceptKey(block, 'inverse');
	}
	function visitPartial(partial) {
	  this.acceptRequired(partial, 'name');
	  this.acceptArray(partial.params);
	  this.acceptKey(partial, 'hash');
	}

	exports['default'] = Visitor;
	module.exports = exports['default'];

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.SourceLocation = SourceLocation;
	exports.id = id;
	exports.stripFlags = stripFlags;
	exports.stripComment = stripComment;
	exports.preparePath = preparePath;
	exports.prepareMustache = prepareMustache;
	exports.prepareRawBlock = prepareRawBlock;
	exports.prepareBlock = prepareBlock;
	exports.prepareProgram = prepareProgram;
	exports.preparePartialBlock = preparePartialBlock;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	function validateClose(open, close) {
	  close = close.path ? close.path.original : close;

	  if (open.path.original !== close) {
	    var errorNode = { loc: open.path.loc };

	    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
	  }
	}

	function SourceLocation(source, locInfo) {
	  this.source = source;
	  this.start = {
	    line: locInfo.first_line,
	    column: locInfo.first_column
	  };
	  this.end = {
	    line: locInfo.last_line,
	    column: locInfo.last_column
	  };
	}

	function id(token) {
	  if (/^\[.*\]$/.test(token)) {
	    return token.substr(1, token.length - 2);
	  } else {
	    return token;
	  }
	}

	function stripFlags(open, close) {
	  return {
	    open: open.charAt(2) === '~',
	    close: close.charAt(close.length - 3) === '~'
	  };
	}

	function stripComment(comment) {
	  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
	}

	function preparePath(data, parts, loc) {
	  loc = this.locInfo(loc);

	  var original = data ? '@' : '',
	      dig = [],
	      depth = 0,
	      depthString = '';

	  for (var i = 0, l = parts.length; i < l; i++) {
	    var part = parts[i].part,

	    // If we have [] syntax then we do not treat path references as operators,
	    // i.e. foo.[this] resolves to approximately context.foo['this']
	    isLiteral = parts[i].original !== part;
	    original += (parts[i].separator || '') + part;

	    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
	      if (dig.length > 0) {
	        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
	      } else if (part === '..') {
	        depth++;
	        depthString += '../';
	      }
	    } else {
	      dig.push(part);
	    }
	  }

	  return {
	    type: 'PathExpression',
	    data: data,
	    depth: depth,
	    parts: dig,
	    original: original,
	    loc: loc
	  };
	}

	function prepareMustache(path, params, hash, open, strip, locInfo) {
	  // Must use charAt to support IE pre-10
	  var escapeFlag = open.charAt(3) || open.charAt(2),
	      escaped = escapeFlag !== '{' && escapeFlag !== '&';

	  var decorator = /\*/.test(open);
	  return {
	    type: decorator ? 'Decorator' : 'MustacheStatement',
	    path: path,
	    params: params,
	    hash: hash,
	    escaped: escaped,
	    strip: strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareRawBlock(openRawBlock, contents, close, locInfo) {
	  validateClose(openRawBlock, close);

	  locInfo = this.locInfo(locInfo);
	  var program = {
	    type: 'Program',
	    body: contents,
	    strip: {},
	    loc: locInfo
	  };

	  return {
	    type: 'BlockStatement',
	    path: openRawBlock.path,
	    params: openRawBlock.params,
	    hash: openRawBlock.hash,
	    program: program,
	    openStrip: {},
	    inverseStrip: {},
	    closeStrip: {},
	    loc: locInfo
	  };
	}

	function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
	  if (close && close.path) {
	    validateClose(openBlock, close);
	  }

	  var decorator = /\*/.test(openBlock.open);

	  program.blockParams = openBlock.blockParams;

	  var inverse = undefined,
	      inverseStrip = undefined;

	  if (inverseAndProgram) {
	    if (decorator) {
	      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
	    }

	    if (inverseAndProgram.chain) {
	      inverseAndProgram.program.body[0].closeStrip = close.strip;
	    }

	    inverseStrip = inverseAndProgram.strip;
	    inverse = inverseAndProgram.program;
	  }

	  if (inverted) {
	    inverted = inverse;
	    inverse = program;
	    program = inverted;
	  }

	  return {
	    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
	    path: openBlock.path,
	    params: openBlock.params,
	    hash: openBlock.hash,
	    program: program,
	    inverse: inverse,
	    openStrip: openBlock.strip,
	    inverseStrip: inverseStrip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareProgram(statements, loc) {
	  if (!loc && statements.length) {
	    var firstLoc = statements[0].loc,
	        lastLoc = statements[statements.length - 1].loc;

	    /* istanbul ignore else */
	    if (firstLoc && lastLoc) {
	      loc = {
	        source: firstLoc.source,
	        start: {
	          line: firstLoc.start.line,
	          column: firstLoc.start.column
	        },
	        end: {
	          line: lastLoc.end.line,
	          column: lastLoc.end.column
	        }
	      };
	    }
	  }

	  return {
	    type: 'Program',
	    body: statements,
	    strip: {},
	    loc: loc
	  };
	}

	function preparePartialBlock(open, program, close, locInfo) {
	  validateClose(open, close);

	  return {
	    type: 'PartialBlockStatement',
	    name: open.path,
	    params: open.params,
	    hash: open.hash,
	    program: program,
	    openStrip: open.strip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable new-cap */

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.Compiler = Compiler;
	exports.precompile = precompile;
	exports.compile = compile;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(5);

	var _ast = __webpack_require__(21);

	var _ast2 = _interopRequireDefault(_ast);

	var slice = [].slice;

	function Compiler() {}

	// the foundHelper register will disambiguate helper lookup from finding a
	// function in a context. This is necessary for mustache compatibility, which
	// requires that context functions in blocks are evaluated by blockHelperMissing,
	// and then proceed as if the resulting value was provided to blockHelperMissing.

	Compiler.prototype = {
	  compiler: Compiler,

	  equals: function equals(other) {
	    var len = this.opcodes.length;
	    if (other.opcodes.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      var opcode = this.opcodes[i],
	          otherOpcode = other.opcodes[i];
	      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
	        return false;
	      }
	    }

	    // We know that length is the same between the two arrays because they are directly tied
	    // to the opcode behavior above.
	    len = this.children.length;
	    for (var i = 0; i < len; i++) {
	      if (!this.children[i].equals(other.children[i])) {
	        return false;
	      }
	    }

	    return true;
	  },

	  guid: 0,

	  compile: function compile(program, options) {
	    this.sourceNode = [];
	    this.opcodes = [];
	    this.children = [];
	    this.options = options;
	    this.stringParams = options.stringParams;
	    this.trackIds = options.trackIds;

	    options.blockParams = options.blockParams || [];

	    // These changes will propagate to the other compiler components
	    var knownHelpers = options.knownHelpers;
	    options.knownHelpers = {
	      'helperMissing': true,
	      'blockHelperMissing': true,
	      'each': true,
	      'if': true,
	      'unless': true,
	      'with': true,
	      'log': true,
	      'lookup': true
	    };
	    if (knownHelpers) {
	      for (var _name in knownHelpers) {
	        /* istanbul ignore else */
	        if (_name in knownHelpers) {
	          options.knownHelpers[_name] = knownHelpers[_name];
	        }
	      }
	    }

	    return this.accept(program);
	  },

	  compileProgram: function compileProgram(program) {
	    var childCompiler = new this.compiler(),
	        // eslint-disable-line new-cap
	    result = childCompiler.compile(program, this.options),
	        guid = this.guid++;

	    this.usePartial = this.usePartial || result.usePartial;

	    this.children[guid] = result;
	    this.useDepths = this.useDepths || result.useDepths;

	    return guid;
	  },

	  accept: function accept(node) {
	    /* istanbul ignore next: Sanity code */
	    if (!this[node.type]) {
	      throw new _exception2['default']('Unknown type: ' + node.type, node);
	    }

	    this.sourceNode.unshift(node);
	    var ret = this[node.type](node);
	    this.sourceNode.shift();
	    return ret;
	  },

	  Program: function Program(program) {
	    this.options.blockParams.unshift(program.blockParams);

	    var body = program.body,
	        bodyLength = body.length;
	    for (var i = 0; i < bodyLength; i++) {
	      this.accept(body[i]);
	    }

	    this.options.blockParams.shift();

	    this.isSimple = bodyLength === 1;
	    this.blockParams = program.blockParams ? program.blockParams.length : 0;

	    return this;
	  },

	  BlockStatement: function BlockStatement(block) {
	    transformLiteralToPath(block);

	    var program = block.program,
	        inverse = block.inverse;

	    program = program && this.compileProgram(program);
	    inverse = inverse && this.compileProgram(inverse);

	    var type = this.classifySexpr(block);

	    if (type === 'helper') {
	      this.helperSexpr(block, program, inverse);
	    } else if (type === 'simple') {
	      this.simpleSexpr(block);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('blockValue', block.path.original);
	    } else {
	      this.ambiguousSexpr(block, program, inverse);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('ambiguousBlockValue');
	    }

	    this.opcode('append');
	  },

	  DecoratorBlock: function DecoratorBlock(decorator) {
	    var program = decorator.program && this.compileProgram(decorator.program);
	    var params = this.setupFullMustacheParams(decorator, program, undefined),
	        path = decorator.path;

	    this.useDecorators = true;
	    this.opcode('registerDecorator', params.length, path.original);
	  },

	  PartialStatement: function PartialStatement(partial) {
	    this.usePartial = true;

	    var program = partial.program;
	    if (program) {
	      program = this.compileProgram(partial.program);
	    }

	    var params = partial.params;
	    if (params.length > 1) {
	      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
	    } else if (!params.length) {
	      if (this.options.explicitPartialContext) {
	        this.opcode('pushLiteral', 'undefined');
	      } else {
	        params.push({ type: 'PathExpression', parts: [], depth: 0 });
	      }
	    }

	    var partialName = partial.name.original,
	        isDynamic = partial.name.type === 'SubExpression';
	    if (isDynamic) {
	      this.accept(partial.name);
	    }

	    this.setupFullMustacheParams(partial, program, undefined, true);

	    var indent = partial.indent || '';
	    if (this.options.preventIndent && indent) {
	      this.opcode('appendContent', indent);
	      indent = '';
	    }

	    this.opcode('invokePartial', isDynamic, partialName, indent);
	    this.opcode('append');
	  },
	  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
	    this.PartialStatement(partialBlock);
	  },

	  MustacheStatement: function MustacheStatement(mustache) {
	    this.SubExpression(mustache);

	    if (mustache.escaped && !this.options.noEscape) {
	      this.opcode('appendEscaped');
	    } else {
	      this.opcode('append');
	    }
	  },
	  Decorator: function Decorator(decorator) {
	    this.DecoratorBlock(decorator);
	  },

	  ContentStatement: function ContentStatement(content) {
	    if (content.value) {
	      this.opcode('appendContent', content.value);
	    }
	  },

	  CommentStatement: function CommentStatement() {},

	  SubExpression: function SubExpression(sexpr) {
	    transformLiteralToPath(sexpr);
	    var type = this.classifySexpr(sexpr);

	    if (type === 'simple') {
	      this.simpleSexpr(sexpr);
	    } else if (type === 'helper') {
	      this.helperSexpr(sexpr);
	    } else {
	      this.ambiguousSexpr(sexpr);
	    }
	  },
	  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
	    var path = sexpr.path,
	        name = path.parts[0],
	        isBlock = program != null || inverse != null;

	    this.opcode('getContext', path.depth);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    path.strict = true;
	    this.accept(path);

	    this.opcode('invokeAmbiguous', name, isBlock);
	  },

	  simpleSexpr: function simpleSexpr(sexpr) {
	    var path = sexpr.path;
	    path.strict = true;
	    this.accept(path);
	    this.opcode('resolvePossibleLambda');
	  },

	  helperSexpr: function helperSexpr(sexpr, program, inverse) {
	    var params = this.setupFullMustacheParams(sexpr, program, inverse),
	        path = sexpr.path,
	        name = path.parts[0];

	    if (this.options.knownHelpers[name]) {
	      this.opcode('invokeKnownHelper', params.length, name);
	    } else if (this.options.knownHelpersOnly) {
	      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
	    } else {
	      path.strict = true;
	      path.falsy = true;

	      this.accept(path);
	      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
	    }
	  },

	  PathExpression: function PathExpression(path) {
	    this.addDepth(path.depth);
	    this.opcode('getContext', path.depth);

	    var name = path.parts[0],
	        scoped = _ast2['default'].helpers.scopedId(path),
	        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

	    if (blockParamId) {
	      this.opcode('lookupBlockParam', blockParamId, path.parts);
	    } else if (!name) {
	      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
	      this.opcode('pushContext');
	    } else if (path.data) {
	      this.options.data = true;
	      this.opcode('lookupData', path.depth, path.parts, path.strict);
	    } else {
	      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
	    }
	  },

	  StringLiteral: function StringLiteral(string) {
	    this.opcode('pushString', string.value);
	  },

	  NumberLiteral: function NumberLiteral(number) {
	    this.opcode('pushLiteral', number.value);
	  },

	  BooleanLiteral: function BooleanLiteral(bool) {
	    this.opcode('pushLiteral', bool.value);
	  },

	  UndefinedLiteral: function UndefinedLiteral() {
	    this.opcode('pushLiteral', 'undefined');
	  },

	  NullLiteral: function NullLiteral() {
	    this.opcode('pushLiteral', 'null');
	  },

	  Hash: function Hash(hash) {
	    var pairs = hash.pairs,
	        i = 0,
	        l = pairs.length;

	    this.opcode('pushHash');

	    for (; i < l; i++) {
	      this.pushParam(pairs[i].value);
	    }
	    while (i--) {
	      this.opcode('assignToHash', pairs[i].key);
	    }
	    this.opcode('popHash');
	  },

	  // HELPERS
	  opcode: function opcode(name) {
	    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
	  },

	  addDepth: function addDepth(depth) {
	    if (!depth) {
	      return;
	    }

	    this.useDepths = true;
	  },

	  classifySexpr: function classifySexpr(sexpr) {
	    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

	    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

	    // a mustache is an eligible helper if:
	    // * its id is simple (a single part, not `this` or `..`)
	    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

	    // if a mustache is an eligible helper but not a definite
	    // helper, it is ambiguous, and will be resolved in a later
	    // pass or at runtime.
	    var isEligible = !isBlockParam && (isHelper || isSimple);

	    // if ambiguous, we can possibly resolve the ambiguity now
	    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
	    if (isEligible && !isHelper) {
	      var _name2 = sexpr.path.parts[0],
	          options = this.options;

	      if (options.knownHelpers[_name2]) {
	        isHelper = true;
	      } else if (options.knownHelpersOnly) {
	        isEligible = false;
	      }
	    }

	    if (isHelper) {
	      return 'helper';
	    } else if (isEligible) {
	      return 'ambiguous';
	    } else {
	      return 'simple';
	    }
	  },

	  pushParams: function pushParams(params) {
	    for (var i = 0, l = params.length; i < l; i++) {
	      this.pushParam(params[i]);
	    }
	  },

	  pushParam: function pushParam(val) {
	    var value = val.value != null ? val.value : val.original || '';

	    if (this.stringParams) {
	      if (value.replace) {
	        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
	      }

	      if (val.depth) {
	        this.addDepth(val.depth);
	      }
	      this.opcode('getContext', val.depth || 0);
	      this.opcode('pushStringParam', value, val.type);

	      if (val.type === 'SubExpression') {
	        // SubExpressions get evaluated and passed in
	        // in string params mode.
	        this.accept(val);
	      }
	    } else {
	      if (this.trackIds) {
	        var blockParamIndex = undefined;
	        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
	          blockParamIndex = this.blockParamIndex(val.parts[0]);
	        }
	        if (blockParamIndex) {
	          var blockParamChild = val.parts.slice(1).join('.');
	          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
	        } else {
	          value = val.original || value;
	          if (value.replace) {
	            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
	          }

	          this.opcode('pushId', val.type, value);
	        }
	      }
	      this.accept(val);
	    }
	  },

	  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
	    var params = sexpr.params;
	    this.pushParams(params);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    if (sexpr.hash) {
	      this.accept(sexpr.hash);
	    } else {
	      this.opcode('emptyHash', omitEmpty);
	    }

	    return params;
	  },

	  blockParamIndex: function blockParamIndex(name) {
	    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
	      var blockParams = this.options.blockParams[depth],
	          param = blockParams && _utils.indexOf(blockParams, name);
	      if (blockParams && param >= 0) {
	        return [depth, param];
	      }
	    }
	  }
	};

	function precompile(input, options, env) {
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
	  }

	  options = options || {};
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var ast = env.parse(input, options),
	      environment = new env.Compiler().compile(ast, options);
	  return new env.JavaScriptCompiler().compile(environment, options);
	}

	function compile(input, options, env) {
	  if (options === undefined) options = {};

	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
	  }

	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var compiled = undefined;

	  function compileInput() {
	    var ast = env.parse(input, options),
	        environment = new env.Compiler().compile(ast, options),
	        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
	    return env.template(templateSpec);
	  }

	  // Template is only compiled on first use and cached after that point.
	  function ret(context, execOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled.call(this, context, execOptions);
	  }
	  ret._setup = function (setupOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._setup(setupOptions);
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._child(i, data, blockParams, depths);
	  };
	  return ret;
	}

	function argEquals(a, b) {
	  if (a === b) {
	    return true;
	  }

	  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (!argEquals(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	}

	function transformLiteralToPath(sexpr) {
	  if (!sexpr.path.parts) {
	    var literal = sexpr.path;
	    // Casting to string here to make false and 0 literal values play nicely with the rest
	    // of the system.
	    sexpr.path = {
	      type: 'PathExpression',
	      data: false,
	      depth: 0,
	      parts: [literal.original + ''],
	      original: literal.original + '',
	      loc: literal.loc
	    };
	  }
	}

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _base = __webpack_require__(4);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(5);

	var _codeGen = __webpack_require__(29);

	var _codeGen2 = _interopRequireDefault(_codeGen);

	function Literal(value) {
	  this.value = value;
	}

	function JavaScriptCompiler() {}

	JavaScriptCompiler.prototype = {
	  // PUBLIC API: You can override these methods in a subclass to provide
	  // alternative compiled forms for name lookup and buffering semantics
	  nameLookup: function nameLookup(parent, name /* , type*/) {
	    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
	      return [parent, '.', name];
	    } else {
	      return [parent, '[', JSON.stringify(name), ']'];
	    }
	  },
	  depthedLookup: function depthedLookup(name) {
	    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
	  },

	  compilerInfo: function compilerInfo() {
	    var revision = _base.COMPILER_REVISION,
	        versions = _base.REVISION_CHANGES[revision];
	    return [revision, versions];
	  },

	  appendToBuffer: function appendToBuffer(source, location, explicit) {
	    // Force a source as this simplifies the merge logic.
	    if (!_utils.isArray(source)) {
	      source = [source];
	    }
	    source = this.source.wrap(source, location);

	    if (this.environment.isSimple) {
	      return ['return ', source, ';'];
	    } else if (explicit) {
	      // This is a case where the buffer operation occurs as a child of another
	      // construct, generally braces. We have to explicitly output these buffer
	      // operations to ensure that the emitted code goes in the correct location.
	      return ['buffer += ', source, ';'];
	    } else {
	      source.appendToBuffer = true;
	      return source;
	    }
	  },

	  initializeBuffer: function initializeBuffer() {
	    return this.quotedString('');
	  },
	  // END PUBLIC API

	  compile: function compile(environment, options, context, asObject) {
	    this.environment = environment;
	    this.options = options;
	    this.stringParams = this.options.stringParams;
	    this.trackIds = this.options.trackIds;
	    this.precompile = !asObject;

	    this.name = this.environment.name;
	    this.isChild = !!context;
	    this.context = context || {
	      decorators: [],
	      programs: [],
	      environments: []
	    };

	    this.preamble();

	    this.stackSlot = 0;
	    this.stackVars = [];
	    this.aliases = {};
	    this.registers = { list: [] };
	    this.hashes = [];
	    this.compileStack = [];
	    this.inlineStack = [];
	    this.blockParams = [];

	    this.compileChildren(environment, options);

	    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
	    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

	    var opcodes = environment.opcodes,
	        opcode = undefined,
	        firstLoc = undefined,
	        i = undefined,
	        l = undefined;

	    for (i = 0, l = opcodes.length; i < l; i++) {
	      opcode = opcodes[i];

	      this.source.currentLocation = opcode.loc;
	      firstLoc = firstLoc || opcode.loc;
	      this[opcode.opcode].apply(this, opcode.args);
	    }

	    // Flush any trailing content that might be pending.
	    this.source.currentLocation = firstLoc;
	    this.pushSource('');

	    /* istanbul ignore next */
	    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
	      throw new _exception2['default']('Compile completed with content left on stack');
	    }

	    if (!this.decorators.isEmpty()) {
	      this.useDecorators = true;

	      this.decorators.prepend('var decorators = container.decorators;\n');
	      this.decorators.push('return fn;');

	      if (asObject) {
	        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
	      } else {
	        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
	        this.decorators.push('}\n');
	        this.decorators = this.decorators.merge();
	      }
	    } else {
	      this.decorators = undefined;
	    }

	    var fn = this.createFunctionContext(asObject);
	    if (!this.isChild) {
	      var ret = {
	        compiler: this.compilerInfo(),
	        main: fn
	      };

	      if (this.decorators) {
	        ret.main_d = this.decorators; // eslint-disable-line camelcase
	        ret.useDecorators = true;
	      }

	      var _context = this.context;
	      var programs = _context.programs;
	      var decorators = _context.decorators;

	      for (i = 0, l = programs.length; i < l; i++) {
	        if (programs[i]) {
	          ret[i] = programs[i];
	          if (decorators[i]) {
	            ret[i + '_d'] = decorators[i];
	            ret.useDecorators = true;
	          }
	        }
	      }

	      if (this.environment.usePartial) {
	        ret.usePartial = true;
	      }
	      if (this.options.data) {
	        ret.useData = true;
	      }
	      if (this.useDepths) {
	        ret.useDepths = true;
	      }
	      if (this.useBlockParams) {
	        ret.useBlockParams = true;
	      }
	      if (this.options.compat) {
	        ret.compat = true;
	      }

	      if (!asObject) {
	        ret.compiler = JSON.stringify(ret.compiler);

	        this.source.currentLocation = { start: { line: 1, column: 0 } };
	        ret = this.objectLiteral(ret);

	        if (options.srcName) {
	          ret = ret.toStringWithSourceMap({ file: options.destName });
	          ret.map = ret.map && ret.map.toString();
	        } else {
	          ret = ret.toString();
	        }
	      } else {
	        ret.compilerOptions = this.options;
	      }

	      return ret;
	    } else {
	      return fn;
	    }
	  },

	  preamble: function preamble() {
	    // track the last context pushed into place to allow skipping the
	    // getContext opcode when it would be a noop
	    this.lastContext = 0;
	    this.source = new _codeGen2['default'](this.options.srcName);
	    this.decorators = new _codeGen2['default'](this.options.srcName);
	  },

	  createFunctionContext: function createFunctionContext(asObject) {
	    var varDeclarations = '';

	    var locals = this.stackVars.concat(this.registers.list);
	    if (locals.length > 0) {
	      varDeclarations += ', ' + locals.join(', ');
	    }

	    // Generate minimizer alias mappings
	    //
	    // When using true SourceNodes, this will update all references to the given alias
	    // as the source nodes are reused in situ. For the non-source node compilation mode,
	    // aliases will not be used, but this case is already being run on the client and
	    // we aren't concern about minimizing the template size.
	    var aliasCount = 0;
	    for (var alias in this.aliases) {
	      // eslint-disable-line guard-for-in
	      var node = this.aliases[alias];

	      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
	        varDeclarations += ', alias' + (++aliasCount) + '=' + alias;
	        node.children[0] = 'alias' + aliasCount;
	      }
	    }

	    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

	    if (this.useBlockParams || this.useDepths) {
	      params.push('blockParams');
	    }
	    if (this.useDepths) {
	      params.push('depths');
	    }

	    // Perform a second pass over the output to merge content when possible
	    var source = this.mergeSource(varDeclarations);

	    if (asObject) {
	      params.push(source);

	      return Function.apply(this, params);
	    } else {
	      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
	    }
	  },
	  mergeSource: function mergeSource(varDeclarations) {
	    var isSimple = this.environment.isSimple,
	        appendOnly = !this.forceBuffer,
	        appendFirst = undefined,
	        sourceSeen = undefined,
	        bufferStart = undefined,
	        bufferEnd = undefined;
	    this.source.each(function (line) {
	      if (line.appendToBuffer) {
	        if (bufferStart) {
	          line.prepend('  + ');
	        } else {
	          bufferStart = line;
	        }
	        bufferEnd = line;
	      } else {
	        if (bufferStart) {
	          if (!sourceSeen) {
	            appendFirst = true;
	          } else {
	            bufferStart.prepend('buffer += ');
	          }
	          bufferEnd.add(';');
	          bufferStart = bufferEnd = undefined;
	        }

	        sourceSeen = true;
	        if (!isSimple) {
	          appendOnly = false;
	        }
	      }
	    });

	    if (appendOnly) {
	      if (bufferStart) {
	        bufferStart.prepend('return ');
	        bufferEnd.add(';');
	      } else if (!sourceSeen) {
	        this.source.push('return "";');
	      }
	    } else {
	      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

	      if (bufferStart) {
	        bufferStart.prepend('return buffer + ');
	        bufferEnd.add(';');
	      } else {
	        this.source.push('return buffer;');
	      }
	    }

	    if (varDeclarations) {
	      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
	    }

	    return this.source.merge();
	  },

	  // [blockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // On stack, after: return value of blockHelperMissing
	  //
	  // The purpose of this opcode is to take a block of the form
	  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
	  // replace it on the stack with the result of properly
	  // invoking blockHelperMissing.
	  blockValue: function blockValue(name) {
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs(name, 0, params);

	    var blockName = this.popStack();
	    params.splice(1, 0, blockName);

	    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
	  },

	  // [ambiguousBlockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // Compiler value, before: lastHelper=value of last found helper, if any
	  // On stack, after, if no lastHelper: same as [blockValue]
	  // On stack, after, if lastHelper: value
	  ambiguousBlockValue: function ambiguousBlockValue() {
	    // We're being a bit cheeky and reusing the options value from the prior exec
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs('', 0, params, true);

	    this.flushInline();

	    var current = this.topStack();
	    params.splice(1, 0, current);

	    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
	  },

	  // [appendContent]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  //
	  // Appends the string value of `content` to the current buffer
	  appendContent: function appendContent(content) {
	    if (this.pendingContent) {
	      content = this.pendingContent + content;
	    } else {
	      this.pendingLocation = this.source.currentLocation;
	    }

	    this.pendingContent = content;
	  },

	  // [append]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Coerces `value` to a String and appends it to the current buffer.
	  //
	  // If `value` is truthy, or 0, it is coerced into a string and appended
	  // Otherwise, the empty string is appended
	  append: function append() {
	    if (this.isInline()) {
	      this.replaceStack(function (current) {
	        return [' != null ? ', current, ' : ""'];
	      });

	      this.pushSource(this.appendToBuffer(this.popStack()));
	    } else {
	      var local = this.popStack();
	      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
	      if (this.environment.isSimple) {
	        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
	      }
	    }
	  },

	  // [appendEscaped]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Escape `value` and append it to the buffer
	  appendEscaped: function appendEscaped() {
	    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
	  },

	  // [getContext]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  // Compiler value, after: lastContext=depth
	  //
	  // Set the value of the `lastContext` compiler value to the depth
	  getContext: function getContext(depth) {
	    this.lastContext = depth;
	  },

	  // [pushContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext, ...
	  //
	  // Pushes the value of the current context onto the stack.
	  pushContext: function pushContext() {
	    this.pushStackLiteral(this.contextName(this.lastContext));
	  },

	  // [lookupOnContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext[name], ...
	  //
	  // Looks up the value of `name` on the current context and pushes
	  // it onto the stack.
	  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
	    var i = 0;

	    if (!scoped && this.options.compat && !this.lastContext) {
	      // The depthed query is expected to handle the undefined logic for the root level that
	      // is implemented below, so we evaluate that directly in compat mode
	      this.push(this.depthedLookup(parts[i++]));
	    } else {
	      this.pushContext();
	    }

	    this.resolvePath('context', parts, i, falsy, strict);
	  },

	  // [lookupBlockParam]
	  //
	  // On stack, before: ...
	  // On stack, after: blockParam[name], ...
	  //
	  // Looks up the value of `parts` on the given block param and pushes
	  // it onto the stack.
	  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
	    this.useBlockParams = true;

	    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
	    this.resolvePath('context', parts, 1);
	  },

	  // [lookupData]
	  //
	  // On stack, before: ...
	  // On stack, after: data, ...
	  //
	  // Push the data lookup operator
	  lookupData: function lookupData(depth, parts, strict) {
	    if (!depth) {
	      this.pushStackLiteral('data');
	    } else {
	      this.pushStackLiteral('container.data(data, ' + depth + ')');
	    }

	    this.resolvePath('data', parts, 0, true, strict);
	  },

	  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
	    // istanbul ignore next

	    var _this = this;

	    if (this.options.strict || this.options.assumeObjects) {
	      this.push(strictLookup(this.options.strict && strict, this, parts, type));
	      return;
	    }

	    var len = parts.length;
	    for (; i < len; i++) {
	      /* eslint-disable no-loop-func */
	      this.replaceStack(function (current) {
	        var lookup = _this.nameLookup(current, parts[i], type);
	        // We want to ensure that zero and false are handled properly if the context (falsy flag)
	        // needs to have the special handling for these values.
	        if (!falsy) {
	          return [' != null ? ', lookup, ' : ', current];
	        } else {
	          // Otherwise we can use generic falsy handling
	          return [' && ', lookup];
	        }
	      });
	      /* eslint-enable no-loop-func */
	    }
	  },

	  // [resolvePossibleLambda]
	  //
	  // On stack, before: value, ...
	  // On stack, after: resolved value, ...
	  //
	  // If the `value` is a lambda, replace it on the stack by
	  // the return value of the lambda
	  resolvePossibleLambda: function resolvePossibleLambda() {
	    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
	  },

	  // [pushStringParam]
	  //
	  // On stack, before: ...
	  // On stack, after: string, currentContext, ...
	  //
	  // This opcode is designed for use in string mode, which
	  // provides the string value of a parameter along with its
	  // depth rather than resolving it immediately.
	  pushStringParam: function pushStringParam(string, type) {
	    this.pushContext();
	    this.pushString(type);

	    // If it's a subexpression, the string result
	    // will be pushed after this opcode.
	    if (type !== 'SubExpression') {
	      if (typeof string === 'string') {
	        this.pushString(string);
	      } else {
	        this.pushStackLiteral(string);
	      }
	    }
	  },

	  emptyHash: function emptyHash(omitEmpty) {
	    if (this.trackIds) {
	      this.push('{}'); // hashIds
	    }
	    if (this.stringParams) {
	      this.push('{}'); // hashContexts
	      this.push('{}'); // hashTypes
	    }
	    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
	  },
	  pushHash: function pushHash() {
	    if (this.hash) {
	      this.hashes.push(this.hash);
	    }
	    this.hash = { values: [], types: [], contexts: [], ids: [] };
	  },
	  popHash: function popHash() {
	    var hash = this.hash;
	    this.hash = this.hashes.pop();

	    if (this.trackIds) {
	      this.push(this.objectLiteral(hash.ids));
	    }
	    if (this.stringParams) {
	      this.push(this.objectLiteral(hash.contexts));
	      this.push(this.objectLiteral(hash.types));
	    }

	    this.push(this.objectLiteral(hash.values));
	  },

	  // [pushString]
	  //
	  // On stack, before: ...
	  // On stack, after: quotedString(string), ...
	  //
	  // Push a quoted version of `string` onto the stack
	  pushString: function pushString(string) {
	    this.pushStackLiteral(this.quotedString(string));
	  },

	  // [pushLiteral]
	  //
	  // On stack, before: ...
	  // On stack, after: value, ...
	  //
	  // Pushes a value onto the stack. This operation prevents
	  // the compiler from creating a temporary variable to hold
	  // it.
	  pushLiteral: function pushLiteral(value) {
	    this.pushStackLiteral(value);
	  },

	  // [pushProgram]
	  //
	  // On stack, before: ...
	  // On stack, after: program(guid), ...
	  //
	  // Push a program expression onto the stack. This takes
	  // a compile-time guid and converts it into a runtime-accessible
	  // expression.
	  pushProgram: function pushProgram(guid) {
	    if (guid != null) {
	      this.pushStackLiteral(this.programExpression(guid));
	    } else {
	      this.pushStackLiteral(null);
	    }
	  },

	  // [registerDecorator]
	  //
	  // On stack, before: hash, program, params..., ...
	  // On stack, after: ...
	  //
	  // Pops off the decorator's parameters, invokes the decorator,
	  // and inserts the decorator into the decorators list.
	  registerDecorator: function registerDecorator(paramSize, name) {
	    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
	        options = this.setupHelperArgs(name, paramSize);

	    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
	  },

	  // [invokeHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // Pops off the helper's parameters, invokes the helper,
	  // and pushes the helper's return value onto the stack.
	  //
	  // If the helper is not found, `helperMissing` is called.
	  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
	    var nonHelper = this.popStack(),
	        helper = this.setupHelper(paramSize, name),
	        simple = isSimple ? [helper.name, ' || '] : '';

	    var lookup = ['('].concat(simple, nonHelper);
	    if (!this.options.strict) {
	      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
	    }
	    lookup.push(')');

	    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
	  },

	  // [invokeKnownHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // This operation is used when the helper is known to exist,
	  // so a `helperMissing` fallback is not required.
	  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
	    var helper = this.setupHelper(paramSize, name);
	    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
	  },

	  // [invokeAmbiguous]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of disambiguation
	  //
	  // This operation is used when an expression like `{{foo}}`
	  // is provided, but we don't know at compile-time whether it
	  // is a helper or a path.
	  //
	  // This operation emits more code than the other options,
	  // and can be avoided by passing the `knownHelpers` and
	  // `knownHelpersOnly` flags at compile-time.
	  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
	    this.useRegister('helper');

	    var nonHelper = this.popStack();

	    this.emptyHash();
	    var helper = this.setupHelper(0, name, helperCall);

	    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

	    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
	    if (!this.options.strict) {
	      lookup[0] = '(helper = ';
	      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
	    }

	    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
	  },

	  // [invokePartial]
	  //
	  // On stack, before: context, ...
	  // On stack after: result of partial invocation
	  //
	  // This operation pops off a context, invokes a partial with that context,
	  // and pushes the result of the invocation back.
	  invokePartial: function invokePartial(isDynamic, name, indent) {
	    var params = [],
	        options = this.setupParams(name, 1, params);

	    if (isDynamic) {
	      name = this.popStack();
	      delete options.name;
	    }

	    if (indent) {
	      options.indent = JSON.stringify(indent);
	    }
	    options.helpers = 'helpers';
	    options.partials = 'partials';
	    options.decorators = 'container.decorators';

	    if (!isDynamic) {
	      params.unshift(this.nameLookup('partials', name, 'partial'));
	    } else {
	      params.unshift(name);
	    }

	    if (this.options.compat) {
	      options.depths = 'depths';
	    }
	    options = this.objectLiteral(options);
	    params.push(options);

	    this.push(this.source.functionCall('container.invokePartial', '', params));
	  },

	  // [assignToHash]
	  //
	  // On stack, before: value, ..., hash, ...
	  // On stack, after: ..., hash, ...
	  //
	  // Pops a value off the stack and assigns it to the current hash
	  assignToHash: function assignToHash(key) {
	    var value = this.popStack(),
	        context = undefined,
	        type = undefined,
	        id = undefined;

	    if (this.trackIds) {
	      id = this.popStack();
	    }
	    if (this.stringParams) {
	      type = this.popStack();
	      context = this.popStack();
	    }

	    var hash = this.hash;
	    if (context) {
	      hash.contexts[key] = context;
	    }
	    if (type) {
	      hash.types[key] = type;
	    }
	    if (id) {
	      hash.ids[key] = id;
	    }
	    hash.values[key] = value;
	  },

	  pushId: function pushId(type, name, child) {
	    if (type === 'BlockParam') {
	      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
	    } else if (type === 'PathExpression') {
	      this.pushString(name);
	    } else if (type === 'SubExpression') {
	      this.pushStackLiteral('true');
	    } else {
	      this.pushStackLiteral('null');
	    }
	  },

	  // HELPERS

	  compiler: JavaScriptCompiler,

	  compileChildren: function compileChildren(environment, options) {
	    var children = environment.children,
	        child = undefined,
	        compiler = undefined;

	    for (var i = 0, l = children.length; i < l; i++) {
	      child = children[i];
	      compiler = new this.compiler(); // eslint-disable-line new-cap

	      var index = this.matchExistingProgram(child);

	      if (index == null) {
	        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
	        index = this.context.programs.length;
	        child.index = index;
	        child.name = 'program' + index;
	        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
	        this.context.decorators[index] = compiler.decorators;
	        this.context.environments[index] = child;

	        this.useDepths = this.useDepths || compiler.useDepths;
	        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
	      } else {
	        child.index = index;
	        child.name = 'program' + index;

	        this.useDepths = this.useDepths || child.useDepths;
	        this.useBlockParams = this.useBlockParams || child.useBlockParams;
	      }
	    }
	  },
	  matchExistingProgram: function matchExistingProgram(child) {
	    for (var i = 0, len = this.context.environments.length; i < len; i++) {
	      var environment = this.context.environments[i];
	      if (environment && environment.equals(child)) {
	        return i;
	      }
	    }
	  },

	  programExpression: function programExpression(guid) {
	    var child = this.environment.children[guid],
	        programParams = [child.index, 'data', child.blockParams];

	    if (this.useBlockParams || this.useDepths) {
	      programParams.push('blockParams');
	    }
	    if (this.useDepths) {
	      programParams.push('depths');
	    }

	    return 'container.program(' + programParams.join(', ') + ')';
	  },

	  useRegister: function useRegister(name) {
	    if (!this.registers[name]) {
	      this.registers[name] = true;
	      this.registers.list.push(name);
	    }
	  },

	  push: function push(expr) {
	    if (!(expr instanceof Literal)) {
	      expr = this.source.wrap(expr);
	    }

	    this.inlineStack.push(expr);
	    return expr;
	  },

	  pushStackLiteral: function pushStackLiteral(item) {
	    this.push(new Literal(item));
	  },

	  pushSource: function pushSource(source) {
	    if (this.pendingContent) {
	      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
	      this.pendingContent = undefined;
	    }

	    if (source) {
	      this.source.push(source);
	    }
	  },

	  replaceStack: function replaceStack(callback) {
	    var prefix = ['('],
	        stack = undefined,
	        createdStack = undefined,
	        usedLiteral = undefined;

	    /* istanbul ignore next */
	    if (!this.isInline()) {
	      throw new _exception2['default']('replaceStack on non-inline');
	    }

	    // We want to merge the inline statement into the replacement statement via ','
	    var top = this.popStack(true);

	    if (top instanceof Literal) {
	      // Literals do not need to be inlined
	      stack = [top.value];
	      prefix = ['(', stack];
	      usedLiteral = true;
	    } else {
	      // Get or create the current stack name for use by the inline
	      createdStack = true;
	      var _name = this.incrStack();

	      prefix = ['((', this.push(_name), ' = ', top, ')'];
	      stack = this.topStack();
	    }

	    var item = callback.call(this, stack);

	    if (!usedLiteral) {
	      this.popStack();
	    }
	    if (createdStack) {
	      this.stackSlot--;
	    }
	    this.push(prefix.concat(item, ')'));
	  },

	  incrStack: function incrStack() {
	    this.stackSlot++;
	    if (this.stackSlot > this.stackVars.length) {
	      this.stackVars.push('stack' + this.stackSlot);
	    }
	    return this.topStackName();
	  },
	  topStackName: function topStackName() {
	    return 'stack' + this.stackSlot;
	  },
	  flushInline: function flushInline() {
	    var inlineStack = this.inlineStack;
	    this.inlineStack = [];
	    for (var i = 0, len = inlineStack.length; i < len; i++) {
	      var entry = inlineStack[i];
	      /* istanbul ignore if */
	      if (entry instanceof Literal) {
	        this.compileStack.push(entry);
	      } else {
	        var stack = this.incrStack();
	        this.pushSource([stack, ' = ', entry, ';']);
	        this.compileStack.push(stack);
	      }
	    }
	  },
	  isInline: function isInline() {
	    return this.inlineStack.length;
	  },

	  popStack: function popStack(wrapped) {
	    var inline = this.isInline(),
	        item = (inline ? this.inlineStack : this.compileStack).pop();

	    if (!wrapped && item instanceof Literal) {
	      return item.value;
	    } else {
	      if (!inline) {
	        /* istanbul ignore next */
	        if (!this.stackSlot) {
	          throw new _exception2['default']('Invalid stack pop');
	        }
	        this.stackSlot--;
	      }
	      return item;
	    }
	  },

	  topStack: function topStack() {
	    var stack = this.isInline() ? this.inlineStack : this.compileStack,
	        item = stack[stack.length - 1];

	    /* istanbul ignore if */
	    if (item instanceof Literal) {
	      return item.value;
	    } else {
	      return item;
	    }
	  },

	  contextName: function contextName(context) {
	    if (this.useDepths && context) {
	      return 'depths[' + context + ']';
	    } else {
	      return 'depth' + context;
	    }
	  },

	  quotedString: function quotedString(str) {
	    return this.source.quotedString(str);
	  },

	  objectLiteral: function objectLiteral(obj) {
	    return this.source.objectLiteral(obj);
	  },

	  aliasable: function aliasable(name) {
	    var ret = this.aliases[name];
	    if (ret) {
	      ret.referenceCount++;
	      return ret;
	    }

	    ret = this.aliases[name] = this.source.wrap(name);
	    ret.aliasable = true;
	    ret.referenceCount = 1;

	    return ret;
	  },

	  setupHelper: function setupHelper(paramSize, name, blockHelper) {
	    var params = [],
	        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
	    var foundHelper = this.nameLookup('helpers', name, 'helper'),
	        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');

	    return {
	      params: params,
	      paramsInit: paramsInit,
	      name: foundHelper,
	      callParams: [callContext].concat(params)
	    };
	  },

	  setupParams: function setupParams(helper, paramSize, params) {
	    var options = {},
	        contexts = [],
	        types = [],
	        ids = [],
	        objectArgs = !params,
	        param = undefined;

	    if (objectArgs) {
	      params = [];
	    }

	    options.name = this.quotedString(helper);
	    options.hash = this.popStack();

	    if (this.trackIds) {
	      options.hashIds = this.popStack();
	    }
	    if (this.stringParams) {
	      options.hashTypes = this.popStack();
	      options.hashContexts = this.popStack();
	    }

	    var inverse = this.popStack(),
	        program = this.popStack();

	    // Avoid setting fn and inverse if neither are set. This allows
	    // helpers to do a check for `if (options.fn)`
	    if (program || inverse) {
	      options.fn = program || 'container.noop';
	      options.inverse = inverse || 'container.noop';
	    }

	    // The parameters go on to the stack in order (making sure that they are evaluated in order)
	    // so we need to pop them off the stack in reverse order
	    var i = paramSize;
	    while (i--) {
	      param = this.popStack();
	      params[i] = param;

	      if (this.trackIds) {
	        ids[i] = this.popStack();
	      }
	      if (this.stringParams) {
	        types[i] = this.popStack();
	        contexts[i] = this.popStack();
	      }
	    }

	    if (objectArgs) {
	      options.args = this.source.generateArray(params);
	    }

	    if (this.trackIds) {
	      options.ids = this.source.generateArray(ids);
	    }
	    if (this.stringParams) {
	      options.types = this.source.generateArray(types);
	      options.contexts = this.source.generateArray(contexts);
	    }

	    if (this.options.data) {
	      options.data = 'data';
	    }
	    if (this.useBlockParams) {
	      options.blockParams = 'blockParams';
	    }
	    return options;
	  },

	  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
	    var options = this.setupParams(helper, paramSize, params);
	    options = this.objectLiteral(options);
	    if (useRegister) {
	      this.useRegister('options');
	      params.push('options');
	      return ['options=', options];
	    } else if (params) {
	      params.push(options);
	      return '';
	    } else {
	      return options;
	    }
	  }
	};

	(function () {
	  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

	  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

	  for (var i = 0, l = reservedWords.length; i < l; i++) {
	    compilerWords[reservedWords[i]] = true;
	  }
	})();

	JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
	  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
	};

	function strictLookup(requireTerminal, compiler, parts, type) {
	  var stack = compiler.popStack(),
	      i = 0,
	      len = parts.length;
	  if (requireTerminal) {
	    len--;
	  }

	  for (; i < len; i++) {
	    stack = compiler.nameLookup(stack, parts[i], type);
	  }

	  if (requireTerminal) {
	    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
	  } else {
	    return stack;
	  }
	}

	exports['default'] = JavaScriptCompiler;
	module.exports = exports['default'];

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* global define */
	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var SourceNode = undefined;

	// Unreachable
//	try {
//	  /* istanbul ignore next */
//	  if (false) {
//	    // We don't support this in AMD environments. For these environments, we asusme that
//	    // they are running on the browser and thus have no need for the source-map library.
//	    var SourceMap = require('source-map');
//	    SourceNode = SourceMap.SourceNode;
//	  }
//	} catch (err) {}
	/* NOP */

	/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
	if (!SourceNode) {
	  SourceNode = function (line, column, srcFile, chunks) {
	    this.src = '';
	    if (chunks) {
	      this.add(chunks);
	    }
	  };
	  /* istanbul ignore next */
	  SourceNode.prototype = {
	    add: function add(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src += chunks;
	    },
	    prepend: function prepend(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src = chunks + this.src;
	    },
	    toStringWithSourceMap: function toStringWithSourceMap() {
	      return { code: this.toString() };
	    },
	    toString: function toString() {
	      return this.src;
	    }
	  };
	}

	function castChunk(chunk, codeGen, loc) {
	  if (_utils.isArray(chunk)) {
	    var ret = [];

	    for (var i = 0, len = chunk.length; i < len; i++) {
	      ret.push(codeGen.wrap(chunk[i], loc));
	    }
	    return ret;
	  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
	    // Handle primitives that the SourceNode will throw up on
	    return chunk + '';
	  }
	  return chunk;
	}

	function CodeGen(srcFile) {
	  this.srcFile = srcFile;
	  this.source = [];
	}

	CodeGen.prototype = {
	  isEmpty: function isEmpty() {
	    return !this.source.length;
	  },
	  prepend: function prepend(source, loc) {
	    this.source.unshift(this.wrap(source, loc));
	  },
	  push: function push(source, loc) {
	    this.source.push(this.wrap(source, loc));
	  },

	  merge: function merge() {
	    var source = this.empty();
	    this.each(function (line) {
	      source.add(['  ', line, '\n']);
	    });
	    return source;
	  },

	  each: function each(iter) {
	    for (var i = 0, len = this.source.length; i < len; i++) {
	      iter(this.source[i]);
	    }
	  },

	  empty: function empty() {
	    var loc = this.currentLocation || { start: {} };
	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
	  },
	  wrap: function wrap(chunk) {
	    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

	    if (chunk instanceof SourceNode) {
	      return chunk;
	    }

	    chunk = castChunk(chunk, this, loc);

	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
	  },

	  functionCall: function functionCall(fn, type, params) {
	    params = this.generateList(params);
	    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
	  },

	  quotedString: function quotedString(str) {
	    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
	    .replace(/\u2029/g, '\\u2029') + '"';
	  },

	  objectLiteral: function objectLiteral(obj) {
	    var pairs = [];

	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        var value = castChunk(obj[key], this);
	        if (value !== 'undefined') {
	          pairs.push([this.quotedString(key), ':', value]);
	        }
	      }
	    }

	    var ret = this.generateList(pairs);
	    ret.prepend('{');
	    ret.add('}');
	    return ret;
	  },

	  generateList: function generateList(entries) {
	    var ret = this.empty();

	    for (var i = 0, len = entries.length; i < len; i++) {
	      if (i) {
	        ret.add(',');
	      }

	      ret.add(castChunk(entries[i], this));
	    }

	    return ret;
	  },

	  generateArray: function generateArray(entries) {
	    var ret = this.generateList(entries);
	    ret.prepend('[');
	    ret.add(']');

	    return ret;
	  }
	};

	exports['default'] = CodeGen;
	module.exports = exports['default'];

/***/ }
/******/ ])
});
;
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/tiles.js

/*! Tiles.js | http://thinkpixellab.com/tilesjs | 2012-12-03 */


// single namespace export
var Tiles = {};

(function($) {
"use strict";

    var Tile = Tiles.Tile = function(tileId, element) {

        this.id = tileId;

        // position and dimensions of tile inside the parent panel
        this.top = 0;
        this.left = 0;
        this.width = 0;
        this.height = 0;

        // cache the tile container element
        this.$el = $(element || document.createElement('div'));
    };

    Tile.prototype.appendTo = function($parent, fadeIn, delay, duration) {
        this.$el
            .hide()
            .appendTo($parent);

        if (fadeIn) {
            this.$el.delay(delay).fadeIn(duration);
        }
        else {
            this.$el.show();
        }
    };

    Tile.prototype.remove = function(animate, duration) {
        if (animate) {
            this.$el.fadeOut({
                complete: function() {
                    $(this).remove();
                }
            });
        }
        else {
            this.$el.remove();
        }
    };

    // updates the tile layout with optional animation
    Tile.prototype.resize = function(cellRect, pixelRect, animate, duration, onComplete) {
       
        // store the list of needed changes
        var cssChanges = {},
            changed = false;

        // update position and dimensions
        if (this.left !== pixelRect.x) {
            cssChanges.left = pixelRect.x;
            this.left = pixelRect.x;
            changed = true;
        }
        if (this.top !== pixelRect.y) {
            cssChanges.top = pixelRect.y;
            this.top = pixelRect.y;
            changed = true;
        }
        if (this.width !== pixelRect.width) {
            cssChanges.width = pixelRect.width;
            this.width = pixelRect.width;
            changed = true;
        }
        if (this.height !== pixelRect.height) {
            cssChanges.height = pixelRect.height;
            this.height = pixelRect.height;
            changed = true;
        }

        // Sometimes animation fails to set the css top and left correctly
        // in webkit. We'll validate upon completion of the animation and
        // set the properties again if they don't match the expected values.
        var tile = this,
            validateChangesAndComplete = function() {
                var el = tile.$el[0];
                if (tile.left !== el.offsetLeft) {
                    //console.log ('mismatch left:' + tile.left + ' actual:' + el.offsetLeft + ' id:' + tile.id);
                    tile.$el.css('left', tile.left);
                }
                if (tile.top !== el.offsetTop) {
                    //console.log ('mismatch top:' + tile.top + ' actual:' + el.offsetTop + ' id:' + tile.id);
                    tile.$el.css('top', tile.top);
                }

                if (onComplete) {
                    onComplete();
                }
            };


        // make css changes with animation when requested
        if (animate && changed) {

            this.$el.animate(cssChanges, {
                duration: duration,
                easing: 'swing',
                complete: validateChangesAndComplete
            });
        }
        else {

            if (changed) {
                this.$el.css(cssChanges);
            }

            setTimeout(validateChangesAndComplete, duration);
        }
    };

})(jQuery);

               
/*
    A grid template specifies the layout of variably sized tiles. A single
    cell tile should use the period character. Larger tiles may be created
    using any character that is unused by a adjacent tile. Whitespace is
    ignored when parsing the rows. 

    Examples:

    var simpleTemplate = [
        '    A  A  .  B    ',
        '    A  A  .  B    ',
        '    .  C  C  .    ',
    ]

    var complexTemplate = [
        '    J  J  .  .  E  E    ',
        '    .  A  A  .  E  E    ',
        '    B  A  A  F  F  .    ',
        '    B  .  D  D  .  H    ',
        '    C  C  D  D  G  H    ',
        '    C  C  .  .  G  .    ',
    ];
*/

(function($) {

    // remove whitespace and create 2d array
    var parseCells = function(rows) {
        var cells = [],
            numRows = rows.length,
            x, y, row, rowLength, cell;

        // parse each row
        for(y = 0; y < numRows; y++) {
            
            row = rows[y];
            cells[y] = [];

            // parse the cells in a single row
            for (x = 0, rowLength = row.length; x < rowLength; x++) {
                cell = row[x];
                if (cell !== ' ') {
                    cells[y].push(cell);
                }
            }
        }

        // TODO: check to make sure the array isn't jagged

        return cells;
    };

    function Rectangle(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    Rectangle.prototype.copy = function() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };

    Tiles.Rectangle = Rectangle;

    // convert a 2d array of cell ids to a list of tile rects
    var parseRects = function(cells) {
        var rects = [],
            numRows = cells.length,
            numCols = numRows === 0 ? 0 : cells[0].length,
            cell, height, width, x, y, rectX, rectY;

        // make a copy of the cells that we can modify
        cells = cells.slice();
        for (y = 0; y < numRows; y++) {
            cells[y] = cells[y].slice();
        }

        // iterate through every cell and find rectangles
        for (y = 0; y < numRows; y++) {
            for(x = 0; x < numCols; x++) {
                cell = cells[y][x];

                // skip cells that are null
                if (cell == null) {
                    continue;
                }

                width = 1;    
                height = 1;

                if (cell !== Tiles.Template.SINGLE_CELL) {

                    // find the width by going right until cell id no longer matches 
                    while(width + x < numCols &&
                          cell === cells[y][x + width]) {
                        width++;
                    }

                    // now find height by going down
                    while (height + y < numRows &&
                           cell === cells[y + height][x]) {
                        height++;
                    }
                }

                // null out all cells for the rect
                for(rectY = 0; rectY < height; rectY++) {
                    for(rectX = 0; rectX < width; rectX++) {
                        cells[y + rectY][x + rectX] = null;
                    }
                }

                // add the rect
                rects.push(new Rectangle(x, y, width, height));
            }
        }

        return rects;
    };

    Tiles.Template = function(rects, numCols, numRows) {
        this.rects = rects;
        this.numTiles = this.rects.length;
        this.numRows = numRows;
        this.numCols = numCols;
    };

    Tiles.Template.prototype.copy = function() {

        var copyRects = [],
            len, i;
        for (i = 0, len = this.rects.length; i < len; i++) {
            copyRects.push(this.rects[i].copy());
        }

        return new Tiles.Template(copyRects, this.numCols, this.numRows);
    };

    // appends another template (assumes both are full rectangular grids)
    Tiles.Template.prototype.append = function(other) {

        if (this.numCols !== other.numCols) {
            throw 'Appended templates must have the same number of columns';
        }
        
        // new rects begin after the last current row
        var startY = this.numRows,
            i, len, rect;

        // copy rects from the other template
        for (i = 0, len = other.rects.length; i < len; i++) {
            rect = other.rects[i];
            this.rects.push(
                new Rectangle(rect.x, startY + rect.y, rect.width, rect.height));
        }

        this.numRows += other.numRows;
    };

    Tiles.Template.fromJSON = function(rows) {
        // convert rows to cells and then to rects
        var cells = parseCells(rows),
            rects = parseRects(cells);
        return new Tiles.Template(
            rects,
            cells.length > 0 ? cells[0].length : 0,
            cells.length);
    };

    Tiles.Template.prototype.toJSON = function() {
        // for now we'll assume 26 chars is enough (we don't solve graph coloring)
        var LABELS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            NUM_LABELS = LABELS.length,
            labelIndex = 0,
            rows = [],
            i, len, rect, x, y, label;

        // fill in single tiles for each cell
        for (y = 0; y < this.numRows; y++) {
            rows[y] = [];
            for (x = 0; x < this.numCols; x++) {
                rows[y][x] = Tiles.Template.SINGLE_CELL;
            }
        }

        // now fill in bigger tiles
        for (i = 0, len = this.rects.length; i < len; i++) {
            rect = this.rects[i];
            if (rect.width > 1 || rect.height > 1) {

                // mark the tile position with a label
                label = LABELS[labelIndex];
                for(y = 0; y < rect.height; y++) {
                    for(x = 0; x < rect.width; x++) {
                        rows[rect.y + y][rect.x + x] = label;
                    }
                }

                // advance the label index
                labelIndex = (labelIndex + 1) % NUM_LABELS;
            }
        }

        // turn the rows into strings
        for (y = 0; y < this.numRows; y++) {
            rows[y] = rows[y].join('');
        }

        return rows;
    };
    
    // period used to designate a single 1x1 cell tile
    Tiles.Template.SINGLE_CELL = '.';

})(jQuery);


// template provider which returns simple templates with 1x1 tiles
Tiles.UniformTemplates = {
    get: function(numCols, targetTiles) {
        var numRows = Math.ceil(targetTiles / numCols),
            rects = [],
            x, y;

        // create the rects for 1x1 tiles
        for (y = 0; y < numRows; y++) {
            for (x = 0; x < numCols; x++) {
                rects.push(new Tiles.Rectangle(x, y, 1, 1));
            }
        }

        return new Tiles.Template(rects, numCols, numRows);
    }
};
(function($) {

    var Grid = Tiles.Grid = function(element) {

        this.$el = $(element);

        // animation lasts 500 ms by default
        this.animationDuration = 500;

        // min width and height of a cell in the grid
        this.cellSizeMin = 150;

        // the default set of factories used when creating templates
        this.templateFactory = Tiles.UniformTemplates;
        
        // defines the page size for prioritization of positions and tiles
        this.priorityPageSize = Number.MAX_VALUE;

        // spacing between tiles
        this.cellPadding = 10;

        // actual width and height of a cell in the grid
        this.cellSize = 0;

        // number of tile cell columns
        this.numCols = 1;

        // cache the current template
        this.template = null;

        // flag that tracks whether a redraw is necessary
        this.isDirty = true;

        this.tiles = [];

        // keep track of added and removed tiles so we can update tiles
        // and the render the grid independently.
        this.tilesAdded = [];
        this.tilesRemoved = [];
    };

    Grid.prototype.getContentWidth = function() {
        // by default, the entire container width is used when drawing tiles
        return this.$el.width();
    };

    // gets the number of columns during a resize
    Grid.prototype.resizeColumns = function() {
        var panelWidth = this.getContentWidth();
        
        // ensure we have at least one column
        return Math.max(1, Math.floor((panelWidth + this.cellPadding) /
            (this.cellSizeMin + this.cellPadding)));
    };

    // gets the cell size during a grid resize
    Grid.prototype.resizeCellSize = function() {
        var panelWidth = this.getContentWidth();
        return Math.ceil((panelWidth + this.cellPadding) / this.numCols) -
            this.cellPadding;
    };

    Grid.prototype.resize = function() {
        
        var newCols = this.resizeColumns();
        if (this.numCols !== newCols && newCols > 0) {
            this.numCols = newCols;
            this.isDirty = true;
        }

        var newCellSize = this.resizeCellSize();        
        if (this.cellSize !== newCellSize && newCellSize > 0) {
            this.cellSize = newCellSize;
            this.isDirty = true;    
        }
    };

    // refresh all tiles based on the current content
    Grid.prototype.updateTiles = function(newTileIds) {

        // ensure we dont have duplicate ids
        newTileIds = uniques(newTileIds);

        var numTiles = newTileIds.length,
            newTiles = [],
            i, tile, tileId, index;

        // retain existing tiles and queue remaining tiles for removal
        for (i = this.tiles.length - 1; i >= 0; i--) {
            tile = this.tiles[i];
            index = $.inArray(tile.id, newTileIds);
            if (index < 0) {
                this.tilesRemoved.push(tile);
                //console.log('Removing tile: ' + tile.id)
            }
            else {
                newTiles[index] = tile;
            }
        }

        // clear existing tiles
        this.tiles = [];

        // make sure we have tiles for new additions
        for (i = 0; i < numTiles; i++) {
            
            tile = newTiles[i];
            if (!tile) {

                tileId = newTileIds[i];
                
                // see if grid has a custom tile factory
                if (this.createTile) {
                    
                    tile = this.createTile(tileId);
    
                    // skip the tile if it couldn't be created
                    if (!tile) {
                        //console.log('Tile element could not be created, id: ' + tileId);
                        continue;
                    }

                } else {

                    tile = new Tiles.Tile(tileId);
                }
                
                // add tiles to queue (will be appended to DOM during redraw)
                this.tilesAdded.push(tile);
                //console.log('Adding tile: ' + tile.id);
            }

            this.tiles.push(tile);
        }
    };

    // helper to return unique items
    function uniques(items) {
        var results = [],
            numItems = items ? items.length : 0,
            i, item;

        for (i = 0; i < numItems; i++) {
            item = items[i];
            if ($.inArray(item, results) === -1) {
                results.push(item);
            }
        }

        return results;
    }

    // prepend new tiles
    Grid.prototype.insertTiles = function(newTileIds) {
        this.addTiles(newTileIds, true);
    };

    // append new tiles
    Grid.prototype.addTiles = function(newTileIds, prepend) {

        if (!newTileIds || newTileIds.length === 0) {
            return;
        }

        var prevTileIds = [],
            prevTileCount = this.tiles.length,
            i;

        // get the existing tile ids
        for (i = 0; i < prevTileCount; i++) {
            prevTileIds.push(this.tiles[i].id);
        }

        var tileIds = prepend ? newTileIds.concat(prevTileIds) 
            : prevTileIds.concat(newTileIds);
        this.updateTiles(tileIds);
    };

    Grid.prototype.removeTiles = function(removeTileIds) {

        if (!removeTileIds || removeTileIds.length === 0) {
            return;
        }

        var updateTileIds = [],
            i, len, id;

        // get the set of ids which have not been removed
        for (i = 0, len = this.tiles.length; i < len; i++) {
            id = this.tiles[i].id;
            if ($.inArray(id, removeTileIds) === -1) {
                updateTileIds.push(id);
            }
        }

        this.updateTiles(updateTileIds);
    };

    Grid.prototype.createTemplate = function(numCols, targetTiles) {
        
        // ensure that we have at least one column
        numCols = Math.max(1, numCols);

        var template = this.templateFactory.get(numCols, targetTiles);
        if (!template) {
            
            // fallback in case the default factory can't generate a good template
            template = Tiles.UniformTemplates.get(numCols, targetTiles);
        }
        
        return template;
    };

    // ensures we have a good template for the specified numbef of tiles
    Grid.prototype.ensureTemplate = function(numTiles) {

        // verfiy that the current template is still valid
        if (!this.template || this.template.numCols !== this.numCols) {
            this.template = this.createTemplate(this.numCols, numTiles);
            this.isDirty = true;
        } else {

            // append another template if we don't have enough rects
            var missingRects = numTiles - this.template.rects.length;
            if (missingRects > 0) {
                this.template.append(
                    this.createTemplate(this.numCols, missingRects));    
                this.isDirty = true;
            }

        }
    };

    // helper that returns true if a tile was in the viewport or will be given
    // the new pixel rect coordinates and dimensions
    function wasOrWillBeVisible(viewRect, tile, newRect) {

        var viewMaxY = viewRect.y + viewRect.height,
            viewMaxX = viewRect.x + viewRect.width;

        // note: y axis is the more common exclusion, so check that first

        // was the tile visible?
        if (tile) {
            if (!((tile.top > viewMaxY) || (tile.top + tile.height < viewRect.y) ||
                (tile.left > viewMaxX) || (tile.left + tile.width < viewRect.x))) {
                return true;
            }
        }
        
        if (newRect) {
            // will it be visible?
            if (!((newRect.y > viewMaxY) || (newRect.y + newRect.height < viewRect.y) ||
                (newRect.x > viewMaxX) || (newRect.x + newRect.width < viewRect.x))) {
                return true;
            }
        }
        
        return false;
    }

    Grid.prototype.shouldRedraw = function() {

        // see if we need to calculate the cell size
        if (this.cellSize <= 0) {
            this.resize();
        }

        // verify that we have a template
        this.ensureTemplate(this.tiles.length);

        // only redraw when necessary
        var shouldRedraw = (this.isDirty ||
            this.tilesAdded.length > 0 ||
            this.tilesRemoved.length > 0);

        return shouldRedraw;
    };

    // redraws the grid after tile collection changes
    Grid.prototype.redraw = function(animate, onComplete) {

        // see if we should redraw
        if (!this.shouldRedraw()) {
            if (onComplete) {
                onComplete(false); // tell callback that we did not redraw
            }
            return;
        }        

        var numTiles = this.tiles.length,
            pageSize = this.priorityPageSize,
            duration = this.animationDuration,
            cellPlusPadding = this.cellSize + this.cellPadding,
            tileIndex = 0,
            appendDelay = 0,
            viewRect = new Tiles.Rectangle(
                this.$el.scrollLeft(),
                this.$el.scrollTop(),
                this.$el.width(),
                this.$el.height()),
            tile, added, pageRects, pageTiles, i, len, cellRect, pixelRect,
            animateTile, priorityRects, priorityTiles;

            
        // chunk tile layout by pages which are internally prioritized
        for (tileIndex = 0; tileIndex < numTiles; tileIndex += pageSize) {

            // get the next page of rects and tiles
            pageRects = this.template.rects.slice(tileIndex, tileIndex + pageSize);
            pageTiles = this.tiles.slice(tileIndex, tileIndex + pageSize);

            // create a copy that can be ordered
            priorityRects = pageRects.slice(0);
            priorityTiles = pageTiles.slice(0);

            // prioritize the page of rects and tiles
            if (this.prioritizePage) {
                this.prioritizePage(priorityRects, priorityTiles);
            }
                
            // place all the tiles for the current page
            for (i = 0, len = priorityTiles.length; i < len; i++) {
                tile = priorityTiles[i];
                added = $.inArray(tile, this.tilesAdded) >= 0;

                cellRect = priorityRects[i];
                pixelRect = new Tiles.Rectangle(                        
                    cellRect.x * cellPlusPadding,
                    cellRect.y * cellPlusPadding,
                    (cellRect.width * cellPlusPadding) - this.cellPadding,
                    (cellRect.height * cellPlusPadding) - this.cellPadding);

                tile.resize(
                    cellRect,
                    pixelRect,
                    animate && !added && wasOrWillBeVisible(viewRect, tile, pixelRect),
                    duration);

                if (added) {

                    // decide whether to animate (fadeIn) and get the duration
                    animateTile = animate && wasOrWillBeVisible(viewRect, null, pixelRect);
                    if (animateTile && this.getAppendDelay) {
                        appendDelay = this.getAppendDelay(
                            cellRect, pageRects, priorityRects, 
                            tile, pageTiles, priorityTiles);
                    } else {
                        appendDelay = 0;
                    }

                    tile.appendTo(this.$el, animateTile, appendDelay, duration);
                }
            }
        }

        // fade out all removed tiles
        for (i = 0, len = this.tilesRemoved.length; i < len; i++) {
            tile = this.tilesRemoved[i];
            animateTile = animate && wasOrWillBeVisible(viewRect, tile, null);
            tile.remove(animateTile, duration);
        }

        // clear pending queues for add / remove
        this.tilesRemoved = [];
        this.tilesAdded = [];
        this.isDirty = false;

        if (onComplete) {
            setTimeout(function() { onComplete(true); }, duration + 10);
        }
    };

})(jQuery);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/fileSaver.js

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.1.20150716
 *
 * By Eli Grey, http://eligrey.com
Copyright © 2015 Eli Grey.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				setTimeout(function() {
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name, no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name || "download");
		};
	}

	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/papaparse.js

/*!
	Papa Parse
	v4.3.2
	https://github.com/mholt/PapaParse
*/
(function(root, factory)
{
	if (typeof define === 'function' && define.amd)
	{
		// AMD. Register as an anonymous module.
		define([], factory);
	}
	else if (typeof module === 'object' && module.exports)
	{
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	}
	else
	{
		// Browser globals (root is window)
		root.Papa = factory();
	}
}(this, function()
{
	'use strict';

	var global = (function () {
		// alternative method, similar to `Function('return this')()`
		// but without using `eval` (which is disabled when
		// using Content Security Policy).

		if (typeof self !== 'undefined') { return self; }
		if (typeof window !== 'undefined') { return window; }
		if (typeof global !== 'undefined') { return global; }

        // When running tests none of the above have been defined
        return {};
	})();


	var IS_WORKER = !global.document && !!global.postMessage,
		IS_PAPA_WORKER = IS_WORKER && /(\?|&)papaworker(=|&|$)/.test(global.location.search),
		LOADED_SYNC = false, AUTO_SCRIPT_PATH;
	var workers = {}, workerIdCounter = 0;

	var Papa = {};

	Papa.parse = CsvToJson;
	Papa.unparse = JsonToCsv;

	Papa.RECORD_SEP = String.fromCharCode(30);
	Papa.UNIT_SEP = String.fromCharCode(31);
	Papa.BYTE_ORDER_MARK = '\ufeff';
	Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
	Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
	Papa.SCRIPT_PATH = null;	// Must be set by your code if you use workers and this lib is loaded asynchronously

	// Configurable chunk sizes for local and remote files, respectively
	Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
	Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
	Papa.DefaultDelimiter = ',';			// Used if not specified and detection fails

	// Exposed for testing and development only
	Papa.Parser = Parser;
	Papa.ParserHandle = ParserHandle;
	Papa.NetworkStreamer = NetworkStreamer;
	Papa.FileStreamer = FileStreamer;
	Papa.StringStreamer = StringStreamer;
	Papa.ReadableStreamStreamer = ReadableStreamStreamer;

	if (global.jQuery)
	{
		var $ = global.jQuery;
		$.fn.parse = function(options)
		{
			var config = options.config || {};
			var queue = [];

			this.each(function(idx)
			{
				var supported = $(this).prop('tagName').toUpperCase() === 'INPUT'
								&& $(this).attr('type').toLowerCase() === 'file'
								&& global.FileReader;

				if (!supported || !this.files || this.files.length === 0)
					return true;	// continue to next input element

				for (var i = 0; i < this.files.length; i++)
				{
					queue.push({
						file: this.files[i],
						inputElem: this,
						instanceConfig: $.extend({}, config)
					});
				}
			});

			parseNextFile();	// begin parsing
			return this;		// maintains chainability


			function parseNextFile()
			{
				if (queue.length === 0)
				{
					if (isFunction(options.complete))
						options.complete();
					return;
				}

				var f = queue[0];

				if (isFunction(options.before))
				{
					var returned = options.before(f.file, f.inputElem);

					if (typeof returned === 'object')
					{
						if (returned.action === 'abort')
						{
							error('AbortError', f.file, f.inputElem, returned.reason);
							return;	// Aborts all queued files immediately
						}
						else if (returned.action === 'skip')
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
						else if (typeof returned.config === 'object')
							f.instanceConfig = $.extend(f.instanceConfig, returned.config);
					}
					else if (returned === 'skip')
					{
						fileComplete();	// parse the next file in the queue, if any
						return;
					}
				}

				// Wrap up the user's complete callback, if any, so that ours also gets executed
				var userCompleteFunc = f.instanceConfig.complete;
				f.instanceConfig.complete = function(results)
				{
					if (isFunction(userCompleteFunc))
						userCompleteFunc(results, f.file, f.inputElem);
					fileComplete();
				};

				Papa.parse(f.file, f.instanceConfig);
			}

			function error(name, file, elem, reason)
			{
				if (isFunction(options.error))
					options.error({name: name}, file, elem, reason);
			}

			function fileComplete()
			{
				queue.splice(0, 1);
				parseNextFile();
			}
		}
	}


	if (IS_PAPA_WORKER)
	{
		global.onmessage = workerThreadReceivedMessage;
	}
	else if (Papa.WORKERS_SUPPORTED)
	{
		AUTO_SCRIPT_PATH = getScriptPath();

		// Check if the script was loaded synchronously
		if (!document.body)
		{
			// Body doesn't exist yet, must be synchronous
			LOADED_SYNC = true;
		}
		else
		{
			document.addEventListener('DOMContentLoaded', function () {
				LOADED_SYNC = true;
			}, true);
		}
	}




	function CsvToJson(_input, _config)
	{
		_config = _config || {};
        var dynamicTyping = _config.dynamicTyping || false;
        if (isFunction(dynamicTyping)) {
            _config.dynamicTypingFunction = dynamicTyping;
            // Will be filled on first row call
            dynamicTyping = {};
        }
        _config.dynamicTyping = dynamicTyping;

		if (_config.worker && Papa.WORKERS_SUPPORTED)
		{
			var w = newWorker();

			w.userStep = _config.step;
			w.userChunk = _config.chunk;
			w.userComplete = _config.complete;
			w.userError = _config.error;

			_config.step = isFunction(_config.step);
			_config.chunk = isFunction(_config.chunk);
			_config.complete = isFunction(_config.complete);
			_config.error = isFunction(_config.error);
			delete _config.worker;	// prevent infinite loop

			w.postMessage({
				input: _input,
				config: _config,
				workerId: w.id
			});

			return;
		}

		var streamer = null;
		if (typeof _input === 'string')
		{
			if (_config.download)
				streamer = new NetworkStreamer(_config);
			else
				streamer = new StringStreamer(_config);
		}
		else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))
		{
			streamer = new ReadableStreamStreamer(_config);
		}
		else if ((global.File && _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
			streamer = new FileStreamer(_config);

		return streamer.stream(_input);
	}






	function JsonToCsv(_input, _config)
	{
		var _output = '';
		var _fields = [];

		// Default configuration

		/** whether to surround every datum with quotes */
		var _quotes = false;

		/** whether to write headers */
		var _writeHeader = true;

		/** delimiting character */
		var _delimiter = ',';

		/** newline character(s) */
		var _newline = '\r\n';

		/** quote character */
		var _quoteChar = '"';

		unpackConfig();

		var quoteCharRegex = new RegExp(_quoteChar, 'g');

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields =  _input.meta && _input.meta.fields;

				if (!_input.fields)
					_input.fields =  _input.data[0] instanceof Array
									? _input.fields
									: objectKeys(_input.data[0]);

				if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ['asdf']
			}

			return serialize(_input.fields || [], _input.data || []);
		}

		// Default (any valid paths should return before this)
		throw 'exception: Unable to serialize unrecognized input';


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
				&& _config.delimiter.length === 1
				&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;

			if (typeof _config.quoteChar === 'string')
				_quoteChar = _config.quoteChar;

			if (typeof _config.header === 'boolean')
				_writeHeader = _config.header;
		}


		/** Turns an object's keys into an array */
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		/** The double for loop that iterates the data and writes out a CSV string including header row */
		function serialize(fields, data)
		{
			var csv = '';

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = fields instanceof Array && fields.length > 0;
			var dataKeyedByField = !(data[0] instanceof Array);

			// If there a header row, write it first
			if (hasHeader && _writeHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				for (var col = 0; col < maxCol; col++)
				{
					if (col > 0)
						csv += _delimiter;
					var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}

				if (row < data.length - 1)
					csv += _newline;
			}

			return csv;
		}

		/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
		function safe(str, col)
		{
			if (typeof str === 'undefined' || str === null)
				return '';

			str = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (_quotes instanceof Array && _quotes[col])
							|| hasAny(str, Papa.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) === ' '
							|| str.charAt(str.length - 1) === ' ';

			return needsQuotes ? _quoteChar + str + _quoteChar : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}

	/** ChunkStreamer is the base prototype for various streamer implementations. */
	function ChunkStreamer(config)
	{
		this._handle = null;
		this._paused = false;
		this._finished = false;
		this._input = null;
		this._baseIndex = 0;
		this._partialLine = '';
		this._rowCount = 0;
		this._start = 0;
		this._nextChunk = null;
		this.isFirstChunk = true;
		this._completeResults = {
			data: [],
			errors: [],
			meta: {}
		};
		replaceConfig.call(this, config);

		this.parseChunk = function(chunk)
		{
			// First chunk pre-processing
			if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))
			{
				var modifiedChunk = this._config.beforeFirstChunk(chunk);
				if (modifiedChunk !== undefined)
					chunk = modifiedChunk;
			}
			this.isFirstChunk = false;

			// Rejoin the line we likely just split in two by chunking the file
			var aggregate = this._partialLine + chunk;
			this._partialLine = '';

			var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

			if (this._handle.paused() || this._handle.aborted())
				return;

			var lastIndex = results.meta.cursor;

			if (!this._finished)
			{
				this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
				this._baseIndex = lastIndex;
			}

			if (results && results.data)
				this._rowCount += results.data.length;

			var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);

			if (IS_PAPA_WORKER)
			{
				global.postMessage({
					results: results,
					workerId: Papa.WORKER_ID,
					finished: finishedIncludingPreview
				});
			}
			else if (isFunction(this._config.chunk))
			{
				this._config.chunk(results, this._handle);
				if (this._paused)
					return;
				results = undefined;
				this._completeResults = undefined;
			}

			if (!this._config.step && !this._config.chunk) {
				this._completeResults.data = this._completeResults.data.concat(results.data);
				this._completeResults.errors = this._completeResults.errors.concat(results.errors);
				this._completeResults.meta = results.meta;
			}

			if (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))
				this._config.complete(this._completeResults, this._input);

			if (!finishedIncludingPreview && (!results || !results.meta.paused))
				this._nextChunk();

			return results;
		};

		this._sendError = function(error)
		{
			if (isFunction(this._config.error))
				this._config.error(error);
			else if (IS_PAPA_WORKER && this._config.error)
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					error: error,
					finished: false
				});
			}
		};

		function replaceConfig(config)
		{
			// Deep-copy the config so we can edit it
			var configCopy = copy(config);
			configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
			if (!config.step && !config.chunk)
				configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
			this._handle = new ParserHandle(configCopy);
			this._handle.streamer = this;
			this._config = configCopy;	// persist the copy to the caller
		}
	}


	function NetworkStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.RemoteChunkSize;
		ChunkStreamer.call(this, config);

		var xhr;

		if (IS_WORKER)
		{
			this._nextChunk = function()
			{
				this._readChunk();
				this._chunkLoaded();
			};
		}
		else
		{
			this._nextChunk = function()
			{
				this._readChunk();
			};
		}

		this.stream = function(url)
		{
			this._input = url;
			this._nextChunk();	// Starts streaming
		};

		this._readChunk = function()
		{
			if (this._finished)
			{
				this._chunkLoaded();
				return;
			}

			xhr = new XMLHttpRequest();

			if (this._config.withCredentials)
			{
				xhr.withCredentials = this._config.withCredentials;
			}

			if (!IS_WORKER)
			{
				xhr.onload = bindFunction(this._chunkLoaded, this);
				xhr.onerror = bindFunction(this._chunkError, this);
			}

			xhr.open('GET', this._input, !IS_WORKER);
			// Headers can only be set when once the request state is OPENED
			if (this._config.downloadRequestHeaders)
			{
				var headers = this._config.downloadRequestHeaders;

				for (var headerName in headers)
				{
					xhr.setRequestHeader(headerName, headers[headerName]);
				}
			}

			if (this._config.chunkSize)
			{
				var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
				xhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);
				xhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672
			}

			try {
				xhr.send();
			}
			catch (err) {
				this._chunkError(err.message);
			}

			if (IS_WORKER && xhr.status === 0)
				this._chunkError();
			else
				this._start += this._config.chunkSize;
		}

		this._chunkLoaded = function()
		{
			if (xhr.readyState != 4)
				return;

			if (xhr.status < 200 || xhr.status >= 400)
			{
				this._chunkError();
				return;
			}

			this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
			this.parseChunk(xhr.responseText);
		}

		this._chunkError = function(errorMessage)
		{
			var errorText = xhr.statusText || errorMessage;
			this._sendError(errorText);
		}

		function getFileSize(xhr)
		{
			var contentRange = xhr.getResponseHeader('Content-Range');
			if (contentRange === null) { // no content range, then finish!
        			return -1;
            		}
			return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
		}
	}
	NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
	NetworkStreamer.prototype.constructor = NetworkStreamer;


	function FileStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.LocalChunkSize;
		ChunkStreamer.call(this, config);

		var reader, slice;

		// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
		// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
		var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105

		this.stream = function(file)
		{
			this._input = file;
			slice = file.slice || file.webkitSlice || file.mozSlice;

			if (usingAsyncReader)
			{
				reader = new FileReader();		// Preferred method of reading files, even in workers
				reader.onload = bindFunction(this._chunkLoaded, this);
				reader.onerror = bindFunction(this._chunkError, this);
			}
			else
				reader = new FileReaderSync();	// Hack for running in a web worker in Firefox

			this._nextChunk();	// Starts streaming
		};

		this._nextChunk = function()
		{
			if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
				this._readChunk();
		}

		this._readChunk = function()
		{
			var input = this._input;
			if (this._config.chunkSize)
			{
				var end = Math.min(this._start + this._config.chunkSize, this._input.size);
				input = slice.call(input, this._start, end);
			}
			var txt = reader.readAsText(input, this._config.encoding);
			if (!usingAsyncReader)
				this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
		}

		this._chunkLoaded = function(event)
		{
			// Very important to increment start each time before handling results
			this._start += this._config.chunkSize;
			this._finished = !this._config.chunkSize || this._start >= this._input.size;
			this.parseChunk(event.target.result);
		}

		this._chunkError = function()
		{
			this._sendError(reader.error);
		}

	}
	FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
	FileStreamer.prototype.constructor = FileStreamer;


	function StringStreamer(config)
	{
		config = config || {};
		ChunkStreamer.call(this, config);

		var string;
		var remaining;
		this.stream = function(s)
		{
			string = s;
			remaining = s;
			return this._nextChunk();
		}
		this._nextChunk = function()
		{
			if (this._finished) return;
			var size = this._config.chunkSize;
			var chunk = size ? remaining.substr(0, size) : remaining;
			remaining = size ? remaining.substr(size) : '';
			this._finished = !remaining;
			return this.parseChunk(chunk);
		}
	}
	StringStreamer.prototype = Object.create(StringStreamer.prototype);
	StringStreamer.prototype.constructor = StringStreamer;


	function ReadableStreamStreamer(config)
	{
		config = config || {};

		ChunkStreamer.call(this, config);

		var queue = [];
		var parseOnData = true;

		this.stream = function(stream)
		{
			this._input = stream;

			this._input.on('data', this._streamData);
			this._input.on('end', this._streamEnd);
			this._input.on('error', this._streamError);
		}

		this._nextChunk = function()
		{
			if (queue.length)
			{
				this.parseChunk(queue.shift());
			}
			else
			{
				parseOnData = true;
			}
		}

		this._streamData = bindFunction(function(chunk)
		{
			try
			{
				queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));

				if (parseOnData)
				{
					parseOnData = false;
					this.parseChunk(queue.shift());
				}
			}
			catch (error)
			{
				this._streamError(error);
			}
		}, this);

		this._streamError = bindFunction(function(error)
		{
			this._streamCleanUp();
			this._sendError(error.message);
		}, this);

		this._streamEnd = bindFunction(function()
		{
			this._streamCleanUp();
			this._finished = true;
			this._streamData('');
		}, this);

		this._streamCleanUp = bindFunction(function()
		{
			this._input.removeListener('data', this._streamData);
			this._input.removeListener('end', this._streamEnd);
			this._input.removeListener('error', this._streamError);
		}, this);
	}
	ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
	ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;


	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

		var self = this;
		var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
		var _input;				// The input being parsed
		var _parser;			// The core parser being used
		var _paused = false;	// Whether we are paused or not
		var _aborted = false;   // Whether the parser has aborted or not
		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};

		if (isFunction(_config.step))
		{
			var userStep = _config.step;
			_config.step = function(results)
			{
				_results = results;

				if (needsHeaderRow())
					processResults();
				else	// only call user's step function after header row
				{
					processResults();

					// It's possbile that this line was empty and there's no row here after all
					if (_results.data.length === 0)
						return;

					_stepCounter += results.data.length;
					if (_config.preview && _stepCounter > _config.preview)
						_parser.abort();
					else
						userStep(_results, self);
				}
			};
		}

		/**
		 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
		 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
		 * when an input comes in multiple chunks, like from a file.
		 */
		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			if (!_config.newline)
				_config.newline = guessLineEndings(input);

			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input, _config.newline);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = Papa.DefaultDelimiter;
				}
				_results.meta.delimiter = _config.delimiter;
			}
			else if(isFunction(_config.delimiter))
			{
				_config.delimiter = _config.delimiter(input);
				_results.meta.delimiter = _config.delimiter;
			}

			var parserConfig = copy(_config);
			if (_config.preview && _config.header)
				parserConfig.preview++;	// to compensate for header row

			_input = input;
			_parser = new Parser(parserConfig);
			_results = _parser.parse(_input, baseIndex, ignoreLastRow);
			processResults();
			return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
		};

		this.paused = function()
		{
			return _paused;
		};

		this.pause = function()
		{
			_paused = true;
			_parser.abort();
			_input = _input.substr(_parser.getCharIndex());
		};

		this.resume = function()
		{
			_paused = false;
			self.streamer.parseChunk(_input);
		};

		this.aborted = function ()
		{
			return _aborted;
		};

		this.abort = function()
		{
			_aborted = true;
			_parser.abort();
			_results.meta.aborted = true;
			if (isFunction(_config.complete))
				_config.complete(_results);
			_input = '';
		};

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \''+Papa.DefaultDelimiter+'\'');
				_delimiterError = false;
			}

			if (_config.skipEmptyLines)
			{
				for (var i = 0; i < _results.data.length; i++)
					if (_results.data[i].length === 1 && _results.data[i][0] === '')
						_results.data.splice(i--, 1);
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTyping();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length === 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
				for (var j = 0; j < _results.data[i].length; j++)
					_fields.push(_results.data[i][j]);
			_results.data.splice(0, 1);
		}

        function shouldApplyDynamicTyping(field) {
            // Cache function values to avoid calling it for each row
            if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
                _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
            }
            return (_config.dynamicTyping[field] || _config.dynamicTyping) === true
        }

		function parseDynamic(field, value)
		{
			if (shouldApplyDynamicTyping(field))
			{
				if (value === 'true' || value === 'TRUE')
					return true;
				else if (value === 'false' || value === 'FALSE')
					return false;
				else
					return tryParseFloat(value);
			}
			return value;
		}

		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping))
				return _results;

			for (var i = 0; i < _results.data.length; i++)
			{
				var row = _config.header ? {} : [];

				for (var j = 0; j < _results.data[i].length; j++)
				{
					var field = j;
					var value = _results.data[i][j];

					if (_config.header)
						field = j >= _fields.length ? '__parsed_extra' : _fields[j];

					value = parseDynamic(field, value);

					if (field === '__parsed_extra')
					{
						row[field] = row[field] || [];
						row[field].push(value);
					}
					else
						row[field] = value;
				}

				_results.data[i] = row;

				if (_config.header)
				{
					if (j > _fields.length)
						addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
					else if (j < _fields.length)
						addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
				}
			}

			if (_config.header && _results.meta)
				_results.meta.fields = _fields;
			return _results;
		}

		function guessDelimiter(input, newline)
		{
			var delimChoices = [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;

			for (var i = 0; i < delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					delimiter: delim,
					newline: newline,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++)
				{
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				if (preview.data.length > 0)
					avgFieldCount /= preview.data.length;

				if ((typeof bestDelta === 'undefined' || delta < bestDelta)
					&& avgFieldCount > 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			}
		}

		function guessLineEndings(input)
		{
			input = input.substr(0, 1024*1024);	// max length 1 MB

			var r = input.split('\r');

			var n = input.split('\n');

			var nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);

			if (r.length === 1 || nAppearsFirst)
				return '\n';

			var numWithN = 0;
			for (var i = 0; i < r.length; i++)
			{
				if (r[i][0] === '\n')
					numWithN++;
			}

			return numWithN >= r.length / 2 ? '\r\n' : '\r';
		}

		function tryParseFloat(val)
		{
			var isNumber = FLOAT.test(val);
			return isNumber ? parseFloat(val) : val;
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}





	/** The core parser implements speedy and correct CSV parsing */
	function Parser(config)
	{
		// Unpack the config object
		config = config || {};
		var delim = config.delimiter;
		var newline = config.newline;
		var comments = config.comments;
		var step = config.step;
		var preview = config.preview;
		var fastMode = config.fastMode;
		var quoteChar = config.quoteChar || '"';

		// Delimiter must be valid
		if (typeof delim !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)
			delim = ',';

		// Comment character must be valid
		if (comments === delim)
			throw 'Comment character same as delimiter';
		else if (comments === true)
			comments = '#';
		else if (typeof comments !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)
			comments = false;

		// Newline must be valid: \r, \n, or \r\n
		if (newline != '\n' && newline != '\r' && newline != '\r\n')
			newline = '\n';

		// We're gonna need these at the Parser scope
		var cursor = 0;
		var aborted = false;

		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			// For some reason, in Chrome, this speeds things up (!?)
			if (typeof input !== 'string')
				throw 'Input must be a string';

			// We don't need to compute some of these every time parse() is called,
			// but having them in a more local scope seems to perform better
			var inputLen = input.length,
				delimLen = delim.length,
				newlineLen = newline.length,
				commentsLen = comments.length;
			var stepIsFunction = isFunction(step);

			// Establish starting state
			cursor = 0;
			var data = [], errors = [], row = [], lastCursor = 0;

			if (!input)
				return returnable();

			if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))
			{
				var rows = input.split(newline);
				for (var i = 0; i < rows.length; i++)
				{
					var row = rows[i];
					cursor += row.length;
					if (i !== rows.length - 1)
						cursor += newline.length;
					else if (ignoreLastRow)
						return returnable();
					if (comments && row.substr(0, commentsLen) === comments)
						continue;
					if (stepIsFunction)
					{
						data = [];
						pushRow(row.split(delim));
						doStep();
						if (aborted)
							return returnable();
					}
					else
						pushRow(row.split(delim));
					if (preview && i >= preview)
					{
						data = data.slice(0, preview);
						return returnable(true);
					}
				}
				return returnable();
			}

			var nextDelim = input.indexOf(delim, cursor);
			var nextNewline = input.indexOf(newline, cursor);
			var quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');

			// Parser loop
			for (;;)
			{
				// Field has opening quote
				if (input[cursor] === quoteChar)
				{
					// Start our search for the closing quote where the cursor is
					var quoteSearch = cursor;

					// Skip the opening quote
					cursor++;

					for (;;)
					{
						// Find closing quote
						var quoteSearch = input.indexOf(quoteChar, quoteSearch+1);

						if (quoteSearch === -1)
						{
							if (!ignoreLastRow) {
								// No closing quote... what a pity
								errors.push({
									type: 'Quotes',
									code: 'MissingQuotes',
									message: 'Quoted field unterminated',
									row: data.length,	// row has yet to be inserted
									index: cursor
								});
							}
							return finish();
						}

						if (quoteSearch === inputLen-1)
						{
							// Closing quote at EOF
							var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
							return finish(value);
						}

						// If this quote is escaped, it's part of the data; skip it
						if (input[quoteSearch+1] === quoteChar)
						{
							quoteSearch++;
							continue;
						}

						if (input[quoteSearch+1] === delim)
						{
							// Closing quote followed by delimiter
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							cursor = quoteSearch + 1 + delimLen;
							nextDelim = input.indexOf(delim, cursor);
							nextNewline = input.indexOf(newline, cursor);
							break;
						}

						if (input.substr(quoteSearch+1, newlineLen) === newline)
						{
							// Closing quote followed by newline
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							saveRow(quoteSearch + 1 + newlineLen);
							nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field

							if (stepIsFunction)
							{
								doStep();
								if (aborted)
									return returnable();
							}

							if (preview && data.length >= preview)
								return returnable(true);

							break;
						}
					}

					continue;
				}

				// Comment found at start of new line
				if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)
				{
					if (nextNewline === -1)	// Comment ends at EOF
						return returnable();
					cursor = nextNewline + newlineLen;
					nextNewline = input.indexOf(newline, cursor);
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// Next delimiter comes before next newline, so we've reached end of field
				if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))
				{
					row.push(input.substring(cursor, nextDelim));
					cursor = nextDelim + delimLen;
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// End of row
				if (nextNewline !== -1)
				{
					row.push(input.substring(cursor, nextNewline));
					saveRow(nextNewline + newlineLen);

					if (stepIsFunction)
					{
						doStep();
						if (aborted)
							return returnable();
					}

					if (preview && data.length >= preview)
						return returnable(true);

					continue;
				}

				break;
			}


			return finish();


			function pushRow(row)
			{
				data.push(row);
				lastCursor = cursor;
			}

			/**
			 * Appends the remaining input from cursor to the end into
			 * row, saves the row, calls step, and returns the results.
			 */
			function finish(value)
			{
				if (ignoreLastRow)
					return returnable();
				if (typeof value === 'undefined')
					value = input.substr(cursor);
				row.push(value);
				cursor = inputLen;	// important in case parsing is paused
				pushRow(row);
				if (stepIsFunction)
					doStep();
				return returnable();
			}

			/**
			 * Appends the current row to the results. It sets the cursor
			 * to newCursor and finds the nextNewline. The caller should
			 * take care to execute user's step function and check for
			 * preview and end parsing if necessary.
			 */
			function saveRow(newCursor)
			{
				cursor = newCursor;
				pushRow(row);
				row = [];
				nextNewline = input.indexOf(newline, cursor);
			}

			/** Returns an object with the results, errors, and meta. */
			function returnable(stopped)
			{
				return {
					data: data,
					errors: errors,
					meta: {
						delimiter: delim,
						linebreak: newline,
						aborted: aborted,
						truncated: !!stopped,
						cursor: lastCursor + (baseIndex || 0)
					}
				};
			}

			/** Executes the user's step function and resets data & errors. */
			function doStep()
			{
				step(returnable());
				data = [], errors = [];
			}
		};

		/** Sets the abort flag */
		this.abort = function()
		{
			aborted = true;
		};

		/** Gets the cursor position */
		this.getCharIndex = function()
		{
			return cursor;
		};
	}


	// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code
	// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358
	function getScriptPath()
	{
		var scripts = document.getElementsByTagName('script');
		return scripts.length ? scripts[scripts.length - 1].src : '';
	}

	function newWorker()
	{
		if (!Papa.WORKERS_SUPPORTED)
			return false;
		if (!LOADED_SYNC && Papa.SCRIPT_PATH === null)
			throw new Error(
				'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
				'You need to set Papa.SCRIPT_PATH manually.'
			);
		var workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;
		// Append 'papaworker' to the search string to tell papaparse that this is our worker.
		workerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';
		var w = new global.Worker(workerUrl);
		w.onmessage = mainThreadReceivedMessage;
		w.id = workerIdCounter++;
		workers[w.id] = w;
		return w;
	}

	/** Callback when main thread receives a message */
	function mainThreadReceivedMessage(e)
	{
		var msg = e.data;
		var worker = workers[msg.workerId];
		var aborted = false;

		if (msg.error)
			worker.userError(msg.error, msg.file);
		else if (msg.results && msg.results.data)
		{
			var abort = function() {
				aborted = true;
				completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
			};

			var handle = {
				abort: abort,
				pause: notImplemented,
				resume: notImplemented
			};

			if (isFunction(worker.userStep))
			{
				for (var i = 0; i < msg.results.data.length; i++)
				{
					worker.userStep({
						data: [msg.results.data[i]],
						errors: msg.results.errors,
						meta: msg.results.meta
					}, handle);
					if (aborted)
						break;
				}
				delete msg.results;	// free memory ASAP
			}
			else if (isFunction(worker.userChunk))
			{
				worker.userChunk(msg.results, handle, msg.file);
				delete msg.results;
			}
		}

		if (msg.finished && !aborted)
			completeWorker(msg.workerId, msg.results);
	}

	function completeWorker(workerId, results) {
		var worker = workers[workerId];
		if (isFunction(worker.userComplete))
			worker.userComplete(results);
		worker.terminate();
		delete workers[workerId];
	}

	function notImplemented() {
		throw 'Not implemented.';
	}

	/** Callback when worker thread receives a message */
	function workerThreadReceivedMessage(e)
	{
		var msg = e.data;

		if (typeof Papa.WORKER_ID === 'undefined' && msg)
			Papa.WORKER_ID = msg.workerId;

		if (typeof msg.input === 'string')
		{
			global.postMessage({
				workerId: Papa.WORKER_ID,
				results: Papa.parse(msg.input, msg.config),
				finished: true
			});
		}
		else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
		{
			var results = Papa.parse(msg.input, msg.config);
			if (results)
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: results,
					finished: true
				});
		}
	}

	/** Makes a deep copy of an array or object (mostly) */
	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function bindFunction(f, self)
	{
		return function() { f.apply(self, arguments); };
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}

	return Papa;
}));

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.core.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

"use strict";

var nunaliit2;

if( typeof nunaliit2 !== 'function' ) {
	nunaliit2 = function(){};
	if( typeof window !== 'undefined' ){
		window.nunaliit2 = nunaliit2;
	};
};

if( typeof nunaliit2.coreScriptName === 'undefined' ){
	nunaliit2.coreScriptName = 'nunaliit2.js';
};


// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.utils.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

$Id: n2.utils.js 8415 2012-08-07 15:39:35Z jpfiset $
*/

// @requires n2.core.js
// @namespace nunaliit2
;(function($n2){
"use strict";

/**
 	Logs to the console a string and a set of arguments. This works best with Firebug installed.
 	@name log
 	@function
 	@memberOf nunaliit2
 	@param {string} msg Log message
 	@param {Object} o1  Object to be inspected in log
 */
$n2.log = function(msg,o1) {
	if( typeof window === 'object'
	 && window.console 
	 && typeof window.console.log === 'function' ) {
		try { window.console.log.apply(window.console,arguments); }
			catch(e) {};
	};
};

/**
	Logs an error to the console
	@name logError
	@function
	@memberOf nunaliit2
	@param {String} msg Log message
	@param {Object} o1  Object to be inspected in log
*/
$n2.logError = function() {
	if( typeof window === 'object'
	 && window.console 
	 && typeof window.console.error === 'function' ) {
		try { window.console.error.apply(window.console,arguments); }
			catch(e) {};
	} else {
		$n2.log.apply(this,arguments);
	};
};

// Install logger on window
if( typeof window !== 'undefined' ) {
	if( typeof(window.log) === 'undefined' ) {
		window.log = $n2.log;
	};
};

var nativeArrayIndexOf = null;
if( typeof Array !== 'undefined' && Array.prototype ){
	nativeArrayIndexOf = Array.prototype.indexOf;
};

var nativeStringTrim = null;
if( typeof String !== 'undefined' && String.prototype ){
	nativeStringTrim = String.prototype.trim;
};


var cachedBrowserInfo = null;

//*********************************************
// reportError - This function reports an error
// only once, supressing it after the first report.
// The id is used to identify the error.

$n2.ERROR_NO_SUPRESS = {};

var reportedErrors = {};

/**
 	Alerts the user of an error. An error is presented to the user
 	only the first time it is encountered. Subsequent similar errors
 	are suppressed.
 	@name reportError
 	@function
 	@memberOf nunaliit2
 	@param {String} id A unique identifier for the error reported.
 	@param {String} msg Error message presented to the user. If omitted,
 	                    the id is presented to the user.
 */
$n2.reportError = function(id,str) {
	if( arguments.length < 1 ) return;
	
	if( arguments.length < 2 ) str = id; 

	$n2.logError.apply(null,arguments);	
	if( id === $n2.ERROR_NO_SUPRESS ) {
		// Report, always
		alert(str);
	} else if( reportedErrors[id] ) {
		// do not report again
	} else {
		reportedErrors[id] = 1;
		alert(str);
	};	
};

$n2.reportErrorForced = function(str) {
	$n2.reportError($n2.ERROR_NO_SUPRESS,str);	
};

//*********************************************
// isDefined

/**
 	Returns true if a the given argument is defined.
 	@name isDefined
 	@function
 	@memberOf nunaliit2
 	@param {String} _v Argument to be tested.
 */
$n2.isDefined = function(_v) {
	return('undefined' != typeof(_v) && null != _v);
};

if( typeof window !== 'undefined' ) {
	if( typeof(window.isDefined) === 'undefined' ) {
		window.isDefined = $n2.isDefined;
	};
};

//*********************************************
// isArray

/**
 	Returns true if a the given argument is an array.
 	@name isArray
 	@function
 	@memberOf nunaliit2
 	@param {Object} o Argument to be tested.
 */
$n2.isArray = function(o) {
	if( o === null ) return false;
	if( o === undefined ) return false;
	if( typeof(o) !== 'object' ) return false;
	if( typeof(o.length) !== 'number' ) return false;
	if( typeof(o.push) !== 'function' ) return false;
	if( typeof(o.pop) !== 'function' ) return false;
	if( typeof(o.concat) !== 'function' ) return false;
	if( typeof(o.join) !== 'function' ) return false;
	if( typeof(o.slice) !== 'function' ) return false;
	if( typeof(o.reverse) !== 'function' ) return false;
	if( typeof(o.splice) !== 'function' ) return false;
	if( typeof(o.sort) !== 'function' ) return false;
	
	return true;
};

//*********************************************
// inArray

/**
	Returns the index of the element if found in
	the array. Returns -1 if not found.
	@name inArray
	@function
	@memberOf nunaliit2
	@param {Object} elem Element searched for in array
	@param {Array} arr Element searched for in array
	@param {Number} index Index where the search is started
	@return {Number} Index of found element. Returns -1, if not found.
*/
$n2.inArray = function( elem, arr, index ) {
	var len;

	if ( arr ) {
		if ( nativeArrayIndexOf ) {
			return nativeArrayIndexOf.call( arr, elem, index );
		};

		len = arr.length;
		index = index ? index : 0;
		index = index < 0 ? Math.max( 0, len + index ) : index;

		for( ; index < len; ++index) {
			if( index in arr 
			 && arr[index] === elem ) {
				return index;
			};
		};
	};

	return -1;
};


//*********************************************
// getUniqueId

var n2UniqueId = 0;
/**
	Returns an identifier unique to this instance of
	nunaliit2.
	@name getUniqueId
	@function
	@memberOf nunaliit2
	@return {String} Unique string that can be used as an identifier
*/
$n2.getUniqueId = function(prefix) {
	prefix = prefix ? prefix : 'nunaliit2_uniqueId_';
	var id = prefix + n2UniqueId;
	++n2UniqueId;
	return id;
};

/**
 	Returns the media type (image, video or audio)
 	associated with the given file.
 	@name getMediaType
 	@function
 	@memberOf nunaliit2
 	@param {String} filename Name of file of given media file.
 	@param {String} mimetype MIME Type associated with file.
 	@returns {String} Type of media: 'audio', 'image' or 'video'
 */
$n2.getMediaType = function(filename, mimetype) {
	var mediaType = null;

	// Start with MIME type, if provided
	if(typeof(mimetype) != 'undefined'
	 && null != mimetype 
	 && '' != mimetype
	 ) {
		var mimeClass = mimetype.split('/');
		if ('image' === mimeClass[0] ||
			'video' === mimeClass[0] ||
			'audio' === mimeClass[0]) {
			mediaType = mimeClass[0];
		};
	
		// Known mime types	
		if( null === mediaType
		 && 'application/ogg' === mimetype ) {
			mediaType = 'audio';
		};
	};
	
	if( null === mediaType 
	 && typeof(filename) != 'undefined' 
	 && null != filename 
	 && '' != filename
	 ) {
		var fileFrags = filename.split('.');
		var ext = fileFrags[fileFrags.length - 1];
		
		// known extensions
		if( 'mp3' === ext.toLowerCase() ) {
			mediaType = 'audio';
		} else if( 'ogg' === ext.toLowerCase() ) {
			mediaType = 'audio';
		} else if( 'jpg' === ext.toLowerCase() ) {
			mediaType = 'image';
		} else if( 'png' === ext.toLowerCase() ) {
			mediaType = 'image';
		} else if( 'jpeg' === ext.toLowerCase() ) {
			mediaType = 'image';
		} else if( 'bmp' === ext.toLowerCase() ) {
			mediaType = 'image';
		} else if( 'mov' === ext.toLowerCase() ) {
			mediaType = 'video';
		};
	};
	return(mediaType);
};

/**
 	Converts a textual representation of LongLat into an object
 	with values for longitude and latitude. Return null if the
 	textual representation can not be recognized.
 	@name parseLongLatText
 	@function
 	@memberOf nunaliit2
 	@param {String} text A textual representation of LongLat (45°32'48.94"N, 73°33'19.93"W)
 	@returns {Object} Hash containing two properties: lat and long
 */
var longLatRe = /^\s*([0-9]{1,2})(°|d|\u00B0)\s*([0-9]{1,2})['m]\s*([0-9]{1,2}(\.[0-9]+)?)["s]\s*([NS])\s*,?\s*([0-9]{1,3})(°|d|\u00B0)\s*([0-9]{1,2})['m]\s*([0-9]{1,2}(\.[0-9]+)?)["s]\s*([WE])\s*$/;
$n2.parseLongLatText = function(text) {
	var result = {};
	
	//$n2.log('longLat text',text,longLatRe);

	var matchObj = text.match(longLatRe);
	if( null == matchObj ) {
		return null;
	};

	//$n2.log('longLat',matchObj);

	var longMult = 1;
	if( 'S' === matchObj[6] ) {
		longMult = -1;
	};
	result.lng = longMult * (
		1 * matchObj[1] 
		+ (1 * matchObj[3] / 60)
		+ (1 * matchObj[4] / 3600)
	);
		
	var latMult = 1;
	if( 'W' === matchObj[12] ) {
		latMult = -1;
	};
	result.lat = latMult * (
		1 * matchObj[7] 
		+ (1 * matchObj[9] / 60)
		+ (1 * matchObj[10] / 3600)
	);
		
	//$n2.log('parseLongLatText',text,result);

	return result;
};

/**
 * Generate the HTML representation of a hyperlink, given a text label,
 * url, and optional css classes (single string or array of strings).
 * If no url is included or it is an empty string, then a string is returned
 * within a classed div.
 * @param text label for hyperlink
 * @param url text for url
 * @param cls class string or array of class strings
 */
$n2.generateHyperlinkHTML = function(text, url, cls) {
	function catStrings(ar) {
		var out = '';
		var spc = '';
		for (var i=0; i < ar.length; i++) {
			out.concat(spc, ar[i]);
			spc = ' ';
		};
		return out;
	};
	
	var clsString = '';
	if ($n2.isArray(cls)) {
		clsString = catStrings(cls);
	} else {
		clsString = cls;
	};
	
	var classSpec = '';
	if ('' !== clsString) {
		classSpec = ' class="' + clsString + '"';
	};
	
	var uTxt = url;
	if (! $n2.isDefined(uTxt) || uTxt === '') {
		uTxt = '';
	};
	
	var label = text;
	if (! $n2.isDefined(label) || label === '') {
		label = uTxt; // replicate url as text if no label
	};
	
	var out = '';
	if (uTxt !== '') { // generate <a>
		out = '<a' + classSpec + 
			' href="' + uTxt +
			'" target="_blank">' + label + '</a>';
	} else { // return label string as classed div
		out = '<div' + classSpec + '>' + label + '</div>'; 
	};
	
	return out;
};

/**
	Extends a javascript object using refinements.
	@name extend
	@function
	@memberOf nunaliit2
	@param {Object} target Target object to receive the extensions
	@returns {Object} The target object that was extended
*/
$n2.extend = function() {
	// copy reference to target object
	var target = arguments[0] || {}
		,deep = false;

	// Handle a deep copy situation
	var i = 1;
	if ( typeof target === 'boolean' ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	for(var e=arguments.length; i<e; ++i) {
		var options = arguments[i];

		// Only deal with non-null/undefined values
		if( null != options ) {
			// Extend the base object
			for(var name in options) {
				var src = target[ name ];
				var copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging arrays
				if ( deep && copy && $n2.isArray(copy) ) {
					var clone = (src && $n2.isArray(src)) ? src : [];

					target[ name ] = $n2.extend( deep, clone, copy );
					
				} else if( deep && copy && typeof(copy) === 'object' ) {
					// Recurse if we're merging objects
					var clone = ('object' == typeof(src)) ? src : {};

					target[ name ] = $n2.extend( deep, clone, copy );

				} else if( copy !== undefined ) {
					// Don't bring in undefined values
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

/**
	Makes a deep copy of the given object.
	@name deepCopy
	@function
	@memberOf nunaliit2
	@param {Object} o Object to be copied
	@returns {Object} The copy of the object given in argument
*/
$n2.deepCopy = function(o) {
	if( null === o ){
		return o;
		
	} else if( typeof o === 'undefined' ) {
		return o;
		
	} else if( $n2.isArray(o) ) {
		var c = [];
		for(var i=0,e=o.length; i<e; ++i){
			c[i] = $n2.deepCopy(o[i]);
		};
		return c;
		
	} else if( typeof(o) === 'object' ) {
		var c = {};
		for(var i in o){
			c[i] = $n2.deepCopy(o[i]);
		};
		return c;

	} else {
		return o;
	};
};

/**
	Helper function for localization. It redirects to l10n
	package if it is loaded. This function request a string
	localized for the current locale given a string in the
	default language (generally english). If the l10n package
	is not loaded, it returns the requested string.
	@name loc
	@function
	@memberOf nunaliit2
	@param {String} str String to be translated
	@param {String} packageName Name of package making the
	                            translation request
	@returns {String} The string localized for the current locale.
*/
$n2.loc = function(str, packageName, args) {
	if( $n2.l10n && $n2.l10n.getLocalizedString ) {
		return $n2.l10n.getLocalizedString(str, packageName, args);
	};
	return str;
};

/**
 * Trim function for strings. If available, use the one already provided.
 * If not, use home made one.
 * @name trim
 * @function
 * @memberOf nunaliit2
 * @param {String} text String to be trimmed of leading and trailing white
 *                      spaces.
 * @returns {String} String which is a trimmed version of the input argument.
 */
var reLeftWhite = /^[\s\t\x0d\x0a]+/;
var reRightWhite = /[\s\t\x0d\x0a]+$/;
$n2.trim = function(text){
	if( null === text ) {
		return '';
	};
	
	if( nativeStringTrim ) {
		return nativeStringTrim.call(text);
	};

	// Use own version
	return text.toString()
		.replace(reLeftWhite, '')
		.replace(reRightWhite, '')
		;
};

/** @namespace nunaliit2.utils */
$n2.utils = {
	
	_callbacks: {},
		
	/**
	 * Converts a string to a string that can be used with a HTML id
	 * or class name. Not all characters can be used in HTML identifiers
	 * and class names and this routine escape the unwanted characters from
	 * the given string. 
	 * @name stringToHtmlId
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {String} s String to be converted in a form where it can be used
	 *                   as an HTML id or HTML class name.
	 * @returns {String} String safe for HTML id or class name.
	 */
	stringToHtmlId: function(s){
		var res = [];
		for(var i=0,e=s.length; i<e; ++i) {
			var c = s[i];
			if( c >= 'a' && c <= 'z' ) { res.push(c); }
			else if( c >= 'A' && c <= 'Z' ) { res.push(c); }
			else if( c >= '0' && c <= '9' ) { res.push(c); }
			else {
				var code = c.charCodeAt(0);
				var o0 = (code & 0x07) + 0x30;
				var o1 = ((code >> 3) & 0x07) + 0x30;
				var o2 = ((code >> 6) & 0x07) + 0x30;
				res.push('_');
				res.push( String.fromCharCode(o2) );
				res.push( String.fromCharCode(o1) );
				res.push( String.fromCharCode(o0) );
			};
		};
		return res.join('');
	},
	
	/**
	 * Unescapes a string previously converted using stringToHtmlId(). 
	 * @name unescapeHtmlId
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {String} s String to be unescaped.
	 * @returns {String} String initially passed to the stringToHtmlId() function.
	 */
	unescapeHtmlId: function(s){
		var res = [];
		for(var i=0,e=s.length; i<e; ++i) {
			var c = s[i];
			if( c === '_' ) { 
				++i;
				var o2 = s.charCodeAt(i);
				++i;
				var o1 = s.charCodeAt(i);
				++i;
				var o0 = s.charCodeAt(i);
				
				var b = ((o2-0x30)<<6)+((o1-0x30)<<3)+(o0-0x30);
				res.push(String.fromCharCode(b));
				
			} else {
				res.push(c);
			};
		};
		return res.join('');
	},

	/**
	 * Returns information about the browser. This is based on code found
	 * here: http://www.quirksmode.org/js/detect.html 
	 * @name getBrowserInfo
	 * @function
	 * @memberOf nunaliit2.utils
	 * @returns {Object} Object containing information about the browser
	 * where the application runs
	 */
	getBrowserInfo: function(){
		
		if( cachedBrowserInfo ){
			return cachedBrowserInfo;
		};

		var dataBrowser = [
   			{
   				string: navigator.userAgent,
   				subString: "Chrome",
   				identity: "Chrome"
   			},
   			{ 	
   				string: navigator.userAgent,
   				subString: "OmniWeb",
   				versionSearch: "OmniWeb/",
   				identity: "OmniWeb"
   			},
   			{
   				string: navigator.vendor,
   				subString: "Apple",
   				identity: "Safari",
   				versionSearch: "Version"
   			},
   			{
   				prop: window.opera,
   				identity: "Opera",
   				versionSearch: "Version"
   			},
   			{
   				string: navigator.vendor,
   				subString: "iCab",
   				identity: "iCab"
   			},
   			{
   				string: navigator.vendor,
   				subString: "KDE",
   				identity: "Konqueror"
   			},
   			{
   				string: navigator.userAgent,
   				subString: "Firefox",
   				identity: "Firefox"
   			},
   			{
   				string: navigator.vendor,
   				subString: "Camino",
   				identity: "Camino"
   			},
   			{		// for newer Netscapes (6+)
   				string: navigator.userAgent,
   				subString: "Netscape",
   				identity: "Netscape"
   			},
   			{
   				string: navigator.userAgent,
   				subString: "MSIE",
   				identity: "Explorer",
   				versionSearch: "MSIE"
   			},
   			{
   				string: navigator.userAgent,
   				subString: "Gecko",
   				identity: "Mozilla",
   				versionSearch: "rv"
   			},
   			{ 		// for older Netscapes (4-)
   				string: navigator.userAgent,
   				subString: "Mozilla",
   				identity: "Netscape",
   				versionSearch: "Mozilla"
   			}
   		];
		var dataOS = [
  			{
  				string: navigator.platform,
  				subString: "Win",
  				identity: "Windows"
  			},
  			{
  				string: navigator.platform,
  				subString: "Mac",
  				identity: "Mac"
  			},
  			{
  				string: navigator.userAgent,
  				subString: "iPhone",
  				identity: "iPhone/iPod"
  			},
  			{
  				string: navigator.platform,
  				subString: "Linux",
  				identity: "Linux"
  			}
  		];
		
		var browserInfo = {};
		var versionSearchString;
		init();
		cachedBrowserInfo = browserInfo;
		return browserInfo;

		function init() {
			browserInfo.browser = searchString(dataBrowser) || "An unknown browser";
			browserInfo.version = searchVersion(navigator.userAgent)
				|| searchVersion(navigator.appVersion)
				|| "an unknown version";
			browserInfo.OS = searchString(dataOS) || "an unknown OS";
		};
		
		function searchString(data) {
			for (var i=0;i<data.length;i++)	{
				var dataString = data[i].string;
				var dataProp = data[i].prop;
				versionSearchString = data[i].versionSearch || data[i].identity;
				if (dataString) {
					if (dataString.indexOf(data[i].subString) != -1)
						return data[i].identity;
				}
				else if (dataProp)
					return data[i].identity;
			}
		};

		function searchVersion(dataString) {
			var index = dataString.indexOf(versionSearchString);
			if (index == -1) return;
			return parseFloat(dataString.substring(index+versionSearchString.length+1));
		};
		
	},

	/**
	 * Returns true if the input is a number, regardless if it is a number
	 * in a string, or a direct number.
	 * See http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
	 * @name isNumber
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {String} String or number to be tested
	 * @returns {Boolean} True if given parameter represents a number. False, otherwise.
	 */
	isNumber: function(n){
		return !isNaN(parseFloat(n)) && isFinite(n);
	},
	
	/**
	 * Returns a object that describes the javascript declaration included
	 * in the host page. The HTML of the host page is traversed to find all
	 * javascript declarations and if one matches the name given in argument,
	 * an object is returned to describe the declaration. If a matching
	 * declaration is not found, null is returned.
	 * @name findJavascriptDeclaration
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param javascriptFileName {String} name of the file for the seeked javascript
	 * declaration. This should be the name and extension, without any path fragment.
	 * @returns {Object} Object that describes the jaavascript declaration. Null if
	 * the seeked declaration is not found.
	 */
	findJavascriptDeclaration: function(javascriptFileName){
		var scriptLocation = null;
		var scriptElem = null;
		var pattern = new RegExp('(^|(.*?\\/))'+javascriptFileName+'$');
	 
		var scripts = document.getElementsByTagName('script');
		for( var loop=0; loop<scripts.length; ++loop ) {
			var src = scripts[loop].getAttribute('src');
			if (src) {
				var match = src.match(pattern);
				if( match ) {
					scriptLocation = match[1];
					scriptElem = scripts[loop];
					break;
				}
			}
		};
		
		var result = null;
		if( null != scriptElem ){
			result = {
				element: scriptElem
				,location: scriptLocation
				,name: javascriptFileName
			};
		};
		
		return result;
	},
	
	/**
	 * Inserts new javascript declarations at the end of the host document. Multiple 
	 * declarations are added this way, each one based
	 * on a name found in the given array of strings. Finally, a callback is given
	 * which is called when the new declarations have been added and parsed.
	 * @name insertJavascriptDeclarations
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param declarationDescription {Object} Declaration description previously
	 * obtained using nunaliit2.utils.findJavascriptDeclaration(). All new declarations
	 * are inserted previous to this one. Also, new declarations are made relative to
	 * the path of this declaration.
	 * @param names string[]} Names of the javascript files that should be inserted
	 * as new declarations. These names may contain path fragments, relative to the
	 * declaration description given in argument. 
	 * @param callback {Function} Function called after all declarations have been inserted.
	 * @returns {void}
	 */
	insertJavascriptDeclarations: function(declarationDescription, names, callback){
		
		if( typeof names === 'string' ){
			names = [ names ];
		};

		var scriptLocation = declarationDescription.location;
		var insertBeforeElem = declarationDescription.element;

		// Keep track of callback
		var loaded = false;

		for( var i=0; i<names.length; ++i ) {
			var script = document.createElement('script');
			script.setAttribute('type', 'text/javascript');
			script.setAttribute('src', scriptLocation + names[i]);
			script.onreadystatechange = script.onload = function() {
				if( !loaded ){
					loaded = true;
					if( typeof callback === 'function' ){
						callback();
					};
				};
			};

			insertBeforeElem.parentNode.insertBefore(script,insertBeforeElem);
		};
	},
	
	/**
	 * Accepts a formatting string and arguments. Returns the formatted
	 * string. For example, $n2.formatString('{a} and {b}',{a:1,b:2}) returns
	 * '1 and 2'
	 * @name formatString
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param format {String} Formatting string that contains sequences to be
	 * replaced by arguments. The sequences are names included within curly
	 * braces, for example {a}
	 * @param args {Object} Dictionary of arguments
	 * @returns {String}
	 */
	formatString: function(format, args){
		return format.replace(/{([^}]+)}/g, function(match, name) {
			name = $n2.trim(name);
			if( '' === name ) return match;
			
			return typeof args[name] !== 'undefined'
				? args[name]
				: match
			;
		});
	},
	
	/**
	 * Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC. This
	 * is equivalent to Date.now(). However, Date.now() is not supported in IE8.
	 * @name getCurrentTime
	 * @function
	 * @memberOf nunaliit2.utils
	 * @returns {Number}
	 */
	getCurrentTime: Date.now || function () {
		return +new Date();
	},
	
	/**
	 * Returns a string which represents the date formatted as specified.
	 * @name formatDate
	 * @function
	 * @memberOf nunaliit2.utils
	 * @returns {String}
	 */
	formatDate: function(date, format){
		var str = format.replace('%Y',''+date.getFullYear());
		
		var monthNumStr = ''+(date.getMonth()+1);
		if( monthNumStr.length < 2 ) monthNumStr = '0'+monthNumStr;
		str = str.replace('%m',monthNumStr);
		
		var dateNumStr = ''+date.getDate();
		if( dateNumStr.length < 2 ) dateNumStr = '0'+dateNumStr;
		str = str.replace('%d',dateNumStr);
		
		var hoursNumStr = ''+date.getHours();
		if( hoursNumStr.length < 2 ) hoursNumStr = '0'+hoursNumStr;
		str = str.replace('%H',hoursNumStr);
		
		var minutesNumStr = ''+date.getMinutes();
		if( minutesNumStr.length < 2 ) minutesNumStr = '0'+minutesNumStr;
		str = str.replace('%M',minutesNumStr);
		
		var secondsNumStr = ''+date.getSeconds();
		if( secondsNumStr.length < 2 ) secondsNumStr = '0'+secondsNumStr;
		str = str.replace('%S',secondsNumStr);
		
		return str;
	},
	
	/**
	 * Returns a Javascript object returned in an XMLHttpRequest
	 * with an error. 
	 * @name parseHttpJsonError
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {Object} Instance of XMLHttpRequest used to retrieve information
	 * @param {String} Error string that should be returned if an object can not
	 *                 be parsed.
	 * @returns {Object} JSON object returned by the instance of XMLHttpRequest
	 */
	parseHttpJsonError: function(xmlHttpRequest,defaultText){
		// Need JSON
		if( !JSON || typeof(JSON.parse) !== 'function' ) {
			return createDefault();
		};
		
		// Need a response text
		var text = xmlHttpRequest.responseText;
		if( !text ) return createDefault();
		
		// Parse
		var error = JSON.parse(text);
		if( !error ) return createDefault();
		
		return error;
		
		function createDefault(){
			return {
				error: defaultText
				,reason: defaultText
			};
		};
	},

	/**
	 * Creates a version of the function where the rate of calls is limited to
	 * one call per defined time out.
	 * @name debounce
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {Function} func The function that should be limited in the rate at which
	 *                   it is fired.
	 * @param {Number} wait Number of milliseconds between the calls to the function
	 * @param {boolean} immediate If set, executes the function in parameters at the start. 
	 *                            Otherwise, first execution is after wait time.
	 * @returns {boolean} If true, the function is called immediately, and again in the
	 *                    future after a period defined by the timeout.
	 */
	debounce: function(func, wait, immediate) {
		var timeout = null;
		return function() {
			var context = this, args = arguments;
			var later = function() {
				timeout = null;
				if (!immediate) func.apply(context, args);
			};
			if (immediate && !timeout) func.apply(context, args);
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
		};
	},

	/**
	 * Creates a version of the function where the rate of calls is throttled to no
	 * more than a set rate. If, during the delay, the function is called again, then
	 * it will result in a last call at the end of the delay.
	 * @name throttle
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {Function} func The function that should be limited in the rate at which
	 *                   it is fired.
	 * @param {Number} wait Number of milliseconds between the calls to the function
	 * @returns {boolean} If true, the function is called immediately, and again in the
	 *                    future after a period defined by the timeout.
	 */
	throttle: function(func, wait) {
		var timeoutId = undefined;
		var lastRan = undefined;
		var throttledFn = function() {
			var context = this, args = arguments;
			var immediate = false;
			if( !lastRan ){
				immediate = true;
			} else {
				var timeSinceLastCall = Date.now() - lastRan;
				if( timeSinceLastCall >= wait ){
					immediate = true;
				};
			};
			if( immediate ){
				// Run it now.
				func.apply(context, args);
				lastRan = Date.now();
			} else if( timeoutId ){
				// Already waiting for a timeout. No
				// need to schedule again
			} else {
				// Schedule to be called again in the future
				var delay = wait - (Date.now() - lastRan);
				timeoutId = setTimeout(
					function(){
						func.apply(context, args);
						lastRan = Date.now();
						timeoutId = undefined;
					}
					,delay
				);
			};
		};

		// Call this function for the next invocation to be immediate
		throttledFn.setImmediate = function(){
			lastRan = undefined;
		};

		return throttledFn;
	},

	/**
	 * Returns the identifier associated with the given element. If no identifier
	 * is currently assigned to the element, assign a unique one and then return it.
	 * @name getElementIdentifier
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {Object} elem DOM element where the identifier is desired.
	 * @returns {String} Element identifier
	 */
	getElementIdentifier: function(elem){
		var $elem = $(elem);
		var id = $elem.attr('id');
		if( !id ){
			id = $n2.getUniqueId();
			$elem.attr('id',id);
		};
		return id;
	},
	
	/**
	 * Returns an array of all values found in a map or array.
	 * @name values
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {Object} map Javascript object or array
	 * @returns {Object[]} Values found in the object or array
	 */
	values: function(map){
		var v = [];
		for(var i in map){
			v[v.length] = map[i];
		};
		return v;
	},
	
	/**
	 * Returns an array of all keys found in a map or array.
	 * @name keys
	 * @function
	 * @memberOf nunaliit2.utils
	 * @param {Object} map Javascript object or array
	 * @returns {Object[]} Keys found in the object or array
	 */
	keys: function(map){
		var v = [];
		for(var i in map){
			v[v.length] = i;
		};
		return v;
	}
};

// HTML Escape
var htmlEscapeCharMap = {
	'&': '&amp;'
	,'<': '&lt;'
	,'>': '&gt;'
	,'"': '&quot;'
	,"'": '&#x27;'
	,'`': '&#x60;'
};

var reHtmlCharSelect = /[&<>"'`]/g;
var reHtmlCharTest = /[&<>"'`]/;

var htmlEscapeCharFn = function(match) {
 	return htmlEscapeCharMap[match] || "";
};

/**
 * Accepts a string and returns an escaped version of the string, which
 * can be used in HTML. This function converts all the characters that are
 * reserved in HTML for the escaped version of the same character.
 * @name escapeHtml
 * @function
 * @memberOf nunaliit2.utils
 * @param str {String} String to be escaped for HTML
 * @returns {String} String escaped for use in HTML
 */
$n2.utils.escapeHtml = function(str) {
	if( typeof(str) !== 'string' ) {
		return "";
	};
	
	// Need to escape?
	if( !reHtmlCharTest.test(str) ) {
		return str;
	};
	
	// Perform escape
	return str.replace(reHtmlCharSelect, htmlEscapeCharFn);
};

/**
 * Accepts a string and returns an instance of the named class.
 * Example: var canvasMap1 = $n2.utils.getInstance('$n2.canvasMap', opts)
 * @name getInstance
 * @function
 * @memberOf nunaliit2.utils
 * @param str {String} String of class name 
 * @returns Instance object
 */
$n2.utils.getInstance = function(str, var_args ) {
	if ( typeof(str) !== 'string'){
		return null;
	};
	var arr = str.split(".");

	var fn = (window || this);
	for (var i = 0, len = arr.length; i < len; i++) {
	    fn = fn[arr[i]];
	}

	if (typeof fn !== "function") {
	  throw new Error("Function not found");
	}
	

	var args = new Array(arguments.length -1);
	for (var i=1; i< arguments.length; i++) {
		args[i-1] = arguments[i];
	}
	
	var instance = new fn(args);
	
	if (typeof instance !== "object") {
		  throw new Error("Instance object not found");
		}
	return instance;
};

/**
 * Accepts a string and returns a method of the named method.
 * Example: var canvasMethod = $n2.utils.getMethod('$n2.canvasMap.handleCanvasDisplay')
 * @name getMethod
 * @function
 * @memberOf nunaliit2.utils
 * @param str {String} String of method name 
 * @returns function 
 */
$n2.utils.getMethod = function(str, var_args ) {
	if ( typeof(str) !== 'string'){
		return null;
	};
	var arr = str.split(".");

	var fn = (window || this);
	for (var i = 0, len = arr.length; i < len; i++) {
	    fn = fn[arr[i]];
	}

	if (typeof fn !== "function") {
	  throw new Error("Function not found");
	}
	

	return fn;
};
})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.cookie.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($n2){
"use strict";

function getCookies(){
	var cookies = {};
	
	if( typeof document !== 'undefined' 
	 && document.cookie ) {
		var rawCookies = document.cookie.split(';');

		for(var i=0,e=rawCookies.length; i<e; ++i){
			var c = rawCookies[i].split('=');
			if( c.length && c.length > 1 ) {
				var key = decodeURIComponent( $n2.trim(c[0]) );
				var value = decodeURIComponent( $n2.trim(c[1]) );
				cookies[key]=value;
			};
		};
	};
	
	return cookies;
};
	
function getCookie(name){
	var cookies = getCookies();
	if( typeof(cookies[name]) === 'undefined' ) return null;
	return cookies[name];
};

function setCookie(opt_){
	var opt = $n2.extend({
		name: null
		,value: null
		,end: null
		,path: null
		,domain: null
		,secure: false
	},opt_);
    
	var cookie = [
		escape(opt.name)
		,'='
		,escape(opt.value)
	];

	// Expiry
	if( null !== opt.end ) {
		switch( typeof(opt.end) ) {  
			case "number": 
				cookie.push('; max-age=' + opt.end); 
				break;  
			case "string": 
				cookie.push('; expires=' + opt.end);
				break;  
			case "object": 
				if( opt.end.hasOwnProperty("toGMTString") ) { 
					cookie.push('; expires=' + opt.end.toGMTString());
				}; 
				break;  
		};
	};
	
	// Domain
	if( opt.domain ) {
		cookie.push('; domain=' + opt.domain);
	};
	
	// path
	if( opt.path ) {
		cookie.push('; path=' + opt.path);
	};
	
	// path
	if( opt.secure ) {
		cookie.push('; secure');
	};
	
    document.cookie = cookie.join('');
};

function deleteCookie(name) {
	document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
};

$n2.cookie = {
	getCookies: getCookies
	,getCookie: getCookie
	,setCookie: setCookie
	,deleteCookie: deleteCookie
};
	
})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.scripts.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

var customScriptsByUrl = {};

//=====================================================================
/**
 * Return true if the URL is associated with a global resource
 * (as opposed to a relative URL)
 */
function isContextIndependentURL(url){
	var prefixes = [
		"http://"
		,"https://"
	];
	
	for(var i in prefixes){
		var prefix = prefixes[i];
		
		// If URL starts with prefix, then is is context independent
		if( url.substr(0,prefix.length) === prefix ){
			return true;
		};
	};
	
	return false;
};

//=====================================================================
function getScriptLocation(scriptName) {
	var scriptLocation = null;
	
	if( typeof document === 'object' ) {
		var pattern = new RegExp("(^|(.*?\\/))"+scriptName+"$");
	 
		var scripts = document.getElementsByTagName('script');
		for( var loop=0; loop<scripts.length; ++loop ) {
			var src = scripts[loop].getAttribute('src');
			if (src) {
				var match = src.match(pattern);
				if( match ) {
					scriptLocation = {
						location: match[1]
						,elem: scripts[loop]
					};
					break;
				};
			};
		};
	};

	return scriptLocation;
};

//=====================================================================
function getCoreScriptLocation() {
	if( typeof $n2.coreScriptName === 'string' ){
		return getScriptLocation($n2.coreScriptName);
	};
	
	return null;
};

//=====================================================================
function getFirstScriptLocation() {
	var scriptLocation;

	if( typeof document === 'object' ) {
		var scripts = document.getElementsByTagName('script');
		if( scripts.length > 0 ){
			var scriptElem = scripts.item(0);
			scriptLocation = {
				location: scriptElem.getAttribute('src')
				,elem: scriptElem
			};
		};
	};
	
	return scriptLocation;
};

//=====================================================================
function loadScript(opts_) {
	var opts = $n2.extend({
		url: null
		,scriptLocation: null
		,onLoaded: null
		,onError: null
	},opts_);
	
	var scriptUrl = opts.url;
	var refLocation = opts.scriptLocation;

	var scriptElems = document.getElementsByTagName('script');
	var scriptElem = scriptElems.item( scriptElems.length - 1 );
	if( refLocation && refLocation.elem ) {
		scriptElem = refLocation.elem;
	};

	var s = document.createElement('script');
	s.src = scriptUrl;
	s.type = 'text/javascript';
	
	if( typeof s.addEventListener === 'function' ){
		if( typeof opts.onLoaded === 'function' ){
			s.addEventListener('load',opts.onLoaded);
		};
		if( typeof opts.onError === 'function' ){
			s.addEventListener('error',opts.onError);
		};
	} else {
		if( typeof opts.onLoaded === 'function' ){
			s.onload = opts.onLoaded;
		};
		if( typeof opts.onError === 'function' ){
			s.onerror = opts.onError;
		};
	};
	
	scriptElem.parentNode.insertBefore(s,scriptElem);
};

//=====================================================================
function _loadedScript(url){
	var customScript = customScriptsByUrl[url];
	if( customScript ){
		customScript.loaded = true;
	};
};

//=====================================================================
function loadCustomScripts(scriptUrls) {
	var scriptElems = document.getElementsByTagName('script');
	var insertBeforeElem = scriptElems.item( scriptElems.length - 1 );
	var location = '';

	var nunaliitCustomLocation = getScriptLocation('nunaliit_custom.js');
	if( nunaliitCustomLocation && nunaliitCustomLocation.elem ) {
		insertBeforeElem = nunaliitCustomLocation.elem;
		location = nunaliitCustomLocation.location;
	};
	
	// Convert string urls into request objects
	if( typeof scriptUrls === 'string' ){
		// Convert single string into an array
		scriptUrls = [scriptUrls];
	};
	if( $n2.isArray(scriptUrls) ){
		for(var i=0,e=scriptUrls.length; i<e; ++i){
			var scriptUrl = scriptUrls[i];
			if( typeof scriptUrl === 'string' ){
				var request = {
					url: scriptUrl
					,requiredForConfiguration: true
				};
				scriptUrls[i] = request;
			};
		};
	};
	
	if( $n2.isArray(scriptUrls) ){
		// Accumulate scripts to install
		var requestsToInstall = [];
		for(var i=0,e=scriptUrls.length; i<e; ++i){
			var request = $n2.extend({
				url: null
				,requiredForConfiguration: true
			},scriptUrls[i]);

			var url = request.url;
			if( url ){
				if( customScriptsByUrl[url] ){
					// Already requested. Nothing to do
				} else {
					customScriptsByUrl[url] = request;
					request.loaded = false;
					requestsToInstall.push(request);
				};
			};
		};

		for(var i=0,e=requestsToInstall.length; i<e; ++i){
			var request = requestsToInstall[i];
			var url = request.url;
			
			var s = document.createElement('script');
			if( isContextIndependentURL(url) ){
				s.src = url;
			} else {
				// relative URL must be fixed for location
				s.src = location + url;
			};
			s.type = 'text/javascript';
			var cb = getLoadedCallback(url);
			if( typeof s.addEventListener === 'function' ){
				s.addEventListener('load',cb);
				s.addEventListener('error',cb);
			} else {
				s.onload = cb;
				s.onerror = cb;
			};
			insertBeforeElem.parentNode.insertBefore(s,insertBeforeElem);
		};
	};
	
	function getLoadedCallback(url){
		return function(){
			_loadedScript(url);
			return true;
		};
	};
};

//=====================================================================
function areAllCustomScriptsLoaded(){
	var allLoaded = true;
	
	for(var url in customScriptsByUrl){
		var customScript = customScriptsByUrl[url];
		if( customScript.requiredForConfiguration 
		 && !customScript.loaded ){
			allLoaded = false;
		};
	};
	
	return allLoaded;
};

//=====================================================================
function loadGoogleMapApi(opts_){
	var opts = $n2.extend({
		googleMapApiKey: null
		,onLoaded: null
		,onError: null
	},opts_);
	
	// Check if Google Map is already loaded
	var googleMapScriptFound = false;
	if( typeof document === 'object' ) {
		var scripts = document.getElementsByTagName('script');
		for( var loop=0; loop<scripts.length; ++loop ) {
			var scriptElem = scripts.item(loop);
			var src = scriptElem.getAttribute('src');
			if( typeof src === 'string' ){
				if( src.indexOf('maps.google.com/maps/api/js') >= 0 ) {
					googleMapScriptFound = true;
				};
				if( src.indexOf('maps.googleapis.com/maps/api/js') >= 0 ) {
					googleMapScriptFound = true;
				};
			};
		};
	};
	if( googleMapScriptFound ){
		if( typeof opts.onError === 'function' ){
			opts.onError( 'Google Map API library already installed' );
			$n2.logError('Hint: remove Google Map script inclusion from HTML page');
		};
		return;
	};
	
	// Check if library is already loaded
	if( typeof window === 'object' 
	 && window.google 
	 && window.google.maps ){
		opts.onError( 'Google Map API library already loaded' );
		return;
	};
	
	// Attempt to load
	var firstScriptLocation = getFirstScriptLocation();
	var url = 'https://maps.googleapis.com/maps/api/js';
	if( typeof opts.googleMapApiKey === 'string' ){
		url += '?key='+opts.googleMapApiKey;
	};
	loadScript({
		url: url
		,scriptLocation: firstScriptLocation
		,onLoaded: opts.onLoaded
		,onError: opts.onError
	});
};

//=====================================================================
$n2.scripts = {
	getScriptLocation: getScriptLocation
	,getCoreScriptLocation: getCoreScriptLocation
	,getFirstScriptLocation: getFirstScriptLocation
	,loadScript: loadScript
	,loadCustomScripts: loadCustomScripts
	,areAllCustomScriptsLoaded: areAllCustomScriptsLoaded 
	,loadGoogleMapApi: loadGoogleMapApi 
};

})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.css.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

//=====================================================================
function _getAllCssElements() {
	var elements = [];
	
	var $head = $('head');
	var $elems = $head.children('link,style').each(function(){
		var $elem = $(this);
		
		var tagName = $elem.prop('tagName');
		if( 'STYLE' === tagName ){
			elements.push($elem);

		} else if( 'LINK' === tagName ){
			var rel = $elem.attr('rel');
			if( !rel ) rel = "";
			var type = $elem.attr('type');
			if( !type ) type = "";
			
			if( 'stylesheet' === rel.toLowerCase() 
			 && 'text/css' === type.toLowerCase() ){
				elements.push($elem);
			};
		};
	});

	return elements;
};

//=====================================================================
function setCss(opts_) {
	var opts = $n2.extend({
		css: null
		,name: null
	},opts_);
	
	if( typeof opts.css !== 'string' ){
		throw new Error('setCss() must specify css as a string');
	};
	
	var $cssElement = undefined;
	var $insertPoint = undefined;

	var elements = _getAllCssElements();
	elements.forEach(function($css){
		$insertPoint = $css;
		
		var n2Name = $css.attr('n2-name');
		if( opts.name && opts.name === n2Name ){
			$cssElement = $css;
		};
	});
	
	// Replace?
	if( $cssElement ){
		$cssElement.text(opts.css);

	} else {
		// Must insert
		$cssElement = $('<style>')
			.attr('type','text/css')
			.text(opts.css)
			;
		
		if( typeof opts.name === 'string' ){
			$cssElement.attr('n2-name', opts.name);
		};
		
		// Do we have a position?
		if( $insertPoint ){
			$insertPoint.after($cssElement);
		} else {
			$('head').append($cssElement);
		};
	};
};

//=====================================================================
$n2.css = {
	setCss: setCss
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.class.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

var EmptyInit = function(){};

// Class definition.
// Usage:
//   var myClass = $n2.Class(<classname string, optional>, <superclass class, optional>*, {
//      var1: 1
//      ,var2: 2
//      ,initialize: function(v){
//         this.var2 = v;
//         this.report();
//      }
//      ,report: function(){
//         alert('var1: '+this.var1+' var2:'+this.var2);
//      }
//   }); 
//
//   var inst = new myClass(5);
$n2.Class = function() {
	// This is a copy of this class' prototype
    var proto = {};
    var vars = {};
    var className = null;
	
	// This function is the class. It also represents the constructor
	// that is called when a new instance of the class is created.
    var Class = function() {
    	// Check that 'new' was called
    	if( this.initialize !== proto.initialize ){
    		throw new Error('"new" must be called when creating an instance of this class');
    	};
    	
    	// Initialize instance variables from templates.
    	for(var key in vars){
    		if( vars[key] === null ) {
    			this[key] = vars[key];
    		} else if( $n2.isArray(vars[key]) ) {
    			this[key] = $n2.extend(true, [], vars[key]);
    		} else if( typeof(vars[key]) === 'object' ){
    			this[key] = $n2.extend(true, {}, vars[key]);
    		} else if( typeof(vars[key]) === 'function' ){
    			// This should not happen. Functions should be in
    			// the prototype
    		} else {
    			this[key] = vars[key];
    		};
    	};
    	
    	// Assign class name
    	if( typeof(className) === 'string' ) {
    		this._classname = className;
    	};
    	
    	// Call initialization function
        this.initialize.apply(this, arguments);
    };

    // Process class definition
    for(var i=0, len=arguments.length; i<len; ++i) {
    	if( i === 0 && typeof(arguments[i]) === 'string' ) {
    		// Class name
    		Class._classname = className = arguments[i];
    		
    	} else if( typeof(arguments[i]) === 'function' ) {
            // This is a superclass. Extend this class' prototype
    		// from the superclass' prototype
            var parent = arguments[i].prototype;
            for(var key in parent){
            	if( typeof(parent[key]) === 'function' ){
            		proto[key] = parent[key];
            	} else {
            		vars[key] = parent[key];
            	};
            };
            
            // Extend variables from superclass
            if( arguments[i]._vars ){
                $n2.extend(vars, arguments[i]._vars);
            };
            
        } else {
            // Class definition. Save functions in prototype.
        	// Save variable initializations separately.
            var def = arguments[i];
            for(var key in def){
            	if( typeof(def[key]) === 'function' ){
            		proto[key] = def[key];
            	} else {
            		vars[key] = def[key];
            	};
            };
        };
    }
                
    // Supply an empty initialize method if the
    // class does not have one
    if( !proto.initialize ) {
    	proto.initialize = EmptyInit;
    };
    
    // Add getClass function
    proto.getClass = function(){ return Class; };
    
    Class.prototype = proto;
    Class._vars = vars;
    return Class;
};

})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.construct.js

/*
Copyright (c) 2018, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

 */

;
(function($n2) {
	"use strict";
	
	/**
	 The single inheritance construct function

	 Class definition.
	 Usage:
	 var myClass = $n2.Construct(<classname string, optional>, <superclass
	 class, optional>*, {
	 var1: 1
	 ,var2: 2
	 ,initialize: function(v){
	 this.var2 = v;
	 this.report();
	 }

	 var inst = new myClass(5);
 	*/	
	/**
	 * If constructor: function() provided, invoke the parent's constructor yourselves 
	 * (inside the constructor).
	 * Or you can just provide initialize : function(), in which case, the parent invoking 
	 * is taken care by us. The (super: function) will always be call 
	 * at very end of the initiation of the subclass. 
	 */
	$n2.Construct = function() {
		// This is a copy of this class' prototype
		var proto = {};
		var vars = {};
		var className = null;
		var isContructorProvided = false;

		// This function is the class. It also represents the constructor
		// that is called when a new instance of the class is created.
		var childClass = function(options) {

			// Initialize instance variables from templates.
			for ( var key in vars) {
				if (vars[key] === null) {
					this[key] = vars[key];
				} else if ($n2.isArray(vars[key])) {
					this[key] = $n2.extend(true, [], vars[key]);
				} else if (typeof (vars[key]) === 'object') {
					this[key] = $n2.extend(true, {}, vars[key]);
				} else if (typeof (vars[key]) === 'function') {
					// This should not happen. Functions should be in
					// the prototype
				} else {
					this[key] = vars[key];
				}
				;
			}
			;

			// Assign class name
			if (typeof (className) === 'string') {
				this._classname = className;
			}
			;
			
			// The consideration here is: in long run, the initialize() way of constructing class 
			// should be deprecated. Instead, the constructor() should be used.
			// Also, the subclass.base(this, 'constructor', opts) can be seen as a temporary alternative
			// to the ES6's super() method.
			if ( false == isContructorProvided) {
				this.initialize.apply(this, arguments);
				
			} else {
				this.customConstructor.apply(this, arguments);
				
			}
			//
		};

		childClass.base = function(me, methodName, var_args) {

			var args = new Array(arguments.length - 2);
			for (var i = 2; i < arguments.length; i++) {
				args[i - 2] = arguments[i];
			}
			if (childClass.superClass_) {
				childClass.superClass_[methodName].apply(me, args);
			} else {
				// nothing need to be done if no superClass providing

			}
		};

		// Process class definition
		var singleInherit = true;
		for (var i = 0, len = arguments.length; i < len; ++i) {
			if (i === 0 && typeof (arguments[i]) === 'string') {
				// Class name
				childClass._classname = className = arguments[i];

			} else if (typeof (arguments[i]) === 'function') {

				if (singleInherit) {
					
					singleInherit = false;
					/** Constructor * */
					tempCtor.prototype = arguments[i].prototype;
					childClass.superClass_ = arguments[i].prototype;
					proto = new tempCtor();

					
					// Extend variables from superclass
					if (arguments[i]._vars) {
						$n2.extend(vars, arguments[i]._vars);
					}
					;
				} else {
					throw new Error('multi inheritance not support');
				}
			} else {
				// Class definition. Save functions in prototype.
				// Save variable initializations separately.
				var def = arguments[i];
				for ( var key in def) {
					if (typeof (def[key]) === 'function') {
						proto[key] = def[key];
						isContructorProvided |= (key === "constructor")
					} else {
						vars[key] = def[key];
					}
					;
				}
				;
			}
			;
		}

		// Supply an empty initialize method if the
		// class does not have one
		if (!proto.initialize) {
			proto.initialize = function() {
			};
			;
		}
		;

		// Add getClass function
		proto.getClass = function() {
			return childClass;
		};

		childClass.prototype = proto;
		childClass.prototype.customConstructor = proto.constructor || function(){};
		childClass._vars = vars;
		childClass.prototype.constructor = childClass;
		

		return childClass;

		function tempCtor() {
		};
	};

})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.error.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.error'
;

// *******************************************************
var Error = $n2.Class({

	msg: undefined,

	cause: undefined,

	conditions: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			msg: undefined
			,cause: undefined
			,conditions: undefined
		},opts_);
		
		this.msg = opts.msg;
		this.cause = opts.cause;

		if( $n2.isArray(opts.conditions) ){
			for(var i=0,e=opts.conditions.length; i<e; ++i){
				var condition = opts.conditions[i];
				this.setCondition(condition);
			};
		};
	},

	getMessage: function(){
		if( typeof this.msg === 'string' ){
			return this.msg;
		};
		return _loc('<error>');
	},
	
	setCondition: function(condition){
		if( typeof condition === 'string' ){
			if( !this.conditions ){
				this.conditions = {};
			};
			this.conditions[condition] = true;
		};
	},

	isConditionSet: function(condition){
		if( typeof condition === 'string' ){
			if( this.conditions
			 && this.conditions[condition] ){
				return true;
			};

			if( this.cause 
			 && typeof this.cause.isConditionSet === 'function' ){
				return this.cause.isConditionSet(condition);
			};
		};
		
		return false;
	},

	getCause: function(){
		return this.cause;
	},

	setCause: function(cause){
		this.cause = cause;
	},

	toString: function(){
		var messages = [];
		var cause = this;
		while( cause ){
			if( cause.msg ){
				messages.push(cause.msg);
			};
			cause = cause.cause;
		};
		if( messages.length < 1 ){
			messages.push( _loc('<error>') );
		};
		return messages.join(': ');
	}
});

//*******************************************************
function fromString(str,cause){
	var err = new Error({
		msg: str
		,cause: cause
	});
	
	return err;
};

//*******************************************************
function checkErrorCondition(err, condition){
	if( typeof err === 'object' 
	 && typeof err.isConditionSet === 'function' ){
		return err.isConditionSet(condition);
	};
	return false;
};

//*******************************************************
$n2.error = {
	Error: Error
	,fromString: fromString
	,checkErrorCondition: checkErrorCondition
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.crypto.sha1.js

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS 180-1
 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

;(function($n2){
"use strict";

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }
function b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }
function any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }
function hex_hmac_sha1(k, d)
  { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_sha1(k, d)
  { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_sha1(k, d, e)
  { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA1 of a raw string
 */
function rstr_sha1(s)
{
  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
}

/*
 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
 */
function rstr_hmac_sha1(key, data)
{
  var bkey = rstr2binb(key);
  if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
//  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
//  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var remainders = Array();
  var i, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. We stop when the dividend is zero.
   * All remainders are stored for later use.
   */
  while(dividend.length > 0)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[remainders.length] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  /* Append leading zero equivalents */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)))
  for(i = output.length; i < full_length; i++)
    output = encoding[0] + output;

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of big-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binb(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
  return output;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function binb_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = bit_rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

// Export
if( !$n2.crypto ){
	$n2.crypto = {};
};
$n2.crypto.hex_sha1 = hex_sha1;
$n2.crypto.b64_sha1 = b64_sha1;
$n2.crypto.any_sha1 = any_sha1;
$n2.crypto.hex_hmac_sha1 = hex_hmac_sha1;
$n2.crypto.b64_hmac_sha1 = b64_hmac_sha1;
$n2.crypto.any_hmac_sha1 = any_hmac_sha1;

})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.storage.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

var sessionStorage = null;
var localStorage = null;

function getSessionStorage(){
	
	if( !sessionStorage ){
		if( window.sessionStorage ){
			sessionStorage = new Storage(window.sessionStorage);
		} else {
			sessionStorage = new FallbackStorage();
		};
	};
	
	return sessionStorage;
};

function getLocalStorage(){
	
	if( !localStorage ){
		if( window.localStorage ){
			localStorage = new Storage(window.localStorage);
		} else {
			localStorage = new FallbackStorage();
		};
	};
	
	return localStorage;
};

var Storage = $n2.Class({
	
	browserObj: null,
	
	initialize: function(browserObj){
		this.browserObj = browserObj;
	},
	
	getKeys: function(){
		var keys = [];
		
		var s = this.browserObj.length;
		for(var i=0;i<s; ++i){
			keys.push(this.browserObj.key(i));
		};
		
		return keys;
	},
	
	getItem: function(key){
		return this.browserObj.getItem(key);
	},
	
	setItem: function(key, value){
		this.browserObj.setItem(key, value);
	},
	
	removeItem: function(key){
		this.browserObj.removeItem(key);
	},
	
	clear: function(){
		this.browserObj.clear();
	}
});

var FallbackStorage = $n2.Class({
	
	store: null,
	
	initialize: function(){
		this.store = {};
	},
	
	getKeys: function(){
		var keys = [];
		
		for(var key in this.store){
			keys.push(key);
		};
		
		return keys;
	},
	
	getItem: function(key){
		if( this.store[key] ) {
			return this.store[key];
		};
		return null;
	},
	
	setItem: function(key, value){
		this.store[key] = value;
	},
	
	removeItem: function(key){
		delete this.store[key];
	},
	
	clear: function(){
		this.store = {};
	}
});

//============================================================
// Exports
$n2.storage = {
	getSessionStorage: getSessionStorage,
	getLocalStorage: getLocalStorage,
	Storage: Storage
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.indexedDb.js

;(function($n2){
"use strict";

var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
,DH = 'n2.indexedDb';

// ===================================================
var DB_STORE_DOCS = 'docs';
var DB_STORE_INFO = 'info';
var DocumentCache = $n2.Class('DocumentCache',{

	db: null,

	dispatchService: null,

	id: null,
	
	changes: null,
	
	changesByDocId: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			db: null
			,dispatchService: null
		},opts_);
		
		this.db = opts.db;
		this.dispatchService = opts.dispatchService;

		this.id = $n2.getUniqueId();
		this.changes = null;
		this.changesByDocId = {};
	},

	/**
	 * Initialize or re-initialize the cache to the given update
	 * sequence number.
	 */
	initializeCache: function(opts_){
		var opts = $n2.extend({
			dbName: null
			,updateSequence: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;

		var dbName = opts.dbName;
		if( typeof dbName !== 'string' ){
			throw new Error('When initializing document cache, dd name must be a string');
		};
		
		var updateSequence = opts.updateSequence;
		if( typeof updateSequence !== 'string' ){
			throw new Error('When initializing document cache, update sequence must be a number');
		};
		
		this.clearCache({
			onSuccess: function(){
				_this._writeUpdateSequence({
					dbName: dbName
					,updateSequence: updateSequence
					,onSuccess: function(){
						_this.changes = null;
						_this.changesByDocId = {};
						opts.onSuccess();
					}
					,onError: function(err){
						$n2.log('Error while recording initial sequence number. '+err);
						opts.onError(err);
					}
				});
			}
			,onError: function(err){
				$n2.log('Error while clearing document store. '+err);
				opts.onError(err);
			}
		});
	},
	
	getUpdateSequence: function(opts_){
		var opts = $n2.extend({
			dbName: null
			,onSuccess: function(updateSequence){}
			,onError: function(err){}
		},opts_);

		var db = this.db;
		
		if( typeof opts.dbName !== 'string' ){
			throw new Error('DocumentCache.getUpdateSequence() must have a string attribute for "dbName"');
		};
		
		// Check changes
		var updateSequence;
		if( this.changes ){
			this.changes.forEach(function(change){
				if( change 
				 && change.updateSequence
				 && change.dbName === opts.dbName ){
					updateSequence = change.updateSequence;
				};
			});
		};

		if( updateSequence ){
			opts.onSuccess(updateSequence);
		} else {
			// Get the value stored in the indexedDb
			this._readUpdateSequence({
				dbName: opts.dbName
				,onSuccess: opts.onSuccess
				,onError: opts.onError
			});
		};
	},
	
	performChanges: function(changes){
		// changes:
		// [
		//    // Revision update
		//    {
		//       "dbName": <string: name of database>,
		//       "id": <string: document identifier>,
		//       "rev": <string: current document revision>,
		//       "deleted": <optional boolean: if set, document was deleted>
		//    },
		//    // Database update sequence
		//    {
		//       "dbName": <string: name of database>,
		//       "updateSequence": <string: latest sequence for database>
		//    },
		//    // Document revision
		//    {
		//       "dbName": <string: name of database>,
		//       "id": <string: document identifier>,
		//       "rev": <string: document revision>,
		//       "doc": {
		//          "_id": <string: document identifier must match id>,
		//          "_rev": <string: document revision must match rev>,
		//       }
		//    },
		//    // Document attachments
		//    {
		//       "dbName": <string: name of database>,
		//       "id": <string: document identifier>,
		//       "rev": <string: document revision>,
		//       "attachments": {
		//          <string: attachment name>: <string: attachment value (works only for string attachments)>
		//       }
		//    }
		// ]

		var _this = this;
		var db = this.db;
		
		// Before anything, validate the given changes
		changes.forEach(function(change){
			// Check change structure
			if( typeof change !== 'object' ){
				throw new Error('A cache change must be an object');
			};
			if( typeof change.dbName !== 'string' ){
				throw new Error('A cache change must have a string "dbName" attribute');
			};
			if( typeof change.updateSequence ){
				// This is an update sequence request

			} else if( typeof change.id === 'string' ){
				// This is a document change
				if( typeof change.rev !== 'string' ){
					throw new Error('A document cache change must have a string "rev" attribute');
				};

				if( change.doc === undefined ){
					// OK
				} else if( typeof change.doc !== 'object' ){
					throw new Error('A document cache change must have an object "doc" attribute, if specified');
				} else {
					if( change.doc._id !== change.id ){
						throw new Error('A document cache change that includes a document must match doc._id and change.id');
					};
					if( change.doc._rev !== change.rev ){
						throw new Error('A document cache change that includes a document must match doc._rev and change.rev');
					};
				};

				if( change.deleted === undefined ){
					// OK
				} else if( typeof change.deleted !== 'boolean' ){
					throw new Error('A document cache change must have a boolean "deleted" attribute, if specified');
				};
				
				if( change.attachments === undefined ){
					// OK
				} else if( typeof change.attachments !== 'object' ){
					throw new Error('If a document cache change contains a "attachments" attribute, it must be an object');
				} else {
					for(var attName in change.attachments){
						var att = change.attachments[attName];
						
						if( typeof att !== 'string' ){
							throw new Error('If a document cache change contains "attachments", they must be strings');
						};
					};
				};

			} else {
				$n2.log('Invalid cache change',change);
				throw new Error('Unrecognized cache change');
			};
			
			// Clean up document from extra information that could have been
			// added by Nunaliit like __n2Source
			if( change.doc ){
				var clone = {};
				for(var key in change.doc){
					if( key.length >= 2 
					 && key[0] === '_' 
					 && key[1] === '_' ){
						// Do not copy keys that starts with two underscores
					} else {
						clone[key] = change.doc[key];
					};
				};
				change.doc = clone;
			};
			
			// Convert id for internal use
			if( typeof change.id === 'string' 
			 && typeof change.dbName === 'string' ){
				change.id = change.dbName + '|' + change.id;
				delete change.dbName;
			};
		});

		// Start applying changes
		var mustStartThread = true;
		if( this.changes ){
			mustStartThread = false;
		} else {
			this.changes  = [];
			this.changesByDocId = {};
		};

		// Add changes to list of current changes
		changes.forEach(function(change){
			_this.changes.push(change);
			
			if( change.id ){
				// This is a change to a document. Store the latest
				// changes with the latest revision.
				var latest = _this.changesByDocId[change.id];
				if( latest ){
					// There is a change already scheduled for this document.
					// Keep the latest
					var latestNumber = _this._getNumberFromRevision(latest.rev);
					var changeNumber = _this._getNumberFromRevision(change.rev);
					if( changeNumber > latestNumber ){
						// This is a newer revision. Replace the one in cache
						_this.changesByDocId[change.id] = change;
					} else if( changeNumber === latestNumber ){
						// This is the same revision. Merge the changes
						_this._mergeChanges(latest, change);
					};
				} else {
					// There is currently no change associated with this document.
					// Accept this one
					_this.changesByDocId[change.id] = change;
				};
			};
		});

		if( mustStartThread ){
			// Start a different thread to handle changes
			setTimeout(applyChange,0);
		};
		
		function applyChange(){
			if( _this.dispatchService ){
				_this.dispatchService.send(DH,{
					type: 'waitReport'
					,requester: _this.id
					,name: 'cacheDocuments'
					,label: _loc('Caching documents')
					,count: _this.changes.length
				});
			};
			
			
			if( _this.changes.length <= 0 ){
				// Done applying all changes. Set changes to null to indicate
				// that thread is terminated
				_this.changes = null;
			} else {
				var change = _this.changes.shift();
				
				if( change.updateSequence ){
					_this._writeUpdateSequence({
						dbName: change.dbName
						,updateSequence: change.updateSequence
						,onSuccess: applyChange
						,onError: applyChange
					});
				} else if( change.id ) {
					// This is a change related to a document. Apply the
					// change only if it is the latest one
					var latestChange = _this.changesByDocId[change.id];
					if( latestChange
					 && change.id === latestChange.id 
					 && change.rev === latestChange.rev ){
						// This is the latest change. Apply
						delete _this.changesByDocId[change.id];

						// Get entry from cache
						_this._getCacheEntry({
							id: latestChange.id
							,onSuccess: function(cacheEntry){
								if( cacheEntry ){
									// There is an entry in the cache. Figure out which one
									// to store
									var cacheNumber = _this._getNumberFromRevision(cacheEntry.rev);
									var changeNumber = _this._getNumberFromRevision(latestChange.rev);
									if( cacheNumber > changeNumber ){
										// Cache is more recent. Do nothing
										applyChange();
									} else if( cacheNumber < changeNumber ){
										// Cache is older than change. Save the change
										_this._storeCacheEntry({
											cacheEntry: latestChange
											,onSuccess: applyChange
											,onError: applyChange
										});
									} else {
										// At this point, the cache and the change are at the same
										// level. Merge both and store the result
										_this._mergeChanges(cacheEntry, latestChange);
										_this._storeCacheEntry({
											cacheEntry: cacheEntry
											,onSuccess: applyChange
											,onError: applyChange
										});
									};
								} else {
									// There is no entry in the cache. Store this one.
									_this._storeCacheEntry({
										cacheEntry: latestChange
										,onSuccess: applyChange
										,onError: applyChange
									});
								};
							}
						});
						
					} else {
						// This is not the latest change. Skip.
						applyChange();
					};
				} else {
					$n2.logError('Unrecognized change to document cache',change);
					applyChange();
				};
			};
		};
	},
	
	getDocument: function(opts_){
		var opts = $n2.extend({
			dbName: null
			,docId: null
			,onSuccess: function(doc){}
			,onError: function(err){}
		},opts_);

		var _this = this;

		var dbName = opts.dbName;
		if( typeof dbName !== 'string' ){
			throw new Error('DocumentCache.getDocument() must have dbName specified as a string attribute');
		};

		var docId = opts.docId;
		if( typeof docId !== 'string' ){
			throw new Error('DocumentCache.getDocument() must have docId specified as a string attribute');
		};
		
		var entryId = dbName + '|' + docId;
		
		// Check pending changes for this document
		var pendingChange;
		if( this.changesByDocId 
		 && this.changesByDocId[entryId] ){
			pendingChange = this.changesByDocId[entryId];
		};
		
		this._getCacheEntry({
			id: entryId
			,onSuccess: function(cacheEntry){
		    	if( cacheEntry && pendingChange ){
		    		// We have to figure which entry we want to use, the one
		    		// in memory (pending) or the one from the cache
					var cacheNumber = _this._getNumberFromRevision(cacheEntry.rev);
					var pendingNumber = _this._getNumberFromRevision(pendingChange.rev);
					if( cacheNumber > pendingNumber ){
						// Cache is more recent. Keep cache

					} else if( cacheNumber < pendingNumber ){
						// Cache is older than pending change. Use pending change.
						cacheEntry = pendingChange;

					} else {
						// At this point, the cache and the change are at the same
						// level. Merge pending changes to cache entry
						_this._mergeChanges(cacheEntry, pendingChange);
					};
		    	};

		    	if( !cacheEntry ){
		    		// Not in cache
					opts.onSuccess(undefined);
		    	} else if( cacheEntry.doc ){
					opts.onSuccess(cacheEntry.doc);
		    	} else {
		    		// In cache, but no document
					opts.onSuccess(undefined);
		    	};
			}
			,onError: opts.onError
		});
	},
	
	getDocuments: function(opts_){
		var opts = $n2.extend({
			dbName: null
			,docIds: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		
		var dbName = opts.dbName;
		if( typeof dbName !== 'string' ){
			throw new Error('DocumentCache.getDocuments() must have dbName specified as a string attribute');
		};

	    var docs = [];
	    var docIds = opts.docIds.slice(); // clone
	    var index = 0;
	    fetch();
	    
	    function fetch(){
	    	if( index >= docIds.length ){
	    		opts.onSuccess(docs);
	    	} else {
	    		var docId = docIds[index];
	    		++index;

	    		_this.getDocument({
	    			dbName: dbName
    				,docId: docId
    				,onSuccess: function(doc){
		    	    	if( doc ){
			    			docs.push(doc);
		    	    	};
		    	    	fetch();
    				}
    				,onError: fetch
	    		});
	    	};
	    };
	},
	
	getAttachment: function(opts_){
		var opts = $n2.extend({
			dbName: null
			,docId: null
			,attName: null
			,onSuccess: function(att, rev){}
			,onError: function(err){}
		},opts_);

		var _this = this;

		var dbName = opts.dbName;
		if( typeof dbName !== 'string' ){
			throw new Error('DocumentCache.getAttachment() must have dbName specified as a string attribute');
		};

		var docId = opts.docId;
		if( typeof docId !== 'string' ){
			throw new Error('DocumentCache.getAttachment() must have docId specified as a string attribute');
		};

		var attName = opts.attName;
		if( typeof attName !== 'string' ){
			throw new Error('DocumentCache.getAttachment() must have attName specified as a string attribute');
		};
		
		var entryId = dbName + '|' + docId;
		
		// Check pending changes for this document
		var pendingChange;
		if( this.changesByDocId 
		 && this.changesByDocId[entryId] ){
			pendingChange = this.changesByDocId[entryId];
		};
		
		this._getCacheEntry({
			id: entryId
			,onSuccess: function(cacheEntry){
		    	if( cacheEntry && pendingChange ){
		    		// We have to figure which entry we want to use, the one
		    		// in memory (pending) or the one from the cache
					var cacheNumber = _this._getNumberFromRevision(cacheEntry.rev);
					var pendingNumber = _this._getNumberFromRevision(pendingChange.rev);
					if( cacheNumber > pendingNumber ){
						// Cache is more recent. Keep cache

					} else if( cacheNumber < pendingNumber ){
						// Cache is older than pending change. Use pending change.
						cacheEntry = pendingChange;

					} else {
						// At this point, the cache and the change are at the same
						// level. Merge pending changes to cache entry
						_this._mergeChanges(cacheEntry, pendingChange);
					};
		    	};

		    	if( !cacheEntry ){
		    		// Not in cache
					opts.onSuccess(undefined);
		    	} else  if( cacheEntry.attachments ){
		    		var att = cacheEntry.attachments[attName];
					opts.onSuccess(att, cacheEntry.rev);
		    	} else {
		    		// In cache, but no document
					opts.onSuccess(undefined);
		    	};
			}
			,onError: opts.onError
		});
	},
	
	clearCache: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var _this = this;

		this._clearDocumentStore({
			onSuccess: function(){
				_this._clearInfoStore({
					onSuccess: opts.onSuccess
					,onError: opts.onError
				});
			}
			,onError: opts.onError
		});
	},
	
	_clearDocumentStore: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var db = this.db;
		
		var transaction = db.transaction(DB_STORE_DOCS, 'readwrite');
	    var store = transaction.objectStore(DB_STORE_DOCS);
	    var req = store.clear();
	    req.onsuccess = opts.onSuccess;
		req.onerror = function(evt){
			var error = this.error;
			$n2.log('Unable to clear indexedDb document store',error);
			opts.onError(error);
		};
		
	},
	
	_clearInfoStore: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var db = this.db;
		
		var transaction = db.transaction(DB_STORE_INFO, 'readwrite');
	    var store = transaction.objectStore(DB_STORE_INFO);
	    var req = store.clear();
	    req.onsuccess = opts.onSuccess;
		req.onerror = function(evt){
			var error = this.error;
			$n2.log('Unable to clear indexedDb info store',error);
			opts.onError(error);
		};
		
	},
	
	_storeCacheEntry: function(opts_){
		var opts = $n2.extend({
			cacheEntry: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var db = this.db;
		var cacheEntry = opts.cacheEntry;

		var transaction = this.db.transaction(DB_STORE_DOCS, 'readwrite');
	    var store = transaction.objectStore(DB_STORE_DOCS);
	    var req = store.put(cacheEntry);
	    req.onsuccess = function (evt) {
			opts.onSuccess();
		};
		req.onerror = function() {
			opts.onError(this.error);
		};
	},
	
	_getCacheEntry: function(opts_){
		var opts = $n2.extend({
			id: null
			,onSuccess: function(doc){}
			,onError: function(err){}
		},opts_);

		var db = this.db;
		var id = opts.id;
		
		var transaction = db.transaction(DB_STORE_DOCS, 'readonly');
	    var store = transaction.objectStore(DB_STORE_DOCS);
	    var req = store.get(id);
	    req.onsuccess = function (evt) {
	    	var cacheEntry = this.result;
			opts.onSuccess(cacheEntry);
		};
		req.onerror = function(evt) {
			opts.onError(this.error);
		};
	},
	
	/**
	 * Retrieves the update sequence stored for a database
	 */
	_readUpdateSequence: function(opts_){
		var opts = $n2.extend({
			dbName: null
			,onSuccess: function(updateSequence){}
			,onError: function(err){}
		},opts_);

		var db = this.db;
		
		if( typeof opts.dbName !== 'string' ){
			throw new Error('dbName must be a string');
		};

		var transaction = db.transaction(DB_STORE_INFO, 'readonly');
	    var store = transaction.objectStore(DB_STORE_INFO);
	    var req = store.get(opts.dbName+'|sequenceNumber');
	    req.onsuccess = function (evt) {
			// In CouchDB 1.x, update_seq is a number
			// In CouchDB 2.x, update_seq is a string
	    	var value = this.result;
	    	if( typeof value === 'object' 
	    	 && typeof value.updateSequence === 'string' ){
				opts.onSuccess(value.updateSequence);
	    	} else if( typeof value === 'object' 
	    	 && typeof value.updateSequence === 'number' ){
				opts.onSuccess(''+value.updateSequence);
	    	} else if( typeof value === 'undefined' ){
	    		opts.onSuccess(undefined);
	    	} else {
	    		var err = $n2.error.fromString('Invalid format for indexedDb sequence number');
				opts.onError(err);
	    	};
		};
		req.onerror = function(evt) {
			opts.onError(this.error);
		};
	},
	
	_writeUpdateSequence: function(opts_){
		var opts = $n2.extend({
			dbName: null
			,updateSequence: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var db = this.db;
		
		if( typeof opts.dbName !== 'string' ){
			throw new Error('dbName must be a string');
		};
		if( typeof opts.updateSequence !== 'string' ){
			throw new Error('updateSequence must be a string');
		};

		var transaction = db.transaction(DB_STORE_INFO, 'readwrite');
	    var store = transaction.objectStore(DB_STORE_INFO);
	    var req = store.put({
	    	_id: opts.dbName+'|sequenceNumber'
	    	,updateSequence: opts.updateSequence
	    });
	    req.onsuccess = opts.onSuccess;
		req.onerror = function(evt) {
			opts.onError(this.error);
		};
	},
	
	_getNumberFromRevision: function(revision){
		var splits = revision.split('-');
		var number = 1 * splits[0];
		return number;
	},
	
	_mergeChanges: function(targetChange, change){
		if( typeof targetChange !== 'object' ){
			throw new Error('DocumentCache._mergeChanges() targetChange must be an object');
		};
		if( typeof change !== 'object' ){
			throw new Error('DocumentCache._mergeChanges() change must be an object');
		};
		if( typeof targetChange.id !== 'string' ){
			throw new Error('DocumentCache._mergeChanges() targetChange.id must be a string');
		};
		if( targetChange.id !== change.id ){
			throw new Error('DocumentCache._mergeChanges() targetChange.id and change.id must be the same');
		};
		if( typeof targetChange.rev !== 'string' ){
			throw new Error('DocumentCache._mergeChanges() targetChange.rev must be a string');
		};
		if( targetChange.rev !== change.rev ){
			throw new Error('DocumentCache._mergeChanges() targetChange.rev and change.rev must be the same');
		};
		
		// Deal with deleted
		if( targetChange.deleted ){
			// Nothing to do

		} else if( change.deleted ){
			targetChange.deleted = true;
			delete targetChange.doc;
			delete targetChange.attachments;

		} else {
			// Copy document content
			if( change.doc ){
				targetChange.doc = change.doc;
			};

			// Copy attachments
			if( change.attachments ){
				if( !targetChange.attachments ){
					targetChange.attachments = {};
				};
				
				for(var attName in change.attachments){
					targetChange.attachments[attName] = 
						change.attachments[attName];
				};
			};
		};
	}
});

//===================================================
var IndexedDbService = $n2.Class('IndexedDbService',{

	db: null,
	
	documentCache: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			db: null
			,dispatchService: null
		},opts_);
		
		this.db = opts.db;
		
		this.documentCache = new DocumentCache({
			db: this.db
			,dispatchService: opts.dispatchService
		});
	},

	getDocumentCache: function(){
		return this.documentCache;
	}
});

//===================================================
var DB_NAME = 'nunaliit';
var DB_VERSION = 4;
function openIndexedDb(opts_){
	var opts = $n2.extend({
		dispatchService: null
		,onSuccess: function(indexedDbService){}
		,onError: function(err){}
	},opts_);
	
	if( typeof indexedDB !== 'object' ){
		opts.onError( new Error('IndexedDB not available in this browser') );
	};

	var req = indexedDB.open(DB_NAME, DB_VERSION);
	req.onsuccess = function (evt) {
		// Better use "this" than "req" to get the result to avoid problems with
		// garbage collection.
		// db = req.result;
		var db = this.result;
		
		var indexedDbService = new IndexedDbService({
			db: db
			,dispatchService: opts.dispatchService
		});

		opts.onSuccess(indexedDbService);
	};

	req.onerror = function (evt) {
		$n2.log("openDb:", evt.target.errorCode);
		opts.onError(this.error);
	};
	
	req.onupgradeneeded = function (evt) {
		
		var db = this.result;
		var oldVersion = undefined;
		var newVersion = undefined;
		if( evt && evt.currentTarget ){
			newVersion = evt.newVersion;
			oldVersion = evt.oldVersion;
		};

		$n2.log('Upgrading indexDB '+DB_NAME+' from: '+oldVersion+' to: '+newVersion);

		if( oldVersion < 1 ){ // docs store has existed since version 1
			db.createObjectStore(
				DB_STORE_DOCS
				,{ 
					keyPath: 'id' 
				}
			);
		} else if( oldVersion < 4 ){ // change in structure since version 4
			db.deleteObjectStore(DB_STORE_DOCS);
			db.createObjectStore(
				DB_STORE_DOCS
				,{ 
					keyPath: 'id' 
				}
			);
		};
		
		if( oldVersion < 2 ){ // info store has existed since version 1
			db.createObjectStore(
				DB_STORE_INFO
				,{ 
					keyPath: '_id' 
				}
			);
		};
	};
};
	
//===================================================
$n2.indexedDb = {
	openIndexedDb: openIndexedDb
};
	
})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.debug.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.debug'
;

//==================================================================
var DebugConfiguration = $n2.Class({

	initialize: function(opts_){
		var opts = $n2.extend({

		},opts_);
	},

	loadConfiguration: function(){
		var localStorage = $n2.storage.getLocalStorage();

		var debugConfStr = localStorage.getItem('n2debug_configuration');

		var debugConf = undefined;
		if( debugConfStr ){
			try {
				debugConf = JSON.parse(debugConfStr);
			} catch(e) {
				$n2.log('Unable to parse Debug configuration:'+e);
			};
		};

		if( !debugConf ){
			debugConf = {};
		};

		return debugConf;
	},

	saveConfiguration: function(debugConf){
		var localStorage = $n2.storage.getLocalStorage();

		var debugConfStr = JSON.stringify(debugConf);
		localStorage.setItem('n2debug_configuration',debugConfStr);
	},

	deleteConfiguration: function(){
		var localStorage = $n2.storage.getLocalStorage();
		localStorage.removeItem('n2debug_configuration');
	},

	isBadProxyEnabled: function(){
		var debugConf = this.loadConfiguration();
		if( debugConf.badProxy ) return true;
		return false;
	},

	setBadProxyEnabled: function(flag){
		var debugConf = this.loadConfiguration();
		if( flag ){
			debugConf.badProxy = true;
		} else if( debugConf.badProxy ){
			delete debugConf.badProxy;
		};
		this.saveConfiguration(debugConf);
	},

	isEventLoggingEnabled: function(){
		var debugConf = this.loadConfiguration();
		if( debugConf.logging ) return true;
		return false;
	},

	setEventLoggingEnabled: function(flag){
		var debugConf = this.loadConfiguration();
		if( flag ){
			debugConf.logging = true;
		} else if( debugConf.logging ){
			delete debugConf.logging;
		};
		this.saveConfiguration(debugConf);
	},

	isCouchDbCachingEnabled: function(){
		var debugConf = this.loadConfiguration();
		if( debugConf.couchDbCaching ) return true;
		return false;
	},

	setCouchDbCachingEnabled: function(flag){
		var debugConf = this.loadConfiguration();
		if( flag ){
			debugConf.couchDbCaching = true;
		} else if( debugConf.couchDbCaching ){
			delete debugConf.couchDbCaching;
		};
		this.saveConfiguration(debugConf);
	},

	isCouchDbCachingDisabled: function(){
		var debugConf = this.loadConfiguration();
		if( debugConf.disableCouchDbCaching ) return true;
		return false;
	},

	setCouchDbCachingDisabled: function(flag){
		var debugConf = this.loadConfiguration();
		if( flag ){
			debugConf.disableCouchDbCaching = true;
		} else if( debugConf.disableCouchDbCaching ){
			delete debugConf.disableCouchDbCaching;
		};
		this.saveConfiguration(debugConf);
	},

	forceSlowConnectionHandling: function(){
		var debugConf = this.loadConfiguration();
		if( debugConf.forceSlowConnectionHandling ) return true;
		return false;
	},

	setForceSlowConnectionHandling: function(flag){
		var debugConf = this.loadConfiguration();
		if( flag ){
			debugConf.forceSlowConnectionHandling = true;
		} else if( debugConf.forceSlowConnectionHandling ){
			delete debugConf.forceSlowConnectionHandling;
		};
		this.saveConfiguration(debugConf);
	}
});


//*******************************************************
$n2.debug = {
	DebugConfiguration: DebugConfiguration
	,setBadProxy: function(flag){
		var debugConf = new DebugConfiguration();
		debugConf.setBadProxyEnabled(flag);
	}
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.url.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($n2){
"use strict";

//-----------------------------------------------------
var Url = $n2.Class({
	
	url: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			url: null // String
		},opts_);
		
		this.url = opts.url;
	},
	
	clone: function(){
		return new Url({
			url: this.url
		});
	},

	getUrl: function(){
		return this.url;
	},

	getUrlWithoutHash: function() {
		var href = this.getUrl();

		var index = href.indexOf('#');
		if( index >= 0 ) {
			href = href.substr(0,index);
		};
		
		return href;
	},

	getHash: function() {
		var hash = undefined;
		
		var href = this.getUrl();
		var index = href.indexOf('#');
		if( index >= 0 ) {
			hash = href.substr(index+1);
		};
		
		return hash;
	},

	setHash: function(hash) {
		var href = this.getUrl();
		var index = href.indexOf('#');
		if( index >= 0 ) {
			// There already exist a hash...
			if( hash ){
				// ...replace it
				this.url = href.substr(0,index+1)+hash;
			} else {
				// ...remove it
				this.url = href.substr(0,index);
			};
		} else {
			// Currently, there is no hash...
			if( hash ){
				// ...add one
				this.url = href + '#' + hash;
			};
		};
		
		return this;
	},

	getUrlWithoutParams: function() {
		var href = this.getUrlWithoutHash();
		
		var index = href.indexOf('?');
		if( index >= 0 ) {
			href = href.substr(0,index);
		};
		
		return href;
	},

	getParams: function() {
		var result = {};

		var href = this.getUrlWithoutHash();
		var index = href.indexOf('?');
		if( index >= 0 ){
			var paramsString = href.slice(index + 1);
			var params = paramsString.split('&');
			for(var loop=0; loop<params.length; ++loop) {
				var s = params[loop].split('=');
				var key = decodeURIComponent(s[0]);
				var value = decodeURIComponent(s[1]);
				if( null == result[key] ) {
					result[key] = [];
				}
				result[key].push( value );
			}
		};

		return result;
	},
		
	getParam: function(name) {
		var params = this.getParams();
		if( null == params[name] ) {
			return [];
		}
		return params[name];
	},

	getParamValue: function(name, defaultValue) {
		var params = this.getParams();
		if( null == params[name] ) {
			return defaultValue;
		}
		return params[name][0];
	},
	
	setParamValue: function(name, value){
		var hash = this.getHash();
		var path = this.getUrlWithoutParams();
		var params = this.getParams();
		
		params[name] = [value];
		
		this._setUrlFromComponents(path, params, hash);
		
		return this;
	},
	
	_setUrlFromComponents: function(path, params, hash){
		var newUrl = [path];
		
		if( params ){
			var first = true;
			for(var name in params){
				var values = params[name];
				for(var i=0,e=values.length; i<e; ++i){
					var value = values[i];
					
					if( first ){
						first = false;
						newUrl.push('?');
					} else {
						newUrl.push('&');
					};
					
					newUrl.push( encodeURIComponent(name) );
					newUrl.push( '=' );
					newUrl.push( encodeURIComponent(value) );
				};
			};
		};
		
		if( hash ){
			newUrl.push( '#' );
			newUrl.push( hash );
		};
		
		this.url = newUrl.join('');
		
		return this;
	}
});	
	
//-----------------------------------------------------
// Exports
$n2.url = {
	Url: Url
	
	,getCurrentLocation: function(){
		if( typeof window === 'object' 
		 && window.location 
		 && window.location.href ) {
			return new Url({
				url: window.location.href
			});
		};
		
		return null;
	}

	,getUrlWithoutHash: function() {
		var loc = $n2.url.getCurrentLocation();
		return loc ? loc.getUrlWithoutHash() : null;
	}
	
	,getUrlWithoutParams: function() {
		var loc = $n2.url.getCurrentLocation();
		return loc ? loc.getUrlWithoutParams() : null;
	}

	,getParams: function() {
		var loc = $n2.url.getCurrentLocation();
		return loc ? loc.getParams() : {};
	}
		
	,getParam: function(name) {
		var loc = $n2.url.getCurrentLocation();
		return loc ? loc.getParam(name) : null;
	}

	,getParamValue: function(name, defaultValue) {
		var loc = $n2.url.getCurrentLocation();
		return loc ? loc.getParamValue(name, defaultValue) : defaultValue;
	}
};

})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.csv.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

//var 
//	_loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
//	,DH = 'n2.csv'
//	;

// ------------------------------------------------------------------------
/**
 * Given an array of values, compute a line of CSV.
 * @param values Array of values
 * @return String that represents the values in CSV format
 */
function ComputeCsvLine(values){
	if( ! $n2.isArray(values) ){
		throw 'In CSV conversion, values must be given in the form of an array';
	};
	
	var line = [];
	for(var j=0,k=values.length; j<k; ++j){
		var value = values[j];
		if( typeof value === 'string' ) {
			value = value.replace(/"/g,'""');
			line.push('"'+value+'"');

		} else if( typeof value === 'undefined' ) {
			line.push('');

		} else {
			line.push(''+value);
		};
	};
	
	return line.join(',');
};

//------------------------------------------------------------------------
/**
 * Given a table of values, compute the CSV representation
 * and return it into a string.
 * @param table A table of values
 * @return String that represents the values in CSV format
 */
function ValueTableToCsvString(table){
	var valid = true;
	if( ! $n2.isArray(table) ){
		valid = false;
	} else {
		for(var i=0,e=table.length; i<e; ++i){
			var row = table[i];
			if( ! $n2.isArray(row) ){
				valid = false;
				break;
			};
		};
	};
	if( !valid ){
		throw 'In CSV conversion, a table must be given in the form of an array of arrays of values';
	};
	
	var result = [];
	for(var i=0,e=table.length; i<e; ++i){
		var row = table[i];
		var line = ComputeCsvLine(row);
		result.push(line);
	};
	
	return result.join('\n');
};

//------------------------------------------------------------------------
function Parse(opts_){
	var opts = $n2.extend({
		csv: undefined
	},opts_);
	
	if( typeof opts.csv !== 'string' ){
		throw new Error('When parsing CSV, parameter "csv" must be a string');
	};
	
	var results =  Papa.parse(opts.csv,{
		header: true,
		skipEmptyLines: true
	});
	
	// Check for errors
	if( results.errors 
	 && results.errors.length > 0 ){
		var resError = results.errors[0];
		var message = 'Row '+resError.row+': '+resError.message;
		throw new Error(message);
	};
	
	return results.data;
};

//------------------------------------------------------------------------
$n2.csv = {
	ComputeCsvLine: ComputeCsvLine
	,ValueTableToCsvString: ValueTableToCsvString
	,Parse: Parse
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.jquery.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

// This file contains code that corrects/fixes issues when using jQuery with Nunaliit

;(function($,$n2){
"use strict";

// In IE8, must disable caching of $.ajax requests
var browserInfo = $n2.utils.getBrowserInfo();
if( browserInfo && browserInfo.browser === 'Explorer' ){
	// This is IE
	if( typeof(browserInfo.version) === 'number' ){
		if( browserInfo.version < 9 ){
			// IE8 or older, disable caching on AJAX calls
			if( $.ajaxSetup ){
				$.ajaxSetup({
					cache: false
				});				
			};
			
			// IE8 or older, Array.indexOf does not exist
			if (!Array.prototype.indexOf) {
				Array.prototype.indexOf = function(elt /*, from*/) {
					var len = this.length >>> 0;
					
					var from = Number(arguments[1]) || 0;
					from = (from < 0) ? Math.ceil(from) : Math.floor(from);
					if (from < 0) from += len;
					
					for(; from < len; ++from) {
						if( from in this 
						 && this[from] === elt) {
							return from;
						};
					};
					return -1;
				};
			};
		};
	};
};

/*
 *  jQuery-UI Widget: menuselector
 * 
 *  This is a widget that should be installed on a <select> element for
 *  making it easier to style the drop-down list.
 *  
 *  Usage:
 *  	$elem.menuselector(options);
 *  
 *  Example:
 *  	<select id="sel">
 *  		<option>Select one...</option>
 *  		<option value="first">ABC</option>
 *  		<option value="second">DEF</option>
 *  	</select>
 *  
 *  	$('#sel').menuselector();
 */
if( typeof $.widget === 'function' ){
	$.widget( 'nunaliit.menuselector', {
		
		options: {
			menuClass: null
		}
	
		,_create: function() {
			var _this = this;
	
			this.wrapper = $('<span>')
				.addClass('nunaliit-menuselector')
				.insertAfter(this.element);
			
			var classes = this.element.attr('class');
			
			var text = this.element.find('option').first().text();
			this.button = $('<select>')
				.appendTo(this.wrapper)
				.mousedown(function(e){
					_this._toggleMenu();
					return false;
				});
			if( classes ){
				this.button.attr('class',classes);
			};
			$('<option>')
				.text(text)
				.appendTo(this.button);
	
			this.menu = $('<div>')
				.addClass('nunaliit-menuselector')
				.css('position','absolute')
				.css('left','0px')
				.css('top','0px')
				.css('display','block')
				.css('z-index',1000)
				.hide()
				.appendTo(this.wrapper);
	
			this.element.hide();
		}
		
		,_createMenu: function(wrapper) {
	
			var _this = this;
			
			var $menu = $('<ul>')
				.appendTo(wrapper)
				.addClass('nunaliit-menuselector-menu');
			
			if( this.options.menuClass ){
				$menu.addClass(this.options.menuClass);
			};
			
			this.element.find('option').each(function(){
				var $opt = $(this);
				
				var value = $opt.val();
				if( value ) {
					var $li = $('<li>').appendTo($menu);
					$('<a>')
						.appendTo($li)
						.attr('href','#')
						.text($opt.text())
						.click(createClickHandler(value))
						;
				};
			});
			
			$menu.menu();
			
			function createClickHandler(value){
				return function(){
					_this._click(value);
					return false;
				};
			};
		}
		
		,_toggleMenu: function(){
			var wrapper = this.wrapper
				,menu = wrapper.children('div');
			
			// Close if already visible
			if( menu.is(':visible') ) {
				menu.empty();
				menu.hide();
			} else {
				this._createMenu(menu);
				menu.show();
				menu.position({
						my:'left top'
						,at: 'left bottom'
						//,collision: 'none'
						,of: this.button
					})
					;
			};
		}
		
		,_click: function(value) {
			this._toggleMenu();
			this.element.val(value);
			this.element.trigger('change');
		}
		
		,_destroy : function() {
			this.wrapper.remove();
			this.element.show();
		}
	});
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.l10n.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

// L10N = LOCALIZATION

// @requires n2.core.js
// @requires n2.utils.js
// @namespace nunaliit2
;(function($n2){
"use strict";

if( !$n2.l10n ) $n2.l10n = {};
if( !$n2.l10n.strings ) $n2.l10n.strings = {};
if( !$n2.l10n.strings['en'] ) $n2.l10n.strings['en'] = {};

var reLangCountry = /^([a-z][a-z])-([a-zA-Z][a-zA-Z])$/;
var reLang = /^([a-z][a-z])$/;

// Short-cut
var strings = $n2.l10n.strings;

var cachedLocale = null;

var translationRequests = {};

function getLocale() {
	if( cachedLocale ) return cachedLocale;
	
	if( null == cachedLocale && $n2.cookie ) {
		var lang = $n2.cookie.getCookie('nunaliit-l10n');
		if( lang ) {
			cachedLocale = createLocaleFromLanguage(lang);
		};
	};
	
	if( null == cachedLocale && $n2.url ) {
		var lang = $n2.url.getParamValue('lang',null);
		if( lang ) {
			cachedLocale = createLocaleFromLanguage(lang);
		};
	};
	
	if ( null == cachedLocale && typeof navigator === 'object' ) {
		if ( navigator.language ) {
	    	cachedLocale = createLocaleFromLanguage(navigator.language);
	        
	    } else if ( navigator.browserLanguage ) {
	    	cachedLocale = createLocaleFromLanguage(navigator.browserLanguage);
	        
	    } else if ( navigator.systemLanguage ) {
	    	cachedLocale = createLocaleFromLanguage(navigator.systemLanguage);
	        
	    } else if ( navigator.userLanguage ) {
	    	cachedLocale = createLocaleFromLanguage(navigator.userLanguage);
	    };
	    
	};
	
	// Default
	if( null == cachedLocale ) {
		cachedLocale = createLocaleFromLanguage('en-US');
	};

	return cachedLocale;
	
	function createLocaleFromLanguage(lang) {
		if( null == lang ) return null;
		
		var mLangCountry = lang.match(reLangCountry);
	    if( mLangCountry ) {
	    	return {
				locale: lang
				,lang: mLangCountry[1]
				,country: mLangCountry[2]
			};
		};

		var mLang = lang.match(reLang);
	    if( mLang ) {
	    	return {
				locale: lang
				,lang: mLang[1]
				,country: null
			};
		};

		$n2.log('Locale specified, but not in xx-YY format. Ignored.',lang);
    	return null;
	};
};

function getDictionaryFromLang(lang) {
	var dict = strings[lang];
	
	if( !dict ) {
		dict = {};
		strings[lang] = dict;
	};
	
	return dict;
};

function getStringForLang(str,lang){
	var result = {
		str: null
		,lang: null
		,fallback: false
	};

	// Handle content that contains translation
	if( typeof(str) === 'string' ) {
		result.str = str;
		
	} else if( typeof(str) === 'object' 
	 && str.nunaliit_type === 'localized' ){
		// Check request language
		if( typeof(str[lang]) === 'string' ) {
			result.str = str[lang];
			result.lang = lang;

		} else if( typeof(str.en) === 'string' ) {
			// Fallback to 'en'
			result.str = str.en;
			result.lang = lang;
			result.fallback = true;
			
		} else {
			// Fallback to any language
			for(var fbLang in str){
				if( 'nunaliit_type' === fbLang ){
					// ignore
				} else {
					result.str = str[fbLang];
					result.lang = fbLang;
					result.fallback = true;
					break;
				};
			};
		};
	};
	
	return result;
};

function getStringForLocale(str){
	var locale = getLocale();
	var lang = locale.lang;
	
	return getStringForLang(str,lang);
};

function getLocalizedString(str, packageName, args) {
	var suppressTranslationRequest = false;
	
	if( null === str ) return str;
	if( typeof str === 'undefined' ) return str;
	
	var locale = getLocale();
	var lang = locale.lang;

	// Assume that input str is english
	var lookupStr = str;
	var lookupLang = 'en';

	// Handle content that contains translation
	if( str.nunaliit_type === 'localized' ){
		// Translation should be provided in string, not
		// dictionary
		suppressTranslationRequest = true;
		
		lookupStr = null;
		
		// Check request language
		if( typeof(str[lang]) === 'string' ) {
			lookupStr = str[lang];
			lookupLang = lang;

		} else if( typeof(str.en) === 'string' ) {
			// Fallback to 'en'
			lookupStr = str.en;
			lookupLang = lang;
			
		} else {
			// Fallback to any language
			for(var fbLang in str){
				if( 'nunaliit_type' === fbLang ){
					// ignore
				} else if(typeof str[fbLang] === 'string' ) {
					lookupStr = str[fbLang];
					lookupLang = fbLang;
					break;
				};
			};
		};
	};

	// Get translation from dictionary
	var dic = getDictionaryFromLang(lang);
	var langStr = dic[lookupStr];
	
	if( !langStr ) {
		// Not in dictionary. Use lookup string
		langStr = lookupStr;

		if( lookupLang !== lang ) {
			// Request tranlation for this language
			if( !suppressTranslationRequest ){
				requestTranslation(lookupStr, lang, packageName);
			};
			
			// Store english version for now
			dic[lookupStr] = langStr;
		};
	};

	if( args ){
		return $n2.utils.formatString(langStr,args);
	};
	return langStr;
};

/**
 * Looks up a string in the dictionary of translations for the current
 * locale. If a string is not found, return undefined
 */
function lookupDictionaryTranslation(str, packageName, args){
	var locale = getLocale();
	var lang = locale.lang;

	var dic = getDictionaryFromLang(lang);
	var langStr = dic[str];
	
	if( !langStr ) {
		// Not in dictionary. Assume that input str is english
		if( 'en' !== lang ) {
			// Request tranlation for this language
			requestTranslation(str, lang, packageName);
		} else {
			// A request made in english. If not in dictionary, just use
			// input string
			langStr = str;
		};
	};

	// Need to format?
	if( langStr && args ){
		return $n2.utils.formatString(langStr,args);
	};
	
	return langStr;
};

function addLocalizedString(enStr, lang, langStr) {
	var dict = getDictionaryFromLang(lang);
	dict[enStr] = langStr;
	
	$n2.l10n.refreshLocalizedStrings();
};

function addLocalizedStrings(lang, strings) {
	var dict = getDictionaryFromLang(lang);

	for(var key in strings) {
		var value = strings[key];
		if( typeof value === 'string' && value ){
			dict[key] = value;
		};
	};
	
	$n2.l10n.refreshLocalizedStrings();
};


function getTranslationRequestsFromLang(lang) {
	var dic = translationRequests[lang];
	if( !dic ) {
		dic = {};
		translationRequests[lang] = dic;
	};
	return dic;
};

function requestTranslation(str, lang, packageName) {
	var dic = getTranslationRequestsFromLang(lang);
	var request = dic[str];
	
	if( !request ) {
		// Request has not yet been made
		request = {
			lang: lang
			,str: str
			,packageName: packageName
		};
		
		// Remember request
		dic[str] = request;
		
		// Send request
		if( $n2.l10n.sendTranslationRequest ) {
			$n2.l10n.sendTranslationRequest(request);
		};
	};
};

function refreshLocalizedStrings(){
	if( typeof jQuery !== 'undefined' ) {
		jQuery('body').find('.n2s_waiting_for_localization').each(function(){
			var $jq = $(this);
			var text = $jq.text();
			var locText = $n2.l10n.lookupDictionaryTranslation(text, 'nunaliit2');
			if( typeof locText === 'string' ) {
				$jq.text(locText);
				$jq.removeClass('n2s_waiting_for_localization');
			};
		});
	};
};

$n2.l10n.getLocale = getLocale;
$n2.l10n.getLocalizedString = getLocalizedString;
$n2.l10n.getStringForLang = getStringForLang;
$n2.l10n.getStringForLocale = getStringForLocale;
$n2.l10n.requestTranslation = requestTranslation;
$n2.l10n.translationRequests = translationRequests;
$n2.l10n.lookupDictionaryTranslation = lookupDictionaryTranslation;
$n2.l10n.addLocalizedString = addLocalizedString;
$n2.l10n.addLocalizedStrings = addLocalizedStrings;
$n2.l10n.refreshLocalizedStrings = refreshLocalizedStrings;

// Load core translations
if( $n2.scripts ) {
	var locale = getLocale();
	
	var coreLocation = $n2.scripts.getCoreScriptLocation();
	if( coreLocation ) {
		// Do not load default language
		if( 'en' !== locale.lang ) {
			var url = coreLocation.location + 'nunaliit2.'+locale.lang+'.js';
			$n2.scripts.loadScript({
				url: url
				,scriptLocation: coreLocation
			});
		};		

		var langUrl = coreLocation.location + '../nunaliit_lang.'+locale.lang+'.js';
		$n2.scripts.loadScript({
			url: langUrl
			,scriptLocation: coreLocation
		});
	};
	
	// Notify via DOM classes
	if( typeof jQuery !== 'undefined' ) {
		jQuery('body').addClass('nunaliit_language_'+locale.lang);
	};
};

})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.interval.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

var Interval = $n2.Class({
	
	min: null,
	
	max: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			min: null
			,max: null
		},opts_);
		
		if( typeof opts.min !== 'number' ){
			throw _loc('Interval min must be a number');
		};
		if( typeof opts.max !== 'number' ){
			throw _loc('Interval max must be a number');
		};
		if( opts.min > opts.max ){
			throw _loc('Interval min can not be greater than max');
		};
		
		this.min = opts.min;
		this.max = opts.max;
	},
	
	size: function(){
		return (this.max - this.min);
	},

	equals: function(interval){
		if( !interval ){
			return false;
		};
		
		if( typeof interval.min !== 'number' ){
			return false;
		};
		if( typeof interval.max !== 'number' ){
			return false;
		};
		
		if( this.min === interval.min 
		 && this.max === interval.max ){
			return true;
		};

		return false;
	},

	isIncludedIn: function(interval){
		if( !interval ){
			return false;
		};
		
		if( typeof interval.min !== 'number' ){
			return false;
		};
		if( typeof interval.max !== 'number' ){
			return false;
		};
		
		if( this.min >= interval.min 
		 && this.max <= interval.max ){
			return true;
		};

		return false;
	},

	extendTo: function(interval){
		var min = this.min;
		var max = this.max;
		
		if( interval ){
			if( min > interval.min ){
				min = interval.min;
			};
			
			if( max < interval.max ){
				max = interval.max;
			};
		};
		
		var myClass = this.getClass();
		
		return new myClass({
			min: min
			,max: max
		});
	},

	intersectsWith: function(interval){
		if( !interval ){
			return false;
		};
		
		if( this.min > interval.max ){
			return false;
		};
		if( this.max < interval.min ){
			return false;
		};
		
		return true;
	},

	intersection: function(interval){
		if( !this.intersectsWith(interval) ){
			return null;
		};
		
		var min = this.min;
		var max = this.max;

		if( min < interval.min ){
			min = interval.min;
		};

		if( max > interval.max ){
			max = interval.max;
		};
		
		var myClass = this.getClass();
		
		return new myClass({
			min: min
			,max: max
		});
	}
});

//*******************************************************
$n2.Interval = Interval;
$n2.interval = {
	Interval: Interval
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.date.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

//*******************************************************
var DateInterval = $n2.Class({
	
	dateStr: null,

	min: null,
	
	max: null,
	
	ongoing: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dateStr: null
			,min: null
			,max: null
			,ongoing: false
			,now: null
		},opts_);
		
		this.ongoing = opts.ongoing;
		this.dateStr = opts_.dateStr;
		
		if( typeof opts.min !== 'number' ){
			throw _loc('Interval min must be a number');
		};
		this.min = opts.min;
		
		if( this.ongoing ) {
			this.max = this.min;
			
			if( opts.now ){
				if( this.min > opts.now ){
					throw _loc('Ongoing time interval must begin before now');
				};
			};
			
		} else {
			if( typeof opts.max !== 'number' ){
				throw _loc('Interval max must be a number');
			};
			if( opts.min > opts.max ){
				throw _loc('Interval min can not be greater than max');
			};
			this.max = opts.max;
		};
	},
	
	getMin: function(){
		return this.min;
	},
	
	getMax: function(now){
		if( this.ongoing ){
			return now;
		};
		
		return this.max;
	},
	
	getDateString: function(){
		return this.dateStr;
	},
	
	/**
	 * Returns an object structure that can be saved in a
	 * document.
	 */
	getDocumentStructure: function(){
		var obj = {
			nunaliit_type: 'date'
			,date: this.dateStr
			,min: this.min
		};
		
		if( this.ongoing ){
			obj.ongoing = true;
		} else {
			obj.max = this.max;
		};
		
		return obj;
	},

	size: function(now){
		return (this.getMax(now) - this.min);
	},

	equals: function(interval){
		if( !interval ){
			return false;
		};
		
		// Check that it is an instance of DateInterval
		if( typeof interval.min !== 'number' ){
			return false;
		};
		var isOngoing = false;
		if( typeof interval.ongoing === 'boolean' ){
			isOngoing = interval.ongoing;
		};
		if( !isOngoing ){
			if( typeof interval.max !== 'number' ){
				return false;
			};
		};
		
		if( this.ongoing !== isOngoing ){
			return false;
		};
		
		if( this.ongoing ){
			if( this.min === interval.min ){
				return true;
			};
		} else {
			if( this.min === interval.min 
			 && this.max === interval.max ){
				return true;
			};
		};

		return false;
	},

	isIncludedIn: function(interval, now){
		if( !interval ){
			return false;
		};
		
		if( this.getMin() >= interval.getMin() 
		 && this.getMax(now) <= interval.getMax(now) ){
			return true;
		};

		return false;
	},

	extendTo: function(interval, now){
		if( !interval ){
			return this;
		};
		
		if( now ){
			// Ok to extend mixed
		} else if( this.ongoing !== interval.ongoing ){
			throw 'Can not extend ongoing and regular date intervals';
		};
		
		if( this.ongoing && interval.ongoing ){
			// Extending two on-going intervals
			if( this.min > interval.min ){
				return new DateInterval({
					ongoing: true
					,min: interval.min
				});
				
			} else {
				return this;
			};
			
		} else {
			var extended = false;
			var myMin = this.min;
			var otherMin = interval.min;
			var myMax = this.getMax(now);
			var otherMax = interval.getMax(now);
			
			if( myMin > otherMin ){
				myMin = otherMin;
				extended = true;
			};
			
			var updatedOngoing = false;
			if( myMax < otherMax ){
				myMax = otherMax;
				extended = true;
				
				if( interval.ongoing ){
					updatedOngoing = true;
				};
			} else if( this.ongoing ){
				updatedOngoing = true;
			};

			if( extended ){
				if( updatedOngoing ){
					return new DateInterval({
						ongoing: true
						,min: myMin
					});
				} else {
					return new DateInterval({
						ongoing: false
						,min: myMin
						,max: myMax
					});
				};
			} else {
				return this;
			};
		};
	},

	intersectsWith: function(interval, now){
		if( !interval ){
			return false;
		};
		
		if( this.getMin() > interval.getMax(now) ){
			return false;
		};
		if( this.getMax(now) < interval.getMin() ){
			return false;
		};
		
		return true;
	},

	intersection: function(interval, now){
		if( !this.intersectsWith(interval, now) ){
			return null;
		};
		
		if( this.ongoing 
		 && interval.ongoing ){
			if( this.min >= interval.min ){
				return this;
			} else {
				return new DateInterval({
					ongoing: true
					,min: interval.min
				});
			};
			
		} else {
			var min = this.getMin();
			var max = this.getMax(now);

			if( min < interval.getMin() ){
				min = interval.getMin();
			};

			if( max > interval.getMax(now) ){
				max = interval.getMax(now);
			};
			
			return new DateInterval({
				ongoing: false
				,min: min
				,max: max
			});
		};
	},
	
	save: function(){
		var obj = null;
		
		if( this.ongoing ){
			obj = {ongoing:true,min:this.min};
		} else {
			obj = {min:this.min,max:this.max};
		};
		
		if( this.dateStr ){
			obj.dateStr = this.dateStr;
		};
		
		return obj;
	}
});

//*******************************************************
var rFindYear = /(^|[^a-zA-Z0-9])(\d\d\d\d)/;
var rFindMonthDay = /^-(\d\d)-(\d\d)/;
var rFindMonthDay2 = /^(\d\d)(\d\d)/;
var rFindMonth = /^-?(\d\d)/;
var rFindHMS = /^( +|T)(\d\d):(\d\d)(:(\d\d))?/;
var rFindHMS2 = /^( +|T)(\d\d)(\d\d)(\d\d)?/;
var rFindEod = /^([^a-zA-Z0-9]|$)/;
/*
year            9999
year month      999999
                9999-99
year month date 99999999
                9999-99-99
hour minute       99:99
                  9999
                T99:99
                T9999
hour min sec     99:99:99
                 999999
                T99:99:99
                T999999
 */

/**
 * Finds a date string in the form of YYYY-MM-DD hh:mm:ss
 * and returns an object specifying the found string. Returns
 * null if nothing is found.
 * 
 * If a date string is found, the following structure is returned:
 * {
 *    input: <string> original string given to routine
 *    ,index: <number> index into string where found date string begins
 *    ,str: <string> date string found in original string
 *    ,interval: <object> instance of DateInterval that is interpreted from the found date string
 *    ,year: <number> year specified in found date string
 *    ,month: <number> month specified in found date string
 *    ,day: <number> day of month specified in found date string
 *    ,hours: <number> hours specified in found date string
 *    ,minutes: <number> minutes specified in found date string
 *    ,seconds: <number> seconds specified in found date string
 * }
 */
function findSingleDateString(str,index){
	var result = undefined;
	
	index = index ? index : 0;
	var next = (index>0) ? str.substr(index) : str;
	
	var mFindYear = rFindYear.exec(next);
	if( mFindYear ){
		var parseTime = false;

		result = {
			input: str
			,index: mFindYear.index + index + mFindYear[1].length
			,year: 1 * mFindYear[2]
		};
		
		index = index + mFindYear.index + mFindYear[1].length + mFindYear[2].length;
		var next = str.substr(index);
		
		var mFindMonthDay = rFindMonthDay.exec(next);
		if( mFindMonthDay ) {
			result.month = 1 * mFindMonthDay[1];
			result.day = 1 * mFindMonthDay[2];
			
			if( result.month < 1 
			 || result.month > 12 
			 || result.day < 1 
			 || result.day > 31 ){
				// Error. Continue searching
				return findDateString(str,index);
			};
			
			index += mFindMonthDay[0].length;
			next = str.substr(index);

			parseTime = true;
			
		} else {
			var mFindMonthDay2 = rFindMonthDay2.exec(next);
			if( mFindMonthDay2 ) {
				result.month = 1 * mFindMonthDay2[1];
				result.day = 1 * mFindMonthDay2[2];

				if( result.month < 1 
				 || result.month > 12 
				 || result.day < 1 
				 || result.day > 31 ){
					// Error. Continue searching
					return findDateString(str,index);
				};

				index += mFindMonthDay2[0].length;
				next = str.substr(index);

				parseTime = true;
				
			} else {
				var mFindMonth = rFindMonth.exec(next);
				if( mFindMonth ){
					result.month = 1 * mFindMonth[1];

					if( result.month < 1 
					 || result.month > 12 ){
						// Error. Continue searching
						return findDateString(str,index);
					};

					index += mFindMonth[0].length;
					next = str.substr(index);
				};
			};
		};
		
		if( parseTime ){
			var timeStruct = startsWithTimeStringAt(next);
			if( timeStruct ){
				// Followed by time string
				result.hours = timeStruct.hours;
				result.minutes = timeStruct.minutes;
				result.seconds = timeStruct.seconds;
				index += timeStruct.index + timeStruct.str.length;
				next = str.substr(index);
			};
		};

		// At this point, we should have either reached the end of the string
		// or encountered a white space
		var mFindEod = rFindEod.exec(next);
		if( !mFindEod ){
			// Error. Continue searching
			return findDateString(str,index);
		};
		
		// Compute date string
		var l = index - result.index;
		result.str = str.substr(result.index, l);
		next = str.substr(index);
		
		// OK, reached end of string
		if( typeof result.seconds !== 'undefined' ){
			var min = (new Date(
					result.year,
					result.month-1,
					result.day,
					result.hours,
					result.minutes,
					result.seconds)).getTime();
			var max = (new Date(
					result.year,
					result.month-1,
					result.day,
					result.hours,
					result.minutes,
					result.seconds+1)).getTime();
			
			result.interval = new DateInterval({
				min: min
				,max: max-1000
				,dateStr: result.str
			});

		} else if( typeof result.minutes !== 'undefined' ){
			var min = (new Date(
					result.year,
					result.month-1,
					result.day,
					result.hours,
					result.minutes)).getTime();
			var max = (new Date(
					result.year,
					result.month-1,
					result.day,
					result.hours,
					result.minutes+1)).getTime();
			
			result.interval = new DateInterval({
				min: min
				,max: max-1000
				,dateStr: result.str
			});

		} else if( typeof result.hours !== 'undefined' ){
			var min = (new Date(
					result.year,
					result.month-1,
					result.day,
					result.hours)).getTime();
			var max = (new Date(
					result.year,
					result.month-1,
					result.day,
					result.hours+1)).getTime();
			
			result.interval = new DateInterval({
				min: min
				,max: max-1000
				,dateStr: result.str
			});

		} else if( typeof result.day !== 'undefined' ){
			var min = (new Date(
					result.year,
					result.month-1,
					result.day)).getTime();
			var max = (new Date(
					result.year,
					result.month-1,
					result.day+1)).getTime();
			
			result.interval = new DateInterval({
				min: min
				,max: max-1000
				,dateStr: result.str
			});

		} else if( typeof result.month !== 'undefined' ){
			var min = (new Date(
					result.year,
					result.month-1,
					1)).getTime();
			var max = (new Date(
					result.year,
					result.month,
					1)).getTime();
			
			result.interval = new DateInterval({
				min: min
				,max: max-1000
				,dateStr: result.str
			});

		} else {
			var min = (new Date(
					result.year,
					0,
					1)).getTime();
			var max = (new Date(
					result.year+1,
					0,
					1)).getTime();
			
			result.interval = new DateInterval({
				min: min
				,max: max-1000
				,dateStr: result.str
			});
		};
	};
	
	return result;
};

/**
 * Finds a time string in the form of T?hh:mm:ss
 * and returns an object specifying the found string. Returns
 * null if nothing is found.
 * 
 * If a time string is found, the following structure is returned:
 * {
 *    input: <string> original string given to routine
 *    ,index: <number> index into string where found date string begins
 *    ,str: <string> date string found in original string
 *    ,hours: <number> hours specified in found time string
 *    ,minutes: <number> minutes specified in found time string
 *    ,seconds: <number> seconds specified in found time string
 * }
 */
function startsWithTimeStringAt(str,index){
	var result = undefined;
	
	index = index ? index : 0;
	var next = (index>0) ? str.substr(index) : str;
	
		
	var mFindHMS = rFindHMS.exec(next);
	var mFindHMS2 = rFindHMS2.exec(next);
	
	if(mFindHMS) {
		result = {
			index: index
			,hours: 1 * mFindHMS[2]
			,minutes: 1 * mFindHMS[3]
		};
		if( typeof mFindHMS[5] !== 'undefined' ){
			result.seconds = 1 * mFindHMS[5];
		};

		if( result.hours > 23 
		 || result.minutes > 59 
		 || (typeof result.seconds !== 'undefined' && result.seconds > 59) ){
			return undefined;
		};

		index += mFindHMS[0].length;
		
	} else if(mFindHMS2) {
		result = {
				index: index
				,hours: 1 * mFindHMS2[2]
				,minutes: 1 * mFindHMS2[3]
			};
		if( typeof mFindHMS2[4] !== 'undefined' ){
			result.seconds = 1 * mFindHMS2[4];
		};

		if( result.hours > 23 
		 || result.minutes > 59 
		 || (typeof result.seconds !== 'undefined' && result.seconds > 59) ){
			return undefined;
		};

		index += mFindHMS2[0].length;
	} else {
		return result;
	};

	// Compute date string
	var l = index - result.index;
	result.str = str.substr(result.index, l);
	next = str.substr(index);
		
	// At this point, we should have either reached the end of the string
	// or encountered a white space
	var mFindEod = rFindEod.exec(next);
	if( mFindEod ){
		// OK, reached end of date
	} else {
		// Not ended properly
		result = undefined;
	};

	return result;
};

var rDurationSeparator = /^\s*\/\s*/;

/**
 * Finds a date string or a date range string.
 * date-range :=  date-string '/' date-string
 *             |  date-string;
 * 
 * If a date range is found, the following structure is returned:
 * {
 *    input: <string> original string given to routine
 *    ,index: <number> index into string where found date range begins
 *    ,str: <string> date range found in original string
 *    ,interval: <object> instance of DateInterval that is interpreted from the found date range
 * }
 */
function findDateString(str,index){

	var result = findSingleDateString(str,index);
	if( result ){
		// At this point, we have one date. See if this is a duration, with
		// another date after an appropriate separator. There are two variants:
		// - date / date  This is a regular date interval
		// - date / -     This is an ongoing date interval
		index = result.index + result.str.length;
		var next = str.substr(index);
		var mDurationSeparator = rDurationSeparator.exec(next);
		if( mDurationSeparator ){
			index += mDurationSeparator[0].length;
			
			if( '-' === str[index] ){
				// On-Going
				++index;
				
				var l = index - result.index;
				result.str = str.substr(result.index, l);
				
				result.interval = new DateInterval({
					ongoing: true
					,min: result.interval.min
					,dateStr: result.str
				});

				if( typeof result.year !== 'undefined' ) delete result.year;
				if( typeof result.month !== 'undefined' ) delete result.month;
				if( typeof result.day !== 'undefined' ) delete result.day;
				if( typeof result.hours !== 'undefined' ) delete result.hours;
				if( typeof result.minutes !== 'undefined' ) delete result.minutes;
				if( typeof result.seconds !== 'undefined' ) delete result.seconds;
				
			} else {
				var another = findSingleDateString(str,index);
				if( another && another.index == index ){
					// This is a regular duration
					result.str = str.substr(result.index,another.index+another.str.length-result.index);
					result.interval = result.interval.extendTo(another.interval);
					result.interval.dateStr = result.str;
					
					if( typeof result.year !== 'undefined' ) delete result.year;
					if( typeof result.month !== 'undefined' ) delete result.month;
					if( typeof result.day !== 'undefined' ) delete result.day;
					if( typeof result.hours !== 'undefined' ) delete result.hours;
					if( typeof result.minutes !== 'undefined' ) delete result.minutes;
					if( typeof result.seconds !== 'undefined' ) delete result.seconds;
				};
			};
		};
	};
	
	return result;
};

//*******************************************************
/**
 * If the input string contains a date, returns an instance of
 * DateInterval. Otherwise, returns null.
 */
function parseUserDate(dateStr){
	var dateInterval = null;
	
	var effectiveStr = $n2.trim(dateStr);
	var findStr = findDateString(effectiveStr, 0);
	if( findStr ){
		if( effectiveStr === findStr.str ){
			dateInterval = findStr.interval;
		};
	};
	
	if( null == dateInterval ){
		throw _loc('Can not parse date: {date}',{date:dateStr});
	};
	
	return dateInterval;
};

//*******************************************************
function findAllDateStrings(str){
	var results = [];
	
	var d = findDateString(str);
	while(d){
		results.push(d);
		
		var index = d.index + d.str.length;
		d = findDateString(str,index);
	};
	
	return results;
};

//*******************************************************
function parseDateStructure(obj){
	if( !obj || typeof obj.date !== 'string' ){
		throw _loc('Invalid date structure');
	};
	
	var dateInt = parseUserDate(obj.date);
	
	return dateInt;
};

//*******************************************************
$n2.date = {
	DateInterval: DateInterval
	,parseUserDate: parseUserDate
	,parseDateStructure: parseDateStructure
	,findDateString: findDateString
	,findAllDateStrings: findAllDateStrings
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.dateService.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

//*******************************************************
var DateService = $n2.Class({
	
	url: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			url: null
		},opts_);
		
		this.url = opts.url;
	},
	
	getDocIdsFromInterval: function(opts_){
		var opts = $n2.extend({
			interval: null
			,onSuccess: function(docIds){}
			,onError: function(err){}
		},opts_);
		
		var min = null;
		if( !opts.interval 
		 || typeof opts.interval.min !== 'number' ){
			opts.onError('Interval must be supplied');
			return;
		} else {
			min = opts.interval.min;
		};
		var ongoing = false;
		var max = min;
		if( typeof opts.interval.ongoing === 'boolean' ){
			ongoing = opts.interval.ongoing;
		};
		if( !ongoing ){
			if( typeof opts.interval.max !== 'number' ){
				opts.onError('Interval must contain ongoing or max');
				return;
			} else {
				max = opts.interval.max;
			};
		};
		
		var requestData = {
			min: min	
		};
		if( ongoing ) {
			requestData.ongoing = true;
		} else {
			requestData.max = max;
		};
		
	    $.ajax({
	    	url: this.url + 'docIdsFromInterval'
	    	,type: 'get'
	    	,async: true
	    	,data: requestData
	    	,dataType: 'json'
	    	,success: function(res) {
	    		if( res.docIds ) {
	    			opts.onSuccess(res.docIds);
	    		} else {
					opts.onError('Malformed response for doc ids from interval('+min+','+max+')');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = $n2.utils.parseHttpJsonError(XMLHttpRequest, textStatus);
				var errStr = err.error;
				opts.onError('Error obtaining doc ids from interval('+min+','+max+'): '+errStr);
	    	}
	    });
	}
});



//*******************************************************
$n2.dateService = {
	DateService: DateService
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.base64.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

    var codex = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	
$n2.Base64 = {

    encode: function(input) {
        var output = [];

        var index = 0;
        while( index < input.length ) {
            var chr1 = input.charCodeAt(index++);
            var chr2 = input.charCodeAt(index++);
            var chr3 = input.charCodeAt(index++);

            var enc1 = chr1 >> 2;
            var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            var enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output.push(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
        };

        return output.join('');
    }

    ,decode : function(input) {
    	var output = [];
 
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
 
		var i = 0;
		while (i < input.length) {
 
			var enc1 = codex.indexOf(input.charAt(i++));
			var enc2 = codex.indexOf(input.charAt(i++));
			var enc3 = codex.indexOf(input.charAt(i++));
			var enc4 = codex.indexOf(input.charAt(i++));
 
			var chr1 = (enc1 << 2) | (enc2 >> 4);
			var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			var chr3 = ((enc3 & 3) << 6) | enc4;
 
			output.push( String.fromCharCode(chr1) );
 
			if (enc3 != 64) {
				output.push( String.fromCharCode(chr2) );
			}
			if (enc4 != 64) {
				output.push( String.fromCharCode(chr3) );
			}
 
		}
 
		return output.join('');
    }
};

})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.blindWidget.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

/*
 * This is a widget based on the jquery-ui accordion styles
 * and behaviour.
 * It enables to opening and closing of one pane, with appropriate
 * callbacks.
 */
;(function($,$n2){
"use strict";
	
	var noopFn = function(){}
	
	var BlindWidget = $n2.Class({
		options: null
		
		,id: null
		
		,initialize: function($elem, opts_){

			var _this = this;
			
			this.options = $n2.extend({
				time: 500
				,data: null
				,onBeforeOpen: noopFn
				,onAfterOpen: noopFn
				,onBeforeClose: noopFn
				,onAfterClose: noopFn
			},opts_);
			
			var id = $elem.attr('id');
			if( null === id || typeof(id) === 'undefined' ) {
				id = $n2.getUniqueId();
				$elem.attr('id',id);
			};
			this.id = id;
			
			var $header = $elem.children().first();
			var $div = $header.next();
			
			$elem.addClass('n2Blind ui-accordion ui-widget ui-helper-reset ui-accordion-icons');
			
			var headerText = $header.text();
			$header.empty()
				.append( $('<span class="ui-icon ui-icon-triangle-1-e"></span>') )
				.append( $('<a class="n2BlindA" href="#"></a>') )
				.click(function(){
					_this._headerClicked();
					return false;
				});
			$header.find('a')
				.text(headerText);
			$header.addClass('ui-accordion-header ui-helper-reset ui-state-default ui-corner-top');
			
			$div
				.addClass('ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content-active')
				.css('display','none');
		}
	
		,setText: function(t){
			var $elem = $('#'+this.id);
			var $header = $elem.children().first();
			$header.find('a').text(t);
		}
		
		,setHtml: function(h){
			var $elem = $('#'+this.id);
			var $header = $elem.children().first();
			$header.find('a').html(h);
		}

		,_headerClicked: function(){

			var _this = this;

			var $sections = $('#'+this.id);
			if( $sections.length < 1 ) {
				return;
			};
			var $header = $sections.children().first();
			var $a = $header.find('a');
			var $div = $header.next();
			
			var info = {
				data: this.options.data
				,link: $a
				,content: $div
			};

			if( $div.hasClass('n2uiActive') ) {
				$header.removeClass('ui-state-active ');
				$header.find('span')
					.removeClass('ui-icon-triangle-1-s')
					.addClass('ui-icon-triangle-1-e');
				$div.removeClass('n2uiActive');
				this.options.onBeforeClose(info);
				$div.hide('blind',{},this.options.time,function(){
					_this.options.onAfterClose(info);
				});
			} else {
				$header.addClass('ui-state-active ');
				$header.find('span')
					.removeClass('ui-icon-triangle-1-e')
					.addClass('ui-icon-triangle-1-s');
				$div.addClass('n2uiActive');
				this.options.onBeforeOpen(info);
				$div.show('blind',{},this.options.time,function(){
					_this.options.onAfterOpen(info);
				});
			};
		}
	});
	
	$n2.blindWidget = function($jq,options){
		return new BlindWidget($jq.first(),options);
	};
})(jQuery, nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.help.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

var 
	_loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
	,DH = 'n2.help'
	;

//=========================================================================	

var helpDisplayByKey = {};	
	
//=========================================================================	
var HelpDisplay = $n2.Class({
	
	helpDialogId: null,
	
	title: null,
	
	htmlContent: null,
	
	textContent: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			title: 'Help'
			,htmlContent: null
			,textContent: null
		},opts_);
		
		this.title = opts.title;
		this.htmlContent = opts.htmlContent;
		this.textContent = opts.textContent;
		
		this.helpDialogId = $n2.getUniqueId();
	},
	
	show: function($elem){
		// If open, then close it
		var $dialog = this._getDialogElem();
		if( $dialog.length > 0 ){
			$dialog.dialog('open');
		} else {
			this._createDialog($elem);
		};
	},
	
	hide: function(){
		var $dialog = this._getDialogElem();
		if( $dialog.length > 0 ){
			$dialog.dialog('close');
		};
	}, 
	
	toggle: function($elem){
		var $dialog = this._getDialogElem();
		if( $dialog.length > 0 ){
			var isOpen = $dialog.dialog('isOpen');
			if( isOpen  ) {
				this.hide($elem);
			} else {
				this.show($elem);
			};
		} else {
			this.show($elem);
		};
	},
	
	_getDialogElem: function(){
		return $('#'+this.helpDialogId);
	},
	
	_createDialog: function($elem){

		// Check that dialog support is available
		if( !$.fn ) return;
		if( !$.fn.dialog ) return;
		
		var $dialog = $('<div>')
			.attr('id',this.helpDialogId)
			.addClass('n2help_content')
			.appendTo( $('body') );
		
		if( this.htmlContent ){
			// localize content
			var content = _loc(this.htmlContent);
			$dialog.html(content);
		} else if( this.textContent ){
			var content = _loc(this.textContent);
			$dialog.text(content);
		} else {
			return;
		};
		
		$dialog.appendTo( $('body') );
		
		var initialHeight = $dialog.height();
		var initialWidth = $dialog.width();
		
		var windowHeight = $(window).height();
		var windowWidth = $(window).width();
		
		var diagMaxHeight = Math.floor(windowHeight * 0.8);
		var diagMaxWidth = Math.floor(windowWidth * 0.8);

		var dialogOptions = {
			autoOpen: true
			,dialogClass:'n2help_dialog'
			,title: _loc(this.title)
			,modal: false
			,width: 400
//			,position:{
//				my: 'right top'
//				,at: 'right bottom'
//				,of: $('#'+_this.helpButtonName+' .nunaliit_module_help_button')
//			}
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		
		// Ensure to not exceed available geometry
		var height = initialHeight;
		if( initialHeight > diagMaxHeight ){
			dialogOptions.height = diagMaxHeight;
			height = diagMaxHeight;
		};
		var width = initialWidth;
		if( initialWidth > diagMaxWidth ){
			dialogOptions.width = diagMaxWidth;
			width = diagMaxWidth;
		};
		
		if( $elem ){
			var offset = $elem.offset();
			
			var fitsAbove = false;
			var fitsBelow = false;
			var fitsLeft = false;
			var fitsRight = false;
			
			if( offset.top >= height ){
				fitsAbove = true;
			};
			if( (windowHeight - offset.top - $elem.height()) >= height ){
				fitsBelow = true;
			};
			if( offset.left >= width ){
				fitsLeft = true;
			};
			if( (windowWidth - offset.left - $elem.width()) >= height ){
				fitsRight = true;
			};
			
			if( fitsBelow && fitsLeft ){
				dialogOptions.position = {
					my: 'right top'
					,at: 'right bottom'
					,of: $elem
				};
				
			} else if( fitsBelow && fitsRight ){
				dialogOptions.position = {
					my: 'left top'
					,at: 'left bottom'
					,of: $elem
				};
				
			} else if( fitsBelow ){
				dialogOptions.position = {
					my: 'center top'
					,at: 'center bottom'
					,of: $elem
				};
				
			} else if( fitsAbove && fitsLeft ){
				dialogOptions.position = {
					my: 'right bottom'
					,at: 'right top'
					,of: $elem
				};
				
			} else if( fitsAbove && fitsRight ){
				dialogOptions.position = {
					my: 'left bottom'
					,at: 'left top'
					,of: $elem
				};
				
			} else if( fitsAbove ){
				dialogOptions.position = {
					my: 'center bottom'
					,at: 'center top'
					,of: $elem
				};
				
			} else if( fitsLeft ){
				dialogOptions.position = {
					my: 'right center'
					,at: 'left center'
					,of: $elem
				};
				
			} else if( fitsRight ){
				dialogOptions.position = {
					my: 'left center'
					,at: 'right center'
					,of: $elem
				};
			};
		};
		
		$dialog.dialog(dialogOptions);
	}
});
	
//=========================================================================	

function ShowHelp(key, $elem){
	var helpDisplay = helpDisplayByKey[key];
	if( helpDisplay ){
		helpDisplay.show($elem);
	};
};

//=========================================================================	

function ToggleHelp(key, $elem){
	var helpDisplay = helpDisplayByKey[key];
	if( helpDisplay ){
		helpDisplay.toggle($elem);
	};
};

//=========================================================================	

function InstallHelpInfo(key, helpInfo){
	if( key && helpInfo ){
		if( 'html' === helpInfo.type 
		 && helpInfo.content ){
			helpDisplayByKey[key] = new HelpDisplay({
				htmlContent: helpInfo.content
				,title: helpInfo.title
			});
			
		} else if( 'text' === helpInfo.type 
		 && helpInfo.content ){
			helpDisplayByKey[key] = new HelpDisplay({
				textContent: helpInfo.content
				,title: helpInfo.title
			});
		};
	};
};

//=========================================================================	

$n2.help = {
	ShowHelp: ShowHelp
	,ToggleHelp: ToggleHelp
	,InstallHelpInfo: InstallHelpInfo
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.docFnCall.js

/*
Copyright (c) 2018, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var docFnCall = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,7],$V2=[1,8],$V3=[5,7,8,11,12,14,15,16,17,18,19,24,25,26,27,28,29,30,32,33],$V4=[1,13],$V5=[1,12],$V6=[1,15],$V7=[1,16],$V8=[1,17],$V9=[1,18],$Va=[1,23],$Vb=[1,24],$Vc=[1,25],$Vd=[1,26],$Ve=[1,27],$Vf=[1,28],$Vg=[1,29],$Vh=[1,30],$Vi=[1,31],$Vj=[1,32],$Vk=[1,33],$Vl=[1,34],$Vm=[1,35],$Vn=[8,11,12,14,15,16,17,18,19,24,25,26,27,28,29,33],$Vo=[8,11,12,29,33],$Vp=[8,11,12,14,15,16,17,18,19,29,33],$Vq=[8,11,12,14,15,16,17,18,19,24,25,29,33];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"program":3,"prgroot":4,"EOF":5,"identifier":6,"(":7,")":8,"arguments":9,"value":10,"&&":11,"||":12,"!":13,"==":14,"!=":15,">=":16,"<=":17,">":18,"<":19,"true":20,"false":21,"NUMBER":22,"STRING":23,"+":24,"-":25,"*":26,"/":27,"%":28,",":29,".":30,"VAR_NAME":31,"[":32,"]":33,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",7:"(",8:")",11:"&&",12:"||",13:"!",14:"==",15:"!=",16:">=",17:"<=",18:">",19:"<",20:"true",21:"false",22:"NUMBER",23:"STRING",24:"+",25:"-",26:"*",27:"/",28:"%",29:",",30:".",31:"VAR_NAME",32:"[",33:"]"},
productions_: [0,[3,2],[4,1],[4,3],[4,4],[10,3],[10,3],[10,2],[10,3],[10,3],[10,3],[10,3],[10,3],[10,3],[10,3],[10,3],[10,4],[10,1],[10,1],[10,1],[10,1],[10,1],[10,3],[10,3],[10,3],[10,3],[10,3],[9,3],[9,1],[6,3],[6,4],[6,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2:

        	this.$ = new ProgramRoot($$[$0],null);
        
break;
case 3:

        	this.$ = new ProgramRoot($$[$0-2],null);
        
break;
case 4:

        	this.$ = new ProgramRoot($$[$0-3],$$[$0-1]);
        
break;
case 5:

        	this.$ = new Expression($$[$0-2],'&&',$$[$0]);
        
break;
case 6:

        	this.$ = new Expression($$[$0-2],'||',$$[$0]);
        
break;
case 7:

        	this.$ = new Expression($$[$0],'!');
        
break;
case 8:

    		this.$ = $$[$0-1];
    	
break;
case 9:

        	this.$ = new Comparison($$[$0-2],$$[$0],'==');
        
break;
case 10:

        	this.$ = new Comparison($$[$0-2],$$[$0],'!=');
        
break;
case 11:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>=');
        
break;
case 12:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<=');
        
break;
case 13:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>');
        
break;
case 14:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<');
        
break;
case 15:

        	this.$ = new FunctionCall($$[$0-2],null);
        
break;
case 16:

        	this.$ = new FunctionCall($$[$0-3],$$[$0-1]);
        
break;
case 17:

        	this.$ = $$[$0];
        
break;
case 18:

    		this.$ = new Literal(true);
    	
break;
case 19:

    		this.$ = new Literal(false);
    	
break;
case 20:

    		this.$ = new Literal(1 * $$[$0]);
    	
break;
case 21:

    		this.$ = new Literal($$[$0]);
    	
break;
case 22:

    		this.$ = new MathOp($$[$0-2],$$[$0],'+');
    	
break;
case 23:

    		this.$ = new MathOp($$[$0-2],$$[$0],'-');
    	
break;
case 24:

    		this.$ = new MathOp($$[$0-2],$$[$0],'*');
    	
break;
case 25:

    		this.$ = new MathOp($$[$0-2],$$[$0],'/');
    	
break;
case 26:

    		this.$ = new MathOp($$[$0-2],$$[$0],'%');
    	
break;
case 27:

        	this.$ = new Argument($$[$0-2],$$[$0]);
        
break;
case 28:

        	this.$ = new Argument($$[$0]);
        
break;
case 29:

        	var id = new Literal($$[$0]);
        	this.$ = new ObjectSelector(id,$$[$0-2]);
        
break;
case 30:

        	this.$ = new ObjectSelector($$[$0-1],$$[$0-3]);
        
break;
case 31:

        	this.$ = new Variable($$[$0]);
        
break;
}
},
table: [{3:1,4:2,6:3,31:$V0},{1:[3]},{5:[1,5]},{5:[2,2],7:[1,6],30:$V1,32:$V2},o($V3,[2,31]),{1:[2,1]},{6:14,7:$V4,8:[1,9],9:10,10:11,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{31:[1,19]},{6:14,7:$V4,10:20,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{5:[2,3]},{8:[1,21]},{8:[2,28],11:$Va,12:$Vb,14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm,29:[1,22]},{6:14,7:$V4,10:36,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:37,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},o($Vn,[2,17],{7:[1,38],30:$V1,32:$V2}),o($Vn,[2,18]),o($Vn,[2,19]),o($Vn,[2,20]),o($Vn,[2,21]),o($V3,[2,29]),{11:$Va,12:$Vb,14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm,33:[1,39]},{5:[2,4]},{6:14,7:$V4,9:40,10:11,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:41,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:42,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:43,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:44,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:45,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:46,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:47,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:48,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:49,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:50,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:51,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:52,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},{6:14,7:$V4,10:53,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},o($Vn,[2,7]),{8:[1,54],11:$Va,12:$Vb,14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm},{6:14,7:$V4,8:[1,55],9:56,10:11,13:$V5,20:$V6,21:$V7,22:$V8,23:$V9,31:$V0},o($V3,[2,30]),{8:[2,27]},o($Vo,[2,5],{14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vo,[2,6],{14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vp,[2,9],{24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vp,[2,10],{24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vp,[2,11],{24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vp,[2,12],{24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vp,[2,13],{24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vp,[2,14],{24:$Vi,25:$Vj,26:$Vk,27:$Vl,28:$Vm}),o($Vq,[2,22],{26:$Vk,27:$Vl,28:$Vm}),o($Vq,[2,23],{26:$Vk,27:$Vl,28:$Vm}),o($Vn,[2,24]),o($Vn,[2,25]),o($Vn,[2,26]),o($Vn,[2,8]),o($Vn,[2,15]),{8:[1,57]},o($Vn,[2,16])],
defaultActions: {5:[2,1],9:[2,3],21:[2,4],40:[2,27]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
    function _parseError (msg, hash) {
        this.message = msg;
        this.hash = hash;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    //return true;
}};


// Functions in the global space receives the context document
// as 'this'.
var global = {
	Math: Math
};
parser.global = global;

// -----------------------------------------------------------
var ProgramRoot = function(fnId, args){
	this.fnId = fnId;
	this.args = args;
};
ProgramRoot.prototype.getValue = function(ctxt){
	var result = {
		args: []
	};

	result.fn = this.fnId.getValue(ctxt);

	if( this.args ){
		this.args.pushOnArray(ctxt, result.args);
	};

	return result;
};

// -----------------------------------------------------------
var FunctionCall = function(value, args){
	this.value = value;
	this.args = args;
};
FunctionCall.prototype.getValue = function(ctxt){
	var value = this.value.getValue(ctxt);
	if( typeof value === 'function' ){
		var args = [];
		if( this.args ){
			this.args.pushOnArray(ctxt, args);
		};
		return value.apply(ctxt, args);
	};
	return false;
};

// -----------------------------------------------------------
// Argument
var Argument = function(a1, a2){
	this.valueNode = a1;
	if( a2 ){
		this.nextArgument = a2;
	} else {
		this.nextArgument = null;
	};
};
Argument.prototype.getCount = function(){
	if( this.nextArgument ){
		return 1 + this.nextArgument.getCount();
	};
	
	return 1;
};
Argument.prototype.getArgument = function(ctxt, position){
	if( position < 1 ){
		return this.valueNode.getValue(ctxt);
	};
	
	if( this.nextArgument ){
		this.nextArgument.getArgument(ctxt, position-1);
	};
	
	return undefined;
};
Argument.prototype.pushOnArray = function(ctxt, array){
	var value = this.valueNode.getValue(ctxt);
	array.push(value);
	
	if( this.nextArgument ){
		this.nextArgument.pushOnArray(ctxt, array);
	};
};

// -----------------------------------------------------------
var Expression = function(n1, op, n2){
	this.n1 = n1;
	this.n2 = n2;
	this.op = op;
};
Expression.prototype.getValue = function(ctxt){
	var r1 = this.n1.getValue(ctxt);
	var r2 = undefined;
	if( this.n2 ){
		r2 = this.n2.getValue(ctxt);
	};
	if( '!' === this.op ){
		return !r1;
		
	} else if( '&&' === this.op ){
		return (r1 && r2);
		
	} else if( '||' === this.op ){
		return (r1 || r2);
	};
	return false;
};

// -----------------------------------------------------------
var Literal = function(value){
	this.value = value;
};
Literal.prototype.getValue = function(ctxt){
	return this.value;
};

// -----------------------------------------------------------
var Comparison = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
Comparison.prototype.getValue = function(ctxt){
	var left = this.leftNode.getValue(ctxt);
	var right = this.rightNode.getValue(ctxt);

	if( '==' === this.op ){
		return (left == right);

	} else if( '!=' === this.op ){
		return (left != right);

	} else if( '>=' === this.op ){
		return (left >= right);

	} else if( '<=' === this.op ){
		return (left <= right);

	} else if( '>' === this.op ){
		return (left > right);

	} else if( '<' === this.op ){
		return (left < right);
	};
	
	return false;
};

// -----------------------------------------------------------
var MathOp = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
MathOp.prototype.getValue = function(ctxt){
	var left = this.leftNode.getValue(ctxt);
	var right = this.rightNode.getValue(ctxt);

	if( '+' === this.op ){
		return (left + right);

	} else if( '-' === this.op ){
		return (left - right);

	} else if( '*' === this.op ){
		return (left * right);

	} else if( '/' === this.op ){
		return (left / right);

	} else if( '%' === this.op ){
		return (left % right);
	};
	
	return 0;
};

// -----------------------------------------------------------
var ObjectSelector = function(id, previousSelector){
	this.idNode = id;
	this.previousSelector = previousSelector;
};
ObjectSelector.prototype.getValue = function(ctxt){
	var obj = this.previousSelector.getValue(ctxt);
	if( typeof obj === 'object' ){
		var id = this.idNode.getValue(ctxt);
		if( typeof id === 'undefined' ){
			return undefined;
		};
		
		return obj[id];
	};

	return undefined;
};

// -----------------------------------------------------------
var Variable = function(variableName){
	this.variableName = variableName;
};
Variable.prototype.getValue = function(ctxt){
	var obj = undefined;
	
	if( ctxt && 'doc' === this.variableName ) {
		obj = ctxt.doc;
		
	} else if( ctxt
	        && ctxt.funcMap 
	        && ctxt.funcMap[this.variableName] ) {
		obj = ctxt.funcMap[this.variableName];
		
	} else if( global && global[this.variableName] ) {
		obj = global[this.variableName];
	};
	
	return obj;
};


/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: /* skip whitespace */ 
break;
case 1: return 20; 
break;
case 2: return 21; 
break;
case 3: return 22; 
break;
case 4: return 31; 
break;
case 5: yy_.yytext = yy_.yytext.substr(1,yy_.yytext.length-2); return 23; 
break;
case 6: return 14; 
break;
case 7: return 15; 
break;
case 8: return 16; 
break;
case 9: return 17; 
break;
case 10: return 18; 
break;
case 11: return 19; 
break;
case 12: return 7; 
break;
case 13: return 8; 
break;
case 14: return '{'; 
break;
case 15: return '}'; 
break;
case 16: return 32; 
break;
case 17: return 33; 
break;
case 18: return 29; 
break;
case 19: return 30; 
break;
case 20: return 13; 
break;
case 21: return 24; 
break;
case 22: return 25; 
break;
case 23: return 26; 
break;
case 24: return 27; 
break;
case 25: return 28; 
break;
case 26: return 11; 
break;
case 27: return 12; 
break;
case 28: return 5; 
break;
case 29: return 'INVALID'; 
break;
}
},
rules: [/^(?:\s+)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:[_a-zA-Z][_a-zA-Z0-9]*)/,/^(?:'(\\'|[^'])*')/,/^(?:==)/,/^(?:!=)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:\()/,/^(?:\))/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?:\.)/,/^(?:!)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = docFnCall;
exports.Parser = docFnCall.Parser;
exports.parse = function () { return docFnCall.parse.apply(docFnCall, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}	
//--------------------------------------------------------------------------
function parse(){
	return docFnCall.parse.apply(docFnCall, arguments);
};

//--------------------------------------------------------------------------
function getGlobalContext(){
	return docFnCall.global;
};
	
//--------------------------------------------------------------------------
$n2.docFnCall = {
	parse: parse
	,getGlobalContext: getGlobalContext
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.schema.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };


var defaultErrorFn = function(err){ $n2.reportError(err); };
var defaultSuccessFn = function(){};

var typeClassStringPrefix = 'n2schema_type_';

var HTML = ':html';
var INPUT = ':input';
var FIELD = ':field';
var SELECTOR = ':selector';
var ITERATE = ':iterate';
var EMPTY = ':empty';
var CONTEXT = ':context';
var PARENT = ':parent';
var SELECT = '::cur-selector';
var LOCALIZE = ':localize';
var ARRAY = ':array';

//============================================================
// Object

function parseSelectorString(selStr){
	if( '.' === selStr ){
		return new $n2.objectSelector.ObjectSelector([]);
	};
	
	var selectors = selStr.split('.');
	return new $n2.objectSelector.ObjectSelector(selectors);
};

//============================================================
var customFieldHandlers = {};

function registerCustomFieldHandler(opts_){
	var opts = $n2.extend({
		customType: null
		,handler: null
	},opts_);
	
	if( typeof opts.customType === 'string'
	 && typeof opts.handler === 'function' ){
		customFieldHandlers[opts.customType] = opts.handler;
	};
};

//============================================================

function _localizeString() {
	var args = [];
	args.push.apply(args,arguments);
	var options = args.pop();

	// Gets the text between start and end tags
	var text = options.fn(this);

	// Syntax is: <selector>(,<option>)*
	var splits = text.split(',');
	var key = splits[0];

	// <option> is one of:
	// - optionName
	// - optionName=optionValue
	// - optionsName=value1+value2+...
	var opts = {};
	for(var i=1,e=splits.length;i<e;++i){
		var optStr = splits[i];
		var optSplit = optStr.split('=');
		if( optSplit.length > 1 ){
			var valSplits = optSplit[1].split('+');
			if( valSplits.length > 1 ) {
				opts[optSplit[0]]=valSplits;
			} else {
				opts[optSplit[0]]=[optSplit[1]];
			};
		} else {
			opts[optSplit[0]]=[];
		};
	};
	
	// Get data from key
	var objSel = parseSelectorString(key);
	var s = objSel.getValue(this);

	if( s
	 && typeof(s) === 'object' 
	 && s.nunaliit_type === 'localized') {
		var lang = 'en';
		if( $n2.l10n && $n2.l10n.getLocale ){
			lang = $n2.l10n.getLocale().lang;
		};
		
		if( s[lang] ) {
			if( opts.html ) {
				return s[lang];
			};
			
			var escaped = $n2.utils.escapeHtml(s[lang]);
			return escaped;
			
		} else {
			// Find a language to fall back on
			var fbLang = 'en';
			if( !s[fbLang] ) {
				fbLang = null;
				for(var l in s){
					if( l.length > 0 && l[0] === ':' ){
						// ignore
					} else if( l === 'nunaliit_type' ) {
						// ignore
					} else if( s[l] ) { // ignore empty string
						fbLang = l;
						break;
					};
				};
			};
			
			if( fbLang ){
				var result = [];
				result.push('<span class="n2_localized_string n2_localize_fallback">');
				result.push('<span class="n2_localize_fallback_lang">(');
				result.push(fbLang);
				result.push(')</span>');
				if( s[fbLang] ){
					if( opts.html ) {
						result.push(''+s[fbLang]);
					} else {
						var escaped = $n2.utils.escapeHtml(s[fbLang]);
						result.push(escaped);
					};
				};
				result.push('</span>');
				return result.join('');
				
			} else {
				return '';
			};
		};
		
	} else if( typeof(s) === 'undefined' ) {
		return '';

	} else if( s === null ) {
		return '';
		
	} else {
		// Must be string, number, boolean, float, ...
		// From Handlebars, we do not get a real "string". Instead,
		// "this" is an object that reacts like string. ''+s becomes
		// a real javascript string.
		if( opts.html ) {
			return ''+s;
		};
		
		var escaped = $n2.utils.escapeHtml(''+s);
		return escaped;
		
	};
};

function _formSingleField(r,completeSelectors,options){
	
	// option: textarea
	if( options.textarea ){
		r.push('<textarea');
	} else if( options.checkbox ){
		r.push('<input type="checkbox"');
	} else {
		r.push('<input type="text"');
	};
	
	// placeholder
	if( options.placeholder 
	 && typeof options.placeholder[0] === 'string' ){
		var placeHolderValue = options.placeholder[0];
		placeHolderValue = placeHolderValue.replace(/&/g, '&amp;');
		placeHolderValue = placeHolderValue.replace(/"/g, '&quot;');
		r.push(' placeholder="');
		r.push( _loc(placeHolderValue) );
		r.push('"');
	};
	
	r.push(' class="n2schema_input');
	
	var selClass = createClassStringFromSelector(completeSelectors);
	r.push(' '+selClass);
	
	if( options.date ){
		r.push(' ' + typeClassStringPrefix + 'date');
		
	} else if( options.numeric ){
		r.push(' ' + typeClassStringPrefix + 'numeric');
		
	} else if( options.layers ){
		r.push(' ' + typeClassStringPrefix + 'layers');
		
	} else if( options.localized ){
		r.push(' ' + typeClassStringPrefix + 'localized');
	
	};

	if( options.textarea ){
		r.push('"></textarea>');
	} else if( options.checkbox ){
		r.push('"/>');
	} else {
		r.push('"/>');
	};

	if( options.date ){
		r.push('<div class="n2schema_help_date"></div>');
	};
	
	if( options.wikiTransform ){
		r.push('<div class="n2schema_help_wiki"></div>');
	};
};

function _formField() {
	// The arguments to handlebars block expression functions are:
	// ([obj,]options)
	// obj is not provided in this case, since we do not expect any arguments
	// to {{:field}}
	// options.fn is a function to render inner content
	// options.data is provided by helper that is rendering current portion
	// options.data.n2_selector is provided by the _array() helper
	// this points to the current object
	//
	// Syntax to :form is:
	// {{#:field}}<selector>(,<option>)*{{/:field}}
	var args = [];
	args.push.apply(args,arguments);
	var options = args.pop();
	
	// Compute current selector
	var currentSelector = null;
	if( options 
	 && options.data 
	 && options.data.n2_selector ){
		// Within an array, the current selector is passed in options
		currentSelector = options.data.n2_selector;

	} else if( typeof this === 'object' 
     && this !== null 
     && this[SELECT]){
		currentSelector = this[SELECT];
	};

	// Gets the text between start and end tags and
	// parse it
	var text = options.fn(this);
	
	var splits = text.split(',');
	var identifier = splits[0];
	var objSel = parseSelectorString(identifier);
	var obj = objSel.getValue(this);
	var completeSelectors = currentSelector.getChildSelector(objSel);
	
	if( obj
	 && typeof obj === 'object'
	 && !obj[SELECT] ){
		obj[SELECT] = completeSelectors;
	};
	
	// <option> is one of:
	// - optionName
	// - optionName=optionValue
	// - optionsName=value1+value2+...
	var opts = {};
	for(var i=1,e=splits.length;i<e;++i){
		var optStr = splits[i];
		var optSplit = optStr.split('=');
		if( optSplit.length > 1 ){
			var valSplits = optSplit[1].split('+');
			for(var j=0,k=valSplits.length; j<k; ++j){
				valSplits[j] = decodeURIComponent( valSplits[j] );
			};
			opts[optSplit[0]]=valSplits;
		} else {
			opts[optSplit[0]]=[];
		};
	};
	
	var r = [];
	
	r.push('<div class="n2schema_field_wrapper">');

	if( opts.custom ){
		r.push('<div class="n2schema_field_container n2schema_field_custom"');
		if( opts.custom.length > 0 && typeof opts.custom[0] === 'string'){
			r.push(' n2-custom-type="'+opts.custom+'"');
		} else {
			r.push(' nunaliit-error="Custom type not specified"');
		};
		r.push(' nunaliit-selector="'+completeSelectors.encodeForDomAttribute()+'"');
		r.push('>');
		r.push('</div>');
		
		
	} else if( obj && obj.nunaliit_type === 'localized' ) {
		var langs = getSortedLanguages(opts.localized, obj);
		
		// Turn on "localized" option, if not already on
		if( !opts.localized ){
			opts.localized = [];
		};
		
		for(var i=0,e=langs.length;i<e;++i){
			var lang = langs[i];
			
			var langSel = completeSelectors.getChildSelector(lang);

			r.push('<div class="n2schema_field_container n2schema_field_container_localized');
			if( opts.textarea ){
				r.push(' n2schema_field_container_textarea');
			};
			r.push('">');
			r.push('<span class="n2_localize_lang">('+lang+')</span>');
			_formSingleField(r,langSel,opts);
			r.push('</div>');
		};
		
	} else if( !obj && opts.localized ) {
		// This is a localized string that does not yet exist
		// This condition is true if obj is an empty string or
		// if obj is undefined (or null)

		var langs = getSortedLanguages(opts.localized, null);
		
		for(var i=0,e=langs.length;i<e;++i){
			var lang = langs[i];
			
			var langSel = completeSelectors.getChildSelector(lang);
			
			r.push('<div class="n2schema_field_container n2schema_field_container_localized');
			if( opts.textarea ){
				r.push(' n2schema_field_container_textarea');
			};
			r.push('">');
			r.push('<span class="n2_localize_lang">('+lang+')</span>');
			_formSingleField(r,langSel,opts);
			r.push('</div>');
		};

	} else if( opts.reference ) {
		var attr = completeSelectors.encodeForDomAttribute();
		r.push('<span class="n2schema_field_reference" nunaliit-selector="'+attr+'"');
		if( opts.search 
		 && opts.search[0] ){
			r.push(' n2-search-func="'+opts.search[0]+'"');
		};
		r.push('></span>');

	} else if( opts.geometry ) {
		var attr = completeSelectors.encodeForDomAttribute();
		r.push('<textarea class="n2schema_field_geometry" nunaliit-selector="'+attr+'"');
		r.push('></textarea>');
		
	} else {
		r.push('<div class="n2schema_field_container');
		if( opts.textarea ){
			r.push(' n2schema_field_container_textarea');
		};
		r.push('">');
		_formSingleField(r,completeSelectors,opts);
		r.push('</div>');
	};

	r.push('</div>');
	
	return r.join('');
	
	function getSortedLanguages(langOpts, localizedStr){
		var langMap = {};
		
		if( localizedStr ){
			for(var lang in localizedStr){
				if( lang === 'nunaliit_type' || lang[0] === ':' ){
					// ignore
				} else {
					langMap[lang] = true;
				};
			};
		};

		if( langOpts ){
			for(var i=0,e=langOpts.length;i<e;++i){
				var lang = langOpts[i];
				langMap[lang] = true;
			};
		};
		
		var languages = $n2.languageSupport.getLanguages();
		if( languages ){
			for(var i=0,e=languages.length; i<e; ++i){
				var lang = languages[i].code;
				langMap[lang] = true;
			};
		};
		
		var langs = [];
		for(var lang in langMap){
			langs.push(lang);
		};
		
		var locale = $n2.l10n.getLocale();
		var localeLang = locale.lang;
		langs.sort(function(l1,l2){
			if( l1 === localeLang ) return -1;
			if( l2 === localeLang ) return 1;
			if( l1 < l2 ) return -1;
			if( l1 > l2 ) return 1;
			return 0;
		});
		
		return langs;
	};
};

function _inputField() {
	var args = [];
	args.push.apply(args,arguments);
	var options = args.pop();
	
	var text = options.fn(this);

	// Syntax is: <selector>(,<type>)?
	var splits = text.split(',');
	var key = splits[0];
	
	var completeSelectors = null;
	if( options
	 && options.data
	 && options.data.n2_selector ){
		completeSelectors = options.data.n2_selector;
	} else if( this[SELECT] ) {
		completeSelectors = this[SELECT];
	} else {
		return '';
	};
	if( '.' === key ) {
		// Current selector is fine
	} else {
		var sels = key.split('.');
		completeSelectors = completeSelectors.getChildSelector(sels);
	};	
	
	var cl = 'n2schema_input ' + createClassStringFromSelector(completeSelectors);

	var type = '';
	if( splits[1] ) {
		type = ' n2schema_type_'+splits[1];
	};
	
	return cl + type;
};

function _arrayField() {
	var args = [];
	args.push.apply(args,arguments);
	var options = args.pop();
	
	var obj = args[0];
	
	var newType = null;
	if( args.length > 1 ){
		newType = args[1];
	};
	
	var r = [];
	
	r.push('<div class="n2schema_array">');

	if( obj && obj.length ) {
		for(var i=0,e=obj.length; i<e; ++i){
			var item = obj[i];
	
			var completeSelectors = obj[SELECT];
			completeSelectors = completeSelectors.getChildSelector(i);
			var cl = createClassStringFromSelector(completeSelectors);
			
			r.push('<div class="n2schema_array_item">');

			r.push('<div class="n2schema_array_item_buttons">');
	
			r.push('<div class="n2schema_array_item_delete '+cl+'"></div>');
			
			r.push('<div class="n2schema_array_item_up '+cl+'"></div>');
			
			r.push('<div class="n2schema_array_item_down '+cl+'"></div>');

			r.push('</div>'); // close buttons
	
			r.push('<div class="n2schema_array_item_wrapper">');
	
			r.push( options.fn(item,{data:{n2_selector:completeSelectors}}) );
			
			r.push('</div></div>');
		};
	};

	// Add a new item
	var arraySelector = undefined;
	if( obj ){
		arraySelector = obj[SELECT];
	} else if( options && options.ids && options.ids.length ){
		var selectors = [];
		pathFromData(options.data, selectors);
		selectors.push(options.ids[0]);
		arraySelector = new $n2.objectSelector.ObjectSelector(selectors);
	};
	if( arraySelector ){
		var arrayClass = createClassStringFromSelector(arraySelector);
		r.push('<div class="n2schema_array_add '+arrayClass+'"');
		if( newType ) {
			r.push('n2_array_new_type="'+newType+'"');
		};
		r.push('></div>');
	};
	
	r.push('</div>');
	
	return r.join('');
	
	function pathFromData(data, path){
		if( data._parent ){
			pathFromData(data._parent, path);
		};
		if( data.contextPath ){
			path.push(data.contextPath);
		};
	};
};

function _selectorField(){
	// The arguments to handlebars block expression functions are:
	// ([obj,]options)
	// obj is not provided in this case, since we do not expect any arguments
	// to {{#:selector}}
	// options.fn is a function to render inner content
	// options.data is provided by helper that is rendering current portion
	// options.data.n2_selector is provided by the _array() helper
	// this points to the current object
	//
	// Syntax to :form is:
	// {{#:selector}}<selector>{{/:selector}}
	var args = [];
	args.push.apply(args,arguments);
	var options = args.pop();
	
	// Compute current selector
	var currentSelector = null;
	if( options 
	 && options.data 
	 && options.data.n2_selector ){
		// Within an array, the current selector is passed in options
		currentSelector = options.data.n2_selector;

	} else if( typeof this === 'object' 
     && this !== null 
     && this[SELECT]){
		currentSelector = this[SELECT];
	};
	
	if( !currentSelector ){
		return '';
	};

	// Gets the text between start and end tags and
	// parse it
	var text = options.fn(this);
	
	var objSel = parseSelectorString(text);
	var completeSelectors = currentSelector.getChildSelector(objSel);
	return completeSelectors.encodeForDomAttribute();
};


if( typeof(Handlebars) !== 'undefined' 
 && Handlebars.registerHelper ) {
	Handlebars.registerHelper(LOCALIZE ,_localizeString );
	Handlebars.registerHelper(FIELD    ,_formField      );
	Handlebars.registerHelper(INPUT    ,_inputField     );
	Handlebars.registerHelper(ARRAY    ,_arrayField     );
	Handlebars.registerHelper(SELECTOR ,_selectorField  );
} else {
	$n2.log('Unable to register helper functions with Handlebars. Schemas will not work properly.');
};

function computeViewObj(origObj, context, selector, parent) {
	
	if( !selector ){
		selector = new $n2.objectSelector.ObjectSelector([]);
	};
	
	if( null === origObj ) {
		return origObj;
		
	} else if( typeof(origObj) === 'undefined' ) {
		return null;
		
	} else if( $n2.isArray(origObj) ) {
		var view = [];
		view[CONTEXT] = context;
		view[PARENT] = parent;
		view[SELECT] = selector;
		
		for(var i=0,e=origObj.length; i<e; ++i) {
			var childSelector = selector.getChildSelector(i);
			var value = computeViewObj(origObj[i], context, childSelector, view);
			view.push(value);
		};

		return view;
		
	} else if( typeof(origObj) === 'object' ) {
		var view = {};
		
		view[ITERATE] = [];
		view[CONTEXT] = context;
		view[PARENT] = parent;
		view[SELECT] = selector;

		for(var key in origObj) {
			if('__n2Source' === key) continue;

			var childSelector = selector.getChildSelector(key);
			var value = computeViewObj(origObj[key], context, childSelector, view);
			view[key] = value;
			view[ITERATE].push({key:key,value:value});
		};
		view[EMPTY] = (0 == view[ITERATE].length);
		
		view[ITERATE].sort(function(a,b){
			if( a.key < b.key ) {
				return -1;
			}; 
			if( a.key > b.key ) {
				return 1;
			}; 
			return 0;
		});
		
		return view;
		
	} else {
		return origObj;
	};
};


//============================================================
// Object Query

var ObjectQueryResults = $n2.Class({
	
	objects: null
	
	,length: 0
	
	,initialize: function(obj) {
		
		if( null === obj ) {
			this.objects = [];
		} else if( typeof(obj) === 'undefined' ) {
			this.objects = [];
		} else if( $n2.isArray(obj) ) {
			this.objects = obj;
		} else if( typeof(obj) === 'object' ) {
			this.objects = [obj];
		} else {
			this.objects = [];
		};
		this.length = this.objects.length;
	}

	,query: function(selectors) {
		if( null === selectors ) {
			var interim = this._selectInterim(null, this.objects);
			return new ObjectQueryResults(interim);
			
		} else if( typeof(selectors) === 'string' ) {
			var interim = this._selectInterim(selectors, this.objects);
			return new ObjectQueryResults(interim);
			
		} else if( typeof(selectors) === 'undefined' ) {
			return ObjectQueryResultsEmpty;

		} else if( $n2.isArray(selectors) ) {
			var interim = this.objects;
			for(var i=0,e=selectors.length; i<e; ++i){
				var sel = selectors[i];
				interim = this._selectInterim(sel, interim);
			};
			return new ObjectQueryResults(interim);
		
		} else {
			return ObjectQueryResultsEmpty;
		}
	}
	
	,each: function(f) {
		for(var i=0,e=this.objects.length; i<e; ++i) {
			var obj = this.objects[i];
			f(obj, i);
		};
	}
	
	,_selectInterim: function(sel, arr) {
		var result = [];
		for(var i=0,e=arr.length; i<e; ++i) {
			this._selectFromObject(arr[i], sel, result);
		};
		return result;
	}
	
	,_selectFromObject: function(obj, sel, result) {
		if( null === sel ) {
			// matches any
			for(var key in obj) {
				var value = obj[key];
				result.push(value);
			};
		} else if( 'string' === typeof(sel) ) {
			if( typeof(obj[sel]) !== 'undefined' ) {
				result.push(obj[sel]);
			};
		} else if( 'function' === typeof(sel) ) {
			for(var key in obj) {
				if( sel(obj, key) ) {
					result.push(obj[key]);
				};
			};
		};
	}
});

var ObjectQueryResultsEmpty = new ObjectQueryResults();

$n2.ObjectQuery = function(obj, query){
	
	var result = new ObjectQueryResults(obj);
	return result.query(query);
};


//============================================================
// Schema Repository Functions

var SchemaRepositoryFunctions = $n2.Class({
	
	onCreateFns: null
	
	,initialize: function(){
		this.onCreateFns = [];
	}

	,addOnDocumentCreateFunction: function(fn){
		if( typeof(fn) === 'function' ){
			this.onCreateFns.push(fn);
		};
	}
	
	,onDocumentCreate: function(doc, schema){
		for(var i=0,e=this.onCreateFns.length;i<e;++i){
			var f = this.onCreateFns[i];
			f(doc, schema);
		};
	}
});

//============================================================
// Schema Repository

var SchemaRepository = $n2.Class({
	
	schemasByName: null
	
	,loadSchemasFn: null
	
	,rootSchemasQueried: false
	
	,repositoryFunctions: null
	
	,initialize: function() {
		this.schemasByName = {};
		this.repositoryFunctions = new SchemaRepositoryFunctions();
	}

	,addSchemas: function(opt_) {
		
		var opt = $n2.extend({
			schemas: null
			,onSuccess: defaultSuccessFn
			,onError: defaultErrorFn
		},opt_);
		
		var schemas = opt.schemas;
		if( ! $n2.isArray(schemas) ) {
			schemas = [ schemas ];
		};
		
		for(var i=0,e=schemas.length; i<e; ++i) {
			var schema = schemas[i];
			
			if( schema.isSchema ) {
				var schemaObj = schema;
				schemaObj.repositoryFunctions = this.repositoryFunctions;
			} else {
				var schemaObj = new Schema(this, schema);
			};
			
			var name = schemaObj.name;
			this.schemasByName[name] = schemaObj;
		};
		
		this._resolveSchemaDependencies(opt);
	}

	,getSchema: function(opt_) {
		
		var _this = this;
		
		var opt = $n2.extend({
			name: null
			,onSuccess: defaultSuccessFn
			,onError: defaultErrorFn
		},opt_);
		
		if( this.schemasByName[opt.name] ) {
			if( this.schemasByName[opt.name]._error ) {
				opt.onError( 'Schema "'+opt.name+'" not found' );
			} else {
				opt.onSuccess( this.schemasByName[opt.name] );
			};
			return;
		};
		
		if( this.loadSchemasFn ) {
			this._loadSchemaDefinitions({
				names: [ opt.name ]
				,onSuccess: function(){
					if( _this.schemasByName[opt.name]._error ){
						opt.onError( 'Schema "'+opt.name+'" not found' );
					} else {
						opt.onSuccess( _this.schemasByName[opt.name] );
					};
				}
				,onError: opt.onError
			});
			return;
		};
		
		opt.onError('Can not find schema named: '+opt.name);
	}

	,getSchemas: function(opt_) {
		
		var _this = this;
		
		var opt = $n2.extend({
			names: null
			,onSuccess: defaultSuccessFn
			,onError: defaultErrorFn
		},opt_);
		
		var resultSchemas = [];
		var namesToQuery = null;
		
		// Collect schemas already cached
		for(var i=0,e=opt.names.length; i<e; ++i){
			var n = opt.names[i]; // name
			var s = this.schemasByName[n]; // schema
			if( s && s._error ) {
				// skip
			} else if( s ) {
				resultSchemas[resultSchemas.length] = s;
			} else {
				if( null === namesToQuery ) namesToQuery = [];
				namesToQuery[namesToQuery.length] = n;
			};
		};
		
		// If all in cache, just return
		if( null === namesToQuery ) {
			opt.onSuccess( resultSchemas );
			return;
		};
		
		if( this.loadSchemasFn ) {
			this._loadSchemaDefinitions({
				names: namesToQuery
				,onSuccess: function(){
					for(var i=0,e=namesToQuery.length; i<e; ++i){
						var s = _this.schemasByName[namesToQuery[i]]; // schema
						if( s && !s._error ) {
							resultSchemas[resultSchemas.length] = s;
						};
					};
					opt.onSuccess( resultSchemas );
				}
				,onError: opt.onError
			});
			return;
		};
		
		opt.onError('Can not find requested schemas: '+namesToQuery);
	}

	,getRootSchemas: function(opt_) {
		
		var opt = $n2.extend({
			onSuccess: defaultSuccessFn
			,onError: defaultErrorFn
		},opt_);
		
		var _this = this;
		
		if( !this.rootSchemasQueried 
		 && this.loadSchemasFn ) {
			var _this = this;
			this._loadSchemaDefinitions({
				rootSchemas: true
				,onSuccess: function(){
					_this.rootSchemasQueried = true;
					_this.getRootSchemas(opt_);
				}
				,onError: opt.onError
			});
			return;
		};
		
		var schemas = [];
		for(var name in this.schemasByName) {
			var schema = this.schemasByName[name];
			if( schema._error ) {
				// skip
			} else if( schema.isRootSchema ) {
				schemas.push(schema);
			};
		};
		
		opt.onSuccess( schemas );
	}
	
	// Forgets all schemas loaded, so far
	,reset: function(){
		this.schemasByName = {};
		this.rootSchemasQueried = false;
	}
	
	,getRepositoryFunctions: function(){
		return this.repositoryFunctions;
	}

	,_loadSchemaDefinitions: function(opt) {

		var _this = this;
		
		var loadingOpt = {
			names: opt.names
			,onSuccess: loaded
			,onError: opt.onError
		};
		
		this.loadSchemasFn(loadingOpt);

		function loaded(schemaDefinitions) {
			if( opt.names ) {
				// Verify that all names are returned
				for(var i=0,e=opt.names.length; i<e; ++i) {
					var name = opt.names[i];
					var def = findSchemaDefinition(name, schemaDefinitions);
					if( !def ) {
						// Insert dummy one, if not found
						schemaDefinitions.push({
							name: name
							,isRootSchema: false
							,display: ''
							,form: ''
							,brief: ''
							,create: {}
							,extensions: []
							,nunaliit_type: 'schema'
							,_error: true
						});
						$n2.log('schema definition not found: '+name);
					};
				};
			};
			
			_this.addSchemas({
				schemas: schemaDefinitions
				,onSuccess: opt.onSuccess
				,onError: opt.onError
			});
		};
		
		function findSchemaDefinition(name, definitions) {
			for(var i=0,e=definitions.length; i<e; ++i){
				var def = definitions[i];
				if( def.name === name ) {
					return def;
				};
			};
			return null;
		};
	}
	
	,_resolveSchemaDependencies: function(opt_) {
		var _this = this;
		
		var missingSchemas = {};
		var currentSchemas = this.schemasByName;
		
		for(var name in this.schemasByName) {
			var schema = this.schemasByName[name];
			schema._resolveSchemaDependencies(currentSchemas, missingSchemas);
		};
		
		var missingSchemasArr = [];
		for(var missingSchemaName in missingSchemas) {
			missingSchemasArr.push(missingSchemaName);
		};

		if( missingSchemasArr.length < 1 ) {
			// all dependencies met
			opt_.onSuccess();
			return;
		};
		
		if( missingSchemasArr.length > 0
		 && !this.loadSchemasFn 
		 ) {
			// missing dependencies, but no way to fetch more
			opt_.onError('Can not find missing dependencies');
			return;
		};
		
		this._loadSchemaDefinitions({
			names: missingSchemasArr
			,onSuccess: opt_.onSuccess
			,onError: opt_.onError
		});
	}
	
	,_getSchemaMap: function() {
		return this.schemasByName;
	}
});

//============================================================
// Schema Extension

var SchemaExtension = $n2.Class({
	
	selector: null
	
	,create: null
	
	,schemaName: null
	
	,dependentSchema: null
	
	,initialize: function(jsonDefinition) {
		
		this.selector = jsonDefinition.selector;
		this.schemaName = jsonDefinition.schemaName;
		
		this.create = false;
		if( typeof(jsonDefinition.create) === 'boolean' ) {
			this.create = jsonDefinition.create;
		};
	}

	,createObject: function(obj, defValues) {

		// Compute default values for this extension
		var targetDefValues = defValues;
		for(var i=0,e=this.selector.length-1; i<e; ++i) {
			var keyName = this.selector[i];
			if( targetDefValues ) {
				targetDefValues = targetDefValues[keyName];
			};
		};
		var keyName = this.selector[i];
		if( targetDefValues ) {
			targetDefValues = targetDefValues[keyName];
		};

		// Verify if it is necessary to create this
		// extension
		if( !this.create 
		 && !targetDefValues ) {
//$n2.log('Skip',this,targetDefValues);
			return;
		};

		// Create objects to follow selectors, if needed
		var targetObj = obj;
		for(var i=0,e=this.selector.length-1; i<e; ++i) {
			var keyName = this.selector[i];
			
			if( targetObj[keyName] ) {
				targetObj = targetObj[keyName];
			} else {
				targetObj[keyName] = {};
				targetObj = targetObj[keyName];
			};
		};
		var keyName = this.selector[i];

		// Add value
		targetObj[keyName] = this.dependentSchema.createObject(targetDefValues);
	}

	,_resolveSchemaDependencies: function(currentSchemas, missingSchemas) {
		if( ! this.dependentSchema 
		 && this.schemaName
		 ) {
			if( currentSchemas[this.schemaName] ) {
				this.dependentSchema = currentSchemas[this.schemaName];
			} else {
				missingSchemas[this.schemaName] = 1;
			};
		}
	}
});

//============================================================
// Schema

var Schema = $n2.Class({
	
	isSchema: null
	
	,isRootSchema: false
	
	,name: null
	
	,repositoryFunctions: null
	
	,displayTemplate: null
	
	,briefTemplate: null
	
	,popupTemplate: null
	
	,formTemplate: null
	
	,relatedSchemaNames: null
	
	,extensions: null
	
	,extensionsByName: null
	
	,cachedDisplay: null
	
	,cachedBrief: null
	
	,cachedPopup: null
	
	,csvExport: null

	,exportInfo: null
	
	,label: null

	,definition: null

	,options: null
	
	,jsonDefinition: null
	
	,_error: null
	
	,initialize: function(repository, jsonDefinition) {
		
		this.repositoryFunctions = repository.getRepositoryFunctions();
			
		this.name = jsonDefinition.name;
		this.displayTemplate = jsonDefinition.display;
		this.briefTemplate = jsonDefinition.brief;
		this.popupTemplate = jsonDefinition.popup;
		this.formTemplate = jsonDefinition.form;
		this.create = jsonDefinition.create;
		this.csvExport = jsonDefinition.csvExport;
		this.exportInfo = jsonDefinition['export'];
		this.label = jsonDefinition.label;
		this.definition = jsonDefinition.definition;
		this.options = jsonDefinition.options;
		this.jsonDefinition = jsonDefinition;
		
		if( jsonDefinition.isRootSchema ) {
			this.isRootSchema = true;
		};

		if( jsonDefinition._error ) {
			this._error = true;
		};

		this.relatedSchemaNames = jsonDefinition.relatedSchemas;
		if( !this.relatedSchemaNames ) {
			this.relatedSchemaNames = [];
		};
		
		this.extensions = [];
		this.extensionsByName = {};
		if( jsonDefinition.extensions ) {
			if( $n2.isArray(jsonDefinition.extensions) ) {
				for(var i=0,e=jsonDefinition.extensions.length; i<e; ++i) {
					var attr = new SchemaExtension(jsonDefinition.extensions[i]);
					this.extensions.push( attr );
					this.extensionsByName[attr.schemaName] = attr;
				};
			} else {
				for(var key in jsonDefinition.extensions) {
					var attr = new SchemaExtension(jsonDefinition.extensions[key]);
					this.extensions.push( attr );
					this.extensionsByName[attr.schemaName] = attr;
				};
			};
		};
		
		this.isSchema = true;
	}

	,getLabel: function(){
		if( this.label ) {
			return _loc(this.label);
		};
		return this.name;
	}

	,createObject: function(defValues) {
		var result = {};
		
		// Start with default object, if provided
		if( this.create ) {
			$n2.extend(true, result, this.create);
		};
		
		// Add all elements not covered by extensions
		if( defValues ) {
			for(var name in defValues) {
				if( !this.extensionsByName[name] ) {
					// This is not covered by an extension, copy
					result[name] = defValues[name];
				};
			};
		};

		// Go over extensions
		for(var i=0,e=this.extensions.length; i<e; ++i) {
			var attr = this.extensions[i];
			attr.createObject(result,defValues);
		};
		
		this.repositoryFunctions.onDocumentCreate(result,this);
		
		return result;
	}
	
	,display: function(obj, $elem, ctxt_) {
		if( !this.displayTemplate ) return;
		
		if( !this.cachedDisplay ) {
			this.cachedDisplay = new Display(this,'displayTemplate');
		};
		
		this.cachedDisplay.display(obj, $elem, ctxt_);
	}
	
	,brief: function(obj, $elem, ctxt_) {
		if( !this.briefTemplate ) return;
		
		if( !this.cachedBrief ) {
			this.cachedBrief = new Display(this,'briefTemplate');
		};
		
		this.cachedBrief.display(obj, $elem, ctxt_);
	}
	
	,popup: function(obj, $elem, ctxt_) {
		if( !this.popupTemplate ) return;
		
		if( !this.cachedPopup ) {
			this.cachedPopup = new Display(this,'popupTemplate');
		};
		
		this.cachedPopup.display(obj, $elem, ctxt_);
	}
	
	,form: function(obj, $elem, ctxt_, callback, functionMap) {
		var form = new Form(this);
		form.form(obj, $elem, ctxt_, callback, functionMap);
		return form;
	}

	,_resolveSchemaDependencies: function(currentSchemas, missingSchemas) {
		for(var i=0,e=this.extensions.length; i<e; ++i) {
			var attr = this.extensions[i];
			attr._resolveSchemaDependencies(currentSchemas, missingSchemas);
		}
	}
});

//============================================================
// Display

function DisplaySelectAny(obj, key) {
	if( EMPTY === key 
	 || ITERATE === key
	 || CONTEXT === key 
	 ) {
		return false;
	};
	return true;
};

var DisplayExtension = $n2.Class({
	
	schemaExtension: null
	
	,subDisplay: null
	
	,selector: null
	
	,initialize: function(schemaExtension, templateName) {
		this.schemaExtension = schemaExtension;
		this.templateName = templateName;

		var subSchema = this.schemaExtension.dependentSchema;
		this.subDisplay = new Display(subSchema, templateName);
		
		this.selector = [];
		for(var i=0,e=schemaExtension.selector.length; i<e; ++i) {
			var sel = schemaExtension.selector[i];
			if( null === sel ) {
				this.selector.push(DisplaySelectAny);
			} else {
				this.selector.push(sel);
			};
		};
	}

	,getName: function() {
		return this.schemaExtension.name;
	}

	,_setHtml: function(parentObj) {
		var subDisplay = this.subDisplay;
		$n2.ObjectQuery(parentObj, this.selector).each(function(obj){
			subDisplay._setHtml(obj);
		});
	}
	
});

var Display = $n2.Class({
	
	schema: null
	
	,templateName: null
	
	,extensions: null

	,initialize: function(schema, templateName) {
		this.schema = schema;
		this.templateName = templateName;
		if( !this.templateName ) {
			this.templateName = 'displayTemplate';
		};
		
		this.extensions = [];
		for(var i=0,e=schema.extensions.length; i<e; ++i) {
			var attr = new DisplayExtension(schema.extensions[i], this.templateName);
			this.extensions.push(attr);
		};
	}

	,display: function(obj, $elem, ctxt_) {
		
		var context = {
			root: obj
		};
		
		$n2.extend(context, ctxt_);

		// Create view for displayTemplate
		var view = computeViewObj(obj, context);
		this._setHtml(view);

		if( view[HTML] ) {
			$elem.html(view[HTML]);
		}
	}
	
	,_setHtml: function(obj) {
		if( null == obj ){
			return;
		};
		
		for(var i=0,e=this.extensions.length; i<e; ++i) {
			var attr = this.extensions[i];
			attr._setHtml(obj);
		};

		var compiledTemplate = this.schema[this.templateName + '__compiled'];
		if( !compiledTemplate ) {
			var displayTemplate = this.schema[this.templateName];
			if( displayTemplate ) {
				compiledTemplate = Handlebars.compile(displayTemplate, {trackIds:true});
				this.schema[this.templateName + '__compiled'] = compiledTemplate;
			};
		};
		if( compiledTemplate ) {
			obj[HTML] = compiledTemplate(obj);
		};
	}
});

//============================================================
// Form

var selectorClassStringPrefix = 'n2schema_selector';

function escapeSelector(sel) {
	var res = [];
	for(var i=0,e=sel.length; i<e; ++i) {
		var c = sel[i];
		if( c >= 'a' && c <= 'z' ) { res.push(c); }
		else if( c >= 'A' && c <= 'Z' ) { res.push(c); }
		else if( c >= '0' && c <= '9' ) { res.push(c); }
		else {
			var code = c.charCodeAt(0);
			var o0 = (code & 0x07) + 0x30;
			var o1 = ((code >> 3) & 0x07) + 0x30;
			var o2 = ((code >> 6) & 0x07) + 0x30;
			res.push('_');
			res.push( String.fromCharCode(o2) );
			res.push( String.fromCharCode(o1) );
			res.push( String.fromCharCode(o0) );
		};
	};
	return res.join('');
};

function unescapeSelector(sel) {
	var res = [];
	for(var i=0,e=sel.length; i<e; ++i) {
		var c = sel[i];
		if( c === '_' ) { 
			++i;
			var o2 = sel.charCodeAt(i);
			++i;
			var o1 = sel.charCodeAt(i);
			++i;
			var o0 = sel.charCodeAt(i);
			
			var b = ((o2-0x30)<<6)+((o1-0x30)<<3)+(o0-0x30);
			res.push(String.fromCharCode(b));
			
		} else {
			res.push(c);
		};
	};
	return res.join('');
};

function createClassStringFromSelector(selector) {
	var cs = 
		selectorClassStringPrefix
		+selector.encodeForDomAttribute();
	return cs;
};

// Given a class name, returns an array that represents the encoded selector.
// Returns null if the class name is not encoding a selector
function createSelectorFromClassString(classString) {
	if( selectorClassStringPrefix 
			=== classString.substr(0,selectorClassStringPrefix.length) ) {
		var selectorString = classString.substr(selectorClassStringPrefix.length);
		var selector = $n2.objectSelector.decodeFromDomAttribute(selectorString);
		
		return selector;
	};
	
	return null;
};

function parseClassNames(classNames) {
	var parsed = {};
	
	for(var i=0,e=classNames.length; i<e; ++i) {
		var className = classNames[i];
		
		var selector = createSelectorFromClassString(className);
		if( selector ) {
			parsed.selector = selector;
		};
		
		if( typeClassStringPrefix === className.substr(0,typeClassStringPrefix.length) ) {
			var typeString = className.substr(typeClassStringPrefix.length);
			parsed.type = typeString;
		};
	};
	
	return parsed;
};

var FormExtension = $n2.Class({
	
	schemaExtension: null
	
	,innerForm: null
	
	,selector: null
	,initialize: function(schemaExtension) {
		this.schemaExtension = schemaExtension;

		var subSchema = this.schemaExtension.dependentSchema;
		this.innerForm = new Form(subSchema);
		
		this.selector = [];
		for(var i=0,e=schemaExtension.selector.length; i<e; ++i) {
			var sel = schemaExtension.selector[i];
			if( null === sel ) {
				this.selector.push(DisplaySelectAny);
			} else {
				this.selector.push(sel);
			};
		};
	}

	,getName: function() {
		return this.schemaExtension.name;
	}

	,_setHtml: function(parentObj) {
		var innerForm = this.innerForm;
		$n2.ObjectQuery(parentObj, this.selector).each(function(obj){
			innerForm._setHtml(obj);
		});
	}
});

var Form = $n2.Class({
	
	schema: null
	
	,extensions: null
	
	,obj: null
	
	,elemId: null
	
	,context: null
	
	,callback: null

	,initialize: function(schema) {
		this.schema = schema;
		
		this.extensions = [];
		for(var i=0,e=schema.extensions.length; i<e; ++i) {
			var attr = new FormExtension(schema.extensions[i]);
			this.extensions.push(attr);
		};
	}

	,form: function(obj, $elem, ctxt_, callback, functionMap) {
		
		this.obj = obj;
		
		this.context = $n2.extend({
			root: obj
		}, ctxt_);

		this.callback = callback;
		if( !this.callback ) {
			this.callback = function(obj,selector,value){};
		};
		
		this.functionMap = {};
		if( functionMap ) {
			for(var fName in functionMap) {
				this.functionMap[fName] = functionMap[fName];
			};
		};
		
		var unique = $elem.attr('id');
		if( typeof(unique) === 'undefined' ) {
			unique = $n2.getUniqueId();
			$elem.attr('id',unique);
		};
		this.elemId = $elem.attr('id');
		
		this.refresh($elem);
	}
	
	,refresh: function($elem) {
		if(typeof($elem) === 'undefined'){
			$elem = $('#'+this.elemId);
		};
		if( $elem.length > 0 ) {
			// Create view for displayTemplate
			var view = computeViewObj(this.obj,this.context);
			this._setHtml(view);
			
			// We are about to empty the $elem and redraw it. If this is
			// a large form, emptying it to a size of 0 would mangle all
			// offsets associated with various scroll bars that parent elements
			// might have. Since the form will most likely be the same
			// approximate size after the redraw, take the current size,
			// apply it as minimum to retain the dimensions during the redraw,
			// and remove changes after enough time was given for everything to
			// redraw itself.
			var currentHeight = $elem.height();
			var currentWidth = $elem.width();
			if( currentHeight > 0 ){
				$elem.css('min-height',currentHeight+'px');
			};
			if( currentWidth > 0 ){
				$elem.css('min-width',currentWidth+'px');
			};
			window.setTimeout(function(){
				$elem.removeAttr('style');
			},500);
			
			$elem.empty();
			var $divEvent = $('<div>')
				.addClass('n2schema_editorEvent')
				.appendTo($elem);

			if( view[HTML] ) {
				$divEvent.html(view[HTML]);
				
				// Install callbacks
				var _this = this;
				$divEvent.find('.n2schema_input').each(function(){
					_this._installHandlers($elem, $(this),_this.obj,_this.callback);
				});

				// Install references
				$divEvent.find('.n2schema_field_reference').each(function(){
					_this._installReference($elem, $(this));
				});

				// Install geometries
				$divEvent.find('.n2schema_field_geometry').each(function(){
					_this._installGeometry($elem, $(this));
				});

				// Install custom types
				$divEvent.find('.n2schema_field_custom').each(function(){
					_this._installCustomType($elem, $(this),_this.obj,_this.callback);
				});
				
				$divEvent.click(function(e){
					var $clicked = $(e.target);
					var classString = $clicked.attr('class');
					var classNames = null;
					if( classString ){
						classNames = classString.split(' ');
					} else {
						classNames = [];
					};
					var classInfo = parseClassNames(classNames);

					//$n2.log('click',this,e);
					if( $clicked.hasClass('n2schema_array_add') ){
						var newType = $clicked.attr('n2_array_new_type');
						var ary = classInfo.selector.getValue(_this.obj);
						if( !ary ){
							// Array does not yet exist. Try to create
							var parentSelector = classInfo.selector.getParentSelector();
							var parentObj = undefined;
							if( parentSelector ){
								parentObj = parentSelector.getValue(_this.obj);
							};
							if( parentObj && typeof parentObj === 'object' ){
								classInfo.selector.setValue(_this.obj,[]);
								ary = classInfo.selector.getValue(_this.obj);
							};
						};
						if( ary && $n2.isArray(ary) ){
							var newItem = '';
							if( 'reference' === newType ){
								newItem = null;
								
							} else if( 'date' === newType ){
								newItem = null;
								
							} else if( 'string' === newType ){
								newItem = '';
								
							} else if( 'localized' === newType ){
								newItem = {
									nunaliit_type: 'localized'
								};
								var locale = $n2.l10n.getLocale();
								var lang = locale.lang;
								newItem[lang] = '';
								
							} else if( 'textarea' === newType ){
								newItem = '';
								
							} else if( newType ){
								try {
									eval('newItem = '+newType);
								} catch(e) {
									$n2.log('Error creating a new item: '+e);
								};
							};
							ary.push(newItem);
						};
						_this.refresh($elem);
						_this.callback(_this.obj,classInfo.selector.selectors,ary);
						
					} else if( $clicked.hasClass('n2schema_array_item_delete') ){
						var itemIndex = 1 * classInfo.selector.getKey();
						var parentSelector = classInfo.selector.getParentSelector();
						var ary = parentSelector.getValue(_this.obj);
						ary.splice(itemIndex,1);
						
						var $item = $clicked.parents('.n2schema_array_item').first();
						$item.remove();
						//_this.refresh($elem);

						_this.callback(_this.obj,classInfo.selector.selectors,ary);
						
					} else if( $clicked.hasClass('n2schema_array_item_up') ){
						// Push item earlier in array
						var itemIndex = 1 * classInfo.selector.getKey();
						if( itemIndex > 0 ) {
							var parentSelector = classInfo.selector.getParentSelector();
							var ary = parentSelector.getValue(_this.obj);
							var removedItems = ary.splice(itemIndex,1);
							ary.splice(itemIndex-1,0,removedItems[0]);
							
							var $item = $clicked.parents('.n2schema_array_item').first();
							var $prevItem = $item.prev();
							$item.insertBefore($prevItem);
							//_this.refresh($elem);

							_this.callback(_this.obj,classInfo.selector.selectors,ary);
						};
						
					} else if( $clicked.hasClass('n2schema_array_item_down') ){
						// Push item later in array
						var itemIndex = 1 * classInfo.selector.getKey();
						var parentSelector = classInfo.selector.getParentSelector();
						var ary = parentSelector.getValue(_this.obj);
						if( itemIndex < (ary.length - 1) ) {
							var removedItems = ary.splice(itemIndex,1);
							ary.splice(itemIndex+1,0,removedItems[0]);
							
							var $item = $clicked.parents('.n2schema_array_item').first();
							var $nextItem = $item.next();
							$item.insertAfter($nextItem);
							//_this.refresh($elem);

							_this.callback(_this.obj,classInfo.selector.selectors,ary);
						};
						
					} else if( $clicked.hasClass('n2schema_referenceDelete') ){
						var referenceKey = classInfo.selector.getKey();
						var parentSelector = classInfo.selector.getParentSelector();
						var parentObj = parentSelector.getValue(_this.obj);
						if( parentObj[referenceKey] ){
							delete parentObj[referenceKey];
							_this.refresh($elem);
							_this.callback(_this.obj,classInfo.selector.selectors,null);
						};
						
					} else if( $clicked.hasClass('n2schema_help_date') ){
						$n2.help.ToggleHelp('dates', $clicked);
						
					} else if( $clicked.hasClass('n2schema_help_wiki') ){
						$n2.help.ToggleHelp('wiki', $clicked);
					};
				});
			};
		};
	},

	_setHtml: function(obj) {
		if( !obj ) return;
		
		for(var i=0,e=this.extensions.length; i<e; ++i) {
			var attr = this.extensions[i];
			attr._setHtml(obj);
		};

		var compiledTemplate = this.schema.formTemplate__compiled;
		if( !compiledTemplate ) {
			var formTemplate = this.schema.formTemplate;
			if( formTemplate ) {
				compiledTemplate = Handlebars.compile(formTemplate,{trackIds:true});
				this.schema.formTemplate__compiled = compiledTemplate;
			};
		};
		if( compiledTemplate ) {
			obj[HTML] = compiledTemplate(obj);
		};
	},
	
	_installHandlers: function($elem,$input,obj,callback) {
		var _this = this;
		
		var classNames = $input.attr('class').split(' ');
		var classInfo = parseClassNames(classNames);
		var inputNodeName = $input.prop('nodeName');
		if( typeof inputNodeName === 'string' ){
			inputNodeName = inputNodeName.toLowerCase();
		};
		
		// Special case for references. Convert input into field
		if( 'reference' === classInfo.type 
		 && classInfo.selector ){
			var $span = $('<span>')
				.attr('nunaliit-selector',classInfo.selector.encodeForDomAttribute())
				;
			$input.after($span);
			$input.remove();
			this._installReference($elem,$span);
			return;
		};

		var selector = classInfo.selector;
		if( selector ) {
			var parentSelector = selector.getParentSelector();
			var key = selector.getKey();
			var changeHandler = this._createChangeHandler(
				obj
				,selector
				,parentSelector
				,classInfo.type
				,function(obj, selector, value){
					if( 'reference' === classInfo.type ){
						_this.refresh($elem);
					};
					callback(obj, selector.selectors, value);
				}
			);
			var keyupHandler = this._createChangeHandler(
					obj
					,selector
					,parentSelector
					,classInfo.type
					,function(obj, selector, value){
					}
				);
			$input.change(changeHandler);
			//$input.blur(handler);
			if( 'date' !== classInfo.type ){ // no key up event for date text boxes
				$input.keyup(keyupHandler);
			};
			
			// Set value
			var value = selector.getValue(obj);
			var type = $input.attr('type');
			if( 'checkbox' === type ) {
				if( value ) {
					$input.attr('checked',true);
				} else {
					$input.attr('checked',false);
				};

			} else if( 'date' === classInfo.type ) {
				if( value ) {
					value = value.date;
				};
				$input.val(value);
				$input.attr('n2OriginalDate',value);

				if( $input.datepicker ) {
					$input.datepicker({
						dateFormat: 'yy-mm-dd'
						,gotoCurrent: true
						,changeYear: true
						,constrainInput: false
						,onSelect: function(){
							var $input = $(this);
							changeHandler.call($input);
						}
					});
				};
				
			} else if( 'numeric' === classInfo.type ) {
				//if( false == $n2.utils.isNumber(value) ) {
				//	value = 0;
				//};
				$input.val(value);

				// On key down, save previous value
				$input.keydown(function(event) {
					var $input = $(this);
					
					var val = $input.val();
					$input.attr('n2Numeric', val);

					//$n2.log('key down',val,event.keyCode,event);
				});

				// On key up, verify that new value is correct
				// Else, restore previous value
				$input.keyup(function(event) {
					var $input = $(this);
					
					var previous = $input.attr('n2Numeric');
					
					var val = $input.val();
					if( '' === val 
						|| '+' === val
						|| '-' === val
					  ){
						// OK. Allow starting a new number

					} else if( $n2.utils.isNumber(val) ){
						// OK. Allow a number

					} else if( 
							// Allow: delete
							event.keyCode === 46 
							// Allow: backspace
							|| event.keyCode === 8 
							// Allow: tab
							|| event.keyCode === 9 
							// Allow: escape
							|| event.keyCode === 27 
				             // Allow: Ctrl+A
				            || (event.keyCode === 65 && event.ctrlKey) 
				             // Allow: home and end
				            || (event.keyCode >= 35 && event.keyCode <= 36)
				             // Allow: left
				            || (event.keyCode === 37)
				             // Allow: right
				            || (event.keyCode === 39)
				             // Allow: ctrl, shift, alt
				            || (event.keyCode >= 16 && event.keyCode <= 18)
					  ){
						// OK. Allow special characters so that user
						// can perform editing of a value, even if it is
						// not yet numeric
						
					} else {
						// Restore previous
						$input.val(previous);
					}

					//$n2.log('key up',val,event);
					
					return true;
				});
				
			} else if( 'layers' === classInfo.type ) {
				if( $n2.isArray(value) ) {
					value = value.join(',');
				};
				$input.val(value);
				
				var getLayersFn = this.functionMap['getLayers'];
				if( getLayersFn && $input.is('input') ) {
					$input.focus(function(e, eventParam){
						if( eventParam && eventParam.inhibitCallback ) {
							return true;
						};
						
						var layerValue = selector.getValue(obj);
						
						getLayersFn({
							currentLayers: layerValue	
							,onSelected: function(layers){ // callback with docId
								var p = parentSelector.getValue(obj);
								if( p ) {
									p[key] = layers;
									if( !layers || layers.length === 0 ){
										delete p[key];
									};
								};
								if( layers ) {
									$input.val( layers.join(',') );
									changeHandler.call($input);
								};
								$input.trigger('focus',{inhibitCallback:true});
							}
							,onReset: function(){ // reset function
								$input.trigger('focus',{inhibitCallback:true});
							}
						});
						
						return true;
					});
				};
				
			} else {
				$input.val(value);
			};
			
			// After setting the value to a <select>, it is possible that no option
			// is representing the current value. In this case, insert an option to
			// represent the current state
			if( 'select' === inputNodeName ){
				var effectiveValue = value;
				if( null === effectiveValue || undefined === effectiveValue ){
					// This is a text field. Null does not have a meaning
					effectiveValue = '';
				};

				var selectedOptions = $input[0].selectedOptions;
				if( selectedOptions ){
					var foundCurrentValue = false;
					for(var i=0,e=selectedOptions.length; i<e; ++i){
						var selectedOption = selectedOptions.item(i);
						var $selectedOptions = $(selectedOption);
						var selectedValue = $selectedOptions.attr('value');
						if( selectedValue === effectiveValue ){
							foundCurrentValue = true;
						};
					};
					
					if( !foundCurrentValue ){
						// At this point, the value carried by the document is not
						// properly represented by the <select> form element. Correct
						// the situation by prepending an <option> element with the
						// correct value. Make this option 'disabled' so that user can
						// not choose it.
						$('<option>')
							.attr('value',effectiveValue)
							.attr('disabled','disabled')
							.text( effectiveValue )
							.prependTo($input);
						$input.val(value);
					};
				};
			};
		};
	},

	_installReference: function($container, $elem) {
		var _this = this;
		
		var domSelector = $elem.attr('nunaliit-selector');
		var objSel = $n2.objectSelector.decodeFromDomAttribute(domSelector);
		var parentSelector = objSel.getParentSelector();
		var key = objSel.getKey();

		var funcIdentifier = $elem.attr('n2-search-func');
		
		var ref = objSel.getValue(this.obj);
		
		if( ref && ref.doc ) {
			// There is a reference
			$elem.empty();
			
			// Brief
			$('<span>')
				.addClass('n2s_briefDisplay')
				.text(ref.doc)
				.appendTo($elem);
			
			// Delete button
			$('<div>')
				.addClass('n2schema_referenceDelete')
				.appendTo($elem)
				.click(function(){
					var parentObj = parentSelector.getValue(_this.obj);
					if( $n2.isArray(parentObj) 
					 && typeof key === 'number' 
					 && parentObj.length > key ){
						// Dealing with an array of references
						if( parentObj[key] ){
							parentObj.splice(key,1);
							_this.refresh($container);
							_this.callback(_this.obj,objSel.selectors,null);
						};
					} else {
						if( parentObj[key] ){
							delete parentObj[key];
							_this.refresh($container);
							_this.callback(_this.obj,objSel.selectors,null);
						};
					};
				});
			
		} else {
			// There is no reference. Install a
			// text input
			$elem.empty();

			var $input = $('<input>')
				.attr('type','text')
				.appendTo($elem);
			
			// Handle changes
			var changeHandler = function(e) {
				var $input = $(this);
				
				var parentObj = parentSelector.getValue(_this.obj);
				if( parentObj ){
					var value = $input.val();
					var cbValue = null;
					
					if( null === value || value === '' ) {
						// delete
						if( parentObj[key] ) {
							delete parentObj[key];
						};
						
					} else {
						// update
						if( !parentObj[key] ) {
							parentObj[key] = {};
						};
						parentObj[key].nunaliit_type = 'reference';
						parentObj[key].doc = value;
						
						cbValue = parentObj[key];
					};
					
					_this.refresh($container);
					_this.callback(_this.obj,objSel.selectors,cbValue);
				};
			};
			$input.change(changeHandler);
			
			// Handle focus
			var focusHandler = {
				fn: this.functionMap['getDocumentId']
				,args: []
			};
//			if( funcIdentifier 
//			 && this.functionMap[funcIdentifier] ){
//				getDocumentIdFn = this.functionMap[funcIdentifier];
//			};
			if( funcIdentifier ){
				if( $n2.docFnCall ){
					try {
						var program = $n2.docFnCall.parse(funcIdentifier);
						if( program ){
							var r = program.getValue({
								doc: _this.obj
								,funcMap: this.functionMap
							});
							if( r ){
								focusHandler = r;
							};
						};
					} catch(err) {
						$n2.logError('Error while processing focus handler '+funcIdentifier, err);
					};
				};
			};
			if( focusHandler ) {
				$input.focus(function(e, eventParam){
					var $input = $(this);

					if( eventParam && eventParam.inhibitCallback ) {
						return true;
					};
					
					window.setTimeout(function(){
						focusHandler.fn({
							contextDoc: _this.obj
							,args: focusHandler.args
							,onSelected: function(docId){ // callback with docId
								var parentObj = parentSelector.getValue(_this.obj);
								if( parentObj ){
									if( !parentObj[key] ){
										parentObj[key] = {};
									};
									parentObj[key].nunaliit_type = 'reference';
									parentObj[key].doc = docId;

									// Update input
									$input.val(docId);
									
									// Call change handler
									changeHandler.call($input);
									
									// Put focus in input
									$input.trigger('focus',{inhibitCallback:true});
								};
							}
							,onReset: function(){ // reset function
								$input.trigger('focus',{inhibitCallback:true});
							}
						});
					}, 0);
					
					return true;
				});
			};
			
		};
	},

	_installGeometry: function($container, $elem) {
		var _this = this;
		
		var domSelector = $elem.attr('nunaliit-selector');
		var objSel = $n2.objectSelector.decodeFromDomAttribute(domSelector);
		var parentSelector = objSel.getParentSelector();
		var key = objSel.getKey();

		var geom = objSel.getValue(this.obj);
		
		if( geom && geom.wkt ) {
			// There is a geometry
			$elem.val(geom.wkt);
		} else {
			$elem.val('');
		};
		
		$elem.change(function(e) {
			var $elem = $(this);
			
			var parentObj = parentSelector.getValue(_this.obj);
			if( parentObj ){
				var value = $elem.val();
				var cbValue = null;
				
				if( null === value || value === '' ) {
					// delete
					if( parentObj[key] ) {
						delete parentObj[key];
					};
					
				} else {
					// update
					if( !parentObj[key] ) {
						parentObj[key] = {};
					};
					parentObj[key].nunaliit_type = 'geometry';
					parentObj[key].wkt = value;
					
					if( parentObj[key].bbox ){
						delete parentObj[key].bbox;
					};
					
					if( parentObj[key].simplified ){
						delete parentObj[key].simplified;
					};
					
					cbValue = parentObj[key];
				};
				
				_this.refresh($container);
				_this.callback(_this.obj,objSel.selectors,cbValue);
			};
		});
	},
	
	_installCustomType: function($container, $elem, doc , callbackFn){
		var _this = this;
		
		var customType = $elem.attr('n2-custom-type');
		
		var selectorStr = $elem.attr('nunaliit-selector');
		var selector = null;
		if( selectorStr ){
			selector = $n2.objectSelector.decodeFromDomAttribute(selectorStr);
		};
		
		function cb(value, suppressFullRefresh){
			if( suppressFullRefresh ){
				$elem.empty();

				var handler = customFieldHandlers[customType];
				if( handler ){
					var obj = undefined;
					if( selector && doc ){
						obj = selector.getValue(doc);
					};
					
					handler({
						elem: $elem
						,doc: doc
						,obj: obj
						,selector: selector
						,customType: customType
						,callbackFn: cb
						,functionMap: _this.functionMap
					});
				};
			} else {
				_this.refresh($container);
			};
			
			_this.callback(doc,selector,value);
		};
		
		if( typeof customType === 'string' ){
			var handler = customFieldHandlers[customType];
			if( handler ){
				var obj = undefined;
				if( selector && doc ){
					obj = selector.getValue(doc);
				};
				
				handler({
					elem: $elem
					,doc: doc
					,obj: obj
					,selector: selector
					,customType: customType
					,callbackFn: cb
					,functionMap: _this.functionMap
				});
			} else {
				$elem.attr('nunaliit-error','No handler found for custom type: "'+customType+'"');
			};
			
		} else {
			$elem.attr('nunaliit-error','Custom type not provided');
		};
		
	},
	
	_createChangeHandler: function(obj, selector, parentSelector, keyType, callback) {
		return function(e) {
			var $input = $(this);
			var parentObj = parentSelector.getValue(obj);
			var effectiveKey = selector.getKey();
			
			if( !parentObj ){
				if( 'localized' === keyType ) {
					var value = $input.val();
					if( value ){
						// Materialize the parent of a localized string
						parentSelector.setValue(obj,{'nunaliit_type':'localized'});
						parentObj = parentSelector.getValue(obj);
					};
				};
			};
			
			if( parentObj ) {
				var assignValue = true;
				var type = $input.attr('type');
				if( 'checkbox' === type ) {
					if( $input.is(':checked') ) {
						var value = true;
					} else {
						value = false;
					};
					
				} else if( 'reference' === keyType ) {
					value = $input.val();
					if( null === value || value === '' ) {
						assignValue = false;
						if( parentObj[effectiveKey] ) {
							delete parentObj[effectiveKey];
						};
					} else {
						if( !parentObj[effectiveKey] ) {
							parentObj[effectiveKey] = {nunaliit_type:'reference'};
						} else {
							parentObj[effectiveKey].nunaliit_type = 'reference';
						};
						parentObj = parentObj[effectiveKey];
						effectiveKey = 'doc';
					};
					
				} else if( 'localized' === keyType ) {
					value = $input.val();
					parentObj[effectiveKey] = value;
					assignValue = false;
					
					var shouldDelete = true;
					for(var lang in parentObj){
						if( 'nunaliit_type' === lang ){
							// ignore
						} else if( parentObj[lang] ) {
							// non-empty string
							shouldDelete = false;
						};
					};
					if( shouldDelete ){
						parentSelector.removeValue(obj);
					};
					
				} else if( 'date' === keyType ) {
					// For date, we will update object
					assignValue = false;
					
					var dateStr = $input.val();
					
					if( !dateStr ){
						if( parentObj[effectiveKey] ) {
							parentObj[effectiveKey] = null;
						};
					} else {
						var trimmedDateStr = $n2.trim(dateStr);
						if( '' === trimmedDateStr ){
							if( parentObj[effectiveKey] ) {
								parentObj[effectiveKey] = null;
							};
						} else {

							var dateInt = null;
							try {
								dateInt = $n2.date.parseUserDate(dateStr);
							} catch(e) {
								var msg = _loc('Invalid date: {err}',{err:e});
								$n2.log(msg);
								alert( msg );
								var original = $input.attr('n2OriginalDate');
								$input.val(original);
							};

							if( dateInt ){
								parentObj[effectiveKey] = dateInt.getDocumentStructure();
							};
						};
					};
					
					// We should be updating parent object with the
					// complete date structure
					value = parentObj[effectiveKey];
					
					
				} else if( 'numeric' === keyType ) {
					value = $input.val();

					if( false == $n2.utils.isNumber(value) ){
						assignValue = false;
					} else {
						// Convert to number
						value = 1 * value;
					};
					
				} else if( 'layers' === keyType ) {
					value = $input.val();
					if( null === value || value === '' ) {
						assignValue = false;
						if( parentObj[effectiveKey] ) {
							delete parentObj[effectiveKey];
						};
					} else {
						value = value.split(',');
						for(var i=0,e=value.length; i<e; ++i){
							value[i] = $n2.trim(value[i]);
						};
					};

				} else {
					value = $input.val();
				};
				if( assignValue ) {
					parentObj[effectiveKey] = value;
				};
				callback(obj,selector.selectors,value);
			};
		};
	}
});

//============================================================
// Exports
$n2.schema = {
	Schema: Schema
	,SchemaRepository: SchemaRepository
	,Display: Display
	,Form: Form
	,registerCustomFieldHandler: registerCustomFieldHandler
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.dispatch.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($n2){
"use strict";

// Localization
//var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };
var HANDLEMARKER = {}
,ADDRESSMARKER = {}
;

// *******************************************************
/**
 * This is a service that connects components via an event or messaging system.
 * The dispatch system supports two types of events or messages:
 * - asynchronous events
 * - synchronous messages
 * 
 * An event is sent using the sent() function. All events are distributed in the
 * order in which they were received. All recipients registered for an event will
 * be given the opportunity to accept the event before the next event is processed.
 * Events are asynchronous, therefore the sender of the event can not predict when
 * the event will be completely processed. Therefore, an event sender can not expect
 * a reply unless it comes in the form of a separate event.
 * 
 * A synchronous message is sent using the syncrhonousCall() function. Unlike events,
 * synchronous messages are delivered immediately, before any events if any are in queue.
 * All recipients of a synchronous message are called before the function synchronousCall()
 * returns. Therefore, the reply to a synchronous call can be saved on the message to be
 * consumed by the sender. A synchronous message is similar to a remote function call.
 * 
 * The information transmitted by asynchronous events and synchronous messages are encoded
 * in a message structure. The message structure is a Javascript object with a "type"
 * attribute:
 * {
 *    "type": "<a message type>"
 * } 
 * 
 * The message type is used to route the events and messages to the appropriate recipients.
 * 
 * In a message structure, any attribute other than "type" is defined by the message type.
 * 
 */
var Dispatcher = $n2.Class({
	
	logging: null,
	
	loggingIncludesMessage: null,
	
	loggingHandleMap: null,

	loggingTypeMap: null,
	
	listeners: null,
	
	handles: null,
	
	dispatching: null,
	
	queue: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			logging: false
			,loggingIncludesMessage: false
			,loggingHandles: null
			,loggingTypes: null
		},opts_);
		
		var _this = this;
		
		this.logging = opts.logging;
		this.loggingIncludesMessage = opts.loggingIncludesMessage;
		
		this.loggingHandleMap = {};
		if( $n2.isArray(opts.loggingHandles) ){
			opts.loggingHandles.forEach(function(handle){
				if( typeof handle === 'string' ){
					_this.loggingHandleMap[handle] = true;
				};
			});
		};
		
		this.loggingTypeMap = {};
		if( $n2.isArray(opts.loggingTypes) ){
			opts.loggingTypes.forEach(function(type){
				if( typeof type === 'string' ){
					_this.loggingTypeMap[type] = true;
				};
			});
		};
		
		this.listeners = {};
		this.handles = {};
		this.dispatching = false;
		this.queue = [];

	},

	/**
	 * Create a handle based on a string. The string should be unique to help
	 * debugging.
	 */
	getHandle: function(name){
		var h = this.handles[name];
		if( !h ) {
			h = {
				dispatch: true
				,name: name
				,receives: {}
				,sends: {}
				,_marker: HANDLEMARKER
			};
			this.handles[name] = h;
		};
		return h;
	},
	
	isHandle: function(h){
		if( typeof h !== 'object' ) return false;
		
		if( h._marker === HANDLEMARKER ){
			return true;
		};
		
		return false;
	},
	
	isAddress: function(addr){
		if( typeof addr !== 'object' ) return false;
		
		if( addr._marker === ADDRESSMARKER ){
			return true;
		};
		
		return false;
	},

	/**
	 * Registers a recipient to receive events and messages of a specific type.
	 * @param handle A handle or a string identifying the recipient.
	 * @param type A string specifying which message type to receive
	 * @param l A function which is called back with the message when it is received. The
	 *          signature for this function is function(message, address, dispatcher)
	 * @return An address (object structure) that can be used in the deregister() function
	 */
	register: function(handle, type, l){
		if( typeof handle === 'string' ){
			handle = this.getHandle(handle);
		};
		if( !this.isHandle(handle) ){
			throw new Error('DispatchService.register: invalid handle');
		};
		if( typeof type !== 'string' ){
			throw new Error('DispatchService.register: type must be a string');
		};
		if( typeof l !== 'function' ){
			throw new Error('DispatchService.register must provide a function');
		};
		
		if( !this.listeners[type] ){
			this.listeners[type] = [];
		};
		var address = {
			type: type
			,id: $n2.getUniqueId()
			,_marker: ADDRESSMARKER
		};
		this.listeners[type].push({
			handle: handle
			,fn: l
			,address: address
		});

		handle.receives[type] = true;
		
		return address;
	},
	
	/**
	 * Removes a registration based on an address.
	 * @param address An address previously obtained using register() or when
	 *                recipient is called back.
	 */
	deregister: function(address){
		if( this.isAddress(address) ){
			var type = address.type;
			var id = address.id;
			if( type && id ){
				var list = this.listeners[type];
				if( list ){
					var index = -1;
					for(var i=0,e=list.length; i<e; ++i){
						var l = list[i];
						if( l.address && l.address.id === id ){
							index = i;
							break;
						};
					};
					
					if( index >= 0 ){
						this.listeners[type].splice(index,1);
					};
				};
			};
		} else {
			throw new Error('DispatchService.deregister: invalid address');
		};
	},
	
	/**
	 * Returns true if any listener is registered for the
	 * given event type.
	 * @param type Message type that is seeked
	 * @return True is anyone has registered for the given message type
	 */
	isEventTypeRegistered: function(type){
		var listeners = this.listeners[type];
		if( listeners && listeners.length > 0 ) {
			return true;
		};
		return false;
	},
	
	/**
	 * Sends an asynchronous event.
	 * @param handle Sender's handle or a string. This helps in debugging of dispatcher.
	 * @param m Message structure to be sent to all recipients registered with the message type.
	 */
	send: function(handle, m){
		
		m.time = Date.now();
		
		if( typeof(handle) === 'string' ){
			handle = this.getHandle(handle);
		};
		
		if( this.dispatching ) {
			// Already dispatching a message, put this one in queue
			this.queue.push({
				h: handle
				,m: m
			});
		} else {
			// Send now
			this._sendImmediate(handle, m);
			
			// Deal with items in queue
			while(this.queue.length > 0){
				var i = this.queue.splice(0,1)[0];
				this._sendImmediate(i.h, i.m);
			};
		};
	},
	
	_sendImmediate: function(h, m) {
		var _this = this;
		
		var logging = false;
		if( this.logging ){
			logging = true;
		} else if( this.loggingHandleMap[h.name] ){
			logging = true;
		} else if( this.loggingTypeMap[m.type] ){
			logging = true;
		};
		var loggingIncludesMessage = this.loggingIncludesMessage;

		var t = m.type;

		// Remember that this message is sent by this handle
		h.sends[t] = true;

		this.dispatching = true;
		var listeners = this.listeners[t];
		if( listeners ) {
			var copy = listeners.slice(0); // make copy to handle deregister during processing
			for(var i=0,e=copy.length; i<e; ++i){
				var l = copy[i];
				
				if( logging ){
					var timeStr = '';
					if( m.time ){
						timeStr = '' + (m.time/1000)+' ';
					};
					
					if( loggingIncludesMessage ) {
						$n2.log(timeStr+h.name+' >'+t+'> '+l.handle.name,m);
					} else {
						$n2.log(timeStr+h.name+' >'+t+'> '+l.handle.name);
					};
				};
				
				try {
					l.fn(m, l.address, this);
				} catch(e) {
					_this._reportError(e,m);
				};
			};
		} else if( typeof listeners === 'undefined' ){
			// Keep track of events sent, even if none is listening
			listeners = [];
			this.listeners[t] = listeners;
		};
		
		if( !listeners || listeners.length < 1 ){
			if( logging ){
				if( loggingIncludesMessage ) {
					$n2.log(''+h.name+' >'+t+' not observed',m);
				} else {
					$n2.log(''+h.name+' >'+t+' not observed');
				};
			};
		};
		
		this.dispatching = false;
	},
	
	_reportError: function(e,m){
		$n2.log('Error while dispatching '+m.type+': '+e);
		if( e.stack ) {
			$n2.log('Stack: '+e.stack);
		};
	},
	
	/**
	 * Sends a synchronous message to all recipients that have registered for the
	 * message type.
	 * @param handle Sender's handle or a string. This helps in debugging of dispatcher.
	 * @param m Message structure to be sent to all recipients registered with the message type.
	 */
	synchronousCall: function(handle, m){
		
		m.time = Date.now();

		if( typeof(handle) === 'string' ){
			handle = this.getHandle(handle);
		};
		
		// Send right away
		var previous = this.dispatching;
		this._sendImmediate(handle, m);
		this.dispatching = previous;
		
		// Deal with items that were put in queue during synchronous call
		if( !previous ) {
			while(this.queue.length > 0){
				var i = this.queue.splice(0,1)[0];
				this._sendImmediate(i.h, i.m);
			};
		};
	}
});

//*******************************************************
$n2.dispatch = {
	Dispatcher: Dispatcher
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.logger.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

// **********************************************************************
var Logger = $n2.Class({
	divId: null,
	
	initialize: function(opts_){
	},

	reportError: function(err){
		this.log(err);
	},
	
	log: function(msg){
		throw new Error('Subclasses must implement function log()');
	}
});

//**********************************************************************
var HtmlLogger = $n2.Class('HtmlLogger', Logger, {
	divId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
		},opts_);
		
		Logger.prototype.initialize.apply(this,arguments);
		
		var $div = $(opts.elem)
			.addClass('n2logger_html');
		this.divId = $n2.utils.getElementIdentifier($div);
		
		$n2.log('HtmlLogger',this);
	},

	reportError: function(err){
		var $e = this._getLogsDiv();

		var $d = $('<div class="error"></div>');
		$d.text(err);
		$e.append($d);
	},
	
	log: function(msg,opts){
		var $e = this._getLogsDiv();

		var $d = $('<div class="log"></div>');
		$d.text(msg);
		
		if( opts ){
			if( opts.preserveSpaces ){
				$d.css({
					'white-space': 'pre'
				});
			};
		};
		
		$e.append($d);
	},
	
	clear: function(){
		this._getLogsDiv().empty();
	},
	
	_getLogsDiv: function(){
		return $('#'+this.divId);
	}
});

//**********************************************************************
var CustomLogger = $n2.Class('CustomLogger', Logger, {

	logFn: null,
	
	reportErrorFn: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			logFn: null
			,reportErrorFn: null
		},opts_);
		
		Logger.prototype.initialize.apply(this,arguments);
		
		this.logFn = opts.logFn;
		this.reportErrorFn = opts.reportErrorFn;
		
		if( typeof this.logFn !== 'function' ){
			throw new Error('In CustomLogger, a function must be provided for logFn');
		} else {
			this.logFn = this.logFn;
		};
		
		if( typeof this.reportErrorFn === 'function' ){
			this.reportError = this.reportErrorFn;
		};

		$n2.log('CustomLogger',this);
	}
});


$n2.logger = {
	Logger: Logger
	,HtmlLogger: HtmlLogger
	,CustomLogger: CustomLogger
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.geometry.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
,DH = 'n2.geometry'
;

// =============================================
var Geometry = $n2.Class('Geometry',{
	
});

//=============================================
var Point = $n2.Class('Point', Geometry,{
	x: undefined,
	
	y: undefined,
	
	z: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			x: undefined
			,y: undefined
			,z: undefined
		},opts_);
		
		this.x = opts.x;
		this.y = opts.y;
		this.z = opts.z;
	},
	
	toString: function(){
		return 'POINT(' + this.x 
			+ ' ' + this.y 
			+ (this.z !== undefined ? ' ' + this.z : '') 
			+ ')';
	}
});

//=============================================
var LineString = $n2.Class('LineString', Geometry,{

	points: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			points: undefined
		},opts_);
		
		var _this = this;

		this.points = [];
		
		if( $n2.isArray(opts.points) ){
			opts.points.forEach(function(point){
				_this.points.push(point);
			});
		};
	},
	
	getPoints: function(){
		return this.points;
	},
	
	toString: function(){
		var acc = [];
		acc.push('LINESTRING(');
		var first = true;
		this.points.forEach(function(point){
			if( first ){
				first = false;
			} else {
				acc.push(',');
			};
			
			acc.push(point.x);
			acc.push(' ');
			acc.push(point.y);
			
			if( undefined !== point.z ){
				acc.push(' ');
				acc.push(point.z);
			};
		});
		acc.push(')');
		return acc.join('');
	}
});

//=============================================
var Polygon = $n2.Class('Polygon', Geometry,{

	linearRings: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			linearRings: undefined
		},opts_);
		
		var _this = this;

		this.linearRings = [];
		
		if( $n2.isArray(opts.linearRings) ){
			opts.linearRings.forEach(function(linearRing){
				_this.linearRings.push(linearRing);
			});
		};
	},
	
	getLinearRings: function(){
		return this.linearRings;
	},
	
	toString: function(){
		var acc = [];
		acc.push('POLYGON(');
		var first = true;
		this.linearRings.forEach(function(linearRing){
			if( first ){
				first = false;
			} else {
				acc.push(',');
			};

			acc.push('(');

			var points = linearRing.getPoints();
			var firstPoint = true;
			points.forEach(function(point){
				if( firstPoint ){
					firstPoint = false;
				} else {
					acc.push(',');
				};

				acc.push(point.x);
				acc.push(' ');
				acc.push(point.y);
				
				if( undefined !== point.z ){
					acc.push(' ');
					acc.push(point.z);
				};
			});

			acc.push(')');
		});
		acc.push(')');
		return acc.join('');
	}
});

//=============================================
var GeometryCollection = $n2.Class('GeometryCollection', Geometry,{

	geometries: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			geometries: undefined
		},opts_);
		
		var _this = this;

		this.geometries = [];
		
		if( $n2.isArray(opts.geometries) ){
			opts.geometries.forEach(function(geometry){
				_this.geometries.push(geometry);
			});
		};
	},
	
	getGeometries: function(){
		return this.geometries;
	},
	
	toString: function(){
		var acc = [];
		acc.push('GEOMETRYCOLLECTION(');
		var first = true;
		this.geometries.forEach(function(geometry){
			if( first ){
				first = false;
			} else {
				acc.push(',');
			};

			acc.push(geometry.toString());
		});
		acc.push(')');
		return acc.join('');
	}
});

//=============================================
var GeometryAssembly = $n2.Class('GeometryAssembly', Geometry,{

	getSize: function(){
		throw new Error('Subclasses to GeometryAssembly must implements getSize()');
	},
	
	getGeometries: function(){
		throw new Error('Subclasses to GeometryAssembly must implements getGeometries()');
	}
});

//=============================================
var MultiPoint = $n2.Class('MultiPoint', GeometryAssembly,{

	points: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			points: undefined
		},opts_);
		
		var _this = this;

		this.points = [];
		
		if( $n2.isArray(opts.points) ){
			opts.points.forEach(function(point){
				_this.points.push(point);
			});
		};
	},

	getSize: function(){
		return points.length;
	},
	
	getGeometries: function(){
		return this.points;
	},
	
	toString: function(){
		var acc = [];
		acc.push('MULTIPOINT(');
		var first = true;
		this.points.forEach(function(point){
			if( first ){
				first = false;
			} else {
				acc.push(',');
			};

			acc.push('(');
			
			acc.push(point.x);
			acc.push(' ');
			acc.push(point.y);
			
			if( undefined !== point.z ){
				acc.push(' ');
				acc.push(point.z);
			};

			acc.push(')');
		});
		acc.push(')');
		return acc.join('');
	}
});

//=============================================
var MultiLineString = $n2.Class('MultiLineString', GeometryAssembly,{

	lineStrings: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			points: undefined
		},opts_);
		
		var _this = this;

		this.lineStrings = [];
		
		if( $n2.isArray(opts.lineStrings) ){
			opts.lineStrings.forEach(function(lineString){
				_this.lineStrings.push(lineString);
			});
		};
	},

	getSize: function(){
		return lineStrings.length;
	},
	
	getGeometries: function(){
		return this.lineStrings;
	},
	
	toString: function(){
		var acc = [];
		acc.push('MULTILINESTRING(');
		var first = true;
		this.lineStrings.forEach(function(lineString){
			if( first ){
				first = false;
			} else {
				acc.push(',');
			};

			acc.push('(');
			
			var points = lineString.getPoints();
			var firstPoint = true;
			points.forEach(function(point){
				if( firstPoint ){
					firstPoint = false;
				} else {
					acc.push(',');
				};
				
				acc.push(point.x);
				acc.push(' ');
				acc.push(point.y);
				
				if( undefined !== point.z ){
					acc.push(' ');
					acc.push(point.z);
				};
			});

			acc.push(')');
		});
		acc.push(')');
		return acc.join('');
	}
});

//=============================================
var MultiPolygon = $n2.Class('MultiPolygon', GeometryAssembly,{

	polygons: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			polygons: undefined
		},opts_);
		
		var _this = this;

		this.polygons = [];
		
		if( $n2.isArray(opts.polygons) ){
			opts.polygons.forEach(function(polygon){
				_this.polygons.push(polygon);
			});
		};
	},

	getSize: function(){
		return polygons.length;
	},
	
	getGeometries: function(){
		return this.polygons;
	},
	
	toString: function(){
		var acc = [];
		acc.push('MULTIPOLYGON(');
		var first = true;
		this.polygons.forEach(function(polygon){
			if( first ){
				first = false;
			} else {
				acc.push(',');
			};

			acc.push('(');
			
			var linearRings = polygon.getLinearRings();
			var firstLinearRing = true;
			linearRings.forEach(function(linearRing){
				if( firstLinearRing ){
					firstLinearRing = false;
				} else {
					acc.push(',');
				};

				acc.push('(');
				
				var points = linearRing.getPoints();
				var firstPoint = true;
				points.forEach(function(point){
					if( firstPoint ){
						firstPoint = false;
					} else {
						acc.push(',');
					};
					
					acc.push(point.x);
					acc.push(' ');
					acc.push(point.y);
					
					if( undefined !== point.z ){
						acc.push(' ');
						acc.push(point.z);
					};
				});

				acc.push(')');
			});
			
			acc.push(')');
		});
		acc.push(')');
		return acc.join('');
	}
});

//=============================================
var CharacterStream = $n2.Class({
	
	str: undefined,
	
	index: undefined,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			str: undefined
		},opts_);
		
		if( typeof opts.str !== 'string' ){
			throw new Error('CharacterStream must be initialized with a string');
		};
		
		this.str = opts.str;
		
		this.index = 0;
	},
	
	getPosition: function(){
		return this.index;
	},
	
	setPosition: function(index){
		if( index > this.str.length ){
			throw new Error('CharacterStream.setPosition() index is out of bounds');
		};
		this.index = index;
	},
	
	atEnd: function(){
		if( this.index >= this.str.length ){
			return true;
		};
		return false;
	},
	
	peekChar: function(){
		if(this.index < this.str.length){
			return this.str[this.index];
		};
		return undefined;
	},
	
	getChar: function(){
		if(this.index < this.str.length){
			var c = this.str[this.index];
			++this.index;
			return c;
		};
		return undefined;
	},
	
	startsWith: function(str, ignoreCase){
		var sizeLeft = this.str.length - this.index;
		if( sizeLeft < str.length ){
			return false;
		};
		
		var portion = this.str.substr(this.index, str.length);
		
		if( ignoreCase ){
			return str.toLowerCase() === portion.toLowerCase();
		} else {
			return str === portion;
		};
	},
	
	skipCharacters: function(count){
		if( this.index + count > this.str.length ){
			throw new Error('CharacterStream.skipCharacters() out of bounds');
		};
		
		this.index += count;
	},
	
	skipSpaces: function(){
		while(this.index < this.str.length){
			var c = this.str[this.index];
			if( isSpace(c) ){
				++this.index;
			} else {
				break;
			};
		};

		function isSpace(c){
			if( ' ' === c 
			 || '\n' === c 
			 || '\r' === c ){
				return true;
			};
			return false;
		};
	}
});

//=============================================
var WktParser = $n2.Class({
	initialize: function(){
		
	},
	
	parseWkt: function(str){
		var stream = new CharacterStream({
			str: str
		});
		
		var geometry = this._parseGeometry(stream);
		
		stream.skipSpaces();
		if( !stream.atEnd() ){
			throw new Error('Expected end of stream at position: '+stream.getPosition());
		};

		return geometry;
	},
	
	_parseGeometry: function(stream){
		stream.skipSpaces();
		
		// POINT(x y) or POINT(x y z)
		if( stream.startsWith("POINT",true) ){
			stream.skipCharacters("POINT".length);
			
			stream.skipSpaces();
			var c = stream.getChar();
			if( '(' !== c ){
				throw new Error('Expected character "(" at position: '+stream.getPosition());
			};
			stream.skipSpaces();
			
			var point = this._parsePoint(stream);

			stream.skipSpaces();
			c = stream.getChar();
			if( ')' !== c ){
				throw new Error('Expected character ")" at position: '+stream.getPosition());
			};
			
			return point;

		} else if( stream.startsWith("MULTIPOINT",true) ){
			// MULTIPOINT((x y))
			// MULTIPOINT((x y),(x y))
			// MULTIPOINT(x y)
			// MULTIPOINT(x y, x y)
			var points = [];
			stream.skipCharacters("MULTIPOINT".length);

			stream.skipSpaces();
			var c = stream.getChar();
			if( '(' !== c ){
				throw new Error('Expected character "(" at position: '+stream.getPosition());
			};
			stream.skipSpaces();

			var done = false;
			while( !done ){
				var c = stream.peekChar();
				if( '(' === c ){
					// (x y) (x y z)
					stream.getChar();
					var point = this._parsePoint(stream);
					points.push(point);
					stream.skipSpaces();
					var end = stream.getChar();
					if( ')' !== end ){
						throw new Error('Expected character ")" at position: '+stream.getPosition());
					};
					
				} else {
					// x y
					// x y z
					var point = this._parsePoint(stream);
					points.push(point);
				};

				// Check if we reached end
				stream.skipSpaces();
				c = stream.peekChar();
				if( ')' === c ){
					stream.getChar();
					done = true;
				};
				
				// If not done, we are expecting a ","
				if( !done ){
					stream.skipSpaces();
					var comma = stream.getChar();
					if( ',' !== comma ){
						throw new Error('Expected character "," or ")" at position: '+stream.getPosition());
					};
					stream.skipSpaces();
				};
			};

			var multiPoint = new MultiPoint({points:points});
			return multiPoint;

		} else if( stream.startsWith("LINESTRING",true) ){
			// LINESTRING(x y,x y)
			stream.skipCharacters("LINESTRING".length);
			stream.skipSpaces();

			var lineString = this._parseLineString(stream);
			return lineString;

		} else if( stream.startsWith("MULTILINESTRING",true) ){
			// MULTILINESTRING((x y,x y))
			// MULTILINESTRING((x y,x y),(x y,x y))
			stream.skipCharacters("MULTILINESTRING".length);
			
			stream.skipSpaces();
			var c = stream.getChar();
			if( '(' !== c ){
				throw new Error('Expected character "(" at position: '+stream.getPosition());
			};
			stream.skipSpaces();

			var lineStrings = [];
			var done = false;
			while( !done ){
				var lineString = this._parseLineString(stream);
				lineStrings.push(lineString);

				stream.skipSpaces();
				var c = stream.peekChar();
				if( ',' === c ){
					stream.getChar();
					stream.skipSpaces();

				} else if( ')' === c ){
					stream.getChar();
					done = true;

				} else {
					throw new Error('Expected character "," or ")" at position: '+stream.getPosition());
				};
			};

			var multiLineString = new MultiLineString({lineStrings:lineStrings});
			return multiLineString;

		} else if( stream.startsWith("POLYGON",true) ){
			// POLYGON((1 2,3 4),(5 6,7 8))
			stream.skipCharacters("POLYGON".length);

			var polygon = this._parsePolygon(stream);
			return polygon;

		} else if( stream.startsWith("MULTIPOLYGON",true) ){
			// MULTIPOLYGON(((1 2,3 4),(5 6,7 8)))
			// MULTIPOLYGON(((1 2,3 4),(5 6,7 8)),((1 2,3 4),(5 6,7 8)))
			stream.skipCharacters("MULTIPOLYGON".length);
			
			stream.skipSpaces();
			var c = stream.getChar();
			if( '(' !== c ){
				throw new Error('Expected character "(" at position: '+stream.getPosition());
			};

			var polygons = [];
			var done = false;
			while( !done ){
				var polygon = this._parsePolygon(stream);
				polygons.push(polygon);

				stream.skipSpaces();
				var c = stream.peekChar();
				if( ',' === c ){
					stream.getChar();
					stream.skipSpaces();

				} else if( ')' === c ){
					stream.getChar();
					done = true;

				} else {
					throw new Error('Expected character "," or ")" at position: '+stream.getPosition());
				};
			};

			var multiPolygon = new MultiPolygon({polygons:polygons});
			return multiPolygon;

		} else if( stream.startsWith("GEOMETRYCOLLECTION",true) ){
			// GEOMETRYCOLLECTION(<geometry>)
			// GEOMETRYCOLLECTION(<geometry>,<geometry>)
			stream.skipCharacters("GEOMETRYCOLLECTION".length);
			
			stream.skipSpaces();
			var c = stream.getChar();
			if( '(' !== c ){
				throw new Error('Expected character "(" at position: '+stream.getPosition());
			};

			var geometries = [];
			var done = false;
			while( !done ){
				var geometry = this._parseGeometry(stream);
				geometries.push(geometry);

				stream.skipSpaces();
				var c = stream.peekChar();
				if( ',' === c ){
					stream.getChar();
					stream.skipSpaces();

				} else if( ')' === c ){
					stream.getChar();
					done = true;

				} else {
					throw new Error('Expected character "," or ")" at position: '+stream.getPosition());
				};
			};

			var geometryCollection = new GeometryCollection({geometries:geometries});
			return geometryCollection;

		} else {
			throw new Error('Unexpected character at position: '+stream.getPosition());
		};
	},
	
	/**
	 * Parses '(' <linestring> [',' <linestring>]+ ')'
	 */
	_parsePolygon: function(stream){
		var linearRings = [];

		stream.skipSpaces();
		var c = stream.getChar();
		if( '(' !== c ){
			throw new Error('Expected character "(" at position: '+stream.getPosition());
		};
		stream.skipSpaces();

		var done = false;
		while( !done ){
			var linearRing = this._parseLineString(stream);
			
			if( linearRing.getPoints().length < 3 ){
				throw new Error('LinearRing must have at least 3 points, at position: '+stream.getPosition());
			};
			
			linearRings.push(linearRing);

			stream.skipSpaces();
			var c = stream.peekChar();
			if( ',' === c ){
				stream.getChar();
				stream.skipSpaces();

			} else if( ')' === c ){
				stream.getChar();
				done = true;

			} else {
				throw new Error('Expected character "," or ")" at position: '+stream.getPosition());
			};
		};

		var polygon = new Polygon({linearRings:linearRings});
		return polygon;
	},

	/**
	 * Parses '(' <point> [',' <point>]+ ')'
	 */
	_parseLineString: function(stream){
		var points = [];

		stream.skipSpaces();
		var c = stream.getChar();
		if( '(' !== c ){
			throw new Error('Expected character "(" at position: '+stream.getPosition());
		};

		var done = false;
		while( !done ){
			// x y
			// x y z
			var point = this._parsePoint(stream);
			points.push(point);

			// Check if we reached end
			stream.skipSpaces();
			c = stream.peekChar();
			if( ')' === c ){
				stream.getChar();
				done = true;
			};
			
			// If not done, we are expecting a ","
			if( !done ){
				stream.skipSpaces();
				var comma = stream.getChar();
				if( ',' !== comma ){
					throw new Error('Expected character "," or ")" at position: '+stream.getPosition());
				};
				stream.skipSpaces();
			};
		};
		
		if( points.length < 2 ){
			throw new Error('LineString requires more than one point: '+stream.getPosition());
		};

		var lineString = new LineString({points:points});
		return lineString;
	},
	
	/**
	 * Parses <number> <space>+ <number> [<space>+ <number>]?
	 */
	_parsePoint: function(stream){
		stream.skipSpaces();
		var x = this._parseNumber(stream);
		stream.skipSpaces();
		var y = this._parseNumber(stream);
		
		// Third position?
		var index = stream.getPosition();
		stream.skipSpaces();
		var z;
		try {
			z = this._parseNumber(stream);
		} catch(e) {
			// Rewind
			stream.setPosition(index);
			z = undefined;
		};

		var point = new Point({
			x: x
			,y: y
			,z: z
		});
		
		return point;
	},
	
	_parseNumber: function(stream){
		var position = stream.getPosition();
		
		var factor = 1;
		var c = stream.peekChar();
		if( '-' === c ){
			stream.getChar();
			factor = -1;
			c = stream.peekChar();
		};

		var value = 0;
		if( '0' <= c && '9' >= c ){
			while( '0' <= c && '9' >= c ){
				stream.getChar();
				var add = 1 * (c - '0');
				value = (value * 10) + add;
				c = stream.peekChar();
			};
			
			if( '.' === c ){
				stream.getChar();

				// Floating point
				var frac = 1;
				c = stream.peekChar();
				while( '0' <= c && '9' >= c ){
					stream.getChar();
					frac = frac / 10;
					var add = frac * (c - '0');
					value = value + add;
					c = stream.peekChar();
				};
			};
		} else {
			stream.setPosition(position);
			throw new Error('Number expected at position: '+position);
		};
		
		return factor * value;
	}
});

//=============================================
function compareGeometries(geom1, geom2){
	if( geom1 === geom2 ) return 0;
	if( !geom1 ) return -1;
	if( !geom2 ) return 1;
	
	// If not the same class, order using class name
	if( geom1.getClass() !== geom2.getClass() ){
		// Different classes
		var className1 = geom1._classname;
		var className2 = geom2._classname;

		// The following line takes care of undefined === undefined
		if( className1 === className2 ) return 0;
		
		if( !className1 ) return -1;
		if( !className2 ) return 1;

		if( className1 < className2 ) return -1;
		if( className1 > className2 ) return 1;
	};
	
	// At this point, both geometries are from the same class
	if( geom1.getClass() === Point ){
		return comparePoints(geom1, geom2);
	};
	if( geom1.getClass() === MultiPoint ){
		return compareMultiPoints(geom1, geom2);
	};
	if( geom1.getClass() === LineString ){
		return compareLineStrings(geom1, geom2);
	};
	if( geom1.getClass() === MultiLineString ){
		return compareMultiLineStrings(geom1, geom2);
	};
	if( geom1.getClass() === Polygon ){
		return comparePolygons(geom1, geom2);
	};
	if( geom1.getClass() === MultiPolygon ){
		return compareMultiPolygons(geom1, geom2);
	};
	if( geom1.getClass() === GeometryCollection ){
		return compareCollections(geom1.getGeometries(), geom2.getGeometries());
	};

	throw new Error('Unable to compare geometries: '+geom1._classname+' '+geom2._classname);
	
	function comparePoints(point1, point2){
		if( point1.x !== point2.x ){
			return point1.x - point2.x;
		};
		if( point1.y !== point2.y ){
			return point1.y - point2.y;
		};
		if( point1.z !== point2.z ){
			if( typeof point1.z === 'number' 
			 && typeof point2.z === 'number' ){
				return point1.z - point2.z;
			};
			if( typeof point1.z === undefined ){
				return -1;
			};
			if( typeof point1.z === null ){
				return -1;
			};
			if( typeof point2.z === undefined ){
				return 1;
			};
			if( typeof point2.z === null ){
				return 1;
			};
		};
		return 0;
	};

	function compareMultiPoints(multiPoint1, multiPoint2){
		var geoms1 = multiPoint1.getGeometries();
		var geoms2 = multiPoint2.getGeometries();
		
		return compareCollections(geoms1, geoms2)
	};

	function compareLineStrings(lineString1, lineString2){
		var points1 = lineString1.getPoints();
		var points2 = lineString2.getPoints();
		
		if( points1.length !== points2.length ){
			return points1.length - points2.length;
		};

		for(var i=0,e=points1.length; i<e; ++i){
			var point1 = points1[i];
			var point2 = points2[i];
			
			var c = comparePoints(point1, point2);
			if( 0 !== c ) return c;
		};
		
		return 0;
	};

	function compareMultiLineStrings(multiLineString1, multiLineString2){
		var geoms1 = multiLineString1.getGeometries();
		var geoms2 = multiLineString2.getGeometries();
		
		return compareCollections(geoms1, geoms2)
	};

	function comparePolygons(poly1, poly2){
		var linearRings1 = poly1.getLinearRings();
		var linearRings2 = poly2.getLinearRings();
		
		if( linearRings1.length !== linearRings2.length ){
			return linearRings1.length - linearRings2.length;
		};

		for(var i=0,e=linearRings1.length; i<e; ++i){
			var linearRing1 = linearRings1[i];
			var linearRing2 = linearRings2[i];
			
			var c = compareLineStrings(linearRing1, linearRing2);
			if( 0 !== c ) return c;
		};
		
		return 0;
	};

	function compareMultiPolygons(multiPolygon1, multiPolygon2){
		var geoms1 = multiPolygon1.getGeometries();
		var geoms2 = multiPolygon2.getGeometries();
		
		return compareCollections(geoms1, geoms2)
	};

	function compareCollections(collection1, collection2){
		if( collection1.length !== collection2.length ){
			return collection1.length - collection2.length;
		};
		
		var clone1 = collection1.slice();
		var clone2 = collection2.slice();
		
		clone1.sort(compareGeometries);
		clone2.sort(compareGeometries);

		for(var i=0,e=clone1.length; i<e; ++i){
			var geom1 = clone1[i];
			var geom2 = clone2[i];
			
			var c = compareGeometries(geom1, geom2);
			if( 0 !== c ) return c;
		};
		
		return 0;
	};
};


//=============================================

$n2.geometry = {
	Point: Point
	,LineString: LineString
	,Polygon: Polygon
	,GeometryCollection: GeometryCollection
	,MultiPoint: MultiPoint
	,MultiLineString: MultiLineString
	,MultiPolygon: MultiPolygon
	,WktParser: WktParser
	,compareGeometries: compareGeometries
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.analytics.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.analytics'
;

// *******************************************************
/**
 * This service registers to the dispatcher and sends the appropriate
 * events to Google Analytics if it is installed.
 */
var AnalyticsService = $n2.Class({
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH,'start',f);
			this.dispatchService.register(DH,'selected',f);
		};
	},
	
	_sendEvent: function(action, value){
		if( typeof ga === 'function' ){
			var event = {
				hitType: 'event'
				,eventCategory: 'nunaliit'
				,eventAction: action
			};
			
			if( typeof value === 'number' ){
				event.eventValue = value;
			} else if( typeof value === 'string' ){
				event.eventLabel = value;
			};
			
			ga('send',event);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'start' === m.type ){
			// Record module
			var msg = {
				type: 'moduleGetCurrent'	
			};
			this.dispatchService.synchronousCall(DH,msg);
			if( msg.moduleId ){
				this._sendEvent('module', msg.moduleId);
			};

		} else if( 'selected' === m.type ) {
			if( m.docId ){
				this._sendEvent('selected', m.docId);

			} else if( m.doc && m.doc._id ){
				this._sendEvent('selected', m.doc._id);
			};
		};
	}
});

//*******************************************************
$n2.analytics = {
	AnalyticsService: AnalyticsService
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.custom.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($n2){
"use strict";

// Localization
//var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

// *******************************************************
// Service used to keep track of customizations
var CustomService = $n2.Class({
	
	custom: null,
	
	initialize: function(options_){
//		var options = $n2.extend({
//			directory: null
//		},options_);
		
		if( typeof(window.nunaliit_custom) === 'undefined' ) {
			window.nunaliit_custom = {};
		};

		this.custom = window.nunaliit_custom;
		
		this._check();
	},

	setOption: function(optionName, optionValue){
		this._check();

		this.custom.options[optionName] = optionValue;

		if( !this.custom.info[optionName] ){
			this.custom.info[optionName] = {
				reads: 0
				,writes: 1
			};
		} else {
			++this.custom.info[optionName].writes;
		};
	},
	
	getOption: function(optionName, defaultValue){
		this._check();

		if( !this.custom.info[optionName] ){
			this.custom.info[optionName] = {
				reads: 1
				,writes: 0
			};
		} else {
			++this.custom.info[optionName].reads;
		};
		
		if( typeof this.custom.options[optionName] === 'undefined' ){
			return defaultValue;
		};
		
		return this.custom.options[optionName];
	},
	
	updateOption: function(optionsMap, optionName){
		var value = this.getOption(optionName);
		if( typeof value !== 'undefined' ){
			optionsMap[optionName] = value;
		};
	},
	
	_check: function(){
		if( !this.custom.options ) this.custom.options = {};
		if( !this.custom.info ) this.custom.info = {};
	}
});

//*******************************************************
$n2.custom = {
	CustomService: CustomService
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.customType.js

/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.customType'
;

//*******************************************************
var CustomType = $n2.Class({
	
	dispatchService: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: undefined
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		if( !this.dispatchService ){
			throw new Error('When creating an instance of CustomType, the dispatchService must be provided');
		};
		
		var typeName = this.getTypeName();
		
		this.dispatchService.register(DH, 'showCustom', function(m, addr, dispatcher){
			_this._handleShowCustom(m, addr, dispatcher);
		});

		$n2.schema.registerCustomFieldHandler({
	        customType: typeName // name of custom type
	        ,handler: function(opts_){ // function called when form for custom type is needed
	        	_this.fieldHandler(opts_);
	        }
	    });

	},

	/**
	 * Subclasses should implement this method
	 */
	getTypeName: function(){
		throw new Error('Subclasses of CustomType must implement getTypeName()');
	},
	
	/**
	 * Subclasses should implement this method
	 */
	show: function(opts_){
		var opts = $n2.extend({
    		elem: undefined
    		,doc: undefined
    		,selector: undefined
    		,showService: undefined
    		,m: undefined
		},opts_);
	},
	
	/**
	 * Subclasses should implement this method
	 */
	fieldHandler: function(opts_){
		var opts = $n2.extend({
	        elem: null
	        ,doc: null
	        ,obj: null
	        ,selector: null
	        ,customType: null
	        ,callbackFn: null
		},opts_);
	},
	
	_handleShowCustom: function(m, addr, dispatcher){
	    var $elem = m.elem;
	    var doc = m.doc;
	    var customType = m.customType;
	    var selector = m.selector;
	    var showService = m.showService;
	    
	    var typeName = this.getTypeName();
	    
	    if( typeName == customType ){
	    	this.show({
	    		elem: $elem
	    		,doc: doc
	    		,selector: selector
	    		,showService: showService
	    		,m: m
	    	});
	    };
	}
});

//*******************************************************
$n2.customType = {
	CustomType: CustomType
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.history.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,TYPE_SELECTED = 'x'
,TYPE_MULTI_SELECTED = 'm'
,TYPE_SEARCH = 's'
;

// ======================= HASH ENCODING ==============================
// The hash stored in the URL is a Base64 encoding of a JSON object.
// The JSON object has the following syntax:
// {
//   t: <string, type>
//   ,s: <number, timestamp>
//   ...
// }
//
// where the type (t) is one of
//    'x' for user selection
//    'm' for user multi-selection
//    's' for user search
//
//
// User Selection:
// {
//   t: 'x'  (TYPE_SELECTED)
//   ,s: <number, timestamp>
//   ,i: <string, document id>
// }
//
// This is a user selection for a particular document id.
//
//
// User Multi-Selection:
// {
//   t: 'm'  (TYPE_MULTI_SELECTED)
//   ,s: <number, timestamp>
// }
//
// This is a user selection for multiple document ids. Since the hash
// might not have the capacity to store a long list of document ids, a
// timestamp is stored in the hash, instead. This timestamp is related to
// a list of document identifiers (array) using the session storage.
//
//
// User Search:
// {
//   t: 's'  (TYPE_SEARCH)
//   ,s: <number, timestamp>
//   ,l: <string, search parameters>
// }
//
// This is a user search action. The search line is stored in the
// 'l' key.


//======================= UTILITIES ===================================
function computeHashFromEntry(entry){
	var json = JSON.stringify(entry);
	var hash = $n2.Base64.encode(json);
	return hash;
};
 
function decodeEntryFromHash(hash){
	var entry = undefined;
	
	try {
		var d = $n2.Base64.decode(hash);
		entry = JSON.parse(d);
	} catch(s) {};
	
	return entry;
};

function createNewEntry(entry){
	if( !entry.s ){
		entry.s = (new Date()).getTime();
	};
	return entry;
};

function getCurrentHash(){
	var hash = window.location.hash;
	if( hash ) {
		hash = hash.substr(1); 
	};
	return hash;
};

function getEventFromHash(hash){
	var event = undefined;
	
	if( 'nostate' === hash ){
		// No event
		
	} else if( !hash || '' === hash ){
		event = {
			type: 'unselected'
		};
	} else {
		var entry = decodeEntryFromHash(hash);
		
		if( entry && TYPE_SELECTED === entry.t ){
			var docId = entry.i;
			event = {
				type: 'userSelect'
				,docId: docId
			};

		} else if( entry && TYPE_MULTI_SELECTED === entry.t ){
			var timestamp = entry.s;
			
			var info = getStorageInfo(timestamp);
			var docIds = info.docIds;
			if( !docIds ){
				docIds = [];
			};
			
			event = {
				type: 'userSelect'
				,docIds: docIds
			};
		
		} else if( entry && TYPE_SEARCH === entry.t ){
			var searchLine = entry.l;
			event = {
				type: 'searchInitiate'
				,searchLine: searchLine
			};
		};
	};
	
	return event;
};

function getEventFromHref(href){
	
	var url = new $n2.url.Url({
		url: href
	});
	var hash = url.getHash();
	return getEventFromHash(hash);
};

//======================= HISTORY =====================================
// This class mimicks the information stored in the browser's history.
// This class is needed because deeper queries are needed than what
// is offered by the browsers.

function reloadStoredHistories(){
	var storage = $n2.storage.getSessionStorage();
	var value = storage.getItem('n2_history');
	
	var raw = null;
	try {
		raw = JSON.parse(value);
	} catch(e) {
		raw = {};
	};
	if( !raw ){
		raw = {};
	};
	
	var histories = [];
	for(var sessionId in raw){
		var h = raw[sessionId];
		var history = new History({
			sessionId: sessionId
		});
		history._reloadFromJson(h);
		histories.push(history);
	};
	
	return histories;
};

var History = $n2.Class({
	
	sessionId: null,
	
	dispatchService: null,
	
	entries: null,
	
	currentEntry: null,
	
	lastUpdated: null,

	lastHref: null,

	lastHistorySize: null,
	
	retrievedFromStorage: null,
	
	hint: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			sessionId: undefined
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.sessionId = opts.sessionId;
		this.dispatchService = opts.dispatchService;
		
		this.entries = [];
		this.currentEntry = undefined;
		this.lastHref = undefined;
		this.lastHistorySize = undefined;
		this.lastUpdated = undefined;
		this.retrievedFromStorage = false;
		this.hint = undefined;
		
		if( !this.sessionId ){
			this.sessionId = 's' + (new Date()).getTime();
		};
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			var DH = 'n2.history.History';
			
			this.dispatchService.register(DH,'start',f);
			this.dispatchService.register(DH,'historyHashModified',f);
			this.dispatchService.register(DH,'historyGetState',f);
			this.dispatchService.register(DH,'historyBack',f);
			this.dispatchService.register(DH,'historyForward',f);
		};
	},
	
	saveToStorage: function(){
		function removeOldestEntry(raw){
			var histories = [];
			for(var sessionId in raw){
				var h = raw[sessionId];
				histories.push({
					s: sessionId
					,h: h
				});
			};
			
			histories.sort(function(a,b){
				var aTime = a.h.lastUpdated;
				var bTime = b.h.lastUpdated;
				
				if( aTime < bTime ) -1;
				if( aTime > bTime ) 1;

				return 0;
			});
			
			if( histories.length > 1 ){
				var sessionId = histories[0].s;
				delete raw[sessionId];
				return true;
			};
			
			return false;
		};
		
		// Create object to represent history
		var h = {
			entries: []
			,lastUpdated: this.lastUpdated
		};
		for(var i=0,j=this.entries.length; i<j; ++i){
			var entry = this.entries[i];
			var e = {
				h: entry.href
				,i: entry.historySize
			};
			h.entries.push(e);
		};

		var storage = $n2.storage.getSessionStorage();
		var value = storage.getItem('n2_history');
		
		var raw = null;
		try {
			raw = JSON.parse(value);
		} catch(e) {
			raw = {};
		};
		if( !raw ){
			raw = {};
		};
		
		raw[this.sessionId] = h;

		var newValue = JSON.stringify(raw);
		while( newValue.length > 2000000 ){
			var removed = removeOldestEntry(raw);
			if( removed ){
				newValue = JSON.stringify(raw);
			} else {
				break;
			};
		};
		
		storage.setItem('n2_history', newValue);
	},

	_reloadFromJson: function(h){
		this.entries = [];
		if( h && h.entries ){
			for(var i=0,j=h.entries.length; i<j; ++i){
				var e = h.entries[i];
				var entry = {
					href: e.h
					,historySize: e.i
					,event: getEventFromHref(e.h)
				};
				this.entries.push(entry);
			};
		};
		this.lastUpdated = h.lastUpdated;
	},

	_reloadFromStorage: function(href,historySize){
		var reloaded = false;

		if( !this.retrievedFromStorage ){
			var histories = reloadStoredHistories();
			
			var candidateCount = 0;
			var candidateHistory = undefined;
			var candidateEntry = undefined;
			for(var i=0,j=histories.length; i<j; ++i){
				var history = histories[i];
				var entry = history._entryWithHref(href,historySize);
				if( entry ){
					++candidateCount;
					candidateHistory = history;
					candidateEntry = entry;
				};
			};
			
			if( 1 === candidateCount ){
				if( this.sessionId === candidateHistory.sessionId ){
					// No need to reload. What we found in storage
					// is a copy of this history. What is in memory is
					// fine.
				} else {
					// Adopt this history
					this.sessionId = candidateHistory.sessionId;
					this.lastUpdated = candidateHistory.lastUpdated;
					
					var entries = [];
					for(var i=0,j=candidateHistory.entries.length; i<j; ++i){
						var entry = candidateHistory.entries[i];
						entries.push(entry);
					};
					this.entries = entries;
					this.currentEntry = candidateEntry;

					reloaded = true;
				};

				this.retrievedFromStorage = true;
			};
		};
		
		return reloaded;
	},
	
	_entryWithHref: function(href, historySize){
		var entry = undefined;
		
		for(var i=0,j=this.entries.length; i<j; ++i){
			var e = this.entries[i];
			if( e.href === href ){
				if( e.historySize <= historySize ){
					entry = e;
				};
			};
		};
		
		return entry;
	},
	
	_indexFromEntry: function(entry){
		var index = undefined;
		for(var i=0,j=this.entries.length; i<j; ++i){
			var e = this.entries[i];
			if( e === entry ){
				index = i;
			};
		};
		return index;
	},
	
	_handle: function(m, addr, dispatcher){
		if( m ){
			if( 'historyHashModified' === m.type ){
				this._checkHistoryChange();

			} else if( 'start' === m.type ) {
				this._checkHistoryChange();

			} else if( 'historyGetState' === m.type ) {
				// Synchronous call
				var state = this._computeState();
				m.state = state;

			} else if( 'historyBack' === m.type ) {
				this.hint = 'back';

			} else if( 'historyForward' === m.type ) {
				this.hint = 'forward';
			};
		};
	},
	
	_checkHistoryChange: function(){
		var historySize = undefined;
		if( window && window.history ){
			historySize = window.history.length;
		};
		
		var href = window.location.href;

		if( this.lastHref !== href ){
			this._historyChanged(href, historySize);
		};
	},

	_historyChanged: function(href, historySize){
		function insertNewEntry(history, href, historySize){
			var entry = {
				href: href
				,historySize: historySize
				,event: getEventFromHref(href)
			};
			
			// Replace the entry with the same history index and remove the
			// entries after
			var found = undefined;
			for(var i=0,j=history.entries.length; i<j; ++i){
				var e = history.entries[i];
				if( e.historySize === historySize ){
					found = i;
					break;
				};
			};

			if( typeof found === 'number' ){
				history.entries = history.entries.slice(0,found);
			};
			
			history.entries.push(entry);
			history.currentEntry = entry;
		};

		//$n2.log('historySize:'+historySize+' href:'+href);
		
		// See if we can find the full history from storage
		var reloaded = this._reloadFromStorage(href, historySize);
		if( reloaded ){
			$n2.log('history reloaded from storage');

		} else if( this.lastHistorySize !== historySize ){
			// This happens only when the history is modified
			// Must create a new entry
			insertNewEntry(this, href, historySize);
			
		} else {
			// In general, when the index does not change, it is because
			// the user is moving forward and back through the history
			// Find entries with matching href
			var indices = [];
			var currentIndex = undefined;
			for(var i=0,j=this.entries.length; i<j; ++i){
				var e = this.entries[i];
				if( e.href === href ){
					indices.push(i);
				};
				if( e === this.currentEntry ){
					currentIndex = i;
				};
			};

			if( indices.length < 1 ){
				// Can not find a matching entry. Has the last entry changed?
				// This happens when while the second last href is displayed,
				// a new one is selected
				if( this.currentEntry 
				 && this.currentEntry.historySize === (historySize - 1) ){
					insertNewEntry(this, href, historySize);

				} else {
					// Not sure what to do here
					$n2.log('history problem. Lost position');
				};

			} else {
				// If hint is 'back', then reverse the indices in
				// order to favour indices earlier in the history
				if( 'back' === this.hint ){
					indices.reverse();
				};

				// Find closest entry and make it current
				var minDistance = undefined;
				var minIndex = undefined;
				if( typeof currentIndex === 'number' ){
					for(var i=0,j=indices.length; i<j; ++i){
						var index = indices[i];
						var distance = (index < currentIndex) ?
								currentIndex - index :
								index - currentIndex;
						if( typeof minDistance === 'undefined' ){
							minDistance = distance;
							minIndex = index;

						} else if(distance <= minDistance) {
							minDistance = distance;
							minIndex = index;
						};
					};
				};
				
				if( typeof minIndex === 'number' ){
					var currentEntry = this.entries[minIndex];
					this.currentEntry = currentEntry;
				};
			};
		};
		
		this.lastHref = href;
		this.lastHistorySize = historySize;

		this.lastUpdated = (new Date()).getTime();
		this.saveToStorage();
		this._reportChange();
	},
	
	_computeState: function(){
		var currentIndex = this._indexFromEntry(this.currentEntry);

		var backIsAvailable = false;
		var forwardIsAvailable = false;
		if( typeof currentIndex === 'number' ){
			if( currentIndex > 0 ){
				backIsAvailable = true;
			};
			if( currentIndex < (this.entries.length - 1) ){
				forwardIsAvailable = true;
			};
		};
		
		var state = {
			entries: this.entries
			,currentEntry: this.currentEntry
			,currentIndex: currentIndex
			,backIsAvailable: backIsAvailable
			,forwardIsAvailable: forwardIsAvailable
		};
		
		return state;
	},
	
	_reportChange: function(){
		var state = this._computeState();
		
		var m = {
			type: 'historyReportState'
			,state: state
		};
		this._dispatch(m);
		
		//$n2.log('historyReportState', state);
	},
	
	_dispatch: function(m){
		var d = this.dispatchService;
		if( d ){
			d.send('n2.history.History',m);
		};
	}
});

// ======================= MONITOR ====================================
// Tracks the changes to hash and reports them as dispatcher messages.
// Accepts 'historyBack', 'historyForward' and 'setHash' messages.

var Monitor = $n2.Class({
	
	options: null,
	
	initialize: function(opts_){
		this.options = $n2.extend({
			directory: null
		},opts_);
		
		var _this = this;
		
		if( window && 'onhashchange' in window ) {
			// Supported
			$(window).bind('hashchange',function(e){
				_this._hashChange(e);
			});
		};
		
		var d = this._getDispatcher();
		if( d ){
			var f = function(m){
				_this._handle(m);
			};
			var DH = 'n2.history.Monitor';

			d.register(DH,'historyBack',f);
			d.register(DH,'historyForward',f);
			d.register(DH,'setHash',f);
			d.register(DH,'replaceHash',f);
		};
	},

	_getDispatcher: function(){
		var d = null;
		if( this.options.directory ){
			d = this.options.directory.dispatchService;
		};
		return d;
	},

	_dispatch: function(m){
		var d = this._getDispatcher();
		if( d ){
			d.send('n2.history.Monitor',m);
		};
	},
	
	_hashChange: function(e){
		var hash = getCurrentHash();

		// Report changes in hash from browser
		this._dispatch({
			type: 'hashChanged'
			,hash: hash
		});

		// Event associated with all changes top hash
		this._dispatch({
			type: 'historyHashModified'
			,hash: hash
		});
	},
	
	_handle: function(m){
		if( 'historyBack' === m.type ){
			if( window.history.back ) {
				window.history.back();
			};
			
		} else if( 'historyForward' === m.type ){
			if( window.history.forward ) {
				window.history.forward();
			};
			
		} else if( 'setHash' === m.type ){
			var hash = m.hash;
			if( window.history.pushState ){
				if( hash ) {
					window.history.pushState({},'','#'+hash);
				} else {
					window.history.pushState({},'','#');
				};
			} else {
				if( hash ) {
					window.location = '#'+hash;
				} else {
					window.location = '#';
				};
			};

			this._dispatch({
				type: 'historyHashModified'
				,hash: getCurrentHash()
			});
			
		} else if( 'replaceHash' === m.type ){
			var hash = m.hash;
			if( window.history.replaceState ){
				if( hash ) {
					window.history.replaceState({},'','#'+hash);
				} else {
					window.history.replaceState({},'','#');
				};
			} else {
				if( hash ) {
					window.location = '#'+hash;
				} else {
					window.location = '#';
				};
			};

			this._dispatch({
				type: 'historyHashModified'
				,hash: getCurrentHash()
			});
		};
	}
});
	
//======================= TRACKER ====================================
// Keeps track of currently selected document and encodes it in the
// URL. On hashChanged events, re-selects the document.

var Tracker = $n2.Class({
	
	options: null,
	
	last: null,
	
	waitingDocId: null,
	
	forceHashReplay: null,
	
	initialize: function(opts_){
		this.options = $n2.extend({
			dispatchService: null
			,disabled: false
		},opts_);
		
		var _this = this;
		
		this.last = {};
		this.forceHashReplay = false;
		
		var d = this._getDispatcher();
		if( d ){
			var f = function(m){
				_this._handle(m);
			};
			var DH = 'n2.history.Tracker';

			d.register(DH,'start',f);
			d.register(DH,'hashChanged',f);
			d.register(DH,'userSelect',f);
			d.register(DH,'userSelectCancelled',f); 
			d.register(DH,'unselected',f);
			d.register(DH,'documentCreated',f);
			d.register(DH,'documentUpdated',f);
			d.register(DH,'documentDeleted',f);
			d.register(DH,'searchInitiate',f);
			d.register(DH,'editInitiate',f);
			d.register(DH,'editCreateFromGeometry',f);
			d.register(DH,'editClosed',f);
		};
	},
	
	getForceHashReplay: function(){
		return this.forceHashReplay;
	},
	
	setForceHashReplay: function(flag){
		if( flag ){
			this.forceHashReplay = true;
		} else {
			this.forceHashReplay = false;
		};
	},

	_getDispatcher: function(){
		var d = null;
		if( this.options ){
			d = this.options.dispatchService;
		};
		return d;
	},

	_dispatch: function(m){
		var d = this._getDispatcher();
		if( d ){
			d.send('n2.history.Tracker',m);
		};
	},

	_synchronousCall: function(m){
		var d = this._getDispatcher();
		if( d ){
			d.synchronousCall('n2.history.Tracker',m);
		};
	},
	
	_handle: function(m){
		if( this.options.disabled ){
			return;
		};

		if( 'start' === m.type ){
			var hash = getCurrentHash();
			if( hash && hash !== '') {
				this._dispatch({
					type: 'hashChanged'
					,hash: hash
				});
			};

		} else if( 'userSelect' === m.type ){
			if( m.docId ) {
				this.last = {
					selected: m.docId	
				};
	
				if( !m._suppressSetHash ) {
					var type = 'setHash';
					if( m._replaceHash ) type = 'replaceHash';
					
					var entry = createNewEntry({t:TYPE_SELECTED,i:m.docId});
					var hash = computeHashFromEntry(entry);
					this._dispatch({
						type: type
						,hash: hash
					});

					this.waitingDocId = null;
				};

			} else if( m.docIds ) {
				this.last = {
					multi_selected: m.docIds
				};
	
				if( !m._suppressSetHash ) {
					var type = 'setHash';
					if( m._replaceHash ) type = 'replaceHash';

					// Save doc ids with a session object associated
					// with the timestamp
					var ts = (new Date()).getTime();
					saveStorageInfo(ts, {
						docIds: m.docIds
					});
					
					var entry = createNewEntry({t:TYPE_MULTI_SELECTED,s:ts});
					var hash = computeHashFromEntry(entry);
					this._dispatch({
						type: type
						,hash: hash
					});

					this.waitingDocId = null;
				};
			};

		} else if( 'userSelectCancelled' === m.type ){
			this.last = {
				selectCancel: true
			};

			if( !m._suppressSetHash ) {
				this._dispatch({
					type: 'historyBack'
				});
			};

		} else if( 'unselected' === m.type ){
			this.last = {
				unselected: true	
			};

			if( !m._suppressSetHash ) {
				this._dispatch({
					type: 'setHash'
					,hash: null
				});

				this.waitingDocId = null;
			};

		} else if( 'documentDeleted' === m.type ){
			var deletedDocId = m.docId;
			if( this.last.selected === deletedDocId ){
				this.last = {
					deleted: deletedDocId
				};
				
				this._dispatch({
					type: 'historyBack'
				});
			};

		} else if( 'searchInitiate' === m.type ){
			this.last = {
				search: m.searchLine
			};

			if( !m._suppressSetHash ) {
				var entry = createNewEntry({t:TYPE_SEARCH,l:m.searchLine});
				var hash = computeHashFromEntry(entry);
				this._dispatch({
					type: 'setHash'
					,hash: hash
				});

				this.waitingDocId = null;
			};

		} else if( 'editInitiate' === m.type 
		 ||  'editCreateFromGeometry' === m.type ){
			this.last = {
				edit: true
			};

			this.waitingDocId = null;

			this._dispatch({
				type: 'setHash'
				,hash: 'nostate'
			});

		} else if( 'editClosed' === m.type ) {
			var lastIsEditInitiate = false;
			if( this.last.edit ){
				lastIsEditInitiate = true;
			};
			
			this.last = {
				editClosed: true
			};

			if( m.inserted && !m.submissionDs) {
				// A document was created. Select it so it is reflected in the
				// history hash
				this._dispatch({
					type: 'userSelect'
					,docId: m.doc._id
					,_replaceHash: true
				});

			} else if( m.inserted && m.submissionDs ){
				// For now, go back and wait for document
				if(lastIsEditInitiate) {
					this._dispatch({
						type: 'historyBack'
					});
				};
				
				this.waitingDocId  = m.doc._id;

			} else {
				// cancelled or deleted
				if(lastIsEditInitiate) {
					this._dispatch({
						type: 'historyBack'
					});
				};
			};

		} else if( 'hashChanged' === m.type ){
			var o = null;

			if( !this.last.editClosed ){
				this.waitingDocId = null;
			};
			
			if( 'nostate' === m.hash ){
				// Do not do anything
				
			} else {
				var c = {
					type: 'historyIsHashChangePermitted'
					,permitted: true
				};
				this._synchronousCall(c);
				
				if( c.permitted ){
					if( '' === m.hash || !m.hash ){
						if( !this.last.unselected ){
							this._dispatch({
								type: 'unselected'
								,_suppressSetHash: true
							});
						};
						
					} else  {
						// Attempt to interpret hash
						this._reloadHash(m.hash);
					};					
				} else {
					// Go back to edit state
					this._dispatch({
						type: 'historyForward'
					});
				};
			};

		} else if( 'documentCreated' === m.type 
		 || 'documentUpdated' === m.type ){
			if( m.docId && m.docId === this.waitingDocId ){
				// OK, we have been waiting for this document. Select it
				this._dispatch({
					type: 'userSelect'
					,docId: m.docId
				});
			};
		};
	},
	
	_reloadHash: function(hash){
		var m = getEventFromHash(hash);
		
		if( m ){
			m._suppressSetHash = true;
			
			if( 'userSelect' === m.type
			 && typeof m.docId === 'string'
			 && this.last.selected === m.docId ){
				// Do not replay selection if already selected
				if( this.forceHashReplay ){
					// Unless specifically requested
					this._dispatch(m);
				};

			} else {
				this._dispatch(m);
			};
		};
	}
});

// ======================= SESSION STORAGE ========================
// Handle saving information relating to a URL

function getStorageInfo(timestamp){
	var storage = $n2.storage.getSessionStorage();
	var value = storage.getItem('n2_historyHash');
	if( !value ){
		return {};
	};
	
	var raw = null;
	try {
		raw = JSON.parse(value);
	} catch(e) {
		$n2.log('Error parsing history hash(1):'+value);
		raw = {};
	};
	if( !raw ){
		raw = {};
	};
	
	var info = raw[''+timestamp];
	if( !info ){
		return {};
	};
	return info;
};

function saveStorageInfo(timestamp, info){
	$n2.log('Save hash '+timestamp);
	var storage = $n2.storage.getSessionStorage();
	var value = storage.getItem('n2_historyHash');
	
	var raw = null;
	try {
		raw = JSON.parse(value);
	} catch(e) {
		$n2.log('Error parsing history hash(2):'+value);
		raw = {};
	};
	if( !raw ){
		raw = {};
	};
	
	raw[''+timestamp] = info;
	var newValue = JSON.stringify(raw);
	while( newValue.length > 2000000 ){
		_removeOldestEntry(raw);
		newValue = JSON.stringify(raw);
	};
	
	storage.setItem('n2_historyHash', newValue);

	return value;
};

function _removeOldestEntry(raw){
	var oldestKey = null;
	for(var key in raw){
		if( !oldestKey ){
			oldestKey = key;
		} else if( key < oldestKey ) {
			oldestKey = key;
		};
	};
	if( oldestKey ){
		delete raw[oldestKey];
	};
};

//======================= EXPORT ++++++++++========================
$n2.history = {
	Monitor: Monitor
	,Tracker: Tracker
	,History: History
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.tree.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };
	
/*

This portion of the script deals with basic trees. A tree is a HTML structure
that contains nested UL and LI tags.

<ul class="tree">
	<li>
		<span>1</span>
	</li>
	<li>
		<span>2</span>
		<ul>
			<li>
				<span>2.1</span>
			</li>
			<li>
				<span>2.2</span>
			</li>
		</ul>
	</li>
</ul>

The top ul tag is called the "root" of the tree.

During initialization, the tree is modified to look like this:

<ul id="tree5" class="tree">
	<li class="treeHideChildren treeNoChildren">
		<div class="treeExpand"></div>
		<span class="treeKey">1</span>
	</li>
	<li class="treeHideChildren">
		<div class="treeExpand"></div>
		<span class="treeKey">2</span>
		<ul class="treeChildren">
			<li class="treeHideChildren">
				<div class="treeExpand"></div>
				<span class="treeKey">2.1</span>
			</li>
			<li class="treeHideChildren">
				<div class="treeExpand"></div>
				<span class="treeKey">2.2</span>
			</li>
		</ul>
	</li>
</ul>

Here is the meaning of the classes:
- tree : Assign to ul element which is the tree root. Assigned externally.
- treeKey : Assigned to first span element in li elements. This is the key shown.
- treeChildren : Assigned to ul elements in li elements. Represents that the element
                 contains the children of the node.
- treeExpand : Assigned to first div element in li element. This div should display
               the icon for expanding/collapsing the tree node.
- treeNoChildren : Assigned to li element when it contains no children
- treeShowChildren : Assigned when the user has decided to show children from node.
- treeHideChildren : Assigned when the user has decided to hide the children.
- treeClickInstalled : Assigned to all elements that have a 'click' event bound by
                       the tree script

Usage:

	var tree = new $n2.tree.Tree($('#tree5'), options);

 */	
	
var treeUuid = 1;

/**
 * Given any element from a tree, this function returns
 * the top-most ul tag in a jQuery set.
 * @param {Object} $elem A DOM node of a jQuery set containing a DOM node.
 * @return {Object} A jQuery set containing the root element of the tree. Null
 *                  if not found.
 */
function findTreeRoot($elem) {
	if( !$elem.jquery ) {
		$elem = $(elem);
	};
	if( $elem.length > 1 ) {
		$elem = $(elem).first();
	};
	if( $elem.hasClass('tree') ) {
		return $elem;
	};
	var parent = $elem.parent();
	if( parent.length > 0 ) {
		return findTreeRoot(parent);
	}
	return null;
};

/**
 * Returns the unique identifier assigned to a tree. This number
 * should not change throughout the life of the tree.
 * @param {Object} elem A DOM node or a jQuery set containing a DOM node which is 
 *                      located within the tree.
 * @return {Integer} The unique identifier. -1 if the tree root is not found.
 */
function getTreeUuid(elem) {
	var $tree = findTreeRoot(elem);
	if( !$tree ) {
		return -1;
	}
	return $tree[0]['treeUuid'];
};

/**
 * Returns the 'id' attribute of the tree root.
 * @param {Object} elem A DOM node or a jQuery set containing a DOM node which is 
 *                      located within the tree.
 * @return {Integer} The DOM identifier. Null if the tree root is not found.
 */
function getTreeId(elem) {
	var $tree = findTreeRoot(elem);
	if( !$tree ) {
		$n2.log('tree getTreeId(): can not find tree root');
		return null;
	}
	return $tree.attr('id');
};

/**
 * Returns the 'li' element where the given node is located. This function
 * travels up the DOM tree until it finds the 'li' element managed by the tree
 * and returns it.
 * @param {Object} elem A DOM node or a jQuery set containing a DOM node which is 
 *                      located within the tree.
 * @return {Object} A jQuery set containing the 'li' element. Null if the 
 *                  'li' element can not be found.
 */
function findLiFromElement(elem) {
	if( !elem.jquery ) {
		elem = $(elem);
	};
	
	if( elem.length < 1 ) {
		return null;
	};
	
	if( elem[0].nodeName.toLowerCase() === 'li' ) {
		return elem;
	};

	return findLiFromElement(elem.parent());
}


/**
	This function adjusts the following classes:
	treeHideChildren, treeShowChildren.
	
	If treeHideChildren is set, it removes treeHideChildren and add
	treeShowChildren. If treeShowChildren is set, it removes 
	treeShowChildren and add treeHideChildren. This way, it toggles
	the visibility of the children.
	
	@name toggleHideChildren
	@function
	@memberOf nunaliit2.tree
*/
function toggleHideChildren($li) {
	var isHidden = $li.hasClass('treeHideChildren');
	if( isHidden ) {
		$li.removeClass('treeHideChildren');
		$li.addClass('treeShowChildren');
	} else {
		$li.addClass('treeHideChildren');
		$li.removeClass('treeShowChildren');
	};
};

/**
	This function is called when a plus/minus sign is clicked
	on the tree. It toggles the children visibility.
	@name liOpenClose
	@function
	@memberOf nunaliit2.tree
*/
function liOpenClose() {
	// "this" is the element that was clicked
	var $li = findLiFromElement(this);
	toggleHideChildren($li);
};

/**
	This function is called when a tree key is clicked.
	The callback specified in the options (onKeyClick) is 
	executed. If the callback returns true, the node is
	toggle (expanding/collapsing).
	
	@name keyClicked
	@function
	@memberOf nunaliit2.tree
*/
function keyClicked(span, opt) {
	var $li = findLiFromElement(span);
	
	var toggle = opt.onKeyClick($li);
	if( toggle ) {
		toggleHideChildren($li);
	};
};

var treeDefaultOptions = {
	allClosed: true
	,onKeyClick: function($li){ return true; }
};

/**
	Takes a jQuery object containing a tree root
	(<ul class="tree">) and
	installs the appropriate classes and functions to
	make it behave like a tree structure. An identifier is
	assigned, if one does not already exist. It also
	assigns to the tree root element a unique identifier (uuid)
	saved under the attribute called 'treeUuid'. After this is done,
	it calls tree_refresh().
	@name tree.init
	@function
	@memberOf nunaliit2
	@param {Object} $tree A jQuery object that contains the head of
	                the tree.
	@param {Object} opt Options for generating the tree
*/
function tree_init($tree, opt) {
	//var opt = $.extend({},treeDefaultOptions,opt_);

	$tree.each(function(){
		var uuid = this['treeUuid'];
		if( !uuid ) {
			uuid = treeUuid;
			++treeUuid;
			this['treeUuid'] = uuid;
		};
		
		var $this = $(this);
		var id = $this.attr('id');
		if( !id 
		 || typeof(id) === 'undefined' ) {
			id = 'tree_'+uuid;
			$this.attr('id',id);
		};
	});
	
	tree_refresh($tree,opt);
};

/**
	Takes a jQuery object containing a tree root
	(<ul class="tree">) and adds the appropriate elements
	to make it work as a tree. It also binds appropriate callbacks
	for expanding/collapsing the tree nodes.
	This function should be called whenever the tree is modified
	by an external entity.
	@name tree_refresh
	@function
	@memberOf nunaliit2.tree
	@param {Object} $tree A jQuery object that contains the root of
	                the tree.
	@param {Object} opt Options for generating the tree
*/
function tree_refresh($tree, opt) {
	//var opt = $.extend({},treeDefaultOptions,opt_);

	$tree.find('li').each(function(j,li){
		var $li = $(li);
		
		// li.treeEditAdd are not real leaves
		if( false == $li.hasClass('treeEditAdd') ) {
			var divSymbol = $li.children('div.treeExpand');
			if( divSymbol.length < 1 ) {
				divSymbol = $('<div class="treeExpand"></div>');
				$li.prepend(divSymbol);
			};
			if( false == divSymbol.hasClass('treeClickInstalled') ) {
				divSymbol.click(liOpenClose);
				divSymbol.addClass('treeClickInstalled');
			};
			
			var firstSpan = $li.children('span').first();
			if( false == firstSpan.hasClass('treeKey') ) {
				firstSpan.addClass('treeKey');
			};
			if( false == firstSpan.hasClass('treeClickInstalled') ) {
				firstSpan.click(function(){
					keyClicked(this,opt);
				});
				firstSpan.addClass('treeClickInstalled');
			};
			
			$li.children('ul').addClass('treeChildren');
			
			// Redo the query, because object code might add other children
			if( $li.children('.treeChildren').length > 0 ) {
				$li.removeClass('treeNoChildren');
			} else {
				$li.addClass('treeNoChildren');
			};
			
			if( false == $li.hasClass('treeHideChildren')
			 && false == $li.hasClass('treeShowChildren') ) {
				// This li element has never been visited. Give
				// it a state according to options
				if( opt.allClosed ) {
					$li.addClass('treeHideChildren');
				} else {
					$li.addClass('treeShowChildren');
				};
			};
		};
	});
};

var Tree = $n2.Class({
	treeId: null
	
	,options: null
	
	,initialize: function($tree, opt_){
		this.options = $.extend(
			{}
			,treeDefaultOptions
			,opt_
			);
		
		tree_init($tree, this.options);
		
		this.treeId = getTreeId($tree);
	}

	,getRoot: function() {
		var $tree = $('#'+this.treeId);
		
		if( $tree.length != 1 ) {
			$n2.log('Tree.getRoot(): id not found: '+this.treeId);
			return null;
		};
		
		return $tree;
	}

	,getId: function() {
		return this.treeId;
	}
	
	,refresh: function() {
		var $tree = this.getRoot();
		if( $tree ) {
			tree_refresh($tree, this.options);
		};
	}
});

/*
 OBJECT SUPPORT
 
 This portion of the script deals with making trees based on
 the structure of javascript objects.
 
 This code is based on the basic trees (as shown above) but it adds
 elements and bread crumbs (attributes to the elements) to synchronize
 the tree and the memory object.

 A tree created based on a javascript object as a structure like this:

 <ul id="tree5" class="tree">
	<li id="tree5_a" class="treeHideChildren treeNoChildren">
		<div class="treeExpand"></div>
		<span class="treeKey">a</span>
		<span class="treeValue">b</span>
	</li>
	<li id="tree5_arr" class="treeShowChildren">
		<div class="treeExpand"></div>
		<span class="treeKey">arr</span>
		<span class="treeValue">[1,2]</span>
		<ul class="treeChildren">
			<li id="tree5_arr_0" class="treeHideChildren treeNoChildren">
				<div class="treeExpand"></div>
				<span class="treeKey">0</span>
				<span class="treeValue">1</span>
			</li>
			<li id="tree5_arr_1" class="treeHideChildren treeNoChildren">
				<div class="treeExpand"></div>
				<span class="treeKey">1</span>
				<span class="treeValue">2</span>
			</li>
		</ul>
	</li>
	<li id="tree5_obj" class="treeShowChildren">
		<div class="treeExpand"></div>
		<span class="treeKey">obj</span>
		<span class="treeValue">{"desc":"A very long descri...</span>
		<ul class="treeChildren">
			<li id="tree5_obj_desc" class="treeHideChildren treeNoChildren">
				<div class="treeExpand"></div>
				<span class="treeKey">desc</span>
				<span class="treeValue">"A very long description..."</span>
				<div class="treeChildren">"A very long description might be truncated in the value field."</div>
			</li>
		</ul>
	</li>
</ul>

the tree above was generated from the following object:

{
	"a":"b"
	,"arr": [1,2]
	,"obj": {
		"desc":"A description"
	}
}

This tree differs from the basic tree as follows:
- 'id' attributes are added to each li element. The 'id' attribute
  represents the location of the associated data in the object structure.
  It is a concatenation of the data selector and all selectors of the parent
  data structures. Finally, the id is concatenated with the tree uuid to ensure
  a unique identifier. Given a tree uuid and a set of selectors, it is possible
  to retrieve the li element which is the node for the associated data.
- An element <span class="treeValue"/> is added to each node. This contains the
  value of the data if the node is scalar (null, number, string). This element contains
  a preview of the children data in other cases. The size of this value is limited,
  so if a scalar data prints too long, it is truncated.
- An element <div class="treeChildren"/> is added to a node if a scalar is too long to
  be displayed in a value field (span.treeValue).
- An attribute called 'treeArrayIndex' is added to li elements that represent data
  structures within an array. This attribute is an integer and is the index within
  the array where the data structure is located.
- An attribute called 'treeObjectKey' is added to li elements that represent data
  structures within an object. This attribute is a string and is the key within
  the object where the data structure is located.

An object selector is an array of strings and numbers. Each element of the array
represent a key from an object or an index from an array. The order in the array
represents the selections required from the top of the object to access a given
data structure within the object. For example, take the following javascript object:

 {
 	"a": "b"
 	,"arr": [
 		0
 		,1
 		,{
 			"desc": "A description"
 		}
 	]
 }
 
 The string "A description" would be access with the following selector:
 	["arr",2,"desc"]

Usage:

	<div id="container"></div>
	
	var obj = {...};
	
	var objectTree = new $n2.tree.ObjectTree($('#container'), obj, options);

 */

/**
 * Given a li element, find the object selector it represents.
 * @param $li {Object} A jQuery set containing the li element for
 *                     which the selectors are seeked.
 * @return {Array} An array of strings and numbers that are the appropriate
 *                 selectors. 
 */
function computeSelectors($li) {

	if( $li.length != 1 ) return null;
	
	// Walk up tree
	var selectors = [];
	if( false == innerCompute($li, selectors) ) {
		return null;
	};
	return selectors;
	
	function innerCompute($li, selectors) {
		var $ul = $li.parent();
		if( $ul.length > 0 && false == $ul.hasClass('tree') ) {
			// First, insert parent's selector
			var $parentLi = $ul.parent();
			if( false == innerCompute($parentLi, selectors) ) {
				return false;
			};
		};
		
		// Add this selector
		var liElem = $li[0];
		if( typeof(liElem['treeArrayIndex']) !== 'undefined' ) {
			selectors.push( 1 * liElem['treeArrayIndex'] );
			return true;
			
		} else if( typeof(liElem['treeObjectKey']) !== 'undefined' ) {
			selectors.push( liElem['treeObjectKey'] );
			return true;
			
		} else {
			// Error
			return false;
		};
	};
};

/**
 * Given a string, converts it so that it is acceptable as an HTML
 * identifier or class.
 * @param s {String} String to be converted.
 * @return {String} Version of the string that is acceptable as a
 *                   HTML identifier or class.
 */
function stringToHtmlId(s){
	if( typeof(s) === 'string' ) {
		var res = [];
		for(var i=0,e=s.length; i<e; ++i) {
			var c = s[i];
			if( c >= 'a' && c <= 'z' ) { res.push(c); }
			else if( c >= 'A' && c <= 'Z' ) { res.push(c); }
			else if( c >= '0' && c <= '9' ) { res.push(c); }
			else {
				var code = c.charCodeAt(0);
				var o0 = (code & 0x07) + 0x30;
				var o1 = ((code >> 3) & 0x07) + 0x30;
				var o2 = ((code >> 6) & 0x07) + 0x30;
				res.push('_');
				res.push( String.fromCharCode(o2) );
				res.push( String.fromCharCode(o1) );
				res.push( String.fromCharCode(o0) );
			};
		};
		return res.join('');
		
	} else if( typeof(s) === 'number' ){
		return ''+s;
		
	} else {
		return '';
	};
};

/**
 * Computes a valid id for a given set of selectors.
 * @param uuid {Integer} Unique identifier of the tree where the 
 *                       id is computed.
 * @param selectors {Array} Object selector
 * @return {String} Identifier that should be used to uniquely identify
 *                  the selected object within a tree.
 */
function computeId(uuid, selectors) {
	var escapedSelectors = [];
	for(var i=0,e=selectors.length;i<e;++i){
		escapedSelectors.push( stringToHtmlId(selectors[i]) );
	};
	var id = 'tree'+uuid+'_'+escapedSelectors.join('_');
	return id;
};

/**
 * Computes a valid class for a given set of selectors.
 * @param selectors {Array} Object selector
 * @return {String} Class name that should be used to uniquely identify
 *                  the selected object within a tree.
 */
function computeClass(selectors) {
	var escapedSelectors = [];
	for(var i=0,e=selectors.length;i<e;++i){
		escapedSelectors.push( stringToHtmlId(selectors[i]) );
	};
	var cName = 'tree_sel_'+escapedSelectors.join('_');
	return cName;
};

/**
 * Generates ids for each li elements given in argument, and sets them
 * accordingly. This functions assumes that all li elements are from the
 * same tree structure.
 * @param $allLis {Object} A jQuery set containing all li elements where
 *                         ids should be generated.
 */
function fixIds($allLis) {
	var uuid = null;
	
	$allLis.each(function(){
		var $li = $(this);
		var selectors = computeSelectors($li);
		if( !uuid ) {
			uuid = getTreeUuid($li);
		};
		
		var id = computeId(uuid, selectors);
		$li.attr('id',id);
	});
}

/**
 * Finds and returns the li elements that is associated with
 * an object selector.
 * @param $tree {Object} A jQuery set that contains the tree root
 * @param selectors {Array} An object selector
 * @return {Object} A jQuery set that contains 0 or 1 element. If an element
 *                  is returned, it is the element associated with the
 *                  given selector.
 */
function findLiFromSelectors($tree, selectors) {
	var uuid = getTreeUuid($tree);
	var id = computeId(uuid, selectors);
	var $li = $tree.find('#'+id);
	return $li;
}

/**
 * Finds and returns a data structure from within an object 
 * that corresponds to the given object selector.
 * @param o {Object} An object where the structure is seeked
 * @param selectors {Array} An object selector
 * @return {Object} An object which is the inner structure found within
 *                  the given object that corresponds to the given
 *                  selector. Null is returned if nothing is found.
 */
function findDataFromObject(o, selectors) {
	if( null === selectors
	 || 0 === selectors.length ) {
		return o;
	};
	
	// This is an error. There are more
	// selectors in the array but we have
	// a scalar. Return an error.
	if( null == o
	 || typeof(o) === 'number' 
	 || typeof(o) === 'string'
	 || typeof(o) === 'undefined'
	 || typeof(o) === 'function' ) {
		return null;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[0];
		if( index >= o.length ) {
			return null;
		};
		if( selectors.length < 2 ) {
			return o[index];
		};
		return findDataFromObject(o[index], selectors.slice(1));
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[0];
		var value = o[key];
		if( value === undefined ) {
			return null;
		};
		if( selectors.length < 2 ) {
			return value;
		};
		return findDataFromObject(value, selectors.slice(1));
	};
	
	// Should not get here. Error. Return null.
	return null;
};

/**
 * Sets a data structure in an object at the position
 * represented by the given selector.
 * @param o {Object} The object where the data must be inserted
 * @param selectors {Array} An object selector that represents
 *                          the position where the new data structure
 *                          should be inserted.
 * @param data {Object} Data structure that should be inserted.
 * @return {Boolean} Returns true if the data structure was inserted. 
 */
function setObjectData(o, selectors, data) {
	if( null === selectors
	 || 0 === selectors.length ) {
		return false;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[0];
		if( index >= o.length ) {
			return false;
		};
		if( selectors.length > 1 ) {
			return setObjectData(o[index], selectors.slice(1), data);
		};
		o[index] = data;
		return true;
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[0];
		if( selectors.length == 1 ) {
			o[key] = data;
			return true;
		}
		var value = o[key];
		if( value === undefined ) {
			return false;
		};
		return setObjectData(value, selectors.slice(1), data);
	};
	
	return false;
};

/**
 * Removes a data structure from an object, given a selector.
 * @param o {Object} Object to be modified
 * @param selectors {Array} Position in the object that should be removed.
 * @return {Boolean} True if the deletion was possible
 */
function deleteObjectData(o, selectors) {
	if( null === selectors
	 || 0 === selectors.length ) {
		return false;
	};
	
	if( o === null ) {
		return false;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[0];
		if( index >= o.length ) {
			return false;
		};
		if( selectors.length > 1 ) {
			return deleteObjectData(o[index], selectors.slice(1));
		};
		// Remove this index
		o.splice(index,1);
		return true;
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[0];
		var value = o[key];
		if( value === undefined ) {
			return false;
		};
		if( selectors.length > 1 ) {
			return deleteObjectData(value, selectors.slice(1));
		};
		delete o[key];
		return true;
	};
	
	return false;
};

/**
 * This functions performs a pretty print of the a given
 * data structure, to a maximum length. It attempts to
 * print in JSON format, however is meant for human consumption.
 * @param data {Object} The data structure to be printed
 * @param maxLen {Integer} The maximum size of the desired string
 * @return {String} A pretty print of the given data structure.
 */
function print(data, maxLen) {
	
	var arr = [];
	innerPrint(data, arr, 0, maxLen);
	return arr.join('');
	
	function innerPrint(data, arr, len, max) {
		if( data === null ) {
			var value = 'null';
			arr.push(value);
			return value.length;
			
		} else if( typeof(data) === 'number' ) {
			var value = ''+data;
			arr.push(value);
			return value.length;

		} else if( typeof(data) === 'string' ) {
			var value = '"'+data+'"';
			arr.push(value);
			return value.length;

		} else if( typeof(data) === 'boolean' ) {
			var value = ''+data;
			arr.push(value);
			return value.length;

		} else if( $n2.isArray(data) ) {
			var myLen = 1;
			arr.push('[');
			for(var i=0,e=data.length; i<e; ++i) {
				if( 0 != i ) {
					arr.push(',');
					++myLen;
				};
				var obj = data[i];
				var innerLen = innerPrint(obj, arr, len+myLen, max);
				myLen += innerLen;
				if( myLen + len >= maxLen ) return myLen;
			}
			arr.push(']');
			++myLen;
			return myLen;
			
		} else if( typeof(data) === 'object' ) {
			var myLen = 1;
			arr.push('{');
			var keys = [];
			for(var key in data) {
				keys.push(key);
			}
			keys.sort();
			for(var i=0,e=keys.length; i<e; ++i) {
				if( 0 != i ) {
					arr.push(',');
					++myLen;
				};
				
				var key = keys[i];
				arr.push(key);
				arr.push(':');
				myLen += key.length + 1;
				
				var obj = data[key];
				var innerLen = innerPrint(obj, arr, len+myLen, max);
				myLen += innerLen;
				if( myLen + len >= maxLen ) return myLen;
			}
			arr.push('}');
			++myLen;
			return myLen;
		}
		
		return 0;
	}
}

/**
 * Creates a pretty print string of the given data
 * according to the options. The returned string is limited
 * to the maximum length specified in the options. If the
 * maximum length is exceeded, the string is truncated and
 * ellipsis are added.
 * @param data {Object} Data structure to be pretty printed
 * @param opt {Object} Options to be used
 * @return {String} String that can be used in <span.treeValue>
 */
function createDisplayFromData(data, opt) {
	var result = {truncated:false};
	var frags = [];
	
	if( opt.valueSeparator ) {
		frags.push(opt.valueSeparator);
	};
	
	var maxLen = opt.valueMaxLen - opt.valueEllipsis.length;
	
	var value = print(data, maxLen);
	if( value.length > maxLen ) {
		value = value.substr(0,maxLen) + opt.valueEllipsis;
		result.truncated = true;
	};
		
	frags.push(value);
	
	result.str = frags.join('');
	
	return result;
};

/**
 * Updates a ul element based on an object.
 * @param o {Object} Data structure used to update the ul element
 * @param selectors {Array} Object selector to identify the data structure
 * @param $ul {Object} A jQuery set that holds the ul element
 * @param opt {Object} Options in use
 * @param ancestors {Array} Objects that are ancestors of the current data structure.
 * This is used to detect cyclic strctures.
 */
function refreshUlFromObject(o, selectors, $ul, opt, ancestors) {
	//$n2.log('refreshUlFromObject',o, selectors, $ul, opt, ancestors);

	var uuid = getTreeUuid($ul);

	// Remove all elements that are no longer in object (in case object has shrunk)
	$ul.children('li').each(function(i,elem){
		if( $(this).hasClass('treeEditAdd') ) {
			// Skip li added by editor
		} else {
			var key = this['treeObjectKey'];
			if( null == key ) {
				$(this).remove();
			} else if( typeof(o[key]) === 'undefined' ) {
				$(this).remove();
			};
		};
	});
	
	var keys = [];
	for(var key in o) {
		keys.push(key);
	};
	keys.sort();

	for(var i=0,e=keys.length; i<e; ++i) {
		var key = keys[i];
		var value = o[key];
		
		if( ancestors.indexOf(value) >= 0 ){
			// This value is cyclic. Skip
		} else {
			selectors.push(key);
			ancestors.push(value);
			
			var id = computeId(uuid, selectors);
			var cName = computeClass(selectors);
			
			// Find li corresponding to key
			var $li = $ul.children('#'+id);
			if( $li.length < 1 ) {
				$li = $('<li>')
					.attr('id',id)
					.addClass('tree_sel '+cName);
				$('<span>')
					.addClass('treeKey')
					.text(key)
					.appendTo($li);
				$li[0]['treeObjectKey'] = key;
				$ul.append($li);
			};
			
			refreshLiFromData(value, selectors, $li, opt, ancestors);
			
			ancestors.pop();
			selectors.pop();
		};
	};
};

/**
 * Updates a ul element based on an array.
 * @param arr {Array} Array used to update the ul element
 * @param selectors {Array} Object selector to identify the array
 * @param $ul {Object} A jQuery set that holds the ul element
 * @param opt {Object} Options in use
 * 
 */
function refreshUlFromArray(arr, selectors, $ul, opt, ancestors) {
	//$n2.log('refreshUlFromArray',arr, selectors, $ul, opt, ancestors);	

	var uuid = getTreeUuid($ul);

	// Remove all elements that are no longer in array (in case array has shrunk)
	$ul.children('li').each(function(i,elem){
		if( $(this).hasClass('treeEditAdd') ) {
			// Skip li added by editor
		} else {
			var index = this['treeArrayIndex'];
			if( typeof(index) != 'number' ) {
				$(this).remove();
			} else if( index >= arr.length || index < 0 ) {
				$(this).remove();
			};
		};
	});

	for(var key=0,e=arr.length; key<e; ++key) {
		var value = arr[key];
		
		if( ancestors.indexOf(value) >= 0 ){
			// Cyclic structure detected. Skip
		} else {
			selectors.push(key);
			ancestors.push(value);
			
			var id = computeId(uuid, selectors);
			var cName = computeClass(selectors);
			
			// Find li based on id
			var $li = $ul.children('#'+id);
			if( $li.length < 1 ) {
				// Must create
				$li = $('<li>')
					.attr('id',id)
					.addClass('tree_sel '+cName);
				$('<span>')
					.addClass('treeKey')
					.text(key)
					.appendTo($li);
				$li[0]['treeArrayIndex'] = key;
				$ul.append($li);
			};

			refreshLiFromData(value, selectors, $li, opt, ancestors);
			
			ancestors.pop();
			selectors.pop();
		};
	};
};


/**
 * Updates a li element based on an object it represents.
 * @param data {Object} Object represented by li element. This could
 *                      be a scalar (null, string, number) or a
 *                      structure (object, array).
 * @param selectors {Array} Object selector to identify the object
 * @param $li {Object} A jQuery set that holds the li element
 * @param opt {Object} Options in use
 * @param ancestors {Array} Objects that are ancestors of the current data structure.
 * This is used to detect cyclic strctures.
 */
function refreshLiFromData(data, selectors, $li, opt, ancestors) {
	//$n2.log('refreshLiFromData',data, selectors, $li, opt, ancestors);	
	
	// Figure out if we should display a value
	var disp = null;
	if( opt.valueDisplayFn ) {
		disp = opt.valueDisplayFn(data, opt);
	};

	// Show value, if desired
	var $valueSpan = $li.children('span.treeValue');
	if( disp ) {
		if( $valueSpan.length > 0 ) {
			$valueSpan.text(disp.str);
		} else {
			$valueSpan = $('<span class="treeValue"></span>');
			$valueSpan.text(disp.str);
			var $keySpan = $li.children('.treeKey');
			$valueSpan.insertAfter($keySpan);
		};
	} else {
		// Values should not be displayed. If one is
		// already there (not likely), remove it.
		$valueSpan.remove();
	};
	
	// Select what to do based on type of data
	if( data === null ) {
		var $childrenElem = $li.children('.treeChildren');
		$childrenElem.remove();
		
	} else if( typeof(data) === 'string' ) {
		$li.children('.treeChildren').remove();
		if( disp ) {
			if( disp.truncated ) {
				// Display truncated in span.treeValue. Add child to see whole content
				var ul = $('<div class="treeChildren"></div>');
				ul.text(data);
				$li.append(ul);
			};
		};
		
	} else if( typeof(data) === 'number'
	 || typeof(data) === 'boolean' ) {
		$li.children('.treeChildren').remove();
		if( disp ) {
			if( disp.truncated ) {
				// Display truncated in span.treeValue. Add child to see whole content
				var ul = $('<div class="treeChildren">'+data+'</div>');
				$li.append(ul);
			};
		};

	} else if( $n2.isArray(data) ) {
		// Find ul that holds children
		var $ul = $li.children('.treeChildren');
		if( $ul.length > 0 ) {
			// Check that it is a ul tag
			if( $ul[0].nodeName.toLowerCase() !== 'ul' ) {
				$ul.remove();
				$ul = null;
			};
		};
		if( !$ul || $ul.length < 1 ) {
			// Add one
			$ul = $('<ul class="treeChildren"></ul>');
			$li.append($ul);
		};
		
		refreshUlFromArray(data, selectors, $ul, opt, ancestors);

	} else if( typeof(data) === 'object' ) {
		// object
		// Find ul that holds children
		var $ul = $li.children('.treeChildren');
		if( $ul.length > 0 ) {
			// Check that it is a ul tag
			if( $ul[0].nodeName.toLowerCase() !== 'ul' ) {
				$ul.remove();
				$ul = null;
			};
		};
		if( !$ul || $ul.length < 1 ) {
			// Add one
			$ul = $('<ul class="treeChildren"></ul>');
			$li.append($ul);
		};

		refreshUlFromObject(data, selectors, $ul, opt, ancestors);
		
	} else {
		// This is not a handled type (function?). Remove children,
		// if any
		$li.children('.treeChildren').remove();
	};
};

var createFromObjDefaultOptions = {
	valueDisplayFn: createDisplayFromData
	,valueSeparator: ' : '
	,valueEllipsis: '...'
	,valueMaxLen: 30
};

/**
	Creates a tree from the structure of an object. The
	generated tree reflects the keys and values found
	in the object.
	@name createTreeFromObject
	@function
	@memberOf nunaliit2.tree
	@param {Object} $treeContainer A jQuery object that contains
		the element that should receive the tree.
	@param {Object} o The javascript object which is source to the
		tree.
	@param {Object} opt Options for generating the tree
*/
function createTreeFromObject($treeContainer, o, opt) {

	$treeContainer.empty();
	var $tree = $('<ul class="tree"></ul>')
		.appendTo($treeContainer);
	
	tree_init($tree,opt);
	
	var selectors = [];

	refreshUlFromObject(o,selectors,$tree,opt,[]);
	tree_refresh($tree,opt);
	
	return $tree;
	
};

/**
 * Given an existing object tree and its associated
 * object, updates the tree to reflect changes that
 * occurred in the object.
 * @param $tree {Object} A jQuery set that holds the root
 *                       of the tree.
 * @param o {Object} Javascript object that should be used
 *                   to update the tree structure
 * @param opt {Object} Options to be used
 */
function refreshTreeFromObject($tree, o, opt) {

	var selectors = [];

	refreshUlFromObject(o,selectors,$tree,opt,[]);
	tree_refresh($tree,opt);
	
	return $tree;
};

var ObjectTree = $n2.Class({
	treeId: null
	
	,options: null
	
	,obj: null
	
	,initialize: function($treeContainer, obj, opt_){
		this.options = $.extend(
			{}
			,treeDefaultOptions
			,createFromObjDefaultOptions
			,opt_
			);
		
		this.obj = obj;

		if( this.obj ) {
			var $tree = createTreeFromObject($treeContainer, this.obj, this.options);
	
			// Do not hold on to the tree directly
			this.treeId = getTreeId($tree);
		} else {
			// This is the case when an instance of ObjectTree is built based
			// on an existing DOM strucure, not from an object.
			this.treeId = $treeContainer.find('ul.tree').attr('id');
		};
	}

	,getRoot: function() {
		var $tree = $('#'+this.treeId);
		
		if( $tree.length != 1 ) {
			$n2.log('ObjectTree.getRoot(): id not found: '+this.treeId);
			return null;
		};
		
		return $tree;
	}

	,getId: function() {
		return this.treeId;
	}

	,getObject: function() {
		return this.obj;
	}
	
	,refresh: function() {
		var $tree = this.getRoot();
		if( $tree ) {
			refreshTreeFromObject($tree, this.obj, this.options);
		};
	}
	
	,findLiFromSelectors: function(selectors){
		var $tree = this.getRoot();
		if( $tree ) {
			return findLiFromSelectors($tree, selectors);
		} else {
			return null;
		};
	}
});

/*
 * 
OBJECT EDITOR

This portion of the script deals with an object editor based on
an object tree. The concept is to reuse the navigation provided by an
object tree, augmenting it with the proper tools to perform editing.

An editor holds on to a pointer to the DOM structure, therefore it must
be destroyed prior to being released. (see destroy())

The modifications to the object tree made by an object editor are as follows:
- binds 'click' event to span.treeValue and div.treeChildren to initiate
  the editing of a value
- binds 'click' event to span.treeKey to initiate the editing of an object key.
  This overrides the click installed by the basic tree.
- adds a <div class="treeEditDelete"/> to each li. Binds a 'click' event to
  it to initiate a key deletion
- adds <div class="treeEditUp"/> and <div class="treeEditDown"/> at each li element
  that represent an index inside an array. Binds 'click' event to them to
  initiate moving indices up and down the array.
- installs a <li class="treeEditAdd"><div></div></li> at the end of each ul. Binds
  a 'click' event to the div element to initiate adding a key to an object or
  growing an array.
  
Classes added by editor:
- treeEditingValue : Assigned to li element where the a value is being edited.
- treeEditingKey : Assigned to li element where a key is being edited.
- treeKeyEditor : Class assigned to portion of the tree used to edit a key.
- treeValueEditor : Class assigned to portion of the tree used to edit a value.
- treeEditorClickInstalled : Class assigned to all elements that have received 
                             a 'click' event from the editor
                             
- treeEditUp : Assigned to div elements that are buttons to initiate an index swap with previouss
- treeEditDown : Assigned to div elements that are buttons to initiate an index swap with next
- treeEditAdd : Assigned to li element that contains a <div/> to add a key to an object 
                or array
- treeEditDelete : Assigned to div elements that are buttons to delete a key from an
                   object or array.
- treeEditOk : Assigned to div elements that are buttons to accept an edit
- treeEditCancel : Assigned to div elements that are buttons to reject an edit


Usage:

	<div id="container"></div>
	
	var obj = {...};
	
	var objectTree = new $n2.tree.ObjectTree($('#container'), obj, options);

	... when ready to edit
	
	var editor = new $n2.tree.ObjectTreeEditor(objectTree, obj, options);
	
	... when done editing
	
	editor.destroy();
*/

function defaultCreateNewKey(cbAddKeyToObject, obj, selectors, data) {
	// Find a key
	var index = 0;
	var key = 'newkey_'+index;
	while( data[key] !== undefined ) {
		++index;
		key = 'newkey_'+index;
		if(index > 100) return;
	};
	
	// Call back into editor with new key and data
	cbAddKeyToObject(selectors, key, null);
}

function defaultGetDeleteConfirmation(cbDeleteKey, obj, selectors) {
	if( confirm( _loc('Do you wish to delete this element?') ) ) {
		cbDeleteKey(); // yes
	};
}

function defaultGetAbortConfirmation(actionFn) {
	if( confirm( _loc('This object is being modified. Do you wish to continue and revert current changes?') ) ) {
		actionFn();
	};
}

var createEditorDefaultOptions = {
	onObjectChanged: function(obj){}
	,beforeValueChanged: function(obj, selectors, data){}
	,afterValueChanged: function(obj, selectors, data){}
	,beforeKeyChanged: function(obj, selectors, fromKey, toKey){}
	,afterKeyChanged: function(obj, selectors, fromKey, toKey){}
	,beforeKeyAdded: function(obj, selectors, key){}
	,afterKeyAdded: function(obj, selectors, key){}
	,beforeKeyDeleted: function(obj, selectors){}
	,afterKeyDeleted: function(obj, selectors){}
	,beforeIndexSwap: function(obj, selectors, index){}
	,afterIndexSwap: function(obj, selectors, index){}
	,createNewKey: defaultCreateNewKey
	,getDeleteConfirmation: defaultGetDeleteConfirmation
	,getAbortConfirmation: defaultGetAbortConfirmation
	,isKeyEditingAllowed: function(obj, selectors, data){ return true; }
	,isValueEditingAllowed: function(obj, selectors, data){ return true; }
	,isKeyDeletionAllowed: function(obj, selectors, data){ return true; }
};

var ObjectTreeEditor = $n2.Class({
	
	$tree: null
	
	,obj: null
	
	,options: null
	
	,initialize: function($tree, obj, opt_) {
		if( !$tree ) {
			$n2.log('ObjectTreeEditor.initialize(): null tree');
		};
		if( $tree.getRoot ) {
			$tree = $tree.getRoot();
			if( !$tree ) {
				$n2.log('ObjectTreeEditor.initialize(): null root');
			};
		};
		
		this.options = $.extend(
				{}
				,treeDefaultOptions
				,createFromObjDefaultOptions
				,createEditorDefaultOptions
				,opt_
			);

		this.$tree = $tree;

		this.obj = obj;
		
		this._installEditors();
	}

	/**
	 * This function must be called before an editor can be disposed of.
	 */
	,destroy: function() {
		this._removeEditors();

		this.$tree = null;
		this.obj = null;
		this.options = null;
	}
	
	,getRoot: function() {
		return this.$tree;
	}

	,getId: function() {
		return getTreeId(this.$tree);
	}
	
	,getObject: function() {
		return this.obj;
	}

	,refresh: function(selectors) {
		if( null == selectors || selectors.length < 1 ) {
			// Refresh everything
			refreshUlFromObject(this.obj, [], this.$tree, this.options, []);
			
		} else {
			var data = findDataFromObject(this.obj, selectors);
			var $li = findLiFromSelectors(this.$tree, selectors);
			
			refreshLiFromData(data, selectors, $li, this.options, []);
		};
		
		this._installEditors();
		tree_refresh(this.$tree,this.options);
	}
	
	,isEditing: function() {
		if( this.$tree.find('.treeEditingValue').length > 0 ) {
			return true;
		};
		if( this.$tree.find('.treeEditingKey').length > 0 ) {
			return true;
		};
		return false;
	}
	
	,cancelEditing: function() {
		this.$tree.find('.treeEditingValue').removeClass('treeEditingValue');
		this.$tree.find('.treeEditingKey').removeClass('treeEditingKey');
		this.$tree.find('.treeValueEditor').remove();
		this.$tree.find('.treeKeyEditor').remove();
	}
	
	,_installEditors: function() {
		var editor = this;

		var $allLiElems = this.$tree.find('li');
		$allLiElems.each(function(i,liElem){
			var $li = $(this);
			
			// Skipped li nodes that are to edit tree
			if( false == $li.hasClass('treeEditAdd') ) {
				var selectors = computeSelectors($li);
				var data = findDataFromObject(editor.obj, selectors);
				var isKeyEditingPermitted = editor.options.isKeyEditingAllowed(editor.obj, selectors, data);
				var isValueEditingPermitted = editor.options.isValueEditingAllowed(editor.obj, selectors, data);
				var isKeyDeletionPermitted = editor.options.isKeyDeletionAllowed(editor.obj, selectors, data);
				
				// In case a scalar is truncated, install editing from
				// div child
				var $divChild = $li.children('div.treeChildren');
				if( $divChild.length > 0
				 && isValueEditingPermitted
				 && false == $divChild.hasClass('treeEditorClickInstalled') ) {
					$divChild.click(function(){editor._initiateValueEdit(this);});
					$divChild.addClass('treeEditorClickInstalled');
				};
	
				// Add edit click to object keys
				if( liElem['treeObjectKey'] ) {
					var $key = $li.children('span.treeKey');
					if( $key.length > 0
					 && isKeyEditingPermitted
					 && false == $key.hasClass('treeEditorClickInstalled') ) {
						$key.unbind('click');
						$key.click(function(){editor._initiateKeyEdit(this);});
						$key.addClass('treeEditorClickInstalled');
					};
				};
	
				// Add edit click to value area
				var $value = $li.children('span.treeValue');
				if( $value.length > 0 
				 && isValueEditingPermitted
				 && false == $value.hasClass('treeEditorClickInstalled') ) {
					$value.click(function(){editor._initiateValueEdit(this);});
					$value.addClass('treeEditorClickInstalled');
				};
				
				// Delete button
				var $delBtn = $li.children('.treeEditDelete');
				if( $delBtn.length < 1 
				 && isKeyDeletionPermitted ) {
					$delBtn = $('<div class="treeEditDelete treeEditorClickInstalled"></div>');
					$value.after($delBtn);
					$delBtn.click(function(){editor._initiateDeleteKey(this);});
				};
	
				// Add edit up/down to array keys
				if( typeof(liElem['treeArrayIndex']) === 'number' ) {
					var $dnBtn = $li.children('.treeEditDown');
					if( $dnBtn.length < 1 ) {
						$dnBtn = $('<div class="treeEditDown treeEditorClickInstalled"></div>');
						$value.after($dnBtn);
						$dnBtn.click(function(){editor._initiateSwapKeys(this,1);});
					};
	
					var $upBtn = $li.children('.treeEditUp');
					if( $upBtn.length < 1 ) {
						$upBtn = $('<div class="treeEditUp treeEditorClickInstalled"></div>');
						$value.after($upBtn);
						$upBtn.click(function(){editor._initiateSwapKeys(this,-1);});
					};
				};
			};
		});
		
		// Add key button
		this.$tree.each(installAddButton);
		this.$tree.find('ul').each(installAddButton);
		
		function installAddButton() {
			var $ul = $(this);
			
			var $li = $ul.children('li.treeEditAdd');
			$li.remove();

			// Reinstall
			$li = $('<li class="treeEditAdd"></li>');
			var $addBtn = $('<div><div/>');
			$addBtn.click(function(){ editor._initiateAddKey(this); });
			$li.append($addBtn);
			
			$ul.append($li);
		};
	}
	
	,_removeEditors: function() {
		this.cancelEditing();

		this.$tree.find('li.treeEditAdd').remove();
		this.$tree.find('.treeEditorClickInstalled')
			.unbind('click')
			.removeClass('treeEditorClickInstalled')
			.removeClass('treeClickInstalled') // allow tree to reinstall click events
			;
		this.$tree.find('.treeEditDelete').remove();
		this.$tree.find('.treeEditUp').remove();
		this.$tree.find('.treeEditDown').remove();

		// Reinstall binding on object keys
		tree_refresh(this.$tree,this.options);
	}
	
	/**
	 * Verifies if editing is being performed. If so, ask the
	 * user if it is OK to cancel editing before continuing.
	 * Perform action if it is OK to continue editing. Simply
	 * return if editing operation should be aborted.
	 */
	,_continueWithEditing: function(actionFn) {
		if( false == this.isEditing() ) {
			actionFn();
		} else {
			var editor = this;
			this.options.getAbortConfirmation(function(){
				editor.cancelEditing();
				actionFn();
			});
		};
	}
	
	,_initiateValueEdit: function(spanValueElem) {
		var editor = this;
		this._continueWithEditing(function(){
			editor._startValueEdit(spanValueElem);
		});
	}
	
	,_startValueEdit: function(spanValueElem) {
		var editor = this;
		
		var $li = findLiFromElement(spanValueElem);
		$li.addClass('treeEditingValue');
		var selectors = computeSelectors($li);
		var data = findDataFromObject(this.obj, selectors);
		var json = JSON.stringify(data);

		// Add editDiv
		var $editDiv = $li.children('div.treeValueEditor');
		if( $editDiv.length < 1 ) {
			$editDiv = $('<div class="treeValueEditor"><br/></div>');

			// Position after delete button
			var $delBtn = $li.children('.treeEditDelete');
			$delBtn.after($editDiv);
			
			var $textArea = $('<textarea></textarea>');
			$editDiv.prepend($textArea);
			
			$textArea.keydown(function(evt){editor._valueEditKeyDown(evt,this);});
			
			var $okButton = $('<input type="button" value="OK"/>');
			$editDiv.append($okButton);
			$okButton.click(function(){editor._acceptValueEdit(this);});
			
			var $cancelButton = $('<input type="button" value="Cancel"/>');
			$editDiv.append($cancelButton);
			$cancelButton.click(function(){editor.cancelEditing();});
		};

		// Set data
		$li.children('.treeValueEditor').find('textarea').val(json).focus();
	}

	,_acceptValueEdit: function(okButton) {
		var $li = findLiFromElement(okButton);
		var selectors = computeSelectors($li);
		var json = $li.children('.treeValueEditor').find('textarea').val();
		
		try {
			var data = JSON.parse(json);
		} catch( e ) {
			$n2.log('JSON error',e);
			alert( _loc('Unable to parse JSON string: ')+e);
			return;
		}
		
		$li.removeClass('treeEditingValue');
		this._beforeValueChanged(selectors, data);
		setObjectData(this.obj, selectors, data);
		this._afterValueChanged(selectors, data);
		
		this.cancelEditing();
		this.refresh();
	}
	
	,_valueEditKeyDown: function(evt, textarea) {
		//$n2.log('_valueEditKeyDown', evt, textarea);
		
		if( evt && evt.keyCode == 13 ) {
			// Enter was pressed
			this._acceptValueEdit(textarea);
		} else if( evt && evt.keyCode == 27 ) {
			// Escape was pressed
			this.cancelEditing();
		};
	}

	,_initiateAddKey: function(addButton) {
		var editor = this;
		this._continueWithEditing(function(){
			editor._startAddKey(addButton);
		});
	}

	,_startAddKey: function(addButton) {
		var editor = this;
		
		var $ul = $(addButton).parents('ul').first();
		if( $ul.length != 1 ) return;
		
		if( $ul[0].treeUuid ) {
			// Root
			var data = this.obj;
			var selectors = [];
		} else {
			var $li = findLiFromElement($ul);
			var selectors = computeSelectors($li);
			var data = findDataFromObject(this.obj, selectors);
		};

		// Add a key
		if( null == data ) {
			// Nothing to do. The object was probably modified
			// and we have lost the opportunity to add a key
			this.refresh();
			
		} else if( $n2.isArray(data) ) {
			var index = data.length;
			this._beforeKeyAdded(selectors, index);
			data.push(null);
			this._afterKeyAdded(selectors, index);
			this.refresh();
			
		} else if( typeof(data) === 'object' ) {
			this.options.createNewKey(cbAddKeyToObject, this.obj, selectors, data);
		};

		function cbAddKeyToObject(selectors, newKey, newData) {
			editor._acceptNewObjectKey(selectors, newKey, newData);
		};
	}
	
	,_acceptNewObjectKey: function(selectors, newKey, newData) {
		var data = findDataFromObject(this.obj, selectors);
		if( data ) {
			this._beforeKeyAdded(selectors, newKey);
			data[newKey] = newData;
			this._afterKeyAdded(selectors, newKey);
			this.refresh();
		};
	}

	,_initiateDeleteKey: function(deleteButton) {
		var editor = this;
		this._continueWithEditing(function(){
			editor._startDeleteKey(deleteButton);
		});
	}

	,_startDeleteKey: function(deleteButton) {
		var $li = findLiFromElement(deleteButton);

		var editor = this;
		var selectors = computeSelectors($li);
		function cbDeleteKey() {
			editor._acceptDeleteKey(selectors);
		};
		this.options.getDeleteConfirmation(cbDeleteKey, this.obj, selectors);
	}

	,_acceptDeleteKey: function(selectors) {
		this._beforeKeyDeleted(selectors);
		deleteObjectData(this.obj, selectors);			
		this._afterKeyDeleted(selectors);
		this.refresh();
	}

	,_initiateSwapKeys: function(btn,direction) {
		var editor = this;
		this._continueWithEditing(function(){
			editor._acceptSwapKeys(btn,direction);
		});
	}
	
	,_acceptSwapKeys: function(btn,direction) {
		var editor = this;
		
		var $li = findLiFromElement(btn);
		var selectors = computeSelectors($li);
		var key = 1 * selectors.pop();
		var arr = findDataFromObject(this.obj, selectors);
		
		var swapKey = key + direction;
		if( swapKey < 0 ) {
			// Nothing to do
			return;
		} else if( swapKey >= arr.length ) {
			// Nothing to do
			return;
		};
		
		var uuid = getTreeUuid($li);
		
		// Callback before
		if( direction < 0 ) {
			this._beforeIndexSwap(selectors, swapKey);
		} else {
			this._beforeIndexSwap(selectors, key);
		};

		// Swap with previous entry
		var $swapLi = $('#tree'+uuid+'_'+selectors.join('_')+'_'+swapKey);
		if( $swapLi.length == 1 ) {
			// Change the elements around
			if( direction < 0 ) {
				$li.after($swapLi);
			} else {
				$swapLi.after($li);
			};
			
			// Fix keys
			$li.children('span.treeKey').empty().text(swapKey);
			$swapLi.children('span.treeKey').empty().text(key);
			
			// Fix indices
			$li[0]['treeArrayIndex'] = swapKey;
			$swapLi[0]['treeArrayIndex'] = key;
			
			// Fix ids...
			var $swapElems = $swapLi.find('span.treeKey').parent();
			$swapElems.removeAttr('id');
			fixIds( $li.find('span.treeKey').parent() );
			fixIds( $swapElems );
			
			// Change array
			var tmp = arr[key];
			arr[key] = arr[swapKey];
			arr[swapKey] = tmp;
		};
		
		// Callback after
		if( direction < 0 ) {
			this._afterIndexSwap(selectors, swapKey);
		} else {
			this._afterIndexSwap(selectors, key);
		};
	}

	,_initiateKeyEdit: function(spanKeyElem) {
		var editor = this;
		this._continueWithEditing(function(){
			editor._startKeyEdit(spanKeyElem);
		});
	}

	,_startKeyEdit: function(spanKeyElem) {
		var editor = this;
		
		var $li = findLiFromElement(spanKeyElem);
		$li.addClass('treeEditingKey');
		var selectors = computeSelectors($li);
		var key = selectors.pop();
		var data = findDataFromObject(this.obj, selectors);
		$n2.log('Key editing',key,data,selectors);
		
		var $keySpan = $li.children('span.treeKey');

		var $keyEditor = $('<span class="treeKeyEditor"></span>');
		var $textInput = $('<input class="treeEditorKeyInput" type="text"/>');
		$textInput.val(key);
		$keyEditor.append($textInput);
		
		$textInput.keydown(function(evt){editor._keyEditKeyDown(evt, this);});
		
		var $ok = $('<div class="treeEditOk"></div>');
		$keyEditor.append($ok);
		$ok.click(function(){editor._acceptKeyEdit(this);});
		
		var $cancel = $('<div class="treeEditCancel"></div>');
		$keyEditor.append($cancel);
		$cancel.click(function(){editor.cancelEditing();});
		
		$keySpan.after($keyEditor);
		
		$textInput.focus();
	}

	,_acceptKeyEdit: function(okButton) {
		var $li = findLiFromElement(okButton);
		var selectors = computeSelectors($li);

		var currentKey = selectors.pop();
		var data = findDataFromObject(this.obj, selectors);
		
		var modifiedKey = $li.children('.treeKeyEditor').find('input').val();
		
		// Verify key
		try {
			JSON.parse('{"'+modifiedKey+'":0}');
		} catch( e ) {
			$n2.log('parsing error',e);
			alert( _loc('Unable to parse key: ')+e);
			return;
		}
		
		// If same key, then nothing to do
		if( modifiedKey === currentKey ) {
			this.cancelEditing();
			return;
		};
		
		// Verify that key is not already in use
		if( data[modifiedKey] !== undefined ) {
			alert( _loc('Key already in use: ')+modifiedKey);
			return;
		};
		
		// At this point, we accept the key modification.
		this._beforeKeyChanged(selectors, currentKey, modifiedKey);
		data[modifiedKey] = data[currentKey];
		delete data[currentKey];
		this._afterKeyChanged(selectors, currentKey, modifiedKey);
		
		// Fix $li
		selectors.push(modifiedKey);
		$li.children('span.treeKey').empty().text(modifiedKey);
		$li[0]['treeObjectKey'] = modifiedKey;
		
		// Fix all ids, including children elements
		fixIds($li.find('span.treeKey').parent());
		
		this.cancelEditing();
		this.refresh();
	}
	
	,_keyEditKeyDown: function(evt, input) {
		//$n2.log('_valueEditKeyDown', evt, textarea);
		
		if( evt && evt.keyCode == 13 ) {
			// Enter was pressed
			this._acceptKeyEdit(input);
		} else if( evt && evt.keyCode == 27 ) {
			// Escape was pressed
			this.cancelEditing();
		};
	}
	
	,_beforeValueChanged: function(selectors, data) {
		this.options.beforeValueChanged(this.obj, selectors, data);
	}
	
	,_afterValueChanged: function(selectors, data) {
		this.options.afterValueChanged(this.obj, selectors, data);
		this.options.onObjectChanged(this.obj);
	}
	
	,_beforeKeyChanged: function(selectors, fromKey, toKey) {
		this.options.beforeKeyChanged(this.obj, selectors, fromKey, toKey);
	}
	
	,_afterKeyChanged: function(selectors, fromKey, toKey) {
		this.options.afterKeyChanged(this.obj, selectors, fromKey, toKey);
		this.options.onObjectChanged(this.obj);
	}
	
	,_beforeKeyAdded: function(selectors, key) {
		this.options.beforeKeyAdded(this.obj, selectors, key);
	}
	
	,_afterKeyAdded: function(selectors, key) {
		this.options.afterKeyAdded(this.obj, selectors, key);
		this.options.onObjectChanged(this.obj);
	}
	
	,_beforeKeyDeleted: function(selectors) {
		this.options.beforeKeyDeleted(this.obj, selectors);
	}
	
	,_afterKeyDeleted: function(selectors) {
		this.options.afterKeyDeleted(this.obj, selectors);
		this.options.onObjectChanged(this.obj);
	}
	
	,_beforeIndexSwap: function(selectors, index) {
		this.options.beforeIndexSwap(this.obj, selectors, index);
	}
	
	,_afterIndexSwap: function(selectors, index) {
		this.options.afterIndexSwap(this.obj, selectors, index);
		this.options.onObjectChanged(this.obj);
	}
});

$n2.tree = {
	Tree: Tree
	,ObjectTree: ObjectTree
	,ObjectTreeEditor: ObjectTreeEditor
	,support: {
		findDataFromObject: findDataFromObject
		,setObjectData: setObjectData
		,deleteObjectData: deleteObjectData
	}
};
	
})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.slideEditor.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };
	

/*
 OBJECT SUPPORT
 

 */

/**
 * Finds and returns a data structure from within an object 
 * that corresponds to the given object selector.
 * @param o {Object} An object where the structure is seeked
 * @param selectors {Array} An object selector
 * @return {Object} An object which is the inner structure found within
 *                  the given object that corresponds to the given
 *                  selector. Null is returned if nothing is found.
 */
function findDataFromObject(o, selectors) {
	if( null === selectors
	 || 0 === selectors.length ) {
		return o;
	};
	
	// This is an error. There are more
	// selectors in the array but we have
	// a scalar. Return an error.
	if( null == o
	 || typeof(o) === 'number' 
	 || typeof(o) === 'string'
	 || typeof(o) === 'undefined'
	 || typeof(o) === 'function' ) {
		return null;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[0];
		if( index >= o.length ) {
			return null;
		};
		if( selectors.length < 2 ) {
			return o[index];
		};
		return findDataFromObject(o[index], selectors.slice(1));
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[0];
		var value = o[key];
		if( value === undefined ) {
			return null;
		};
		if( selectors.length < 2 ) {
			return value;
		};
		return findDataFromObject(value, selectors.slice(1));
	};
	
	// Should not get here. Error. Return null.
	return null;
};

/**
 * Sets a data structure in an object at the position
 * represented by the given selector.
 * @param o {Object} The object where the data must be inserted
 * @param selectors {Array} An object selector that represents
 *                          the position where the new data structure
 *                          should be inserted.
 * @param data {Object} Data structure that should be inserted.
 * @return {Boolean} Returns true if the data structure was inserted. 
 */
function setObjectData(o, selectors, data) {
	if( null === selectors
	 || 0 === selectors.length ) {
		return false;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[0];
		if( index >= o.length ) {
			return false;
		};
		if( selectors.length > 1 ) {
			return setObjectData(o[index], selectors.slice(1), data);
		};
		o[index] = data;
		return true;
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[0];
		if( selectors.length == 1 ) {
			o[key] = data;
			return true;
		}
		var value = o[key];
		if( value === undefined ) {
			return false;
		};
		return setObjectData(value, selectors.slice(1), data);
	};
	
	return false;
};

/**
 * Removes a data structure from an object, given a selector.
 * @param o {Object} Object to be modified
 * @param selectors {Array} Position in the object that should be removed.
 * @return {Boolean} True if the deletion was possible
 */
function deleteObjectData(o, selectors) {
	if( null === selectors
	 || 0 === selectors.length ) {
		return false;
	};
	
	if( o === null ) {
		return false;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[0];
		if( index >= o.length ) {
			return false;
		};
		if( selectors.length > 1 ) {
			return deleteObjectData(o[index], selectors.slice(1));
		};
		// Remove this index
		o.splice(index,1);
		return true;
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[0];
		var value = o[key];
		if( value === undefined ) {
			return false;
		};
		if( selectors.length > 1 ) {
			return deleteObjectData(value, selectors.slice(1));
		};
		delete o[key];
		return true;
	};
	
	return false;
};


/*
ARRAY
*/

function arrayRemove(arr, elem) {
	for(var i=0,e=arr.length; i<e; ++i) {
		if( arr[i] === elem ) {
			arr.splice(i,1);
			return;
		};
	};
};


/*
 * 
OBJECT EDITOR


|-id=<editorId>-------------------------------------------------|
|                                                               |
| |-n2se_root-------------------------------------------------| |
| |                                                           | |
| | |-n2se_history------------------------------------------| | |
| | |                                                       | | |
| | |-------------------------------------------------------| | |
| |                                                           | |
| | |-n2se_main---------------------------------------------| | |
| | |                                                       | | |
| | | |-n2se_back-----------------------------------------| | | |
| | | |                                                   | | | |
| | | |---------------------------------------------------| | | |
| | |                                                       | | |
| | | |-n2se_display--------------------------------------| | | |
| | | |                                                   | | | |
| | | |                                                   | | | |
| | | |---------------------------------------------------| | | |
| | |                                                       | | |
| | |-------------------------------------------------------| | |
| |                                                           | |
| |-----------------------------------------------------------| |
|                                                               |
|---------------------------------------------------------------|


History:
<div class="n2se_history">
	<span class="n2se_history_back"><span class="n2se_btn"></span><span class="n2se_label">Back</span></span>
	<span class="n2se_history_head"></span>
	<span class="n2se_history_level">top</span>
	<span class="n2se_history_inter"></span>
	<span class="n2se_history_level"> ... </span>
	<span class="n2se_history_inter"></span>
	<span class="n2se_history_level"> ... </span>
	<span class="n2se_history_tail"></span>
</div>

Display:
<div class="n2se_display">
	<div class="n2se_entries">
		<div class="n2se_entry">
			<span class="n2se_entry_delete"></span>
			<input class="n2se_entry_key" type="text"/>  // in the case of an array, it is a span
			<span class="n2se_entry_is"> is </span>
			<select class="n2se_entry_select"></select>  // contains options for type
			
			// One of the following
			<input class="n2se_entry_text" type="text"/>
			<input class="n2se_entry_cb" type="checkbox"/>
			<span class="n2se_entry_forward"></span>
		</div>
		<div class="n2se_entry">
			...
		</div>
		(...)
	</div>
	<div class="n2se_addbar">
		<span class="n2se_addbar_addButton"><span class="n2se_btn"></span><span class="n2se_label">Add</span></span>
	</div>
</div>

in the case of editing a string:
<div class="n2se_display">
	<textarea class="n2se_textarea">
		...
	</textarea>
</div>


*/

function defaultCreateNewKey(cbAddKeyToObject, obj, selectors, data) {
	// Find a key
	var index = 0;
	var key = 'newkey_'+index;
	while( data[key] !== undefined ) {
		++index;
		key = 'newkey_'+index;
		if(index > 100) return;
	};
	
	// Call back into editor with new key and data
	cbAddKeyToObject(selectors, key, '');
}

function defaultGetDeleteConfirmation(cbDeleteKey) {
	if( confirm( _loc('Do you wish to delete this element?') ) ) {
		cbDeleteKey(); // yes
	};
}

function defaultObjectKeySort(objFrag) {
	var temp = [];
	for(var key in objFrag) {
		temp.push(key);
	};
	temp.sort();
	var keyOrder = [];
	if( objFrag.n2se_keyorder ) {
		for(var i=0,e=objFrag.n2se_keyorder.length; i<e; ++i) {
			var key = objFrag.n2se_keyorder[i];
			if( typeof(objFrag[key]) !== 'undefined' ) {
				arrayRemove(temp, key);
				keyOrder.push(key);
			};
		};
	};
	for(var i=0,e=temp.length; i<e; ++i) {
		var key = temp[i];
		keyOrder.push(key);
	};
	
	return keyOrder;
};

function defaultObjectKeyOrderSave(objFrag, orderArray) {
	objFrag.n2se_keyorder = orderArray;
};

function defaultIsKeyDisplayed(obj, selectors, data) {
	if( selectors.length > 0 ) {
		var key = selectors[selectors.length-1];
		if( key === 'n2se_keyorder' ) {
			return false;
		};
	};
	return true;
};

var createEditorDefaultOptions = {
	onObjectChanged: function(obj){}
	,objectKeySortAllowed: true
	,objectKeySort: defaultObjectKeySort
	,objectKeyOrderSave: defaultObjectKeyOrderSave
	,getDeleteConfirmation: defaultGetDeleteConfirmation
	,isKeyDisplayed: defaultIsKeyDisplayed
	,isKeyEditingAllowed: function(obj, selectors, data){ return true; }
	,isValueEditingAllowed: function(obj, selectors, data){ return true; }
	,isKeyDeletionAllowed: function(obj, selectors, data){ return true; }
	
	,createNewKey: defaultCreateNewKey
};

var SlideEditor = $n2.Class({
	
	divId: null
	
	,obj: null
	
	,options: null
	
	,currentSelectors: null
	
	,initialize: function($div, obj, opt_) {
		this.options = $.extend(
				{}
				,createEditorDefaultOptions
				,opt_
			);

		var divId = $div.attr('id');
		if( !divId ) {
			divId = $n2.getUniqueId();
			$div.attr('id',divId);
		};
		this.divId = divId;
		
		this.obj = obj;
		this.currentSelectors = [];
		
		this._installEditors();
	}

	/**
	 * This function must be called before an editor can be disposed of.
	 */
	,destroy: function() {
		this._removeEditors();

		this.divId = null;
		this.obj = null;
		this.options = null;
	}
	
	,getDiv: function() {
		
		if( this.divId ) {
			var $div = $('#'+this.divId);
			if( $div.length > 1 ) {
				return $div.first();
			} else if( $div.length > 0 ) {
				return $div;
			};
		};
		
		return null;
	}

	,getId: function() {
		return this.divId;
	}
	
	,getObject: function() {
		return this.obj;
	}
	
	/*
	 * Call from client to indicate that the underlying object was changed
	 */
	,refresh: function() {
		// Verify if current selector is still valid.
		var currentSelectors = this.currentSelectors;
		var objFrag = findDataFromObject(this.obj, currentSelectors);
		
		if( null !== objFrag ) {
			// Current selector is still valid, simply refresh
			this._refresh();
		} else {
			// Need to transition back to a valid place...
			
			// Adjust current selectors
			while(!objFrag) {
				currentSelectors.pop();
				objFrag = findDataFromObject(this.obj, currentSelectors);
			};
			
			// refresh display
			this._refresh({back:true});
		};
	}
	
	,_refresh: function(opt_) {
		this._refreshHistory(opt_);
		this._refreshDisplay(opt_);
	}
	
	,_refreshHistory: function() {
		var editor = this;
		var currentSelectors = this.currentSelectors;
		var $div = this.getDiv();
		if( $div ) {
			var $history = $div.find('.n2se_history');
			
			$history.empty();

			var $back = $('<span class="n2se_history_back"><span class="n2se_btn"></span><span class="n2se_label">'+_loc('Back')+'</span></span>');
			$history.append($back);
			$back.click(function(e){
				editor._backClicked(e);
			});

			var $head = $('<span class="n2se_history_head"></span>');
			$history.append($head);
			
			var $top = $('<span class="n2se_history_level">'+_loc('top')+'</span>');
			$history.append($top);
			$top.click(createHistoryCallback(editor, 0));
			
			for(var i=0,e=currentSelectors.length; i<e; ++i) {
				var $inter = $('<span class="n2se_history_inter"></span>');
				$history.append($inter);

				var selector = currentSelectors[i];
				var $level = $('<span class="n2se_history_level">'+selector+'</span>');
				$history.append($level);
				$level.click(createHistoryCallback(editor, i+1));
			};

			var $tail = $('<span class="n2se_history_tail"></span>');
			$history.append($tail);
		};
		
		function createHistoryCallback(editor, index) {
			var cb = function() {
				editor._historyClicked(index);
			};
			return cb;
		}
	}
	
	,_refreshDisplay: function(opt_) {
		var currentSelectors = this.currentSelectors;
		var $div = this.getDiv();
		if( $div ) {
			var objFrag = findDataFromObject(this.obj, currentSelectors);
			var currentSelectorsCopy = [];
			currentSelectorsCopy.push.apply(currentSelectorsCopy, currentSelectors);

			if( opt_ && opt_.back ) {
				// refresh display using a back transition
				var $main = $div.find('.n2se_main');
				
				var $previousDisplayDivs = $main.find('.n2se_display');

				var $display = $('<div class="n2se_display"></div>');
				if( $previousDisplayDivs.length > 0 ) {
					$previousDisplayDivs.first().before($display);
				} else {
					$main.append($display);
				};

				this._drawDisplayPage($display, this.obj, currentSelectorsCopy, objFrag);
				
				$display.effect(
					'slide'
					,{
						mode: 'show'
						,direction: 'left'
					}
					,500
					,null // no callback
				);
				
				$previousDisplayDivs.effect(
					'slide'
					,{
						mode: 'hide'
						,direction: 'right'
					}
					,500
					,function(){ $previousDisplayDivs.remove(); }
				);
				
			} else if( opt_ && opt_.forward ) {
				// Refresh display with forward transition
				var $main = $div.find('.n2se_main');
				
				var $previousDisplayDivs = $main.find('.n2se_display');

				var $display = $('<div class="n2se_display"></div>');
				$main.append($display);

				this._drawDisplayPage($display, this.obj, currentSelectorsCopy, objFrag);
				
				$previousDisplayDivs.effect(
					'slide'
					,{
						mode: 'hide'
						,direction: 'left'
					}
					,500
					,function(){ $previousDisplayDivs.remove(); }
				);
				
				$display.effect(
					'slide'
					,{
						mode: 'show'
						,direction: 'right'
					}
					,500
					,null // no callback
				);
				
			} else {
				// refresh display in place
				var $display = $div.find('.n2se_display');
				
				$display.empty();
	
				this._drawDisplayPage($display, this.obj, currentSelectorsCopy, objFrag);
			};
		};
	}
	
	,_drawDisplayPage: function($display, obj, selectors, objFrag) {
		var editor = this;
		
		var isArray = false;
		var addBarNeeded = false;
		if( typeof(objFrag) === 'string' ) {
			// String
			// Special case: we need to find the parent object
			//  and key required to update the string
			
			var isValueEditingAllowed = this.options.isValueEditingAllowed(obj, selectors, objFrag);
			var stringKey = selectors.pop();
			var stringParentObj = findDataFromObject(obj, selectors);
			
			var $keyDiv = $('<textarea class="n2se_textarea"></textarea>')
			$display.append($keyDiv);
			$keyDiv.val(objFrag);
			if( isValueEditingAllowed ) {
				$keyDiv.keyup(function(e){
					var $textarea = $(this);
					var newValue = $textarea.val();
					var currentValue = stringParentObj[stringKey];
	
					if( currentValue !== newValue ) {
						stringParentObj[stringKey] = newValue;
						editor._reportObjectChange();
					};
				});
			} else {
				$keyDiv.attr('disabled','disabled');
			};

		} else if( $n2.isArray(objFrag) ) {
			// Array
			addBarNeeded = true;
			isArray = true;
			
			var $entries = $('<div class="n2se_entries"></div>');
			$display.append($entries);

			for(var key=0,e=objFrag.length; key<e; ++key) {
				var $keyDiv = $('<div class="n2se_entry"></div>')
				$entries.append($keyDiv);
				
				selectors.push(key);
				var isValueEditingAllowed = this.options.isValueEditingAllowed(obj, selectors, objFrag[key]);
				var isKeyDeletionAllowed = this.options.isKeyDeletionAllowed(obj, selectors, objFrag[key]);
				selectors.pop();
				
				addKeyValue(editor, $keyDiv, objFrag, key, isArray, false, isValueEditingAllowed, isKeyDeletionAllowed);
			};
			
			$entries.sortable();
			$entries.bind('sortupdate',function(){
				editor._resortArray($display,objFrag);
			});
			
		} else {
			// Object
			addBarNeeded = true;
			
			var $entries = $('<div class="n2se_entries"></div>');
			$display.append($entries);
			
			var keyOrder = this.options.objectKeySort(objFrag);
			
			for(var i=0,e=keyOrder.length; i<e; ++i) {
				var key = keyOrder[i];

				selectors.push(key);
				var isKeyDisplayed = this.options.isKeyDisplayed(obj, selectors, objFrag[key]);
				var isKeyEditingAllowed = this.options.isKeyEditingAllowed(obj, selectors, objFrag[key]);
				var isValueEditingAllowed = this.options.isValueEditingAllowed(obj, selectors, objFrag[key]);
				var isKeyDeletionAllowed = this.options.isKeyDeletionAllowed(obj, selectors, objFrag[key]);
				selectors.pop();
				
				if( isKeyDisplayed ) {
					var $keyDiv = $('<div class="n2se_entry"></div>')
					$entries.append($keyDiv);
					
					addKeyValue(editor, $keyDiv, objFrag, key, isArray, isKeyEditingAllowed, isValueEditingAllowed, isKeyDeletionAllowed);
				};
			};
			
			if( this.options.objectKeySortAllowed ) {
				$entries.sortable();
				$entries.bind('sortupdate',function(){
					editor._resortObject($display,objFrag);
				});
			};
		};
		
		// Install 'add' bar
		if( addBarNeeded ) {
			var $addBar = $('<div class="n2se_addbar"></div>');
			$display.append($addBar);
			var $addButton = $('<span class="n2se_addbar_addButton"><span class="n2se_btn"></span><span class="n2se_label">'+_loc('Add')+'</span></span>');
			$addBar.append($addButton);
			$addButton.click(function(){
				if( isArray ) {
					objFrag.push('');
					editor._refreshDisplay();
					editor._reportObjectChange();

				} else {
					editor.options.createNewKey(function(selectors, newKey, newValue){
							objFrag[newKey] = newValue;
							editor._refreshDisplay();
							editor._reportObjectChange();
						}
						,obj
						,selectors
						,objFrag
					);
				};
			});
		};
		
		function addKeyValue(editor, $keyDiv, objFrag, key, isArray, isKeyEditingAllowed, isValueEditingAllowed, isKeyDeletionAllowed) {

			var value = objFrag[key];
			
			var $del = $('<span class="n2se_entry_delete"></span>');
			$keyDiv.append( $del );
			if( isKeyDeletionAllowed ) {
				$del.click(function(){
					editor.options.getDeleteConfirmation(function(){
						if( isArray ) {
							objFrag.splice(key,1);
						} else {
							delete objFrag[key];
						}
	
						editor._refreshDisplay();
						editor._reportObjectChange();
					});
				});
			} else {
				$del.addClass('n2se_entry_delete_disabled');
			};
			
			if( isArray ) {
				var $keyInput = $('<span class="n2se_entry_key">'+key+'</span>');
				$keyDiv.append( $keyInput );
			} else {
				var $keyInput = $('<input class="n2se_entry_key" type="text"/>');
				$keyDiv.append( $keyInput );
				$keyInput.val(key);
				if( isKeyEditingAllowed ) {
					$keyInput.change(function(e){
						var $keyInput = $(this);
						var newKey = $keyInput.val();
		
						if( key != newKey ) {
							// Check if key already exists
							if( objFrag[newKey] ) {
								// abort
								$keyInput.val(key);
							} else {
								objFrag[newKey] = objFrag[key];
								delete objFrag[key];
								$keyDiv.empty();
								addKeyValue(editor, $keyDiv, objFrag, newKey, isArray, isKeyEditingAllowed, isValueEditingAllowed, isKeyDeletionAllowed);
								editor._reportObjectChange();
							};
						};
					});
				} else {
					$keyInput.attr('disabled','disabled');
				};
			};
			
			$keyDiv.append( $('<span class="n2se_entry_is"> '+_loc('is')+' </span>') );
			
			var $select = $('<select class="n2se_entry_select"></select>');
			$keyDiv.append( $select );
			
			$select.append( $('<option value="string">'+_loc('a String')+'</option>') );
			$select.append( $('<option value="number">'+_loc('a Number')+'</option>') );
			$select.append( $('<option value="boolean">'+_loc('a Checkbox')+'</option>') );
			$select.append( $('<option value="array">'+_loc('an Array')+'</option>') );
			$select.append( $('<option value="object">'+_loc('an Object')+'</option>') );
			$select.append( $('<option value="null">'+_loc('empty')+'</option>') );
			
			var requiresTextBox = false;
			var requiresCheckBox = false;
			var requiresForwardButton = false;
			if( value === null ) {
				$select.val('null');
				
			} else if( typeof(value) === 'undefined' ) {
				$select.val('null');
				
			} else if( $n2.isArray(value) ) {
				$select.val('array');
				requiresForwardButton = true;

			} else if( typeof(value) === 'object' ) {
				$select.val('object');
				requiresForwardButton = true;

			} else if( typeof(value) === 'string' ) {
				$select.val('string');
				requiresTextBox = true;
				requiresForwardButton = true;
				
			} else if( typeof(value) === 'number' ) {
				$select.val('number');
				requiresTextBox = true;
				
			} else if( typeof(value) === 'boolean' ) {
				$select.val('boolean');
				requiresCheckBox = true;

			} else {
				$select.val('string');
				requiresTextBox = true;
				requiresForwardButton = true;
			};
			if( isValueEditingAllowed ) {
				$select.change(function(e){
					var $select = $(this);
					var newType = $select.val();
	
					if( 'string' === newType ) {
						if( typeof(objFrag[key]) === 'object' ) {
							objFrag[key] = '';
						} else {
							objFrag[key] = ''+objFrag[key];
						};
					} else if( 'array' === newType ) { 
						objFrag[key] = [ objFrag[key] ]; 
					} else if( 'object' === newType ) { 
						objFrag[key] = {}; 
					} else if( 'number' === newType ) { 
						objFrag[key] = 1 * objFrag[key];
						if( isNaN(objFrag[key]) ) {
							objFrag[key] = 0;
						};
					} else if( 'boolean' === newType ) { 
						objFrag[key] = false; 
					} else if( 'null' === newType ) { 
						objFrag[key] = null; 
					} else { 
						objFrag[key] = ''; 
					};
	
					$keyDiv.empty();
					addKeyValue(editor, $keyDiv, objFrag, key, isArray, isKeyEditingAllowed, isValueEditingAllowed, isKeyDeletionAllowed);
					editor._reportObjectChange();
				});
			} else {
				$select.attr('disabled','disabled');
			};
			
			if( requiresForwardButton ) {
				var $forwardButton = $('<span class="n2se_entry_forward"></span>');
				$keyDiv.append( $forwardButton );
				$forwardButton.click(function(e){
					editor._forwardClicked(key);
				});
			};

			if( requiresTextBox ) {
				var $textBox = $('<input class="n2se_entry_text" type="text"/>');
				$keyDiv.append( $textBox );
				$textBox.val(value);
				if( isValueEditingAllowed ) {
					$textBox.keyup(function(e){
						var $textBox = $(this);
						var newVal = $textBox.val();
						if( typeof(objFrag[key]) === 'number' ) {
							// force number
							newVal = 1 * newVal;
							if( isNaN(newVal) ) {
								// Error
								$textBox.val( objFrag[key] );
							} else {
								objFrag[key] = newVal;
								editor._reportObjectChange();
							};
						} else {
							objFrag[key] = newVal;
							editor._reportObjectChange();
						};
					});
				} else {
					$textBox.attr('disabled','disabled');
				};
				
			} else if( requiresCheckBox ) {
				var $checkBox = $('<input class="n2se_entry_cb" type="checkbox"/>');
				$keyDiv.append( $checkBox );
				if( value ) {
					$checkBox.attr('checked','checked');
				}
				if( isValueEditingAllowed ) {
					$checkBox.click(function(e){
						var $checkBox = $(this);
						var newVal = $checkBox.is(':checked');
						objFrag[key] = newVal;
						editor._reportObjectChange();
					});
				} else {
					$checkBox.attr('disabled','disabled');
				};
				
			};
		};
	}

	,_installEditors: function() {
		var editor = this;
		var $div = this.getDiv();
		if( $div ) {
			$div.empty();

			var $root = $('<div class="n2se_root"></div>');
			$div.append($root);
			
			var $history = $('<div class="n2se_history"></div>');
			$root.append($history);
			
			var $main = $('<div class="n2se_main"></div>');
			$root.append($main);
			
			var $back = $('<div class="n2se_back"></div>');
			$main.append($back);
			$back.click(function(e){ editor._backClicked(e); });
			
			var $display = $('<div class="n2se_display"></div>');
			$main.append($display);
			
			this._refresh();
		}; // if $div
	}
	
	,_removeEditors: function() {
		var $div = this.getDiv();
		if( $div ) {
			$div.empty();
			
			this.divId = null;
		};
	}
	
	,_backClicked: function(e) {
		if( this.currentSelectors.length > 0 ) {
			this.currentSelectors.pop();
			this._refresh({back:true});
		};
	}
	
	,_forwardClicked: function(key) {
		this.currentSelectors.push(key);
		this._refresh({forward:true});
	}
	
	,_historyClicked: function(selectorIndex) {

		var howManyRemoved = this.currentSelectors.length - selectorIndex;
		if( howManyRemoved > 0 ) {
			this.currentSelectors.splice(selectorIndex, howManyRemoved);
			this._refresh({back:true});
		};
	}
	
	,_reportObjectChange: function() {
		try {
			this.options.onObjectChanged(this.obj);
		} catch(e) {
			$n2.log('Error reported on object refresh',e);
		}
	}
	
	,_resortArray: function($display, objFrag) {
		var $keys = $display.find(".n2se_entry_key");
		$n2.log('$keys',$keys);
		
		var nextArray = [];
		$keys.each(function(i,elem){
			var key = 1 * $(elem).text();
			
			nextArray.push( objFrag[key] );
		});
		
		// Swap
		objFrag.splice(0, objFrag.length);
		for(var i=0,e=nextArray.length; i<e; ++i) {
			objFrag.push( nextArray[i] );
		};
		
		// Refresh display
		this._refresh();
		
		this._reportObjectChange();
	}
	
	,_resortObject: function($display, objFrag) {
		var $keys = $display.find(".n2se_entry_key");

		var orderArray = [];
		$keys.each(function(i,elem){
			var key = $(elem).val();
			orderArray.push( key );
		});
		
		// Save new order
		this.options.objectKeyOrderSave(objFrag, orderArray);
		
		// Refresh display
		this._refresh();
		
		this._reportObjectChange();
	}
});

$n2.slideEditor = {
	Editor: SlideEditor
	,support: {
		findDataFromObject: findDataFromObject
		,setObjectData: setObjectData
		,deleteObjectData: deleteObjectData
	}
};
	
})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.form.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

	
// =====================================
// Object
	
function setDataFromObjectSelector(o, selectors, value) {
	if( typeof(selectors) === 'string' ) {
		selectors = selectors.split('.');
	}
	return setDataOnObject(o, selectors, 0, value);
};

function setDataOnObject(o, selectors, selectorIndex, value) {
	if( selectorIndex >= selectors.length ) {
		return false;
	};
	
	// This is an error. There are more
	// selectors in the array but we have
	// a scalar. Return an error.
	if( null == o
	 || typeof(o) === 'number' 
	 || typeof(o) === 'string'
	 || typeof(o) === 'undefined'
	 || typeof(o) === 'function' ) {
		return false;
	};

	if( selectorIndex == (selectors.length-1) ) {
		// Set
		if( $n2.isArray(o) ) {
			var index = 1 * selectors[selectorIndex];
			if( index >= o.length ) {
				return false;
			};
			o[index] = value;
			return true;
		}

		if( typeof(o) === 'object' ) {
			var key = selectors[selectorIndex];
			o[key] = value;
			return true;
		};
		
		// Should not get here
		return false;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[selectorIndex];
		if( index >= o.length ) {
			return false;
		};
		return setDataOnObject(o[index], selectors, (selectorIndex+1), value);
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[selectorIndex];
		var obj = o[key];
		if( obj === undefined ) {
			return false;
		};
		return setDataOnObject(obj, selectors, (selectorIndex+1), value);
	};
	
	// Should not get here. Error. Return null.
	return false;
};

function getDataFromObjectSelector(o, selectors) {
	if( typeof(selectors) === 'string' ) {
		selectors = selectors.split('.');
	}
	return findDataFromObject(o, selectors, 0);
};

function findDataFromObject(o, selectors, selectorIndex) {
	if( selectorIndex >= selectors.length ) {
		return o;
	};
	
	// This is an error. There are more
	// selectors in the array but we have
	// a scalar. Return an error.
	if( null == o
	 || typeof(o) === 'number' 
	 || typeof(o) === 'string'
	 || typeof(o) === 'undefined'
	 || typeof(o) === 'function' ) {
		return null;
	};
	
	if( $n2.isArray(o) ) {
		var index = 1 * selectors[selectorIndex];
		if( index >= o.length ) {
			return null;
		};
		return findDataFromObject(o[index], selectors, (selectorIndex+1));
	}

	if( typeof(o) === 'object' ) {
		var key = selectors[selectorIndex];
		var value = o[key];
		if( value === undefined ) {
			return null;
		};
		return findDataFromObject(value, selectors, (selectorIndex+1));
	};
	
	// Should not get here. Error. Return null.
	return null;
};
	
// =====================================
// Schema

var FormAttribute = $n2.Class({
	
	defaultValue: null
	
	,name: null

	,label: null
	
	,selector: null

	,type: 'text'
		
	,className: null
	
	,options: null
	
	,initialize: function(schema) {
		$.extend(this,schema);
		
		if( null == this.label ) {
			this.label = this.name;
		}
		
		if( null == this.selector ) {
			this.selector = this.name;
		}
	}
	
	,isHidden: function() {
		return (this.type === 'hidden');
	}
	
});

var FormButton = $n2.Class({
	
	name: null

	,label: null
	
	,initialize: function(name, label) {
		this.name = name;
		this.label = label;
	}
});

/*
Accepts a schema that looks like:
	{
		"title": "First Schema"
		,"attributes": [
			{
				"name" : "name"
				,"label": "Name"
				,"type" : "text"
				,"className": "inputClass"
				,"description": "The name of the entity"
			}
			,{
				"name" : "hideMe"
				,"type" : "hidden"
				,"description": "A hidden input"
			}
			,{
				"name" : "aSelection"
				,"type" : "select"
				,"options" : ["option1", "option2"]
				,"description": "An option selector"
			}
			,{
				"name" : "aDate"
				,"type" : "date"
				,"datePicker": {} // options for datePicker
				,"description": "A date selector"
			}
		]
		,"buttons": [
			{
				"name" : "testButton"
				,"label" : "Test"
			}
		]
	}
*/
var FormSchema = $n2.Class({
	
	attributes: []
	
	,title: ''
	
	,okButton: false

	,okButtonLabel: _loc('OK')
	
	,cancelButton: false
	
	,cancelButtonLabel: _loc('Cancel')
	
	,resetButton: false
	
	,resetButtonLabel: _loc('Reset')
	
	,buttons: null
	
	,initialize: function(schema) {
		if( schema.title ) this.title = schema.title;
		if( schema.okButton ) this.okButton = schema.okButton;
		if( schema.okButtonLabel ) this.okButtonLabel = schema.okButtonLabel;
		if( schema.cancelButton ) this.cancelButton = schema.cancelButton;
		if( schema.cancelButtonLabel ) this.cancelButtonLabel = schema.cancelButtonLabel;
		if( schema.resetButton ) this.resetButton = schema.resetButton;
		if( schema.resetButtonLabel ) this.resetButtonLabel = schema.resetButtonLabel;
		
		if( schema.attributes ) {
			this.attributes = [];
			for(var i=0, e=schema.attributes.length; i<e; ++i) {
				var a = schema.attributes[i];
				
				this.attributes.push( new FormAttribute(a) );
			};
		};
		
		if( schema.buttons ) {
			this.buttons = [];
			for(var i=0, e=schema.buttons.length; i<e; ++i) {
				var b = schema.buttons[i];
				
				this.buttons.push( new FormButton(b.name,b.label) );
			};
		};
	}

	,createForm: function(
		jQuerySet
		,data
		,options_
		) {
		return new Form(this, jQuerySet, data, options_);
	}
	
	,getTitle: function() {
		if( this.formSchema && this.formSchema.title ) {
			return this.formSchema.title;
		};
		
		return null;
	}
	
});

// =====================================
// Input Form

var FormInput = $n2.Class({
	
	uniqueId: null
	
	,attribute: null
	
	,jQuerySet: null
	
	,data: null
	
	,input: null
	
	,initialValue: null

	,onChanged: null
	
	,initialize: function(
		uniqueId
		,attribute
		,data
		,jQuerySet
		,onChanged
		) {
		this.uniqueId = uniqueId;
		this.attribute = attribute;
		this.data = data;
		this.jQuerySet = jQuerySet;
		this.onChanged = onChanged;
		
		this.render();
	}
	
	,render: function() {
		var attr = this.attribute;
		
		var inputHtml = [];
		if( 'select' == attr.type ) {
			inputHtml.push('<select id="');
			inputHtml.push(this.uniqueId);
			if( attr.name ) {
				inputHtml.push('" name="');
				inputHtml.push(attr.name);
			}
			if( attr.className ) {
				inputHtml.push('" class="');
				inputHtml.push(attr.className);
			}
			inputHtml.push('">');
			
			for(var i=0, e=attr.options.length; i<e; ++i) {
				var opt = attr.options[i];
				if( typeof(opt) === 'string' ) {
					opt = { value: opt };
				};
				var label = opt.label ? opt.label : opt.value;
				inputHtml.push('<option value="');
				inputHtml.push(opt.value);
				inputHtml.push('">');
				inputHtml.push(label);
				inputHtml.push('</option>');
			};

			inputHtml.push('</select>');
			
		} else if( 'date' == attr.type ) {
			inputHtml.push('<input id="');
			inputHtml.push(this.uniqueId);
			inputHtml.push('" type="text');
			if( attr.name ) {
				inputHtml.push('" name="');
				inputHtml.push(attr.name);
			}
			if( attr.className ) {
				inputHtml.push('" class="');
				inputHtml.push(attr.className);
			}
			inputHtml.push('"/>');
			
		} else if( 'file' == attr.type ) {
			inputHtml.push('<input id="');
			inputHtml.push(this.uniqueId);
			inputHtml.push('" type="file');
			if( attr.name ) {
				inputHtml.push('" name="');
				inputHtml.push(attr.name);
			}
			if( attr.className ) {
				inputHtml.push('" class="');
				inputHtml.push(attr.className);
			}
			inputHtml.push('"/>');
			
		} else if( 'textarea' == attr.type ) {
			inputHtml.push('<textarea id="');
			inputHtml.push(this.uniqueId);
			if( attr.name ) {
				inputHtml.push('" name="');
				inputHtml.push(attr.name);
			}
			if( attr.className ) {
				inputHtml.push('" class="');
				inputHtml.push(attr.className);
			}
			inputHtml.push('"></textarea>');
			
		} else if( 'array' == attr.type ) {
			inputHtml.push('<div id="');
			inputHtml.push(this.uniqueId);
			inputHtml.push('"/>');
			
		} else {
			inputHtml.push('<input id="');
			inputHtml.push(this.uniqueId);
			if( attr.type ) {
				inputHtml.push('" type="');
				inputHtml.push(attr.type);
			}
			if( attr.name ) {
				inputHtml.push('" name="');
				inputHtml.push(attr.name);
			}
			if( attr.className ) {
				inputHtml.push('" class="');
				inputHtml.push(attr.className);
			}
			inputHtml.push('"/>');
		};
		
		this.input = $(inputHtml.join(''));
		this.input.change(this.onChanged);

		var initialValue = null;
		if( this.data ) {
			initialValue = this.getData();
		};
		if( null == initialValue && this.attribute.defaultValue ) {
			initialValue = this.attribute.defaultValue;
		};
		if( null == initialValue ) {
			initialValue = '';
		};
		this.input.val(initialValue);
		this.initialValue = initialValue;

		this.jQuerySet.append(this.input);
		
		// Install datepicker, if available
		if( 'date' == attr.type && $.ui && $.ui.datepicker ) {
			var dpOptions = $.extend(
				{
					dateFormat: 'yy-mm-dd'
					,gotoCurrent: true
					,changeYear: true
				}
				,attr.datePicker
			);
			this.input.datepicker(dpOptions);
			
		} else if( 'array' == attr.type ) {
			// Install 
		};
	}
	
	,refreshFromData: function() {
		var v = this.getData();
		if( null == v ) {
			v = '';
		}
		this.setCurrentValue(v);
	}
	
	,getName: function() {
		return this.attribute.name;
	}
	
	,getCurrentValue: function() {
		return this.input.val();
	}
	
	,setCurrentValue: function(value) {
		this.input.val(value);
	}
	
	,resetValue: function() {
		this.input.val( this.initialValue );
	}
	
	,hasValueChanged: function() {
		var current = this.getCurrentValue();
		return ( current != this.initialValue );
	}
	
	,getInputElement: function() {
		return this.input;
	}
	
	,getData: function() {
		return getDataFromObjectSelector(this.data, this.attribute.selector);
	}
	
	,setData: function(value) {
		return setDataFromObjectSelector(this.data, this.attribute.selector, value);
	}
	
	,refreshObject: function() {
		var value = this.getCurrentValue();
		var set = this.setData(value);
	}
});

var stubFunction = function(form){return true;};

var defaultPreCancel = function(form) {
	if( form.hasAnyValueChanged() ) {
		if( !window.confirm('Form has changed. Are you sure you want to cancel?') ) {
			return false;
		}
	}
	
	return true;
};

var defaultPreReset = function(form) {
	if( form.hasAnyValueChanged() ) {
		if( !window.confirm('Form has changed. Are you sure you want to reset it?') ) {
			return false;
		}
	}
	
	return true;
};

var defaultFormOptions = {
	formClass: 'n2Form'
	,preCancel: defaultPreCancel
	,postCancel: stubFunction
	,preReset: defaultPreReset
	,postReset: stubFunction
	,preOK: stubFunction
	,postOK: stubFunction
	,buttonPressed: stubFunction
	,onChanged: stubFunction
	,action: null
	,enctype: null
	,method: null
	,target: null
	,title: null
	,titleClass: null
};

var Form = $n2.Class({
	
	schema: null
	
	,inputs: null
	
	,inputsById: null
	
	,inputsByName: null
	
	,elem: null
	
	,data: null
	
	,form: null
	
	,options: null
	
	,inputChangedCallback: null
	
	,initialize: function(
		schema
		,jQuerySet
		,data
		,options_
		) {
		
		this.options = $.extend(true, {}, defaultFormOptions, options_);
	
		this.schema = schema;
		this.data = data;
		
		// Render on first element of jQuerySet
		this.elem = $( jQuerySet[0] );
		
		this.inputs = [];
		this.inputsByName = {};
		this.inputsById = {};
		
		var _this = this;
		this.inputChangedCallback = function(evt) {
			var $input = $(this);
			var inputId = $input.attr('id');
			_this._inputChanged(inputId);
		};

		this.render();
	}
	
	,render: function() {
		this.elem.empty();
		
		var recv = this;
		
		// Create form element
		var formHtml = [];
		formHtml.push('<form');
		if( this.options.formClass ) {
			formHtml.push(' class="');
			formHtml.push(this.options.formClass);
			formHtml.push('"');
		};
		if( this.options.action ) {
			formHtml.push(' action="');
			formHtml.push(this.options.action);
			formHtml.push('"');
		};
		if( this.options.enctype ) {
			formHtml.push(' enctype="');
			formHtml.push(this.options.enctype);
			formHtml.push('"');
		};
		if( this.options.method ) {
			formHtml.push(' method="');
			formHtml.push(this.options.method);
			formHtml.push('"');
		};
		if( this.options.target ) {
			formHtml.push(' target="');
			formHtml.push(this.options.target);
			formHtml.push('"');
		};
		formHtml.push('></form>');
		var $f = $(formHtml.join(''));
		this.form = $f[0];
		
		if( this.options.title ) {
			var $title = $('<div>'+this.options.title+'</div>');
			if( this.options.titleClass ) {
				$title.addClass(this.options.titleClass);
			};
			$f.append($title);
		};
		
		var $t = $('<table></table>');
		$f.append($t);

		// Format visible inputs in a table
		var formSchema = this.schema;
		for(var i=0,e=formSchema.attributes.length; i<e; ++i) {
			var attr = formSchema.attributes[i];
			
			if( ! attr.isHidden() ) {
				var $r = $('<tr></tr>');
				$t.append($r);
			
				var $d = $('<td>'+attr.label+'</td>');
				$r.append($d);
				
				$d = $('<td></td>');
				$r.append($d);
				
				this._addInput(attr, $d);
			};
		};
		
		// Buttons
		var buttonsPresent = false;
		if( formSchema.resetButton
		 || formSchema.okButton 
		 || formSchema.cancelButton 
		  ) {
		  buttonsPresent = true;
		} else if( formSchema.buttons && formSchema.buttons.length > 0 ) {
		  buttonsPresent = true;
		};
		if( buttonsPresent ) {
			var $r = $('<tr></tr>');
			$t.append($r);
		
			var $d = $('<td></td>');
			$r.append($d);
			
			$d = $('<td></td>');
			$r.append($d);

			if( formSchema.okButton ) {
				var $b = $('<button>'+formSchema.okButtonLabel+'</button>');
				if( $b.button ) {
					$b.button({icons:{primary:'ui-icon-check'}});
				};
				$d.append($b);
				$b.click(function(){
					recv._ok();
					return false;
				});
			};

			if( formSchema.cancelButton ) {
				var $b = $('<button>'+formSchema.cancelButtonLabel+'</button>');
				if( $b.button ) {
					$b.button({icons:{primary:'ui-icon-cancel'}});
				};
				$d.append($b);
				$b.click(function(){
					recv._cancel();
					return false;
				});
			};
			
			if( formSchema.resetButton ) {
				var $rb = $('<button>'+formSchema.resetButtonLabel+'</button>');
				if( $rb.button ) {
					$rb.button({icons:{primary:'ui-icon-arrowrefresh-1-s'}});
				};
				$d.append($rb);
				$rb.click(function(){
					recv._reset();
					return false;
				});
			};
			
			if( formSchema.buttons ) {
				for(var i=0,e=formSchema.buttons.length; i<e; ++i) {
					var button = formSchema.buttons[i];
					var $b = $('<button>'+button.label+'</button>');
					if( $b.button ) {
						$b.button();
					};
					$d.append($b);
					$b.click(createButtonPressedCallback(this, button.name));
				};
			};
		};

		// Add hidden inputs at the end of form
		for(var i=0,e=formSchema.attributes.length; i<e; ++i) {
			var attr = formSchema.attributes[i];
			
			if( attr.isHidden() ) {
				this._addInput(attr, $f);
			};
		};

		this.elem.append($f);
		
		function createButtonPressedCallback(self, name) {
			return function() {
				self._buttonPressed(name);
				return false;
			};
		};
	}
	
	,refreshFromData: function() {
		for(var i=0,e=this.inputs.length; i<e; ++i) {
			this.inputs[i].refreshFromData();
		};
	}
	
	,getInputFromName: function(name) {
		return this.inputsByName[name];
	}
	
	,_addInput: function(attr, $parent) {
		
		var inputUniqueId = $n2.getUniqueId();
		var input = new FormInput(inputUniqueId, attr, this.data, $parent, this.inputChangedCallback);
		this.inputs.push(input);
		
		this.inputsByName[attr.name] = input;
		
		this.inputsById[inputUniqueId] = input;
	}
	
	,_ok: function() {
		var okToProceed = this.options.preOK(this);
		if( okToProceed ) {
			this.form.submit();
			
			this.options.postOK(this);
		};
	}
	
	,_cancel: function() {
		var okToProceed = this.options.preCancel(this);
		if( okToProceed ) {
			this.elem.empty();
			this.form = null;
			this.inputs = [];
			this.inputsbyName = {};
			
			this.options.postCancel(this);
		};
	}
	
	,_reset: function() {
		var okToProceed = this.options.preReset(this);
		if( okToProceed ) {
			for(var i=0,e=this.inputs.length; i<e; ++i) {
				this.inputs[i].resetValue();
			};
			
			this.options.postReset(this);
		};
	}
	
	,_buttonPressed: function(name) {
		this.options.buttonPressed(this, name);
	}
	
	,_inputChanged: function(inputUniqueId) {
		//$n2.log('input changed', inputUniqueId);
		var input = this.inputsById[inputUniqueId];
		input.refreshObject();
		this.options.onChanged();
	}
	
	,getFormElement: function() {
		return this.form;
	}
	
	,getInputElements: function() {
		var result = [];
		for(var i=0,e=this.inputs.length; i<e; ++i) {
			result.push(this.inputs[i].getInputElement());
		};
		return result;
	}
	
	,hasAnyValueChanged: function() {
		for(var i=0,e=this.inputs.length; i<e; ++i) {
			if( this.inputs[i].hasValueChanged() ) return true;
		};
		return false;
	}
});

$n2.form = {
	Schema: FormSchema
	,Form: Form
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.displayBox.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.displayBox'
;

//=========================================================================

var DisplayImageSource = $n2.Class({
	
	images: null,
	
	initialize: function(opts_){
//		var opts = $n2.extend({
//			
//		},opts_);
		
		this.images = [];
	},
	
	getCountInfo: function(index){
		var result = {
			count: this.images.length
			,index: (index + 1)
		};
		return result;
	},
	
	getInfo: function(index){
		var info = null;
		var image = this.images[index];
		if( image ){
			info = {
				index: index
				,url: image.url
				,type: image.type
				,isPhotosphere: image.isPhotosphere
				,width: image.width
				,height: image.height
			};
		};
		return info;
	},
	
	printText: function(index, $elem, cb){
		$elem.empty();
		
		var image = this.images[index];
		if( image && image.text){
			$elem.text(image.text);
			
			if( cb ){
				cb(index);
			};
		};
	},
	
	loadImage: function(index, cb){
		var _this = this;
		
		var image = this.images[index];
		if( image ){
			if( image.loaded ){
				if( cb ) {
					var info = this.getInfo(index);
					cb(info);
				};
			} else {
				if( cb ) {
					if( image.cb ) {
						image.cb.push(cb);
					} else {
						image.cb = [cb];
					};
				};

				if( !image.preload ) {
					image.preload = new Image();
					image.preload.onload = function() {

						var image = _this.images[index];
						
						image.loaded = true;
						
						// Save original width and height
						image.width = image.preload.width;
						image.height = image.preload.height;
						
						// Forget onload
						image.preload.onload=function(){};
						
						if( image.cb ){
							var cbs = image.cb;
							image.cb = null;
							
							var info = _this.getInfo(index);
							for(var i=0,e=cbs.length; i<e; ++i){
								cbs[i](info);
							};
						};
					};
					
					var info = this.getInfo(index);
					image.preload.src = info.url;
				};
			};
		};
	},
	
	addImage: function(url, text){
		this.images.push({
			url: url
			,text: text
			,type: 'image'
			,isPhotosphere: false
		});
	},
	
	addPhotosphere: function(url, text){
		this.images.push({
			url: url
			,text: text
			,type: 'image'
			,isPhotosphere: true
		});
	},
	
	getPreviousIndex: function(index, cb){
		if( this.images.length < 2 ) return;

		var previousIndex = index - 1;
		if( previousIndex < 0 ){
			previousIndex = this.images.length - 1;
		};
		
		cb(previousIndex, index);
	},
	
	getNextIndex: function(index, cb){
		if( this.images.length < 2 ) return;

		var nextIndex = index + 1;
		if( nextIndex >= this.images.length ){
			nextIndex = 0;
		};
		
		cb(nextIndex, index);
	}
});

//=========================================================================

var DisplayImageSourceDoc = $n2.Class({
	
	showService: null,
	
	dispatchService: null,
	
	images: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			showService: null
			,dispatchService: null
		},opts_);
		
		this.images = [];
		
		this.showService = opts.showService;
		this.dispatchService = opts.dispatchService;
	},
	
	getCountInfo: function(index){
		var result = {
			count: this.images.length
			,index: (index + 1)
		};
		return result;
	},
	
	getInfo: function(index){
		var info = null;
		var image = this.images[index];
		if( image ){
			var doc = image.doc;

			var docSource = undefined;
			if( this.dispatchService ){
				var m = {
					type: 'documentSourceFromDocument'
					,doc: doc
				};
				this.dispatchService.synchronousCall(DH,m);
				docSource = m.documentSource;
			};

			var url = undefined;
			var originalUrl = undefined;
			if( docSource ){
				var att = docSource.getDocumentAttachment(doc, image.attName);
				
				url = att.computeUrl();
				
				var originalAtt = att.getOriginalAttachment();
				if( originalAtt ){
					originalUrl = originalAtt.computeUrl();
				};
			};

			var type = image.att.fileClass;
			var isPhotoshpere = false;
			if( image.att.photosphere 
			 && 'panorama' === image.att.photosphere.type ){
				isPhotoshpere = true;
			};
			
			info = {
				index: index
				,url: url
				,originalUrl: originalUrl
				,type: type
				,isPhotosphere: isPhotoshpere
				,width: image.width
				,height: image.height
			};
		};
		return info;
	},
	
	printText: function(index, $elem, cb){
		$elem.empty();
		
		var image = this.images[index];
		if( image && this.showService ){
			this.showService.displayBriefDescription(
				$elem
				,{
					onDisplayed: displayed
				}
				,image.doc
			);
		};
		
		function displayed($elem, doc, schema, opt_){
			if( cb ){
				cb(index);
			};
		};
	},
	
	loadImage: function(index, cb){
		var _this = this;
		
		var image = this.images[index];
		if( image ){
			if( image.loaded ){
				if( cb ) {
					var info = this.getInfo(index);
					cb({
						index: index
						,url: info.url
						,type: info.type
						,isPhotosphere: info.isPhotosphere
						,width: image.width
						,height: image.height
					});
				};
			} else {
				if( cb ) {
					if( image.cb ) {
						image.cb.push(cb);
					} else {
						image.cb = [cb];
					};
				};

				if( !image.preload ) {
					var info = this.getInfo(index);
					
					image.preload = new Image();
					image.preload.onload = function() {

						var image = _this.images[index];
						
						image.loaded = true;
						
						// Save original width and height
						image.width = image.preload.width;
						image.height = image.preload.height;
						
						// Forget onload
						image.preload.onload=function(){};
						
						if( image.cb ){
							var cbs = image.cb;
							image.cb = null;
							
							for(var i=0,e=cbs.length; i<e; ++i){
								cbs[i]({
									index: index
									,url: info.url
									,type: info.type
									,isPhotosphere: info.isPhotosphere
									,width: image.width
									,height: image.height
								});
							};
						};
					};
					
					image.preload.src = info.url;
				};
			};
		};
	},
	
	addDocument: function(doc, attachmentName){
		var att = null;
		if( doc 
		 && doc.nunaliit_attachments 
		 && doc.nunaliit_attachments.files 
		 && doc.nunaliit_attachments.files[attachmentName] ){
			att = doc.nunaliit_attachments.files[attachmentName];
		};
		
		if( att ){
			this.images.push({
				doc: doc
				,att: att
				,attName: attachmentName
			});
		};
	},
	
	getPreviousIndex: function(index, cb){
		if( this.images.length < 2 ) return;
		
		var previousIndex = index - 1;
		if( previousIndex < 0 ){
			previousIndex = this.images.length - 1;
		};
		
		cb(previousIndex, index);
	},
	
	getNextIndex: function(index, cb){
		if( this.images.length < 2 ) return;

		var nextIndex = index + 1;
		if( nextIndex >= this.images.length ){
			nextIndex = 0;
		};
		
		cb(nextIndex, index);
	}
});

//=========================================================================
/*

<div id="nunaliit2_uniqueId_127" class="n2DisplayBoxOuter" style="top: 84.5px; left: 0px;">
	<!-- This div is for setting the top position -->
	<div class="n2DisplayBoxImageOuter" style="width: 906px; height: 685px;">
		<div class="n2DisplayBoxImageInner">
			<div class="n2DisplayBoxImageWrapper">
				<img class="n2DisplayBoxImage" src="./db/4ae77032f04d840a2f0fd8c7f1006562/GOPR0027.jpg" style="width: 886px; height: 665px; display: inline;">
			</div>
			<a href="#" class="n2DisplayBoxNavBtn n2DisplayBoxNavBtnPrev" style="display: none; height: 685px;"></a>
			<a href="#" class="n2DisplayBoxNavBtn n2DisplayBoxNavBtnNext" style="display: none; height: 685px;"></a>
			<div class="n2DisplayBoxLoading" style="display: none;">
				<a class="n2DisplayBoxLoadingLink" href="#">
					<img class="n2DisplayBoxLoadingImg">
				</a>
			</div>
			<div class="n2DisplayBoxImageZoom n2DisplayBoxImageZoomPlus"></div>
			<div class="n2DisplayBoxImageZoom n2DisplayBoxImageZoomMinus n2DisplayBoxImageZoomDisabled"></div>
		</div>
	</div>
	<div class="n2DisplayBoxDataOuter" style="display: block; width: 886px;">
		<div class="n2DisplayBoxDataInner">
			<div class="n2DisplayBoxDataDetails">
				<span class="n2DisplayBoxDataCaption n2ShowUpdateDoc_4ae77032f04d840a2f0fd8c7f1006562 n2ShowDocBrief" style="display: inline;">
					<span class="n2s_localized">Demo Media</span>
					(Breakfast at Voyageur Camp)
				</span>
				<span class="n2DisplayBoxDataNumber" style="display: block;">1/1</span>
			</div>
			<div class="n2DisplayBoxButtons">
				<a href="#" class="n2DisplayBoxButtonClose"></a>
			</div>
		</div>
	</div>
</div>

 */

var DisplayBox = $n2.Class({
	
	overlayId: null,
	
	displayDivId: null,
	
	settings: null,
	
	windowResizeHandler: null,

	resizing: null,
	
	imageSource: null,
	
	currentImageIndex: null,

	/* Information about height and width */
	currentImage: null,
	
	currentGeometries: null,
	
	imageLastClick: null,
	
	clickOrigin: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			url: null
			,text: null
			,imageSource: null
			,startIndex: 0
		},opts_);
		
		var _this = this;
	
		this.resizing = false;
		this.currentImageIndex = opts.startIndex;
		
		this.currentGeometries = {};
		this.imageLastClick = 0;
		this.clickOrigin = null;
		
		this._initSettings();
		this._refreshCurrentGeometries();

		this.windowResizeHandler = function(){
			_this._windowResized();
		};
		$(window).on('resize',this.windowResizeHandler);
		
		if( opts.imageSource ){
			this.imageSource = opts.imageSource;
		} else {
			this.imageSource = new DisplayImageSource();
			
			if( opts.url && opts.text ){
				this.imageSource.addImage(opts.url, opts.text);
			};
		};
		
		this._draw();
		
		this._setImageToView();
	},
	
	_draw: function(){
		var _this = this;

		var $body = $('body');

		// Hide elements for IE
		$('embed, object, select').css('visibility','hidden');

		// Add overlay div
		this.overlayId = $n2.getUniqueId();
		var $overlayDiv = $('<div>')
			.attr('id',this.overlayId)
			.addClass('n2DisplayBoxOverlay')
			.appendTo($body);

		// Add display div
		this.displayDivId = $n2.getUniqueId();
		var $displayDiv = $('<div>')
			.attr('id',this.displayDivId)
			.addClass('n2DisplayBoxOuter')
			.appendTo($body);

		// Title bar area
		var $titleBarDiv = $('<div>')
			.addClass('n2DisplayBoxTitleBar')
			.appendTo($displayDiv);
		
		$('<a>')
    		.attr('href','#')
    		.attr('title', _loc('Close'))
    		.addClass('n2DisplayBoxButtonClose')
    		//.text( _loc('Close') )
    		.appendTo($titleBarDiv)
    		.click(function(){
    			_this._close();
    			return false;
    		});
		
		// Image area
		var $imageOuterDiv = $('<div>')
			.addClass('n2DisplayBoxImageOuter')
			.appendTo($displayDiv);
		var $imageInnerDiv = $('<div>')
			.addClass('n2DisplayBoxImageInner')
			.appendTo($imageOuterDiv)
			.click(function(e){
				// Do not close when clicking picture
				e.preventDefault();
				return false;
			})
			.bind('selectstart', function(e){
				e.preventDefault();
				return false;
			})
			;
		$('<a>')
			.attr('href','#')
			.addClass('n2DisplayBoxNavBtn n2DisplayBoxNavBtnPrev')
			.appendTo($imageInnerDiv)
			.bind('click',function(e) {
				e.preventDefault();
				_this._previousImage();
				return false;
			})
			;
		$('<a>')
			.attr('href','#')
			.addClass('n2DisplayBoxNavBtn n2DisplayBoxNavBtnNext')
			.appendTo($imageInnerDiv)
			.bind('click',function(e) {
				e.preventDefault();
				_this._nextImage();
				return false;
			})
			;
		var $loadingDiv = $('<div>')
			.addClass('n2DisplayBoxLoading')
			.appendTo($imageInnerDiv);
		var $loadingLink = $('<a>')
			.addClass('n2DisplayBoxLoadingLink')
			.attr('href','#')
			.appendTo($loadingDiv)
			.click(function(){
				_this._close();
				return false;
			});
		$('<img>')
			.addClass('n2DisplayBoxLoadingImg')
			.appendTo($loadingLink);
		
		// Data area
		var $dataOuterDiv = $('<div>')
			.addClass('n2DisplayBoxDataOuter')
			.appendTo($displayDiv)
			.click(function(e){
				var allowed = _this._isPassThruEvent(e);
				
				// Do not close when clicking data
				return allowed;
			});
		var $dataInnerDiv = $('<div>')
			.addClass('n2DisplayBoxDataInner')
			.appendTo($dataOuterDiv);
		var $dataDetailsDiv = $('<div>')
			.addClass('n2DisplayBoxDataDetails')
			.appendTo($dataInnerDiv);
		$('<span>')
			.addClass('n2DisplayBoxDataCaption')
			.appendTo($dataDetailsDiv);
		$('<span>')
			.addClass('n2DisplayBoxDataNumber')
			.appendTo($dataDetailsDiv);
		var $dataButtonsDiv = $('<div>')
			.addClass('n2DisplayBoxButtons')
			.appendTo($dataInnerDiv);

		$('<a>')
			.attr('href','#')
			.attr('title', _loc('Download'))
			.attr('download', 'image')
			.addClass('n2DisplayBoxButtonDownload n2DisplayBox_passThru')
			.appendTo($dataButtonsDiv);
		
		// Style overlay and show it
		$overlayDiv
			.css({
				backgroundColor: this.settings.overlayBgColor
				,opacity: this.settings.overlayOpacity
			})
			.fadeIn()
			.click(function(){
				_this._close();
				return false;
			});

		// Calculate top and left offset for the jquery-lightbox div object and show it
		$displayDiv
			.hide()
			.click(function(e){
				var passThru = _this._isPassThruEvent(e);
				
				if( passThru ){
					return true;
				};

				// When clicking, close image
				_this._close();
				return false;
			});

		this._resizeOverlay();
		this._resizeDisplay();
	},
	
	_close: function(){
		var $overlayDiv = this._getOverlayDiv();
		var $displayDiv = this._getDisplayDiv();

		$displayDiv.remove();
		$overlayDiv.fadeOut(function() { 
			$overlayDiv.remove(); 
		});
		
		// Show some elements to avoid conflict with overlay in IE. These elements appear above the overlay.
		$('embed, object, select').css('visibility', 'visible');

		this.imageSource = null;
	},
	
	_windowResized: function(){
		var _this = this;

		var $overlayDiv = this._getOverlayDiv();
		var $displayDiv = this._getDisplayDiv();
		
		if( $overlayDiv.length < 1 
		 && $displayDiv.length < 1 ){
			$(window).off('resize',this.windowResizeHandler);
			
		} else {
			$overlayDiv.hide();
			$displayDiv.hide();

			window.setTimeout(function(){
				_this._refreshCurrentGeometries();

				_this._resizeOverlay();
				_this._resizeDisplay();
			},0);
		};
	},
	
	_refreshCurrentGeometries: function(){
		var pageSizes = this._getPageSize();
		this.currentGeometries.pageHeight = pageSizes.pageHeight;
		this.currentGeometries.pageWidth = pageSizes.pageWidth;
		this.currentGeometries.windowWidth = pageSizes.windowWidth;
		this.currentGeometries.windowHeight = pageSizes.windowHeight;

		var pageScroll = this._getPageScroll();
		this.currentGeometries.xScroll = pageScroll.xScroll;
		this.currentGeometries.yScroll = pageScroll.yScroll;
		
//		$n2.log('windowWidth:'+this.currentGeometries.windowWidth
//				+' windowHeight:'+this.currentGeometries.windowHeight
//				+' pageWidth:'+this.currentGeometries.pageWidth
//				+' pageHeight:'+this.currentGeometries.pageHeight
//				);
	},
	
	_resizeOverlay: function(){
		var $overlayDiv = this._getOverlayDiv();

		// Style overlay and show it
		$overlayDiv
			.css({
				width: this.currentGeometries.pageWidth,
				height: this.currentGeometries.pageHeight
			})
			.show();
	},
	
	_resizeDisplay: function(){
		// Calculate top and left offset for the display div object and show it
		var $displayDiv = this._getDisplayDiv();
		$displayDiv.css({
			top: this.currentGeometries.yScroll + (this.currentGeometries.windowHeight / 10),
			left: this.currentGeometries.xScroll
		});

		this._resizeContainerImageBox();
	},
	
	_resizeContainerImageBox: function() {
		if( this.resizing ) return;

		var $displayDiv = this._getDisplayDiv();
		if( $displayDiv.length < 1 ) return;
		
		var _this = this;
		
		this.resizing = true;
		
		var ratios = this._computeMinMaxRatios();
		if( ratios && this.currentImage ){
			// Recall last ratio
			if( typeof this.currentImage.ratio === 'number' ){
				if( this.currentImage.ratio < ratios.min ){
					this.currentImage.ratio = ratios.min;
				};
				if( this.currentImage.ratio > ratios.max ){
					this.currentImage.ratio = ratios.max;
				};
			} else {
				this.currentImage.ratio = ratios.min;
			};
			if( this.currentImage.viewFullImage ){
				this.currentImage.ratio = ratios.min;
			};
			
			// $n2.log('effective ratio: '+this.currentImage.ratio);

			var intImageWidth = Math.floor(this.currentImage.ratio * this.currentImage.width);
			var intImageHeight = Math.floor(this.currentImage.ratio * this.currentImage.height);
			var intWrapperWidth = Math.floor(ratios.min * this.currentImage.width);
			var intWrapperHeight = Math.floor(ratios.min * this.currentImage.height);
			
			this.currentGeometries.imageWrapperWidth = intWrapperWidth;
			this.currentGeometries.imageWrapperHeight = intWrapperHeight;
			
			$displayDiv
				.css({
					//top: Math.floor(pageSizes.windowHeight / 10)+'px',
					top: '30px',
					left: 0
				})
				.show();
			$displayDiv.find('.n2DisplayBoxImageWrapper')
				.css({ width: intWrapperWidth, height: intWrapperHeight })
				.hide();
			$displayDiv.find('.n2DisplayBoxImage')
				.css({ width: intImageWidth, height: intImageHeight });
			$displayDiv.find('.n2DisplayBoxLoadingLink').show();
			$displayDiv.find('.n2DisplayBoxDataOuter').hide();
			$displayDiv.find('.n2DisplayBoxDataNumber').hide();
			
			// Get the width and height of the selected image plus the padding
			var intWidth = (intWrapperWidth + (this.settings.containerBorderSize * 2)); // Plus the image's width and the left and right padding value
			var intHeight = (intWrapperHeight + (this.settings.containerBorderSize * 2)); // Plus the image's height and the top and bottom padding value
			
			$displayDiv.find('.n2DisplayBoxTitleBar').css({ width: intWrapperWidth });
			
			$displayDiv.find('.n2DisplayBoxImageOuter').css({
				width: intWidth
				,height: intHeight
			});
			window.setTimeout(function(){
				_this._showImage(); 
			},0);
			
			$displayDiv.find('.n2DisplayBoxDataOuter').css({ width: intWrapperWidth });
		};
		
		this.resizing = false;
	},
	
	_computeMinMaxRatios: function(){
		var results = null;

		if( this.currentImage ){
			var intImageWidth = this.currentImage.width;
			var intImageHeight = this.currentImage.height;
			if( this.settings.constrainImage ) {
				var ratio = 1;
				var intMaxWidth = this.currentGeometries.windowWidth - (2 * this.settings.containerBorderSize);
				if (intImageWidth > intMaxWidth) {
					ratio = intMaxWidth / intImageWidth;
				};
				var intMaxHeight = this.currentGeometries.windowHeight - (2 * this.settings.containerBorderSize) - 60 - 100;
				if (intImageHeight > intMaxHeight) {
				    var tmpRatio = intMaxHeight / intImageHeight;
				    if( tmpRatio < ratio ) {
				    	ratio = tmpRatio;
				    };
				};

				results = {
					min: ratio
					,max: 1
				};

			} else {
				results = {
					min: 1
					,max: 1
				};
			};

			//$n2.log('ratio min:'+results.min+' max:'+results.max);
		};
		
		
		return results;
	},
	
	_showImage: function() {
		var _this = this;
		
		var $displayDiv = this._getDisplayDiv();

		$displayDiv.find('.n2DisplayBoxLoading').hide();
		$displayDiv.find('.n2DisplayBoxImageWrapper').fadeIn(function() {
			_this._showImageData();
			_this._setNavigation();
			_this._imagePositionUpdated();
		});
		_this._preloadNeighborImages();
	},
	
	_showImageData: function() {
		var _this = this;
		
		var $displayDiv = this._getDisplayDiv();

		$displayDiv.find('.n2DisplayBoxDataOuter').slideDown('fast');
		
		var $caption = $displayDiv.find('.n2DisplayBoxDataCaption').hide();
		this.imageSource.printText(
			this.currentImageIndex
			,$caption
			,function(index){
				if( _this.currentImageIndex == index ){
					$caption.show();
				};
			}
		);

		// If we have an image set, display 'Image X of X'
		var imageCountInfo = this.imageSource.getCountInfo(this.currentImageIndex);
		if( imageCountInfo ) {
			var label = _loc('{index}/{count}', {
				index: imageCountInfo.index
				,count: imageCountInfo.count
			});
			
			$displayDiv.find('.n2DisplayBoxDataNumber')
				.text(label)
				.show();
		} else {
			$displayDiv.find('.n2DisplayBoxDataNumber')
				.hide();
		};
		
		
		// Update Image URL for downloading
		var imageInfo = this.imageSource.getInfo(this.currentImageIndex);
		var originalUrl = imageInfo.originalUrl;
		if( !originalUrl ){
			originalUrl = imageInfo.url;
		};
		var name = imageInfo.name;
		if( !name ){
			var names = originalUrl.split('/');
			if( names.length > 0 ){
				name = names[names.length - 1];
				name = decodeURIComponent(name);
			} else {
				name = 'image';
			};
		};
		var imageDownloadButton = $displayDiv.find('.n2DisplayBoxButtonDownload');
		imageDownloadButton.attr('href',originalUrl);
		imageDownloadButton.attr('download',name);
	},
	
	_setNavigation: function() {
		var _this = this;
		
		var $displayDiv = this._getDisplayDiv();

		$displayDiv.find('.n2DisplayBoxNavBtnPrev').hide();
		this.imageSource.getPreviousIndex(this.currentImageIndex,function(previousIndex,currentIndex){
			if( _this.currentImageIndex === currentIndex ){
				$displayDiv.find('.n2DisplayBoxNavBtnPrev').show();
			};
		});

		$displayDiv.find('.n2DisplayBoxNavBtnNext').hide();
		this.imageSource.getNextIndex(this.currentImageIndex,function(nextIndex,currentIndex){
			if( _this.currentImageIndex === currentIndex ){
				$displayDiv.find('.n2DisplayBoxNavBtnNext').show();
			};
		});
		
		// Enable keyboard navigation
		//_enable_keyboard_navigation();
	},
	
	_nextImage: function(){
		var _this = this;
		this.imageSource.getNextIndex(this.currentImageIndex,function(nextIndex){
			_this.currentImageIndex = nextIndex;
			_this._setImageToView();
		});
	},
	
	_previousImage: function(){
		var _this = this;
		this.imageSource.getPreviousIndex(this.currentImageIndex,function(previousIndex){
			_this.currentImageIndex = previousIndex;
			_this._setImageToView();
		});
	},
	
	_setImageToView: function() { // show the loading
		var _this = this;
		
		var $displayDiv = this._getDisplayDiv();

		// Show the loading
		$displayDiv.find('.n2DisplayBoxLoading').show();
		$displayDiv.find('.n2DisplayBoxDataOuter').hide();
		$displayDiv.find('.n2DisplayBoxDataNumber').hide();
		$displayDiv.find('.n2DisplayBoxNavBtn').hide();

		$displayDiv.find('.n2DisplayBoxImageWrapper').remove();
		$displayDiv.find('.n2DisplayBoxImageZoom').remove();
		
		this.imageSource.loadImage(this.currentImageIndex, function(data){
			// Load only current image
			if( _this.currentImageIndex === data.index ){
				var $divImageInner = $displayDiv.find('.n2DisplayBoxImageInner');
				$divImageInner.find('.n2DisplayBoxImageWrapper').remove();

				// Save original width and height
				_this.currentImage = {
					width: data.width
					,height: data.height
					,viewFullImage: true
					,top: 0
					,left: 0
				};
				
				if( 'image' === data.type ){
					if( data.isPhotosphere 
					 && $n2.photosphere 
					 && $n2.photosphere.IsAvailable() ) {
						var $photosphere = $('<div>')
							.addClass('n2DisplayBoxImageWrapper')
							.prependTo($divImageInner);
						new $n2.photosphere.PhotosphereDisplay({
							elem: $photosphere
							,url: data.url
						});

						// In photosphere, make image a fixed ratio
						_this.currentImage.width = Math.floor(_this.currentImage.height * 3 / 2);

					} else {
						var $wrapper = $('<div>')
							.addClass('n2DisplayBoxImageWrapper')
							.prependTo($divImageInner)
							.mouseout(function(e){
								_this._imageMouseOut(e);
							})
							;
						
						$('<img>')
							.addClass('n2DisplayBoxImage')
							.attr('src',data.url)
							.appendTo($wrapper)
							.mousedown(function(e){
								_this._imageMouseDown(e);
							})
							.mousemove(function(e){
								_this._imageMouseMove(e);
							})
							.mouseup(function(e){
								_this._imageMouseUp(e);
							})
							;
						
						$('<div>')
							.addClass('n2DisplayBoxImageZoom n2DisplayBoxImageZoomPlus')
							.appendTo($divImageInner)
							.click(function(e){
								e.preventDefault();
								_this._imageZoom(+1);
								return false;
							})
							;
						
						$('<div>')
							.addClass('n2DisplayBoxImageZoom n2DisplayBoxImageZoomMinus')
							.appendTo($divImageInner)
							.click(function(e){
								e.preventDefault();
								_this._imageZoom(-1);
								return false;
							})
							;
					};
				};
				
				// Performance an effect in the image container resizing it
				_this._resizeContainerImageBox();
			};
		});
	},
	
	_preloadNeighborImages: function() {
		var _this = this;
		this.imageSource.getPreviousIndex(this.currentImageIndex,function(previousIndex){
			_this.imageSource.loadImage(previousIndex);
		});
		
		this.imageSource.getNextIndex(this.currentImageIndex,function(nextIndex){
			_this.imageSource.loadImage(nextIndex);
		});
	},
	
	_getDisplayDiv: function() {
		return $('#'+this.displayDivId);
	},
	
	_getOverlayDiv: function() {
		return $('#'+this.overlayId);
	},
	
	_getPageSize: function() {
		var xScroll, yScroll, windowWidth = 0, windowHeight = 0, pageWidth, pageHeight;
		
		if (window.innerHeight && window.scrollMaxY) {	
			xScroll = window.innerWidth + window.scrollMaxX;
			yScroll = window.innerHeight + window.scrollMaxY;
		} else if (document.body.scrollHeight > document.body.offsetHeight){ // all but Explorer Mac
			xScroll = document.body.scrollWidth;
			yScroll = document.body.scrollHeight;
		} else { // Explorer Mac...would also work in Explorer 6 Strict, Mozilla and Safari
			xScroll = document.body.offsetWidth;
			yScroll = document.body.offsetHeight;
		};

		if( window.self.innerHeight ) {	// all except Explorer
			if(document.documentElement.clientWidth){
				windowWidth = document.documentElement.clientWidth; 
			} else {
				windowWidth = window.self.innerWidth;
			};
			if(document.documentElement.clientWidth){
				windowHeight = document.documentElement.clientHeight; 
			} else {
				windowHeight = window.self.innerHeight;
			};
		} else if (document.documentElement && document.documentElement.clientHeight) { // Explorer 6 Strict Mode
			windowWidth = document.documentElement.clientWidth;
			windowHeight = document.documentElement.clientHeight;
		} else if (document.body) { // other Explorers
			windowWidth = document.body.clientWidth;
			windowHeight = document.body.clientHeight;
		};
		
		// for small pages with total height less then height of the viewport
		if(yScroll < windowHeight){
			pageHeight = windowHeight;
		} else { 
			pageHeight = yScroll;
		};
		
		// for small pages with total width less then width of the viewport
		if(xScroll < windowWidth){	
			pageWidth = xScroll;		
		} else {
			pageWidth = windowWidth;
		};
		
		var pageSize = {
			pageWidth: pageWidth
			,pageHeight: pageHeight
			,windowWidth: windowWidth
			,windowHeight: windowHeight
		};
		return pageSize;
	},
	
	_getPageScroll: function() {
		var xScroll = 0, yScroll = 0;
		if (window.self.pageYOffset) {
			yScroll = window.self.pageYOffset;
			xScroll = window.self.pageXOffset;
		} else if (document.documentElement && document.documentElement.scrollTop) {	 // Explorer 6 Strict
			yScroll = document.documentElement.scrollTop;
			xScroll = document.documentElement.scrollLeft;
		} else if (document.body) {// all other Explorers
			yScroll = document.body.scrollTop;
			xScroll = document.body.scrollLeft;	
		};
		
		var pageScroll = {
			xScroll: xScroll
			,yScroll: yScroll
		};
		return pageScroll;
	},
	
	_initSettings: function(){
		this.settings = {
			// Configuration related to overlay
			overlayBgColor: '#000'
			,overlayOpacity: 0.8
			// Configuration related to container image box
			,containerBorderSize: 10
			// Don't alter these variables in any way
			,constrainImage: true
		};
	},
	
	_imageZoom: function(change){
		var $displayDiv = this._getDisplayDiv();
		if( $displayDiv.length < 1 ) return;
		
		var ratio = this.currentImage.ratio;
		if( typeof ratio === 'number' ){
			if( change > 0 ){
				ratio = ratio + 0.25;
			} else {
				ratio = ratio - 0.25;
			};
			
			this.currentImage.viewFullImage = false;
			
			var ratios = this._computeMinMaxRatios();
			if( ratios ){
				if( ratio < ratios.min ){
					ratio = ratios.min;
				};
				if( ratio > ratios.max ){
					ratio = ratios.max;
				};
				
				// Must save centre
				var cx = this.currentGeometries.imageWrapperWidth/2 - this.currentImage.left;
				cx = cx / this.currentImage.ratio;
				var cy = this.currentGeometries.imageWrapperHeight/2 - this.currentImage.top;
				cy = cy / this.currentImage.ratio;
				
				this.currentImage.ratio = ratio;
				
				// Recompute top and left from centre
				this.currentImage.left = Math.floor( (this.currentGeometries.imageWrapperWidth/2) 
					- (cx * this.currentImage.ratio) );
				this.currentImage.top = Math.floor( (this.currentGeometries.imageWrapperHeight/2) 
					- (cy * this.currentImage.ratio) );
				
				this._imagePositionUpdated();
			};
		};
	},
	
	_imagePositionUpdated: function(){
		var $displayDiv = this._getDisplayDiv();
		if( $displayDiv.length < 1 ) return;
		
		var $img = $displayDiv.find('.n2DisplayBoxImage');
		// $n2.log('width:'+$img.css('width')+' height:'+$img.css('height'));

		var height = this.currentImage.height * this.currentImage.ratio;
		var width = this.currentImage.width * this.currentImage.ratio;
		
		// Check limits on left and top
		var minTop = this.currentGeometries.imageWrapperHeight - height;
		var minLeft = this.currentGeometries.imageWrapperWidth - width;
		if( this.currentImage.top > 0 ){
			this.currentImage.top = 0;
		};
		if( this.currentImage.top < minTop ){
			this.currentImage.top = minTop;
		};
		if( this.currentImage.left > 0 ){
			this.currentImage.left = 0;
		};
		if( this.currentImage.left < minLeft ){
			this.currentImage.left = minLeft;
		};
		
		$img.css({
				height: height
				,width: width
				,top: this.currentImage.top
				,left: this.currentImage.left
				,position: 'relative'
			});

		// disable zoom buttons, if needed
		var ratios = this._computeMinMaxRatios();
		if( this.currentImage.ratio <= ratios.min ){
			$displayDiv.find('.n2DisplayBoxImageZoomMinus').addClass('n2DisplayBoxImageZoomDisabled');
		} else {
			$displayDiv.find('.n2DisplayBoxImageZoomMinus').removeClass('n2DisplayBoxImageZoomDisabled');
		};
		if( this.currentImage.ratio >= ratios.max ){
			$displayDiv.find('.n2DisplayBoxImageZoomPlus').addClass('n2DisplayBoxImageZoomDisabled');
		} else {
			$displayDiv.find('.n2DisplayBoxImageZoomPlus').removeClass('n2DisplayBoxImageZoomDisabled');
		};
	},
	
	_imageMouseDown: function(e){

		//--------------------------------------------------
		// Event

		e.preventDefault();

		//--------------------------------------------------
		// Double tap/click event

		var now = new Date().getTime();
		if( this.imageLastClick > (now - 200) ) {
			this._imageZoom(1);
		} else {
			this.imageLastClick = now;
		};

		//--------------------------------------------------
		// Add events

		// http://www.quirksmode.org/blog/archives/2010/02/the_touch_actio.html
		// http://www.quirksmode.org/m/tests/drag.html

//		if (e.type === 'touchstart') {
//
//			this.img_ref.onmousedown = null;
//			this.img_ref.ontouchmove = image_move_event;
//			this.img_ref.ontouchend = function() {
//				this.img_ref.ontouchmove = null;
//				this.img_ref.ontouchend = null;
//			};
//
//		} else {
//
//			document.onmousemove = image_move_event;
//			document.onmouseup = function() {
//				document.onmousemove = null;
//				document.onmouseup = null;
//			};
//
//		};

		//--------------------------------------------------
		// Record starting position

		this.currentImage.startLeft = this.currentImage.left;
		this.currentImage.startTop = this.currentImage.top;
		

		this.clickOrigin = this._getEventCoords(e);
	},
	
	_imageMouseUp: function(e){
		this.clickOrigin = null;
	},
	
	_imageMouseOut: function(e){
		this.clickOrigin = null;
	},
	
	_imageMouseMove: function(e) {
		
		if( this.clickOrigin ){

			e.preventDefault();

			var currentPos = this._getEventCoords(e);

			this.currentImage.left = (this.currentImage.startLeft + (currentPos[0] - this.clickOrigin[0]));
			this.currentImage.top = (this.currentImage.startTop + (currentPos[1] - this.clickOrigin[1]));

			this._imagePositionUpdated();

			return false;
		};
		
		return true;
	},
	

	_getEventCoords: function(e) {
		var coords = [];
		if( e.touches && e.touches.length ) {
			coords[0] = e.touches[0].clientX;
			coords[1] = e.touches[0].clientY;
		} else {
			coords[0] = e.clientX;
			coords[1] = e.clientY;
		};
		return coords;
	},
	
	_isPassThruEvent: function(e){
		var $target = $(e.target);
		var allowed = false;
		if( $target.hasClass('n2DisplayBox_passThru') ){
			allowed = true;
		};
		if( !allowed ){
			var allowedParents = $target.parents('.n2DisplayBox_passThru');
			if( allowedParents.length > 0 ){
				allowed = true;
			};
		};
		
		return allowed;
	}
});

// =========================================================================

$n2.displayBox = {
	DisplayBox: DisplayBox
	,DisplayImageSource: DisplayImageSource
	,DisplayImageSourceDoc: DisplayImageSourceDoc
};	
	
})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.displayTiledImage.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

var emptyTileURL = "http://www.maptiler.org/img/none.png";

//=========================================================================

var DisplayTiledImage = $n2.Class({

	url: null,

	extension: null,

	elemId: null,

	mapBounds: null,

	mapMinZoom: null,

	mapMaxZoom: null,

	numZoomLevels: null,

	maxResolution: null,

	docId: null,

	showService: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			url: null
			,parent: null
			,tileMapResourceName: null
			,extension: 'png'
			,docId: null
			,showService: null
		},opts_);
		
		var _this = this;
		
		this.url = opts.url;
		this.extension = opts.extension;
		this.docId = opts.docId;
		this.showService = opts.showService;
		
		// Compute parent
		var $parent;
		if( typeof opts.parent === 'string' ){
			$parent = $('#'+opts.parent);
			if( $parent.length < 1 ){
				$parent = undefined;
			};
		} else if( opts.parent ){
			$parent = $(opts.parent);
		};
		if( !$parent ){
			$parent = $('.nunaliit_content').first();
			if( $parent.length < 1 ){
				$parent = undefined;
			};
		};
		if( !$parent ){
			$parent = $('body');
		};
		this.elemId = $n2.getUniqueId();
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2TiledImage')
			.appendTo($parent);
	
		// Fetch parameters
		if( opts.tileMapResourceName ){
			var tmrUrl = this.url + '/' + opts.tileMapResourceName;
			$.ajax({
				url: tmrUrl
				,type: 'get'
				,async: true
				,dataType: 'xml'
				,success: function(xmlDoc) {
					_this._readTimeMapResourceDoc(xmlDoc);
				}
				,error: function(XMLHttpRequest, textStatus, errorThrown) {
					alert( _loc('Unable to retrieve time map resource at {url}',{
						url: tmrUrl
					}) );
				}
			});
		};
	},

	_draw: function(){
		var _this = this;

		var $elem = $('#'+this.elemId).empty();

		var $container = $('<div>')
			.addClass('n2TiledImage_container')
			.appendTo($elem);
		
		var mapId = $n2.getUniqueId();
		$('<div>')
			.attr('id',mapId)
			.addClass('n2TiledImage_map')
			.appendTo($container);

		var $footer = $('<div>')
			.addClass('n2TiledImage_footer')
			.appendTo($container);
		
		$('<div>')
			.addClass('n2TiledImage_close')
			.appendTo($footer)
			.click(function(){
				_this._close();
				return false;
			});
		
		if( this.docId 
		 && this.showService ){
			var $desc = $('<div>')
				.addClass('n2TiledImage_desc')
				.appendTo($footer);
			this.showService.printBriefDescription($desc, this.docId);
		};
		
		this._drawMap(mapId);
	},

	_drawMap: function(mapDivId){
		var _this = this;

        var options = {
            div: mapDivId,
            controls: [],
            maxExtent: this.mapBounds,
            maxResolution: this.maxResolution,
            numZoomLevels: this.numZoomLevels
        };
        var map = new OpenLayers.Map(options);

        var layer = new OpenLayers.Layer.TMS('TMS Layer', '', {
            serviceVersion: '.',
            layername: '.',
            alpha: true,
            type: this.extension,
            getURL: getURL
        });

        map.addLayer(layer);
        map.zoomToExtent(this.mapBounds);
  
        map.addControls([
			new OpenLayers.Control.Zoom(),
			new OpenLayers.Control.Navigation()
		]);

        function getURL(bounds) {
            bounds = this.adjustBounds(bounds);
            var res = this.getServerResolution();
            var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
            var y = Math.round((bounds.bottom - this.tileOrigin.lat) / (res * this.tileSize.h));
            var z = this.getServerZoom();
            var path = "/" + z + "/" + x + "/" + y + "." + this.type; 
            var url = _this.url;
            if (OpenLayers.Util.isArray(url)) {
                url = this.selectUrl(path, url);
            };
            if( _this.mapBounds.intersectsBounds(bounds) 
             && (z >= _this.mapMinZoom) && (z <= _this.mapMaxZoom) ) {
                return url + path;
            } else {
                return emptyTileURL;
            };
        };
	},

	_close: function(){
		$('#'+this.elemId).remove();
	},
	
	_readTimeMapResourceDoc: function(xmlDoc){
		var _this = this;
		
		$n2.log('Time Map Resource',xmlDoc);

		var tileMap = xmlDoc.documentElement;
		var nodeList = tileMap.childNodes;
		for(var i=0; i<nodeList.length; ++i){
			var childNode = nodeList.item(i);
			
			if( childNode.nodeType === 1 ){ // element
				if( 'BoundingBox' === childNode.localName ){
					parseBoundingBox(childNode);
				} else if( 'TileFormat' === childNode.localName ){
					parseTileFormat(childNode);
				} else if( 'TileSets' === childNode.localName ){
					parseTileSets(childNode);
				};
			};
		};
		
		this._draw();

		function parseBoundingBox(elem){
			var attMap = elem.attributes;
			
			var minx = 0
				,maxx = 0
				,miny = 0
				,maxy = 0;

			var minxAttr = attMap.getNamedItem('minx');
			if(minxAttr){
				minx = 1 * minxAttr.value;
			};

			var maxxAttr = attMap.getNamedItem('maxx');
			if(maxxAttr){
				maxx = 1 * maxxAttr.value;
			};

			var minyAttr = attMap.getNamedItem('miny');
			if(minyAttr){
				miny = 1 * minyAttr.value;
			};

			var maxyAttr = attMap.getNamedItem('maxy');
			if(maxyAttr){
				maxy = 1 * maxyAttr.value;
			};
			
			_this.mapBounds = new OpenLayers.Bounds(minx, miny, maxx, maxy);
		};

		function parseTileFormat(elem){
			var attMap = elem.attributes;
			
			var extAttr = attMap.getNamedItem('extension');
			if(extAttr){
				_this.extension = extAttr.value;
			};
		};

		function parseTileSets(elem){
			var minZoomLevel = undefined,
				maxZoomLevel = undefined,
				maxResolution = undefined,
				numZoomLevels = 0;

			var nodeList = elem.childNodes;
			for(var i=0; i<nodeList.length; ++i){
				var childNode = nodeList.item(i);
				
				if( childNode.nodeType === 1 ){ // element
					if( 'TileSet' === childNode.localName ){
						var attMap = childNode.attributes;
						
						var zoomLevelAttr = attMap.getNamedItem('href');
						if( zoomLevelAttr ){
							var zoomLevel = 1 * zoomLevelAttr.value;
							++numZoomLevels;

							if( typeof minZoomLevel === 'undefined' ){
								minZoomLevel = zoomLevel;
							} else if( minZoomLevel > zoomLevel ){
								minZoomLevel = zoomLevel;
							};

							if( typeof maxZoomLevel === 'undefined' ){
								maxZoomLevel = zoomLevel;
							} else if( maxZoomLevel < zoomLevel ){
								maxZoomLevel = zoomLevel;
							};
						};
						
						var unitsPerPixelAttr = attMap.getNamedItem('units-per-pixel');
						if( unitsPerPixelAttr ){
							var resolution = 1 * unitsPerPixelAttr.value;

							if( typeof maxResolution === 'undefined' ){
								maxResolution = resolution;
							} else if( maxResolution < resolution ){
								maxResolution = resolution;
							};
						};
					};
				};
			};

			if( typeof minZoomLevel !== 'undefined' ){
				_this.mapMinZoom = minZoomLevel;
			};
			if( typeof maxZoomLevel !== 'undefined' ){
				_this.mapMaxZoom = maxZoomLevel;
			};
			if( typeof maxResolution !== 'undefined' ){
				_this.maxResolution = maxResolution;
			};
			
			_this.numZoomLevels = numZoomLevels;
		};
	}
});

// =========================================================================

$n2.displayTiledImage = {
	DisplayTiledImage: DisplayTiledImage
};	
	
})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.mediaDisplay.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };
	
var DEFAULT_VIDEO_HEIGHT = 240;
var DEFAULT_VIDEO_WIDTH = 320;
var DEFAULT_VIDEO_CONTROLLER_HEIGHT = 16;
var DEFAULT_VIDEO_DIALOG_EXTRA_WIDTH = 40;
var DEFAULT_VIDEO_DIALOG_EXTRA_HEIGHT = 56;

var MEDIAELEMENT_DIALOG_EXTRA_WIDTH = 25;

var defaultDialogTitle = _loc('View Media');

var baseDialogOptions = {
	autoOpen: true
	,modal: true
	,dialogClass: 'n2MediaDisplayDialog' // jQuery dialog option
};

$n2.MediaDisplay = $n2.Class({
	 initialize: function() {

	}

	,displayMedia: function(opts_) {
		var opts = $n2.extend({
			type: null
			,url: null
			,mimeType: null
			,title: null
			,author: null
			,description: null
			,width: null // hint of media width (optional)
			,height: null // hint of media height (optional)
			,suppressLeaveConfirmation: false
			,onClose: function(opts) {}
			,onError: function(err){ $n2.reportError(err); }
		},opts_);
		
		var onCloseHook = function(event, ui) {
			opts.onClose(opts);
		};
		opts.onCloseHook = onCloseHook;
		
		if( null == opts.url ) {
			opts.onError('URL must be provided to display a media');
		};
		
		if( 'image' === opts.type ) {
			this._displayImage(opts);
		} else if( 'photosphere' === opts.type ) {
			this._displayPhotosphere(opts);
		} else if( 'audio' === opts.type ) {
			if( $.fn && $.fn.mediaelementplayer ) {
				this._displayAudioMediaElement(opts);
			} else {
				this._displayAudio(opts);
			};
		} else if( 'video' === opts.type ) {
			if( $.fn && $.fn.mediaelementplayer ) {
				this._displayVideoMediaElement(opts);
			} else {
				this._displayVideo(opts);
			};
		} else {
			if( opts.suppressLeaveConfirmation ){
				window.location.href = opts.url;
			} else {
				this._displayUnknown(opts);
			};
		};
	}

	,_displayImage: function(opts) {
		if( $.lightBox ) {
			var lightBoxOptions = {};
			
			var title = '';
			if( opts.metaDataHtml ) {
				title = opts.metaDataHtml;
			} else {
				if( opts.title ) {
					title += opts.title;
				};
				if( opts.author ) {
					title += ' (by ' + opts.author +')';
				};
				if( opts.description ) {
					title += ' <br />' + opts.description;
				};
			};
			
			$.lightBox(lightBoxOptions,[{
				href:opts.url
				,title:title
				}]);

		} else {

			var dialogTitle = defaultDialogTitle;
			if( opts.title ) {
				dialogTitle = opts.title;
			};

			var mediaDialogId = $n2.getUniqueId();
			
			var alt = 'image';
			if( opts.title ){
				alt = opts.title;
			};

			var $mediaDialog = $('<div id="'+mediaDialogId+'"><img alt="'+alt+'"/></div>');
			var $metaDataDiv = $('<div class="n2_dialogMetaData"></div>');
			$mediaDialog.append($metaDataDiv);
			this._addMetaData(opts, $metaDataDiv);
			
			var dialogOptions = $n2.extend({},baseDialogOptions,{
				title: dialogTitle
				,width: 360
				,height: 360
				,close: function(){
					$('#'+mediaDialogId).remove();
					opts.onCloseHook();
				}
			});
			$mediaDialog.dialog(dialogOptions);

			// Image preload process
			var objImagePreloader = new Image();
			objImagePreloader.onload = function() {
				var $d = $('#'+mediaDialogId);

				$d.find('img').attr('src',opts.url);
				// Save original width and height
				var width = objImagePreloader.width;
				var height = objImagePreloader.height;
				//	clear onLoad, IE behaves irratically with animated gifs otherwise
				objImagePreloader.onload=function(){};
				
				var $md = $d.find('.n2_dialogMetaData');
				var mdWidth = $md.width() || 0;
				var mdHeight = $md.height() || 0;
				
				var dWidth = width;
				if( dWidth < mdWidth ) {
					dWidth = mdWidth;
				};
				var dHeight = height + mdHeight;
				
				$d.dialog('option','width',dWidth+30);
				$d.dialog('option','height',dHeight+60);
			};
			objImagePreloader.src = opts.url;
		}
	}
	
	,_displayPhotosphere: function(opts) {
		if( $n2.photosphere.IsAvailable() ){
			var dialogTitle = defaultDialogTitle;
			if( opts.title ) {
				dialogTitle = opts.title;
			};

			var mediaDialogId = $n2.getUniqueId();
			
			var alt = 'image';
			if( opts.title ){
				alt = opts.title;
			};

			var $mediaDialog = $('<div>')
				.attr('id',mediaDialogId);

			var $panoDiv = $('<div>')
				.addClass('n2MediaDisplayPhotosphere')
				.appendTo($mediaDialog);

			var $metaDataDiv = $('<div>')
				.addClass('n2_dialogMetaData')
				.appendTo($mediaDialog);
			this._addMetaData(opts, $metaDataDiv);
			
			var dialogOptions = $n2.extend({},baseDialogOptions,{
				title: dialogTitle
				,width: 1024
				,height: 600
				,close: function(){
					$('#'+mediaDialogId).remove();
					opts.onCloseHook();
				}
			});
			$mediaDialog.dialog(dialogOptions);

			// Load photosphere
			new $n2.photosphere.PhotosphereDisplay({
				elem: $panoDiv
				,url: opts.url
			});
			
		} else {
			this._displayImage(opts);
		};
	}

	,_displayVideo: function(opts) {
		var dialogTitle = defaultDialogTitle;
		if( opts.title ) {
			dialogTitle = opts.title;
		};

		var mediaDialogId = $n2.getUniqueId();
		
		var mkup = [];
		mkup.push('<div id="'+mediaDialogId+'">');

		var browserInfo = $n2.utils.getBrowserInfo();
		if( "Safari" === browserInfo.browser &&
				5.0 <= browserInfo.version){
			var embedHtml = this.generateHtml5Tag({
				url: opts.url
				,sourceType: 'video'
				,mimeType: opts.mimeType
				,autoplay: true
				,loop: false
				,controller: true
			});
		} else {
			var embedOptions = $n2.extend({},{
				url: opts.url
				,sourceType: 'video'
				,mimeType: opts.mimeType
				,controller: true
			});

			if( opts.mediaDisplayVideoWidth ) {
				embedOptions.width = opts.mediaDisplayVideoWidth;
			} else if( opts.width ) {
				embedOptions.width = opts.width;
			} else {
				embedOptions.width = DEFAULT_VIDEO_WIDTH;
			};
			
			if( opts.mediaDisplayVideoHeight ) {
				embedOptions.height = opts.mediaDisplayVideoHeight + DEFAULT_VIDEO_CONTROLLER_HEIGHT;
			} else if( opts.height ) {
				embedOptions.height = opts.height + DEFAULT_VIDEO_CONTROLLER_HEIGHT;
			} else {
				embedOptions.height = DEFAULT_VIDEO_HEIGHT + DEFAULT_VIDEO_CONTROLLER_HEIGHT;
			};

			var embedHtml = this.generateEmbedMarkup(embedOptions);
		};
		
		mkup.push(embedHtml);
		
		mkup.push('</div>');

		var $mediaDialog = $( mkup.join('') );
		
		this._addMetaData(opts, $mediaDialog);
		this._addDownloadButton(opts, $mediaDialog);

		var dialogOptions = $n2.extend({}
			,baseDialogOptions
			,{
				title: dialogTitle
				,close: function(){
					$('#'+mediaDialogId).remove();
					opts.onCloseHook();
				}
			}
		);

		// Dialog width
		if( opts.mediaDisplayVideoWidth ) {
			dialogOptions.width = opts.mediaDisplayVideoWidth + DEFAULT_VIDEO_DIALOG_EXTRA_WIDTH;
		} else if( opts.width ) {
			dialogOptions.width = opts.width + DEFAULT_VIDEO_DIALOG_EXTRA_WIDTH;
		} else {
			dialogOptions.width = DEFAULT_VIDEO_WIDTH + DEFAULT_VIDEO_DIALOG_EXTRA_WIDTH;
		};
		
		// Dialog height
		if( opts.mediaDisplayVideoHeight ) {
			dialogOptions.height = opts.mediaDisplayVideoHeight + DEFAULT_VIDEO_DIALOG_EXTRA_HEIGHT;
		};
		
		$mediaDialog.dialog(dialogOptions);
	}
	
	,_displayVideoMediaElement: function(opts) {
		var dialogTitle = defaultDialogTitle;
		if( opts.title ) {
			dialogTitle = opts.title;
		};

		var mediaDialogId = $n2.getUniqueId();
		var videoId = $n2.getUniqueId();

		var width = DEFAULT_VIDEO_WIDTH;
		if( opts.mediaDisplayVideoWidth ) {
			width = opts.mediaDisplayVideoWidth;
		} else if( opts.width ) {
			width = opts.width;
		};

		var height = DEFAULT_VIDEO_HEIGHT;
		if( opts.mediaDisplayVideoHeight ) {
			height = opts.mediaDisplayVideoHeight + DEFAULT_VIDEO_CONTROLLER_HEIGHT;
		} else if( opts.height ) {
			height = opts.height + DEFAULT_VIDEO_CONTROLLER_HEIGHT;
		};
		
		var mkup = [];
		mkup.push('<div id="'+mediaDialogId+'">');

		mkup.push('<video id="'+videoId+'" controls="controls"  width="'+width+'" height="'+height+'">');
		
		mkup.push('<source src="'+opts.url+'"');
		if( opts.mimeType ){
			mkup.push(' type="'+opts.mimeType+'"');
		};
		mkup.push('>');
		
		mkup.push('</video>');
		
		var $mediaDialog = $( mkup.join('') );
		
		this._addMetaData(opts, $mediaDialog);
		this._addDownloadButton(opts, $mediaDialog);

		var dialogOptions = $n2.extend({}
			,baseDialogOptions
			,{
				title: dialogTitle
				,width: width + MEDIAELEMENT_DIALOG_EXTRA_WIDTH
				,close: function(){
					$('#'+mediaDialogId).remove();
					opts.onCloseHook();
				}
			}
		);
		
		$mediaDialog.dialog(dialogOptions);
		
		$('#'+videoId).mediaelementplayer({
			features: ['playpause','progress','volume','sourcechooser','fullscreen']
		});
	}

	,_displayAudio: function(opts) {
		var dialogTitle = defaultDialogTitle;
		if( opts.title ) {
			dialogTitle = opts.title;
		};

		var mediaDialogId = $n2.getUniqueId();

		if( $.jPlayer ) {
			var $mediaDialog = $('<div id="'+mediaDialogId+'"></div>');
			var $player = $('<div class="n2Media_jPlayer"></div>');
			$mediaDialog.append($player);
			
		} else {
			var browserInfo = $n2.utils.getBrowserInfo();

			// Generate local markup
			var mkup = [];
			mkup.push('<div id="'+mediaDialogId+'">');
			if( "Safari" === browserInfo.browser &&
					5.0 <= browserInfo.version){
				var embedHtml = this.generateHtml5Tag({
					url: opts.url
					,sourceType: 'audio'
					,mimeType: opts.mimeType
//					,width: 200
//					,height: 16
					,autoplay: true
					,loop: false
					,controller: true
				});
			} else {
				var embedHtmlOpts = {
						url: opts.url
						,sourceType: 'audio'
						,mimeType: opts.mimeType
						// Let float
						//,height: 16
						,controller: true
					};
				var embedHtml = this.generateEmbedMarkup(embedHtmlOpts);
			};
			mkup.push(embedHtml);
	
			mkup.push('</div>');
	
			var $mediaDialog = $( mkup.join('') );
		};
		
		this._addMetaData(opts, $mediaDialog);
		this._addDownloadButton(opts, $mediaDialog);

		var dialogOptions = $n2.extend({},baseDialogOptions,{
			title: dialogTitle
			,width: 320
			,close: function(){
				$('#'+mediaDialogId).remove();
				opts.onCloseHook();
			}
		});
		$mediaDialog.dialog(dialogOptions);
		
		if( $.jPlayer ) {
			var $player = $mediaDialog.find('.n2Media_jPlayer');
			$player.jPlayer({
				ready: function(){
					var $m = $(this);
					$m.jPlayer('setMedia',{
						mp3: opts.url
					});
				}
				,swfPath:'./js-external/jQuery.jPlayer/'
				,size: {
					width: 100
					,height: 100
				}
			});
		};
	}

	,_displayAudioMediaElement: function(opts) {
		var dialogTitle = defaultDialogTitle;
		if( opts.title ) {
			dialogTitle = opts.title;
		};

		var mediaDialogId = $n2.getUniqueId();
		var audioId = $n2.getUniqueId();

		var browserInfo = $n2.utils.getBrowserInfo();

		var width = 300;
		
		// Generate local markup
		var mkup = [];
		mkup.push('<div id="'+mediaDialogId+'">');

		//mkup.push('<audio id="'+audioId+'" controls="controls"  width="'+width+'" height="'+height+'">');
		mkup.push('<audio id="'+audioId+'" controls="controls" width="'+width+'">');
		
		mkup.push('<source src="'+opts.url+'"');
		if( opts.mimeType ){
			mkup.push(' type="'+opts.mimeType+'"');
		};
		mkup.push('>');
		
		mkup.push('</audio>');

		mkup.push('</div>');

		var $mediaDialog = $( mkup.join('') );
		
		this._addMetaData(opts, $mediaDialog);
		this._addDownloadButton(opts, $mediaDialog);

		var dialogOptions = $n2.extend({},baseDialogOptions,{
			title: dialogTitle
			,width: width + MEDIAELEMENT_DIALOG_EXTRA_WIDTH
			,close: function(){
				$('#'+mediaDialogId).remove();
				opts.onCloseHook();
			}
		});
		$mediaDialog.dialog(dialogOptions);
		
		$('#'+audioId).mediaelementplayer({
			features: ['playpause','progress','volume','sourcechooser']
		});
	}

	,_displayUnknown: function(opts) {
		var dialogTitle = defaultDialogTitle;
		if( opts.title ) {
			dialogTitle = opts.title;
		};

		var mediaDialogId = $n2.getUniqueId();

		// Generate local markup
		var $mediaDialog = $('<div></div>');
		$mediaDialog.attr('id',mediaDialogId);
		
		var $meta = $('<div></div>')
			.appendTo($mediaDialog);
		this._addMetaData(opts, $mediaDialog);
		
		var $explain = $('<div class="n2Media_explain"></div>');
		$explain.text( _loc('You must leave the atlas to view this file.') );
		$mediaDialog.append($explain);
		
		var $buttons = $('<div class="n2Display_buttons"></div>')
			.appendTo($mediaDialog);
		$('<a class="nunaliit_form_link"></a>')
			.attr('href',opts.url)
			.text( _loc('Proceed') )
			.appendTo($buttons);

		var dialogOptions = $n2.extend({},baseDialogOptions,{
			title: dialogTitle
			,width: 320
			,close: function(){
				$('#'+mediaDialogId).remove();
				opts.onCloseHook();
			}
		});
		$mediaDialog.dialog(dialogOptions);
	}
	
	,_addMetaData: function(opts, $elem) {
		$elem.append( $('<br/>') );
		
		if( opts.metaDataHtml ) {
			var $meta = $('<span></span>');
			$meta.html(opts.metaDataHtml);
			$elem.append( $meta );
			
		} else {
			if( opts.author ) {
				var $author = $('<span></span>');
				$author.text( _loc('(by {author})',{
					author: opts.author
				}) );
				$elem.append( $author );
				$elem.append( $('<br/>') );
			};
			if( opts.description ) {
				var $desc = $('<span></span>');
				$desc.text( opts.description );
				$elem.append( $desc );
			};
		};
	}
	
	,_addDownloadButton: function(opts, $elem) {
		$('<a>')
		.attr('href',opts.url)
		.attr('title', _loc('Download'))
		.addClass('n2DisplayBoxButtonDownload')
		.click(function(e){
			if(opts.suppressLeaveConfirmation){
				return true;
			};
			if( confirm( _loc('You are about to leave this page. Do you wish to continue?') ) ) {
				return true;
			};
			return false;
		})
		.appendTo($elem);
	}
	
	,generateInlineHtmlForMedia: function(opts_) {	
		var opts = $n2.extend({
			type: null
			,url: null
			,mimeType: null
			,autoplay: true
			,caption: null
			,headerHtml: null
			,footerHtml: null
			,onError: function(err){ $n2.reportError(err); }
		},opts_);

		var html = [];
		html.push('<div><p>');
		
		if( opts.headerHtml ) {
			html.push(opts.headerHtml);
			html.push('</p><p>');
		
		};
		
		if( opts.type === 'image' ) {
			html.push('<img src="'+ opts.url +'" alt="');
			if( typeof(opts.caption) === 'string'
			 && opts.caption !== '' ) {
				html.push(opts.caption);
			} else {
				html.push( _loc('an image') );
			};	
			html.push('"/>');

		} else if( opts.type === 'video' ) {
			var mkup = this.generateEmbedMarkup({
				url: opts.url
				,sourceType: 'video'
				,mimeType: opts.mimeType
				,width: 320
    			,height: 256
    			,autoplay: opts.autoplay
    		});
    		html.push(mkup);
    		
		} else if( opts.type === 'audio' ) {
			var browserInfo = $n2.utils.getBrowserInfo();
			var embedOpts = {
				url: opts.url
				,sourceType: 'audio'
				,mimeType: opts.mimeType
				,width: 250
				// Let height float
    			//,height: 16
    			,autoplay: opts.autoplay
			};
			if( "Safari" === browserInfo.browser ){
				embedOpts.height = 16;
			};
			var mkup = this.generateEmbedMarkup(embedOpts);
    		html.push(mkup);
		};
		
		if( opts.footerHtml) {
			html.push('</p><p>');
			html.push(opts.footerHtml);
		};

		html.push('</p></div>');
		
		return html.join('');
	}

	,generateEmbedMarkup: function(opts_) {
		var opts = $n2.extend({
			url: null
			,sourceType: null
			,mimeType: null
			,width: null
			,height: null
			,autoplay: false
			,loop: false
			,controller: false
		},opts_);
		
		if( typeof(QT_GenerateOBJECTText) === 'function' ) {
			// Call Apple Computer code, if available
			var args = [];
			args.push(opts.url);
			args.push(opts.width);
			args.push(opts.height);
			args.push(''); // ActiveX version
			if( opts.autoplay ) {
				args.push('autoplay');
				args.push('true');
			};
			if( opts.loop ) {
				args.push('loop');
				args.push('true');
			};
			if( opts.controller ) {
				args.push('controller');
				args.push('true');
			};
			return QT_GenerateOBJECTText.apply(null, args);
		};
		
		// HTML5
//		var html = this.generateHtml5Tag(opts);
//		if( html ) {
//			return html;
//		};

		// Generate object/embed sequence
		var html = [];
		html.push('<object');
		if( opts.width ) {
			html.push(' width="'+opts.width+'"');
		};
		if( opts.height ) {
			html.push(' height="'+opts.height+'"');
		};
		html.push(' codebase="http://www.apple.com/qtactivex/qtplugin.cab#version=7,3,0,0"');
		html.push('classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B"');
		html.push('><param name="src" value="');
		html.push(opts.url);
		html.push('">');
		html.push('<param name="autoplay" value="');
		if( opts.autoplay ) {
			html.push('true">');
		} else {
			html.push('false">');
		};
		if( opts.controller ) {
			html.push('<param name="controller" value="true">');
		};
		if( opts.loop ) {
			html.push('<param name="loop" value="true">');
		};
		html.push('<embed');
		if( opts.width ) {
			html.push(' width="'+opts.width+'"');
		};
		if( opts.height ) {
			html.push(' height="'+opts.height+'"');
		};
		if( opts.autoplay ) {
			html.push(' autoplay="true"');
		} else {
			html.push(' autoplay="false"');
		};
		if( opts.controller ) {
			html.push(' controller="true"');
		};
		if( opts.loop ) {
			html.push(' loop="true"');
		};
		html.push(' pluginspage="http://www.apple.com/quicktime/download/" src="');
		html.push(opts.url);
		html.push('"></embed></object>');
		 
		return html.join(''); 
	}

	,generateHtml5Tag: function(opts_) {
		var opts = $n2.extend({
			url: null
			,sourceType: null
			,mimeType: null
			,width: null
			,height: null
			,autoplay: false
			,loop: false
			,controller: false
		},opts_);
		
		var html = [];
		if( 'video' === opts.sourceType ) {
			html.push('<video');
		} else if( 'audio' === opts.sourceType ) {
			html.push('<audio');
		} else {
			return null;
		};
		
		if( opts.width ) {
			html.push(' width="'+opts.width+'"');
		};
		if( opts.height ) {
			html.push(' height="'+opts.height+'"');
		};
		if( opts.controller ) {
			html.push(' controls="controls"');
		};
		if( opts.autoplay ) {
			html.push(' autoplay="autoplay"');
		};
		
		// Source
		html.push(' src="');
		html.push(opts.url);
		html.push('"');
		
		if( opts.mimeType ) {
			html.push(' type="'+opts.mimeType+'"');
		};
		
		html.push('>');
		
		// Embed tag in case HTML 5 is not supported
		html.push('<embed');
		if( opts.width ) {
			html.push(' width="'+opts.width+'"');
		};
		if( opts.height ) {
			html.push(' height="'+opts.height+'"');
		};
		if( opts.autoplay ) {
			html.push(' autoplay="true"');
		} else {
			html.push(' autoplay="false"');
		};
		if( opts.controller ) {
			html.push(' controller="true"');
		};
		if( opts.loop ) {
			html.push(' loop="true"');
		};
		html.push(' src="');
		html.push(opts.url);
		html.push('"></embed>');
		
		// Close Tag
		if( 'video' === opts.sourceType ) {
			html.push('</video>');
		} else if( 'audio' === opts.sourceType ) {
			html.push('</audio>');
		} else {
			return null;
		};
		 
		return html.join(''); 
	}
});

$n2.mediaDisplay = new $n2.MediaDisplay();

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.photosphere.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

//*******************************************************
var PhotosphereDisplay = $n2.Class({

	elemId: null,
	camera: null,
	scene: null,
	renderer: null,
	isUserInteracting: null,
	hasUserInteracted: null,
	onMouseDownMouseX: null,
	onMouseDownMouseY: null,
	lon: null,
	lat: null,
	onMouseDownLon: null,
	onMouseDownLat: null,
	phi: null,
	theta: null,
	animateFn: null,
	lastCanvasWidth: null,
	lastCanvasHeight: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,url: null
		},opts_);
		
		var _this = this;
		
		this.isUserInteracting = false;
		this.hasUserInteracted = false;
		this.onMouseDownMouseX = 0;
		this.onMouseDownMouseY = 0;
		this.lon = 0;
		this.lat = 0;
		this.onMouseDownLon = 0;
		this.onMouseDownLat = 0;
		this.phi = 0;
		this.theta = 0;
		this.animateFn = function(){
			_this._animate();
		};
		this.lastCanvasWidth = -1;
		this.lastCanvasHeight = -1;

		var $elem = opts.elem;
		this.elemId = $n2.utils.getElementIdentifier($elem);
		
		var canvasGeom = this._getCanvasSize();

		this.camera = new THREE.PerspectiveCamera( 75, canvasGeom.width / canvasGeom.height, 1, 1100 );
		this.camera.target = new THREE.Vector3( 0, 0, 0 );

		this.scene = new THREE.Scene();

		var geometry = new THREE.SphereGeometry( 500, 60, 40 );
		geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

		var material = new THREE.MeshBasicMaterial( {
			map: THREE.ImageUtils.loadTexture( opts.url )
		} );

		var mesh = new THREE.Mesh( geometry, material );
		
		this.scene.add( mesh );

		this.renderer = new THREE.WebGLRenderer();
		this.renderer.setSize( canvasGeom.width, canvasGeom.height );
		$elem[0].appendChild( this.renderer.domElement );

		$elem.mousedown(function( event ) {

			event.preventDefault();

			_this.isUserInteracting = true;
			_this.hasUserInteracted = true;

			_this.onPointerDownPointerX = event.clientX;
			_this.onPointerDownPointerY = event.clientY;

			_this.onPointerDownLon = _this.lon;
			_this.onPointerDownLat = _this.lat;
		});
		
		$elem.mousemove(function( event ) {
			if ( _this.isUserInteracting === true ) {
				_this.lon = ( _this.onPointerDownPointerX - event.clientX ) * 0.1 + _this.onPointerDownLon;
				_this.lat = ( event.clientY - _this.onPointerDownPointerY ) * 0.1 + _this.onPointerDownLat;
			};
		});
		
		$elem.mouseup(function( event ) {
			_this.isUserInteracting = false;
		});
		
		$elem.mouseout(function( event ) {
			_this.isUserInteracting = false;
		});
		
		$elem.on('mousewheel', function( event ) {

			if( event.originalEvent ) event = event.originalEvent;

			_this.hasUserInteracted = true;
			
			// WebKit
			if ( event.wheelDeltaY ) {
				_this.camera.fov -= event.wheelDeltaY * 0.05;

			// Opera / Explorer 9
			} else if ( event.wheelDelta ) {
				_this.camera.fov -= event.wheelDelta * 0.05;

			// Firefox
			} else if ( event.detail ) {
				_this.camera.fov += event.detail * 1.0;
			};
			
			if( _this.camera.fov < 1 ) {
				_this.camera.fov = 1;
			} else if( _this.camera.fov > 100 ) {
				_this.camera.fov = 100;
			};

			_this.camera.updateProjectionMatrix();
		});

		$elem.on('DOMMouseScroll', function( event ) {
			// WebKit
			if ( event.wheelDeltaY ) {
				_this.camera.fov -= event.wheelDeltaY * 0.05;

			// Opera / Explorer 9
			} else if ( event.wheelDelta ) {
				_this.camera.fov -= event.wheelDelta * 0.05;

			// Firefox
			} else if ( event.detail ) {
				_this.camera.fov += event.detail * 1.0;
			};

			if( _this.camera.fov < 1 ) {
				_this.camera.fov = 1;
			} else if( _this.camera.fov > 100 ) {
				_this.camera.fov = 100;
			};

			_this.camera.updateProjectionMatrix();
		});
		
		this._animate();
	},

	_animate: function() {
		var $elem = this._getElem();
		if( $elem.length > 0 ) {
			window.requestAnimationFrame( this.animateFn );
			
			var geom = this._getCanvasSize();
			if( geom.width !== this.lastCanvasWidth 
			 || geom.height !== this.lastCanvasHeight ){
				this._onCanvasResize();
				this.lastCanvasWidth = geom.width;
				this.lastCanvasHeight = geom.height;
			};
			
			this._update();
		};
	},
	
	_update: function() {

		if( this.hasUserInteracted === false ) {
			this.lon += 0.1;
		}

		this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
		this.phi = THREE.Math.degToRad( 90 - this.lat );
		this.theta = THREE.Math.degToRad( this.lon );

		this.camera.target.x = 500 * Math.sin( this.phi ) * Math.cos( this.theta );
		this.camera.target.y = 500 * Math.cos( this.phi );
		this.camera.target.z = 500 * Math.sin( this.phi ) * Math.sin( this.theta );

		this.camera.lookAt( this.camera.target );

		/*
		// distortion
		this.camera.position.copy( this.camera.target ).negate();
		*/

		this.renderer.render( this.scene, this.camera );

	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_getCanvasSize: function(){
		var geom = {};
		
		var $container = this._getElem();
		geom.width = $container.width();
		geom.height = $container.height();
		
		return geom;
	},
	
	_onCanvasResize: function(){
		var geom = this._getCanvasSize();
		
		this.camera.aspect = geom.width / geom.height;
		this.camera.updateProjectionMatrix();

		this.renderer.setSize( geom.width, geom.height );
	}
});

//*******************************************************
/*
 * Returns true if the logic to display photoshpere images is
 * available.
 */
function IsAvailable(){
	// three.js is required
	if( typeof(window.THREE) !== 'undefined' ){
		return true;
	};
	
	return false;
};

//*******************************************************
$n2.photosphere = {
	PhotosphereDisplay: PhotosphereDisplay	
	,IsAvailable: IsAvailable
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.googleDocs.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// =============================================
// SpreadSheet
// =============================================

var SpreadSheet = $n2.Class({
	
	descriptor: null
	
	,data: null
	
	,entries: null

	,isCellsData: null
	
	,isListData: null
	
	,initialize: function(opts_){
		var opts = $n2.extend({
			descriptor: null
			,data: null
			,isCellsData: false
			,isListData: false
		},opts_);

		this.descriptor = opts.descriptor;
		this.data = opts.data;
		this.isCellsData = opts.isCellsData;
		this.isListData = opts.isListData;
		this.entries = null;
	}

	,getDescriptor: function(){
		return this.descriptor;
	}
	
	,getTitle: function(){
		if( this.descriptor ){
			return this.descriptor.title;
		};
		return null;
	}
	
	,getData: function(){
		return this.data;
	}

	,getEntries: function(){
		if( null === this.entries ){
			if( this.isCellsData ){
				this.entries = parseSpreadSheetCellFeed(this.data);
			} else if( this.isListData ) {
				this.entries = parseSpreadSheetListFeed(this.data);
			};
		};
		return this.entries;
	}
});	

// =============================================
// SpreadSheetDescriptor
// =============================================

var SpreadSheetDescriptor = $n2.Class({
	
	key: null
	
	,id: null
	
	,position: null
	
	,cellsFeedUrl: null
	
	,listFeedUrl: null
	
	,title: null
	
	,initialize: function(opts_){
		var opts = $n2.extend({
			key: null
			,id: null
			,position: null
			,title: null
			,cellsFeedUrl: null
			,listFeedUrl: null
		},opts_);

		this.key = opts.key;
		this.id = opts.id;
		this.position = opts.position;
		this.title = opts.title;
		this.cellsFeedUrl = opts.cellsFeedUrl;
		this.listFeedUrl = opts.listFeedUrl;
	}

	,getSpreadSheet: function(opts_) {
		var opts = $.extend({
				onSuccess: function(spreadsheet){}
				,onError: function(errMsg){}
			},opts_);
		
		var options = {
			key: this.key
			,descriptor: this
			,onSuccess: opts.onSuccess
			,onError: function(errorMsg){
				opts.onError('Error loading spreadsheet at position '+this.position+': '+errorMsg);
			}
		};
		
		if( this.cellsFeedUrl ){
			options.cellsFeedUrl = this.cellsFeedUrl;
		} if( this.position ){
			options.position = this.position;
		} if( this.listFeedUrl ){
			options.listFeedUrl = this.listFeedUrl;
		};
		
		loadSpreadSheet(options);		
	}
});	

// =============================================
// WorkBook
// =============================================

var WorkBook = $n2.Class({
	
	key: null
	
	,title: null
	
	,author: null
	
	,spreadSheetDescriptors: null
	
	,initialize: function(opts_){
		var opts = $n2.extend({
			key: null
			,title: null
		},opts_);

		this.spreadSheetDescriptors = [];
		
		this.key = opts.key;
		this.title = opts.title;
	}

	,getSpreadSheetDescriptors: function(){
		return this.spreadSheetDescriptors;
	}
	
	,getSpreadSheetDescriptor: function(opts_){
		var opts = $n2.extend({
			id: null
			,position: null
			,title: null
		},opts_);
		
		for(var i=0,e=this.spreadSheetDescriptors.length; i<e; ++i){
			var sd = this.spreadSheetDescriptors[i];
			
			if( opts.id && opts.id === sd.id ) {
				return sd;
			} else if( typeof(opts.position) === 'number' && opts.position === sd.position ) {
				return sd;
			} else if( opts.title && opts.title === sd.title ) {
				return sd;
			};
		};
		
		return null;
	}
	
	,getSpreadSheet: function(opts_){
		var opts = $n2.extend({
			id: null
			,position: null
			,title: null
			,onSuccess: function(speadsheet){}
			,onError: function(errMsg){}
		},opts_);
		
		var sd = this.getSpreadSheetDescriptor(opts);
		if( sd ){
			sd.getSpreadSheet({
				onSuccess: opts.onSuccess
				,onError: opts.onError
			});
			return;
		};
		
		opts.onError('SpreadSheet descriptor not found: '+opts.title+'/'+opts.id+'/'+opts.position);
	}
	
	,getAllSpreadSheets: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(arr){}
			,onError: function(errMsg){}
		},opts_);

		var descriptors = this.getSpreadSheetDescriptors();
		
		var result = [];
		if( descriptors.length <= 0 ){
			opts.onSuccess(result);
			
		} else {
			var waiting = [];

			for(var i=0,e=descriptors.length; i<e; ++i){
				waiting.push(descriptors[i]);
			};
			
			for(var i=0,e=descriptors.length; i<e; ++i){
				var sd = descriptors[i];
				sd.getSpreadSheet({
					onSuccess: loaded
					,onError: opts.onError
				});
			};
		};
		
		function loaded(spreadSheet){
			var desc = spreadSheet.getDescriptor();
			var descIndex = waiting.indexOf(desc);
			if( descIndex >= 0 ){
				waiting.splice(descIndex, 1);
			};

			result.push(spreadSheet);
			
			if( waiting.length > 0 ){
				return; // still waiting
			};
			
			// All arrived
			opts.onSuccess(result);
		};
	}
});	
	
function getWorkBook(options_) {
	var options = $.extend({
			key: null
			,onSuccess: function(workbook){}
			,onError: function(errMsg){}
		},options_);
		
	if( !options.key ) {
		options.onError('Google Spreadsheet key required.');
	};
	
	$.ajax({
		async: true
		,dataType: 'json'
		,data: {
			alt: 'json'
		}
		,traditional: true
		,url: 'https://spreadsheets.google.com/feeds/worksheets/'+options.key+'/public/basic'
		,success: handleData
		,error: function(XMLHttpRequest, textStatus, errorThrown){
			options.onError('Unable to load workbook: '+textStatus);
		}
	});
	
	function handleData(data) {
		var workbook = new WorkBook({
			key: options.key
		});
		
		if( data && data.feed ){
			var feed = data.feed;
			
			if( feed.title && feed.title.$t ){
				workbook.title = feed.title.$t;
			};
			
			if( feed.author ){
				workbook.author = {};
				
				if( feed.author.name && feed.author.name.$t ){
					workbook.author.name = feed.author.name.$t;
				};
				
				if( feed.author.email && feed.author.email.$t ){
					workbook.author.email = feed.author.email.$t;
				};
			};
			
			if( feed.entry ){
				for(var i=0,e=feed.entry.length; i<e; ++i){
					var entry = feed.entry[i];
					var sheet = {
						key: options.key
						,position: i+1
					};
					
					if( entry.title ){
						sheet.title = entry.title.$t;
					};
					
					if( entry.id && entry.id.$t ){
						var index = entry.id.$t.lastIndexOf('/');
						if( index >= 0 ){
							sheet.id = entry.id.$t.substr(index+1);
						};
					};
					
					if( entry.link ){
						for(var j=0,k=entry.link.length;j<k;++j){
							var link = entry.link[j];
							if( link.rel === 'http://schemas.google.com/spreadsheets/2006#cellsfeed' ) {
								sheet.cellsFeedUrl = link.href;
							} else if( link.rel === 'http://schemas.google.com/spreadsheets/2006#listfeed' ) {
								sheet.listFeedUrl = link.href;
							};
						};
					};
					
					var sd = new SpreadSheetDescriptor(sheet);

					workbook.spreadSheetDescriptors.push(sd);
				};
			};
		};
		
		options.onSuccess(workbook);
	};
};
	
//=============================================
// Functions
//=============================================
	
function loadSpreadSheet(opts_) {
	var opts = $.extend({
			key: null
			,position: null
			,cellsFeedUrl: null
			,listFeedUrl: null
			,descriptor: null
			,onSuccess: function(data){}
			,onError: function(errorMsg){}
		},opts_);
	
	var url = null;
	var isCellsData = false;
	var isListData = false;
		
	if( opts.cellsFeedUrl ) {
		url = opts.cellsFeedUrl;
		isCellsData = true;
		
	} else if( opts.key && opts.position ) {
		url = 'https://spreadsheets.google.com/feeds/cells/'+opts.key+'/'+opts.position+'/public/values';
		isCellsData = true;

	} else if( opts.listFeedUrl ) {
		url = opts.listFeedUrl;
		isListData = true;
		
	} else {
		opts.onError('Requested spreadsheet not identified.');
		return;
	};
	
	$.ajax({
		async: true
		,dataType: 'json'
		,data: {
			alt: 'json'
		}
		,traditional: true
		,url: url
		,success: function(data){
			var ss = new SpreadSheet({
				descriptor: opts.descriptor
				,data: data
				,isCellsData: isCellsData
				,isListData: isListData
			});
			opts.onSuccess(ss);
		}
		,error: function(XMLHttpRequest, textStatus, errorThrown){
			opts.onError('Unable to load spreadsheet: '+textStatus);
		}
	});
};

var gsxRe = /^gsx\$(.*)$/;
function parseSpreadSheetListFeed(data) {
	var res = [];
	
	if( data && data.feed && data.feed.entry ) {
		var entries = data.feed.entry;
		for(var loop=0; loop<entries.length; ++loop) {
			var entry = entries[loop];
			var e = {};
			for(var key in entry) {
				var match = key.match(gsxRe);
				if( match ) {
					var value = entry[key].$t;
					e[match[1]] = value;
				};
			};
			res.push(e);
		};
	};

	return res;
};

var reIdRowCol = /\/R([0-9]+)C([0-9]+)$/;
function parseSpreadSheetCellFeed(data) {
	var res = [];
	
	if( data && data.feed && data.feed.entry ) {
		var cells = data.feed.entry;
		
		// First pass, assign row/col to each entry.
		// Accumulate columns
		var entries = [];
		var columnByPosition = [];
		var columnByName = {};
		for(var loop=0,loopEnd=cells.length; loop<loopEnd; ++loop) {
			var cell = cells[loop];
			if( cell.id && cell.id['$t'] ){
				var test = reIdRowCol.exec(cell.id['$t']);
				if( test ){
					cell._row = 1 * test[1];
					cell._col = 1 * test[2];
					
					if( cell._row === 1 ){
						// header
						var name = '_'+cell._col;
						if( cell.content && cell.content['$t'] ){
							name = cell.content['$t'];
						};
						
						var column = null;
						if( columnByName[name] ){
							columnByName[name].isArray = true;
						} else {
							column = {
								name: name
								,isArray: false
							};
							columnByName[name] = column;
						};
						
						columnByPosition[cell._col] = column;
						
					} else {
						entries.push(cell);
					};
				};
			};
		};
		
		// Sort
		entries.sort(function(a,b){
			if( a._row < b._row ) return -1;
			if( a._row > b._row ) return 1;
			if( a._col < b._col ) return -1;
			if( a._col > b._col ) return 1;
			return 0;
		});

		// Second pass, create entries
		var currentEntry = null;
		var currentRow = -1;
		for(var loop=0,loopEnd=entries.length; loop<loopEnd; ++loop) {
			var cell = entries[loop];
			
			if( currentRow != cell._row ){
				if( currentEntry ){
					completeEntry(currentEntry);
				};
				currentRow = cell._row;
				currentEntry = {};
				res.push(currentEntry);
			};
			
			var isArray = true;
			var colName = '_';
			var column = columnByPosition[cell._col];
			if( column ){
				isArray = column.isArray;
				colName = column.name;
			};
			
			var value = '';
			if( cell.content && cell.content['$t'] ){
				value = cell.content['$t'];
			};
			
			if( isArray ){
				if( !currentEntry[colName] ) {
					currentEntry[colName] = [];
				};
				currentEntry[colName].push(value);
				
			} else {
				currentEntry[colName] = value;
			};
		};
		
		// Complete last entry
		if( currentEntry ){
			completeEntry(currentEntry);
		};
	};

	return res;
	
	function completeEntry(entry){
		if( entry ){
			for(var colName in columnByName){
				var column = columnByName[colName];
				if( typeof(entry[colName]) === 'undefined' ){
					if( column.isArray ){
						entry[colName] = [];
					} else {
						entry[colName] = '';
					};
				};
			};
		};
	};
};

$n2.googleDocs = {
	getWorkBook: getWorkBook
	,loadSpreadSheet: loadSpreadSheet
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.dbSearchEngine.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

/**
 	Returns a map of functions to access the database engine.
 	@name dbSearchEngine
 	@function
 	@memberOf nunaliit2
 	@param {Object} options_
 		Options to connect to the database.
 		url: Relative path, from the application root, where the
 		the database search servlet can be accessed
 		relMediaPath: Relative path, from the application root, where media
 		files are located.
 	@returns {DbSearchEngine}
 		Instance of DbSearchEngine configured according to
 		options.
 */
$n2.dbSearchEngine = function(options_) {

	var defaultOptions = {
		url: './search'
		,relMediaPath: 'test_media/'
	};
	
	var options = $.extend({},defaultOptions,options_);
	
	return {
		getRelMediaPath: function(mediaFile) {
			if( mediaFile ) {
				return options.relMediaPath+mediaFile;
			};
			return options.relMediaPath;
		}
		
		,getHoverSound: function(placeId, opts_) {
			$.ajax({
				type: 'POST'
				,url: options.url + '/getHoverMedia'
				,data: {
					id:placeId
				}
				,dataType: 'json'
				,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
				,async: true
				,success: function(result) {
    				if( result && result.media && result.media.length > 0 ) {
    					var media = result.media[0];
						if( media && media.hover_audio) {
							opts_.installSoundFn(media.hover_audio, opts_);
	    				};
    				};
				}
			});
		}
	
		,searchForContributions: function(searchString, callback) {
			$.ajax({
				type: 'POST'
				,url: options.url + '/searchContributions'
				,data: {
					content:searchString
				}
				,dataType: 'json'
				,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
				,async: true
				,success: function(result) {
					if( result.contributions ) {
						callback(result.contributions);
					};
				}
			});
		}
		
		,searchForPlaceNames: function(searchString, callback) {
			$.ajax({
				type: 'POST'
				,url: options.url + '/searchFeatures'
				,data: {
					content:searchString
				}
				,dataType: 'json'
				,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
				,async: true
				,success: function(result) {
					if( result.features ) {
						callback(result.features);
					};
				}
			});
		}
		
		,findGeometryCentroidFromPlaceId: function(placeId, callback) {
			$.ajax({
				type: 'POST'
				,url: options.url + '/findGeometryCentroid'
				,data: {
					type:'place_id'
					,id:placeId
				}
				,dataType: 'json'
				,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
				,async: true
				,success: function(result) {
					if( result && result.features ) {
						callback(result.features);
					};
				}
			});
		}
		
		,findGeometryCentroidFromId: function(id, callback) {
			$.ajax({
				type: 'POST'
				,url: options.url + '/findGeometryCentroid'
				,data: {
					type:'id'
					,id:id
				}
				,dataType: 'json'
				,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
				,async: true
				,success: function(result) {
					if( result && result.features ) {
						callback(result.features);
					};
				}
			});
		}
		
		,getAudioMediaFromPlaceId: function(placeId, callback) {
			$.ajax({
				type: 'POST'
				,url: options.url + '/getAudioMedia'
				,data: {
					id:placeId
				}
				,dataType: 'json'
				,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
				,async: true
				,success: function(result) {
					if( result && result.media ) {
						callback(result.media);
					};
				}
			});
		}
	};
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.contributionDb.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

/**
 	Returns a map of functions to access the contributions
 	from the database.
 	@name contributionDb
 	@function
 	@memberOf nunaliit2
 	@param {Object} options_ Options to connect to the contribution servlet.
 */
$n2.contributionDb = function(options_) {

	var defaultOptions = {
		url: './contributions'
	};
	
	var options = $.extend({},defaultOptions,options_);
	
	return {
		getContributionsFromPlaceId: function(placeId, callback) {
			$.getJSON(
				'./contributions/fromName?name=' + encodeURIComponent(placeId)
				,function(result) {
					var contributions = result.contributions;
					if( contributions ) {
						callback(contributions);
					};
				}
			);
		}
	};
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.upload.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

function onProgressUpdate(tracker) {
	var progressKey = tracker.getProgressKey();
	var $set = $('#n2UploadProgress_'+progressKey);
	if( $set.length < 1 ) {
		// Element is gone, stop tracking
		tracker.cancel();
	} else {
		var total = tracker.getTotal();
		var count = tracker.getCurrent();
		var percent = 0;
		if( total != 0 ) {
			percent = ((count / total) * 100);
		}
		$set.find('.n2UploadProgressBar').css('width',''+percent+'%').attr('alt','File Upload '+percent+'%');
		$set.find('.n2UploadProgressBarBackground').attr('alt','File Upload '+percent+'%');
	};
};

var UploadDefaultOptions = {
	url: null
	,progressServer: null // Instance of n2.progress.ProgressTracker
};

var Upload = $n2.Class({
	
	options: null
	
	,welcomeMessage: null
	
	,initialize: function(options_) {
		this.options = $n2.extend({},UploadDefaultOptions,options_);
	}

	,buildForm: function(jQuerySet, options_) {
		var upload = this;
		
		var opts = $.extend({
				onSuccess: function(res){}
				,onError: function(errorMsg){ $n2.reportError(errorMsg); }
			}
			,this.options
			,options_
		);
		
		// Empty jQuerySet
		jQuerySet.empty();
		
		// This works only if jquery.form is available
		if( !$.fn.ajaxSubmit ) {
			opts.onError( _loc('Can not perform file uploads unless jquery.form.js is included') );
		};
		
		jQuerySet.each(function(i, elem){
			installForm(elem, opts.docId, opts.rev);
		});
		
		function installForm(elem, docId, docRev) {
			var $elem = $(elem)
				,$form = $('<form class="n2UploadForm" method="post"></form>')
				,$button = $('<input class="n2UploadInputButton" type="button"/>')
				;
			$form.append( $('<input class="n2UploadInputFile" type="file" name="_attachments"/>') );
			$button.val( _loc('Upload') );
			$form.append( $button );
			$elem.append($form);
			
			$button.click(uploadClicked);
		};

		function uploadClicked(evt) {
			var $btn = $(this);
			var $form = $btn.parents('.n2UploadForm');

			// Disable elements while file is uploading
			$form.find('.n2UploadInputButton').attr('disabled','disabled');

			if( opts.progressServer ) {
				opts.progressServer.requestProgressKey(function(key){
					performUpload($form, key);
				});
			} else {
				performUpload($form, null);
			}
		};
		
		function performUpload($form, progressKey) {

			$form.find('.n2UploadProgressId').remove();
			if( progressKey ) {
				$form.prepend( $('<input class="n2UploadProgressId" type="hidden" name="progressId" value="'+progressKey+'"/>') );
			};

			$form.ajaxSubmit({
				type: 'post'
				,url: opts.url + 'put'
				,dataType: 'json'
				,success: function(res) {
					$form.find('*').removeAttr('disabled');
					if( res.error ) {
						opts.onError(_loc('Error while uploading: ')+res.error,options_);
					} else {
						opts.onSuccess(res,options_);
					}
				}
				,error: function(xhr, status, err) {
					$form.find('*').removeAttr('disabled');
					opts.onError(_loc('Error while uploading: ')+err,options_);
				}
			});
			
			// Add progress div, if required
			if( progressKey ) {
				var progressDiv = $('<div id="n2UploadProgress_'+progressKey+'" class="n2UploadProgress">'
						               +'<div class="n2UploadProgressBarBackground">'
						                  +'<div class="n2UploadProgressBar">'
						             +'</div></div></div>');
				$form.after(progressDiv);
				upload.options.progressServer.createProgressTracker({
					progressKey: progressKey
					,onUpdate: onProgressUpdate
				});
			};
		};
	}

	,submitForm: function(options_) {
		var _this = this;
		
		var opts = $.extend({
				form: null
				,uploadFile: null
				,suppressInformationDialog: false
				,onSuccess: function(res){}
				,onError: function(errorMsg){ $n2.reportError(errorMsg); }
			}
			,this.options
			,options_
		);
		
		// This works only if jquery.form is available
		if( !$.fn.ajaxSubmit ) {
			opts.onError( 'Can not perform file uploads unless jquery.form.js is included' );
			return;
		};
		
		if( !opts.form ) {
			opts.onError( 'Form element is required' );
			return;
		};
		var $form = opts.form;
		if( typeof($form) === 'string' ) {
			$form = $('#'+$form);
		};
		
		// Disable elements while file is uploading
		$form.find('.n2UploadInputButton').attr('disabled','disabled');

		if( opts.progressServer ) {
			opts.progressServer.requestProgressKey(function(key){
				performUpload($form, opts.uploadFile, key);
			});
		} else {
			performUpload($form, null);
		};
		
		function performUpload($form, uploadFile, progressKey) {

			$form.find('.n2UploadProgressId').remove();
			if( progressKey ) {
				$form.prepend( $('<input class="n2UploadProgressId" type="hidden" name="progressId" value="'+progressKey+'"/>') );
			};

			var formData = new FormData($form[0]);
			if(opts.uploadFile !== null) {
				formData.append('media', uploadFile);
			}

			$.ajax({
				type: 'POST'
				,url: opts.url + 'put'
				,data: formData
				,dataType: 'json'
				,processData: false
				,contentType: false
				,success: function(res) {
					$form.find('*').removeAttr('disabled');
					if( res.error ) {
						opts.onError(_loc('Error while uploading: ')+res.error,options_);
					} else {
						if( !opts.suppressInformationDialog ) {
							_this._uploadSucessfulDialog();
						};
						opts.onSuccess(res,options_);
					}
				}
				,error: function(xhr, status, err) {
					$form.find('*').removeAttr('disabled');
					opts.onError(_loc('Error while uploading: ')+err,options_);
				}
			});
			
			// Add progress div, if required
			if( progressKey ) {
				var progressDiv = $('<div id="n2UploadProgress_'+progressKey+'" class="n2UploadProgress">'
						               +'<div class="n2UploadProgressBarBackground">'
						                  +'<div class="n2UploadProgressBar">'
						             +'</div></div></div>');
				$form.after(progressDiv);
				_this.options.progressServer.createProgressTracker({
					progressKey: progressKey
					,onUpdate: onProgressUpdate
				});
			};
		};
	}
	
	/**
	 * Get welcome message from the upload server if none has been
	 * obtained before. If this is the first try, reaches the server
	 * for the welcome.
	 */
	,checkWelcome: function(options_){
		var opts = $.extend({
				onSuccess: function(message){}
				,onError: function(errorMsg){ $n2.reportError(errorMsg); }
			}
			,this.options
			,options_
		);
		
		if( this.welcomeMessage ) {
			opts.onSuccess(this.welcomeMessage);
		} else {
			this.getWelcome(opts);
		};
	}

	/**
	 * Forces to fetch a welcome message from the upload server
	 */
	,getWelcome: function(options_) {
		var opts = $.extend({
				onSuccess: function(message){}
				,onError: function(errorMsg){ $n2.reportError(errorMsg); }
			}
			,this.options
			,options_
		);
		
		var _this = this;
		
		$.ajax({
			url: opts.url+'welcome'
			,type: 'GET'
			,dataType: 'json'
			,success: function(data, textStatus, jqXHR){
				if( data && data.ok ) {
					_this.welcomeMessage = data;
					opts.onSuccess(data);
				} else {
					opts.onError(data);
				};
			}
			,error: function(jqXHR, textStatus, errorThrown){
				opts.onError(errorThrown);
			}
		});
	}
	
	,_uploadSucessfulDialog: function(){
		if( ! $.fn.button 
		 || ! $.fn.dialog ) {
			// No jquery-ui. Ignore
			return;
		};
		
		// Inform user of approval process
		var infoDialogId = $n2.getUniqueId();
		var $dialog = $('<div id="'+infoDialogId+'"></div>');

		var $label = $('<span></span>');
		$label.text( _loc('Your file was uploaded and will become available when it has been approved.') );
		$dialog.append($label);
		
		$('<br/>').appendTo($dialog);
		
		var $ok = $('<button></button>');
		$ok.text( _loc('OK') );
		$ok.button({icons:{primary:'ui-icon-check'}});
		$dialog.append( $ok );
		$ok.click(function(){
			var $diag = $('#'+infoDialogId);
			$diag.dialog('close');
			return false;
		});
		
		var dialogOptions = {
			autoOpen: true
			,title: _loc('File Uploaded')
			,modal: true
			,width: 500
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$dialog.dialog(dialogOptions);
	}
});
	
$n2.upload = {
	Upload: Upload
	
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olFixes.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

if( typeof(OpenLayers) !== 'undefined'
 ) {

	// Fixes for nested property styles. This allows a style
	// to specify a property using a dotted notation.
	// for example:
	//  ...
	//    label: "${person.label}"
	//  ...
	if(OpenLayers.Style && OpenLayers.Style.prototype){
		OpenLayers.Style.prototype.addPropertyStyles = function(propertyStyles, symbolizer) {
	        var property;
	        for (var key in symbolizer) {
	            property = symbolizer[key];
	            if (typeof property == "string" &&
	                    property.match(/\$\{\w+(\.\w+)*\}/)) {
	                propertyStyles[key] = true;
	            }
	        }
	        return propertyStyles;
	    };
	};
	
}; // If OpenLayers is defined
	
})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olBBOX.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

if( typeof(OpenLayers) !== 'undefined' && OpenLayers.Map ) {

OpenLayers.Strategy.N2BBOX = OpenLayers.Class(OpenLayers.Strategy.BBOX, {

	// Do not reproject the map extent. Let the couchDb layer figure it out
    getMapBounds: function() {
        if (this.layer.map === null) {
            return null;
        }

        var bounds = this.layer.map.getExtent();

        return bounds;
    },
	
	CLASS_NAME: "OpenLayers.Strategy.N2BBOX" 

});
	
}; // If OpenLayers is defined
	
})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olFilter.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

function reportFilterError(errStr, filterObj) {
	$n2.reportError('OL_FILTER','Filter error. Application might not work properly. '+errStr);
	
	log('Filter error: '+errStr, filterObj);
};

function convertFilterArray(arr, onError) {
	var filters = [];
	
	for(var loop=0; loop<arr.length; ++loop) {
		var filter = convertToOpenLayers(arr[loop], onError);
		if( filter ) { filters.push(filter); };
	}
	
	return filters;
};


/**

 Convert a JSON object declaring a filter into
 an OpenLayers filter.
<pre>
 JSON format:
 {
    comparison: <comparison-name>
    ,property:  <property-name>
    ,value:     <value>
 }
   where comparison-name is '='

 or

 {
    logical: <logical-operation>
    ,filters:  [ <filter>, ... ]
 }
   where logical-operation is 'and', 'or'
</pre>
 	@name convertToOpenLayers
 	@function
 	@memberOf nunaliit2
 	@param {Object} obj JSON object that describes the filter
 */
var convertToOpenLayers = function(obj, onError) {
	if( !onError ) onError = reportFilterError;
	
	if( obj.comparison ) {
		if( null == obj.property ) {
			onError('Missing "property" from comparison filter', obj);
			return null;
		};
		if( null == obj.value ) {
			onError('Missing "value" from comparison filter', obj);
			return null;
		};

		if( '=' == obj.comparison ) {
			return new OpenLayers.Filter.Comparison({
				type: OpenLayers.Filter.Comparison.EQUAL_TO
				,property: obj.property
				,value: obj.value
				});
		};
		
		onError('Invalid comparison filter: '+obj.comparison, obj);
		return null;
	};

	if( obj.logical ) {
		if( null == obj.filters ) {
			onError('Missing "filters" from logical filter', obj);
			return null;
		};
		var filters = convertFilterArray( obj.filters, onError );
		
		if( 'and' == obj.logical ) {
			return new OpenLayers.Filter.Logical({
				type: OpenLayers.Filter.Logical.AND
				,filters: filters
				});
		}

		if( 'or' == obj.logical ) {
			return new OpenLayers.Filter.Logical({
				type: OpenLayers.Filter.Logical.OR
				,filters: filters
				});
		}

		onError('Invalid logical filter: '+obj.logical, obj);
		return null;
	}
	
	onError('Unknown filter type', obj);
	return null;
};

var Filter = $n2.Class({
	olFilter: null
	
	,initialize: function() {
	}
	
	,parseJsonFilter: function(opts_) {
		var opts = $n2.extend({
			json: null
			,onError: reportFilterError
		},opts_);
		
		if( !opts.json ) {
			opts.onError('Invalid JSON',this);
			return false;
		};
		
		this.olFilter = convertToOpenLayers(opts.json, opts.onError);
		
		return (this.olFilter != null);
	}
	
	,fromFids: function(fids) {

		this.olFilter = new OpenLayers.Filter.FeatureId({fids:fids});
		
		return true;
	}
	
	,getOpenLayerFilter: function() {
		return this.olFilter;
	}
	
	,matches: function(f) {
		if( !this.olFilter ) {
			// No filter, matches everything
			return true;
		}
		
		return this.olFilter.evaluate(f);
	}
});

$n2.olFilter = {
	CreateOpenLayersFilter: convertToOpenLayers
	,Filter: Filter
	,fromJson: function(json) {
		var filter = new Filter();
		filter.parseJsonFilter({json:json});
		return filter;
	}
	,fromFid: function(fid) {
		var filter = new Filter();
		filter.fromFids([fid]);
		return filter;
	}
	,fromFids: function(fids) {
		var filter = new Filter();
		filter.fromFids(fids);
		return filter;
	}
};


})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olStyleMapCallback.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function(){
"use strict";

//**************************************************
// OPEN LAYERS STYLE MAP CALLBACK
// This code is an extension of OpenLayers. It adds
// a StyleMap which calls back a function given during
// initialization.
//
// This code is not needed if OpenLayers is not installed.
if( typeof OpenLayers != 'undefined' ) {

/**
 * Class: OpenLayers.StyleMapCallback
 */
OpenLayers.StyleMapCallback = OpenLayers.Class({
    
    /**
     * Property: callback
     * Callback function that is called during "createSymbolizer".
     */
    callback: null,
    
    /**
     * Constructor: OpenLayers.StyleMap
     * 
     * Parameters:
     * callback- {Function} Function called every time the
     *           style map 'createSymbolizer' is called. This
     *           is the function that actually computes the
     *           symbolizer. It should have a signature of
     *           function(feature, intent) and return a hash
     *           of symbolizer attributes.
     * options - {Object} optional hash of additional options for this
     *           instance
     */
    initialize: function (callback, options) {
    	this.callback = callback;
    	
        OpenLayers.Util.extend(this, options);
    },

    /**
     * Method: destroy
     */
    destroy: function() {
        this.callback = null;
    },
    
    /**
     * Needed as a work around for a bug in Control/DrawFeature
     */
    styles: {},
    
    /**
     * Method: createSymbolizer
     * Creates the symbolizer for a feature for a render intent.
     * 
     * Parameters:
     * feature - {<OpenLayers.Feature>} The feature to evaluate the rules
     *           of the intended style against.
     * intent  - {String} The intent determines the symbolizer that will be
     *           used to draw the feature. Well known intents are "default"
     *           (for just drawing the features), "select" (for selected
     *           features) and "temporary" (for drawing features).
     * 
     * Returns:
     * {Object} symbolizer hash
     */
    createSymbolizer: function(feature, intent) {

        if( !this.callback ) {
            return { display: 'none' };
        }

        return this.callback(feature, intent);
    },

    CLASS_NAME: "OpenLayers.StyleMapCallback"
});

};
 
})();

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olUtils.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

function isValidGeom(olGeom){
	var vertices = olGeom.getVertices();
	for(var i=0,e=vertices.length; i<e; ++i){
		var vertice = vertices[i];
		if( typeof(vertice.x) !== 'number' 
			|| vertice.x !== vertice.x // check for NaN
			) { 
			return false;
		} else if( typeof(vertice.y) !== 'number'
			|| vertice.y !== vertice.y // check for NaN
			) {
			return false;
		};
	};
	
	return true;
};

//Sort features so that points are drawn on top (come last)
//of linestrings and linestrings on top of polygons.
//Between polygons and linestrings, sort the largest
//geometries first.
function sortFeatures(features){
	features.forEach(function(f){
		delete f._n2Sort;
	});
    features.sort(featureSorting);
};
function featureSorting(a,b){
	var aSort = a._n2Sort;
	if( !aSort ) {
		aSort = prepareFeatureForSorting(a);
	};
	var bSort = b._n2Sort;
	if( !bSort ) {
		bSort = prepareFeatureForSorting(b);
	};
	
	if( aSort.isPoint && bSort.isPoint ) {
		return 0;
	} else if( aSort.isPoint ) {
		return 1;
	} else if( bSort.isPoint ) {
		return -1;
	} else {
		// One of the two geometries is not a point
		if( aSort.isLineString && bSort.isLineString ) {
			if( aSort.largestDim > bSort.largestDim ) {
				return -1;
			} else {
				return 1;
			};
		} else if( aSort.isLineString ){
			return 1;
		} else if ( bSort.isLineString ) {
			return -1
		} else {
			// Both geometries are polygons
			if( aSort.largestDim > bSort.largestDim ) {
				return -1;
			} else {
				return 1;
			};
		};
	};
};
//Prepare features for sorting
function prepareFeatureForSorting(f){
	f._n2Sort = {};
	var geomClass = f.geometry.CLASS_NAME;
	f._n2Sort.isPoint = (geomClass.indexOf('Point') >= 0);
	if( f._n2Sort.isPoint ) {
		f._n2Sort.isLineString = false;
		f._n2Sort.isPolygon = false;
		f._n2Sort.largestDim = 0;
	} else {
		f._n2Sort.isLineString = (geomClass.indexOf('LineString') >= 0);
		if( f._n2Sort.isLineString ){
			var bounds = f.geometry.getBounds();
			
			f._n2Sort.largestDim = bounds.top - bounds.bottom;
			var tmp = bounds.right - bounds.left;
			if( f._n2Sort.largestDim < tmp ) {
				f._n2Sort.largestDim = tmp;
			};
		} else {
			f._n2Sort.isPolygon = true;
			
			var bounds = f.geometry.getBounds();
			
			// Use area
			f._n2Sort.largestDim = (bounds.top - bounds.bottom) * (bounds.right - bounds.left);
		};
		
	};
	return f._n2Sort;
};

/**
 * _n2Sort caching not possible in this setting yet. 
 * If performance is an issue, maybe need to implement our own ol.layer|ol.render
 * in favor of this renderOrder functionality.
 * @param {ol.Feature} a
 * @param {ol.Feature} b
 * @return {number}
 */
function ol5FeatureSorting(a, b){
	 var aSort = ol5prepareFeatureForSorting(a);

	 var bSort = ol5prepareFeatureForSorting(b);
		if( aSort.isPoint && bSort.isPoint ) {
			return 0;
		} else if( aSort.isPoint ) {
			return 1;
		} else if( bSort.isPoint ) {
			return -1;
		} else {
			// One of the two geometries is not a point
			if( aSort.isLineString && bSort.isLineString ) {
				if( aSort.largestDim > bSort.largestDim ) {
					return -1;
				} else {
					return 1;
				};
			} else if( aSort.isLineString ){
				return 1;
			} else if ( bSort.isLineString ) {
				return -1
			} else {
				// Both geometries are polygons
				if( aSort.largestDim > bSort.largestDim ) {
					return -1;
				} else {
					return 1;
				};
			};
		};
	
};

//ol5 version of preparing features for sorting
function ol5prepareFeatureForSorting(f){
	f._n2Sort = {};
	var geomClass = f.getGeometry().getType();
	f._n2Sort.isPoint = (geomClass.indexOf('Point') >= 0);
	if( f._n2Sort.isPoint ) {
		f._n2Sort.isLineString = false;
		f._n2Sort.isPolygon = false;
		f._n2Sort.largestDim = 0;
	} else {
		f._n2Sort.isLineString = (geomClass.indexOf('LineString') >= 0);
		if( f._n2Sort.isLineString ){
			// Pass in infinity extent to by-pass OpenLayers bug
			var extent = f.getGeometry().getExtent();
			f._n2Sort.largestDim = extent[2]-extent[0]
			var tmp = extent[3]-extent[1];
			if( f._n2Sort.largestDim < tmp ) {
				f._n2Sort.largestDim = tmp;
			};
		} else {
			f._n2Sort.isPolygon = true;
			
			// Pass in infinity extent to by-pass OpenLayers bug
			var extent = f.getGeometry().getExtent();
			
			// Use area
			f._n2Sort.largestDim = (extent[2]-extent[0])*(extent[3]-extent[1]);
		};
		
	};
	return f._n2Sort;
};
$n2.olUtils = {
	isValidGeom: isValidGeom
	,sortFeatures: sortFeatures
	,featureSorting: featureSorting
	, ol5FeatureSorting: ol5FeatureSorting
};


})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olLoadingControl.js

/* Copyright (c) 2006-2008 MetaCarta, Inc., published under the Clear BSD
 * license.  See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license. */


;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

if( typeof(OpenLayers) !== 'undefined' ) {

/**
 * Class: OpenLayers.Control.N2LoadingPanel
 * In some applications, it makes sense to alert the user that something is 
 * happening while tiles are loading. This control displays a div across the 
 * map when this is going on.
 *
 * Inherits from:
 *  - <OpenLayers.Control>
 */
OpenLayers.Control.N2LoadingPanel = OpenLayers.Class(OpenLayers.Control, {

    /**
     * Property: counter
     * {Integer} A counter for the number of layers loading
     */ 
    counter: 0,

    /**
     * Property: maximized
     * {Boolean} A boolean indicating whether or not the control is maximized
    */
    maximized: false,

    /**
     * Property: visible
     * {Boolean} A boolean indicating whether or not the control is visible
    */
    visible: true,

    /**
     * Constructor: OpenLayers.Control.N2LoadingPanel
     * Display a panel across the map that says 'loading'. 
     *
     * Parameters:
     * options - {Object} additional options.
     */
    initialize: function(options) {
         OpenLayers.Control.prototype.initialize.apply(this, [options]);
    },

    /**
     * Function: setVisible
     * Set the visibility of this control
     *
     * Parameters:
     * visible - {Boolean} should the control be visible or not?
    */
    setVisible: function(visible) {
        this.visible = visible;
        if (visible) {
            OpenLayers.Element.show(this.div);
        } else {
            OpenLayers.Element.hide(this.div);
        }
    },

    /**
     * Function: getVisible
     * Get the visibility of this control
     *
     * Returns:
     * {Boolean} the current visibility of this control
    */
    getVisible: function() {
        return this.visible;
    },

    /**
     * APIMethod: hide
     * Hide the loading panel control
    */
    hide: function() {
        this.setVisible(false);
    },

    /**
     * APIMethod: show
     * Show the loading panel control
    */
    show: function() {
        this.setVisible(true);
    },

    /**
     * APIMethod: toggle
     * Toggle the visibility of the loading panel control
    */
    toggle: function() {
        this.setVisible(!this.getVisible());
    },

    /**
     * Method: increaseCounter
     * Increase the counter and show control
    */
    increaseCounter: function() {
        this.counter++;
        if (this.counter > 0) { 
            if (!this.maximized && this.visible) {
                this.maximizeControl(); 
            }
        }
    },
    
    /**
     * Method: decreaseCounter
     * Decrease the counter and hide the control if finished
    */
    decreaseCounter: function() {
        if (this.counter > 0) {
            this.counter--;
        }
        if (this.counter == 0) {
            if (this.maximized && this.visible) {
                this.minimizeControl();
            }
        }
    },

    /**
     * Method: draw
     * Create and return the element to be splashed over the map.
     */
    draw: function () {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        $('<div>')
        	.addClass('n2LoadingPanel_overlay')
        	.appendTo(this.div);
        var $outer = $('<div>')
	    	.addClass('n2LoadingPanel_outertext')
	    	.appendTo(this.div);
        $('<div>')
        	.text( _loc('Loading...') )
        	.appendTo($outer);
        if( this.maximized ) {
        	this.maximizeControl();
        } else {
        	this.minimizeControl();
        };
        return this.div;
    },
     
    /**
     * Method: minimizeControl
     * Set the display properties of the control to make it disappear.
     *
     * Parameters:
     * evt - {Event}
     */
    minimizeControl: function(evt) {
    	if( this.div ) {
    		this.div.style.display = "none";
    	};
        this.maximized = false;
    
        if (evt != null) {
            OpenLayers.Event.stop(evt);
        }
    },
    
    /**
     * Method: maximizeControl
     * Make the control visible.
     *
     * Parameters:
     * evt - {Event}
     */
    maximizeControl: function(evt) {
    	if( this.div ) {
    		this.div.style.display = "block";
    	};
        this.maximized = true;
    
        if (evt != null) {
            OpenLayers.Event.stop(evt);
        }
    },

    /** 
     * Method: destroy
     * Destroy control.
     */
    destroy: function() {
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },     

    CLASS_NAME: "OpenLayers.Control.N2LoadingPanel"

});

}; // If OpenLayers is defined

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olLayerSwitcher.js

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for 
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };


if( typeof(OpenLayers) !== 'undefined' ) {

/**
 * Class: OpenLayers.Control.LayerSwitcher
 * The LayerSwitcher control displays a table of contents for the map. This 
 * allows the user interface to switch between BaseLasyers and to show or hide
 * Overlays. By default the switcher is shown minimized on the right edge of 
 * the map, the user may expand it by clicking on the handle.
 *
 * To create the LayerSwitcher outside of the map, pass the Id of a html div 
 * as the first argument to the constructor.
 * 
 * Inherits from:
 *  - <OpenLayers.Control>
 */
OpenLayers.Control.NunaliitLayerSwitcher = 
  OpenLayers.Class(OpenLayers.Control, {

    /**  
     * Property: layerStates 
     * {Array(Object)} Basically a copy of the "state" of the map's layers 
     *     the last time the control was drawn. We have this in order to avoid
     *     unnecessarily redrawing the control.
     */
    layerStates: null,
    

  // DOM Elements
  
    /**
     * Property: layersDiv
     * {DOMElement} 
     */
    layersDiv: null,
    
    /** 
     * Property: baseLayersDiv
     * {DOMElement}
     */
    baseLayersDiv: null,

    /** 
     * Property: baseLayers
     * {Array(Object)}
     */
    baseLayers: null,
    
    
    /** 
     * Property: dataLbl
     * {DOMElement} 
     */
    dataLbl: null,
    
    /** 
     * Property: dataLayersDiv
     * {DOMElement} 
     */
    dataLayersDiv: null,

    /** 
     * Property: dataLayers
     * {Array(Object)} 
     */
    dataLayers: null,


    /** 
     * Property: minimizeDiv
     * {DOMElement} 
     */
    minimizeDiv: null,

    /** 
     * Property: maximizeDiv
     * {DOMElement} 
     */
    maximizeDiv: null,
    
    /**
     * APIProperty: ascending
     * {Boolean} 
     */
    ascending: true,
    
    /**
     * Internal Property: cachedSymbols
     * {Object}
     * Dictionary of symbol paths
     */
    cachedSymbols: null,
 
    /**
     * Constructor: OpenLayers.Control.LayerSwitcher
     * 
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
    	var _this = this;
    	
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
        this.layerStates = [];
        this.cachedSymbols = {};

        // Callback for base layer radio buttons
        this.__baseFn = function(e){
        	var $elem = $(this);
        	return _this._onBaseLayerChanged($elem, e);
        };

        // Callback for vector layer checkbox buttons
        this.__overlayFn = function(e){
        	var $elem = $(this);
        	return _this._onOverlayChanged($elem, e);
        };
    },

    /**
     * APIMethod: destroy 
     */    
    destroy: function() {
        
        //clear out layers info and unregister their events 
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        
        this.map.events.un({
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },

    /** 
     * Method: setMap
     *
     * Properties:
     * map - {<OpenLayers.Map>} 
     */
    setMap: function(map) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);

        this.map.events.on({
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
    },

    /**
     * Method: draw
     *
     * Returns:
     * {DOMElement} A reference to the DIV DOMElement containing the 
     *     switcher tabs.
     */  
    draw: function() {
		var _this = this;

		OpenLayers.Control.prototype.draw.apply(this);

        // create layout divs
        this.loadContents();

        // set mode to minimize
        if(!this.outsideViewport) {
            this.minimizeControl();
        }

        // populate div with current info
        this.redraw();    

        // Do not let click events leave the control and reach the map
        // This allows the html elements to function properly
		$(this.div).click(function(e){
			var $elem = $(this);
        	_this._onButtonClick($elem,e);

        	if (e.stopPropagation) {
				e.stopPropagation();
			} else {
				e.cancelBubble = true;
			};
			return true;
		});

		// Suppress double click
		$(this.div).dblclick(function(e){
        	if (e.stopPropagation) {
				e.stopPropagation();
			} else {
				e.cancelBubble = true;
			};
			return false;
		});

        return this.div;
    },

    _onButtonClick: function($elem,evt) {
    	var $elem = $(evt.target);
    	var layerSwitcherAttr = $elem.attr('_layer_switcher');
    	
        if( $elem.hasClass('minimizeDiv') ) {
            this.minimizeControl();
            
        } else if( $elem.hasClass('maximizeDiv') ) {
            this.maximizeControl();
        };
    },
    
    _onBaseLayerChanged: function($elem, e){
    	if( $elem.is(':checked') ) {
	    	var _layer = $elem.attr('_layer');
	        this.map.setBaseLayer( this.map.getLayer(_layer) );
    	};
    	return true;
    },
    
    _onOverlayChanged: function($elem, e){
        this.updateMap();
    },
    
    _onSvgClick: function(elemId, e){
        var $input = $('#'+elemId);

        if( false == $input.is(':disabled') ) {
            if( $input.is(':checked') ){
            	$input.removeAttr('checked');
        	} else {
        		$input.attr('checked','checked');
        	};
            this.updateMap();
        };
    },

    /** 
     * Method: clearLayersArray
     * User specifies either "base" or "data". we then clear all the
     *     corresponding listeners, the div, and reinitialize a new array.
     * 
     * Parameters:
     * layersType - {String}  
     */
    clearLayersArray: function(layersType) {
        this[layersType + "LayersDiv"].innerHTML = "";
        this[layersType + "Layers"] = [];
    },


    /**
     * Method: checkRedraw
     * Checks if the layer state has changed since the last redraw() call.
     * 
     * Returns:
     * {Boolean} The layer state changed since the last redraw() call. 
     */
    checkRedraw: function() {
        var redraw = false;
        if ( !this.layerStates.length ||
             (this.map.layers.length != this.layerStates.length) ) {
            redraw = true;
        } else {
            for (var i=0, len=this.layerStates.length; i<len; i++) {
                var layerState = this.layerStates[i];
                var layer = this.map.layers[i];
                if ( (layerState.name != layer.name) || 
                     (layerState.inRange != layer.inRange) || 
                     (layerState.id != layer.id) || 
                     (layerState.visibility != layer.visibility) ) {
                    redraw = true;
                    break;
                }    
            }
        }    
        return redraw;
    },
    
    /** 
     * Method: redraw
     * Goes through and takes the current state of the Map and rebuilds the
     *     control to display that state. Groups base layers into a 
     *     radio-button group and lists each data layer with a checkbox.
     *
     * Returns: 
     * {DOMElement} A reference to the DIV DOMElement containing the control
     */  
    redraw: function() {
    	var _this = this;
    	
        //if the state hasn't changed since last redraw, no need 
        // to do anything. Just return the existing div.
        if (!this.checkRedraw()) { 
            return this.div; 
        } 

        //clear out previous layers 
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        
        var containsOverlays = false;
        var containsBaseLayers = false;
        
        // Save state -- for checking layer if the map state changed.
        // We save this before redrawing, because in the process of redrawing
        // we will trigger more visibility changes, and we want to not redraw
        // and enter an infinite loop.
        var len = this.map.layers.length;
        this.layerStates = new Array(len);
        for (var i=0; i <len; i++) {
            var layer = this.map.layers[i];
            this.layerStates[i] = {
                'name': layer.name, 
                'visibility': layer.visibility,
                'inRange': layer.inRange,
                'id': layer.id
            };
        }    

        var layers = this.map.layers.slice();
        if (!this.ascending) { layers.reverse(); }
        for(var i=0, len=layers.length; i<len; i++) {
            var layer = layers[i];
            var baseLayer = layer.isBaseLayer;

            if (layer.displayInLayerSwitcher) {

                if (baseLayer) {
                    containsBaseLayers = true;
                } else {
                    containsOverlays = true;
                }    

                // only check a baselayer if it is *the* baselayer, check data
                //  layers if they are visible
                var checked = (baseLayer) ? (layer == this.map.baseLayer)
                                          : layer.getVisibility();
    
                // create input element
                var inputId = $n2.getUniqueId();
                var $input = $('<input/>')
                	.attr('id',inputId)
                	.attr('_layer',layer.id)
                	.attr('_layer_switcher',this.id)
                	.attr('defaultChecked',checked)
                	.val(layer.name)
                	.addClass('olButton')
                	;
                
                if( baseLayer ){
                	$input
                		.attr('type','radio')
                		.attr('name',this.id + '_baseLayers');
                } else {
                	$input
	            		.attr('type','checkbox')
	            		.attr('name',layer.name);
                };

                if( checked ) {
                	$input.attr('checked','checked');
                };

                if (!baseLayer && !layer.inRange) {
                	$input.attr('disabled','disabled');
                }
                
                var $inputDiv = $('<div class="n2layerSwitcher_input_container"></div>')
                	.append($input);
                
                // create span
                var $label = $('<label/>')
                	.attr('for',inputId)
                	.addClass('labelSpan')
                	.addClass('olButton')
                	.attr('_layer_switcher',this.id)
                	.text(layer.name)
                	;

                if (!baseLayer && !layer.inRange) {
                	$label.addClass('n2layerSwitcher_outOfRange');
                };
                
                if( baseLayer ){
                	$label.addClass('n2layerSwitcher_alignBottom');
                } else {
                	$label.addClass('n2layerSwitcher_alignBaseline');
                };
                
                var $labelDiv = $('<div class="n2layerSwitcher_label_container"></div>')
                	.append($label);
                
                // SVG Preview
                var $previewDiv = null;
                if( !baseLayer && layer.styleMap ) {
	                var g = new OpenLayers.Geometry.Point(0,0);
	                var f = new OpenLayers.Feature.Vector(g);
	                var style = layer.styleMap.createSymbolizer(f);
	                
	                // SVG
	                var svg = this._createSVGNode('svg');
	                if( svg ) {
		                this._setAttr(svg, 'version', '1.1');
		                this._setAttr(svg, 'style', 'display:inline-block');
		                this._setAttr(svg, 'width', 14);
		                this._setAttr(svg, 'height', 14);
		                this._setAttr(svg, 'viewBox', '-7 -7 14 14');
		                this._addClass(svg, 'n2layerSwitcher_svg');
		                var $svg = $(svg);
		                
		                // Geometry
		                var geom = null;
		                if( style.graphicName 
		                 && this.cachedSymbols[style.graphicName] ){
		                	geom = this._createSVGNode('path');
			                this._setAttr(geom, 'd', this.cachedSymbols[style.graphicName]);
			                
		                } else if( style.graphicName 
				         && OpenLayers.Renderer.symbol[style.graphicName] ) {
		                	var path = this._computePathFromSymbol(OpenLayers.Renderer.symbol[style.graphicName]);
		                	this.cachedSymbols[style.graphicName] = path;
		                	geom = this._createSVGNode('path');
			                this._setAttr(geom, 'd', this.cachedSymbols[style.graphicName]);
		                	
//		                } else if( 'square' === style.graphicName ) {
//		                	geom = this._createSVGNode('path');
//			                this._setAttr(geom, 'd', 'M -4.4 -4.4 L -4.4 4.4 L 4.4 4.4 L 4.4 -4.4 Z');
		                
		                } else {
			                geom = this._createSVGNode('circle');
			                this._setAttr(geom, 'r', 5);
		                };
		                if( geom ) {
			                for(var name in style){
			                	var styleValue = style[name];
			                	
			                	if( 'fillColor' === name ){
				                	this._setAttr(geom, 'fill', styleValue);
				                	
			                	} else if( 'fillOpacity' === name ){
				                	this._setAttr(geom, 'fill-opacity', styleValue);
				                	
			                	} else if( 'strokeColor' === name ){
				                	this._setAttr(geom, 'stroke', styleValue);
				                	
			                	} else if( 'strokeOpacity' === name ){
				                	this._setAttr(geom, 'stroke-opacity', styleValue);
				                	
			                	} else if( 'strokeWidth' === name ){
				                	this._setAttr(geom, 'stroke-width', styleValue);
				                	
			                	} else if( 'strokeLinecap' === name ){
				                	this._setAttr(geom, 'stroke-linecap', styleValue);
		
			                	} else {
			                		this._setAttr(geom, name, styleValue);
			                	};
			                };
			                svg.appendChild(geom);
			                
			                geom.onclick = createSvgClickHandler(inputId);
		                };
		                
		                $previewDiv = $('<div class="n2layerSwitcher_preview_container"></div>')
		                	.append($svg);
	                };
                };
                
                var groupArray = (baseLayer) ? this.baseLayers
                                             : this.dataLayers;
                groupArray.push({
                    'layer': layer,
                    'inputElem': $input,
                    'labelSpan': $label
                });
                                                     
    
                var groupDiv = (baseLayer) ? this.baseLayersDiv
                                           : this.dataLayersDiv;
                var $div = $('<div class="n2layerSwitcher_layer"/>')
                	.append($inputDiv)
                	.append($labelDiv)
                	.appendTo( $(groupDiv) );
                if( $previewDiv ){
                	$div.append($previewDiv);
                };
                
                if( baseLayer ){
                	$input.change(this.__baseFn);
                } else {
                	$input.change(this.__overlayFn);
                };
            };
        };

        // if no overlays, dont display the overlay label
        this.dataLbl.style.display = (containsOverlays) ? "" : "none";        
        
        // if no baselayers, dont display the baselayer label
        this.baseLbl.style.display = (containsBaseLayers) ? "" : "none";        

        return this.div;
        
        function createSvgClickHandler(elemId){
        	return function(e){
        		return _this._onSvgClick(elemId,e);
        	};
        };
    },
    
    _createSVGNode: function(type, id) {
        var node = null;
        if( document.createElementNS ) {
	        node = document.createElementNS('http://www.w3.org/2000/svg', type);
	        if (id) {
	            node.setAttributeNS(null, 'id', id);
	        };
        };
        return node;    
    },
    
    _setAttr: function(node, name, value) {
    	node.setAttributeNS(null, name, value);
    },
    
    _addClass: function(elem, className) {
    	var classNames = [];

    	var currentClasses = elem.getAttribute('class') || '';
    	if( currentClasses ) {
    		classNames = currentClasses.split(' ');
    	};

    	if( classNames.indexOf(className) < 0 ){
        	classNames.push(className);
    	};
    	
    	elem.setAttribute('class',classNames.join(' '));
    },

    /** 
     * Method: updateMap
     * Cycles through the loaded data and base layer input arrays and makes
     *     the necessary calls to the Map object such that that the map's 
     *     visual state corresponds to what the user has selected in 
     *     the control.
     */
    updateMap: function() {

        // set the newly selected base layer        
        for(var i=0, len=this.baseLayers.length; i<len; i++) {
            var layerEntry = this.baseLayers[i];
            if (layerEntry.inputElem.is(':checked')) {
                this.map.setBaseLayer(layerEntry.layer, false);
            };
        };

        // set the correct visibilities for the overlays
        for(var i=0, len=this.dataLayers.length; i<len; i++) {
            var layerEntry = this.dataLayers[i];
            var checked = layerEntry.inputElem.is(':checked');
            layerEntry.layer.setVisibility(checked);
        };

    },

    /** 
     * Method: maximizeControl
     * Set up the labels and divs for the control
     * 
     * Parameters:
     * e - {Event} 
     */
    maximizeControl: function(e) {

        // set the div's width and height to empty values, so
        // the div dimensions can be controlled by CSS
        this.div.style.width = "";
        this.div.style.height = "";

        this.showControls(false);

        if (e != null) {
            OpenLayers.Event.stop(e);                                            
        }
    },
    
    /** 
     * Method: minimizeControl
     * Hide all the contents of the control, shrink the size, 
     *     add the maximize icon
     *
     * Parameters:
     * e - {Event} 
     */
    minimizeControl: function(e) {

        // to minimize the control we set its div's width
        // and height to 0px, we cannot just set "display"
        // to "none" because it would hide the maximize
        // div
        this.div.style.width = "0px";
        this.div.style.height = "0px";

        this.showControls(true);

        if (e != null) {
            OpenLayers.Event.stop(e);                                            
        }
    },

    /**
     * Method: showControls
     * Hide/Show all LayerSwitcher controls depending on whether we are
     *     minimized or not
     * 
     * Parameters:
     * minimize - {Boolean}
     */
    showControls: function(minimize) {

        this.maximizeDiv.style.display = minimize ? "" : "none";
        this.minimizeDiv.style.display = minimize ? "none" : "";

        this.layersDiv.style.display = minimize ? "none" : "";
    },
    
    /** 
     * Method: loadContents
     * Set up the labels and divs for the control
     */
    loadContents: function() {

        // layers list div        
        this.layersDiv = document.createElement("div");
        this.layersDiv.id = this.id + "_layersDiv";
        OpenLayers.Element.addClass(this.layersDiv, "layersDiv");

        this.baseLbl = document.createElement("div");
        this.baseLbl.innerHTML = _loc("Base Layer");
        OpenLayers.Element.addClass(this.baseLbl, "baseLbl");
        
        this.baseLayersDiv = document.createElement("div");
        OpenLayers.Element.addClass(this.baseLayersDiv, "baseLayersDiv");

        this.dataLbl = document.createElement("div");
        this.dataLbl.innerHTML = _loc("Overlays");
        OpenLayers.Element.addClass(this.dataLbl, "dataLbl");
        
        this.dataLayersDiv = document.createElement("div");
        OpenLayers.Element.addClass(this.dataLayersDiv, "dataLayersDiv");

        if (this.ascending) {
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
        } else {
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
        }    
 
        this.div.appendChild(this.layersDiv);

        // maximize button div
        var img = OpenLayers.Util.getImageLocation('layer-switcher-maximize.png');
        this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv(
                                    "OpenLayers_Control_MaximizeDiv", 
                                    null, 
                                    null, 
                                    img, 
                                    "absolute");
        OpenLayers.Element.addClass(this.maximizeDiv, "maximizeDiv olButton");
        this.maximizeDiv.style.display = "none";
        
        this.div.appendChild(this.maximizeDiv);

        // minimize button div
        var img = OpenLayers.Util.getImageLocation('layer-switcher-minimize.png');
        this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv(
                                    "OpenLayers_Control_MinimizeDiv", 
                                    null, 
                                    null, 
                                    img, 
                                    "absolute");
        OpenLayers.Element.addClass(this.minimizeDiv, "minimizeDiv olButton");
        this.minimizeDiv.style.display = "none";

        this.div.appendChild(this.minimizeDiv);
    },
    
    /** 
     * Method: _computePathFromSymbol
     * Given an OpenLayers symbol (array of points, which are tuples of x,y coordinates),
     * create a SVG path with an approximate area of 30 (area of a circle with a radius of 5)
     * Example for symbol: [0,0, 1,0, 1,1, 0,1, 0,0]
     * Examplke fo SVG Path: 'M -4.4 -4.4 L -4.4 4.4 L 4.4 4.4 L 4.4 -4.4 Z'
     */
    _computePathFromSymbol: function(symbol){
    	var area = 0,
    	 minx = undefined,
    	 maxx = undefined,
    	 miny = undefined,
    	 maxy = undefined;

    	// Figure out bounding box
    	for(var i=0,e=symbol.length; i<e; i=i+2){
    		var x = symbol[i];
    		var y = symbol[i+1];
    		
    		if( typeof minx === 'undefined' ){
    			minx = x;
    		} else if( minx > x ){
    			minx = x;
    		};
    		
    		if( typeof maxx === 'undefined' ){
    			maxx = x;
    		} else if( maxx < x ){
    			maxx = x;
    		};
    		
    		if( typeof miny === 'undefined' ){
    			miny = y;
    		} else if( miny > y ){
    			miny = y;
    		};
    		
    		if( typeof maxy === 'undefined' ){
    			maxy = y;
    		} else if( maxy < y ){
    			maxy = y;
    		};
    	};
    	
    	// Compute path, recentering the symbol and adjusting the area so
    	// it fits a bounding box of 10x10
    	var path = [],
    	 transx = (minx+maxx)/2,
    	 transy = (miny+maxy)/2,
    	 width = maxx-minx,
    	 height = maxy-miny,
    	 factor = (width > height) ? width / 10 : height / 10;
    	if( factor <= 0 ){
    		factor = 1;
    	};
    	for(var i=0,e=symbol.length; i<e; i=i+2){
    		var x = symbol[i];
    		var y = symbol[i+1];

    		var effX = (x-transx)/factor;
    		var effY = (y-transy)/factor;
    		
    		// Round to .01
    		effX = Math.floor(effX * 100) / 100;
    		effY = Math.floor(effY * 100) / 100;
    		
    		if( 0 === i ){
        		path.push('M ');
    		} else {
        		path.push('L ');
    		};
    		
    		path.push(''+effX);
    		path.push(' '+effY+' ');
    	};
    	path.push('Z');
    	
    	return path.join('');
    },
    
    CLASS_NAME: "OpenLayers.Control.LayerSwitcher"
});

}; // if(typeof(OpenLayers) !== 'undefined')

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olFeatureHandler.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

if( typeof(OpenLayers) !== 'undefined'
 && OpenLayers.Class
 && OpenLayers.Handler
 ) {

/**
 * @requires OpenLayers/Handler.js
 */

/**
 * Class: OpenLayers.Handler.Feature 
 * Handler to respond to mouse events related to a drawn feature.  Callbacks
 *     with the following keys will be notified of the following events
 *     associated with features: click, clickout, over, out, and dblclick.
 *
 * This handler stops event propagation for mousedown and mouseup if those
 *     browser events target features that can be selected.
 *
 * Inherits from:
 *  - <OpenLayers.Handler>
 */
OpenLayers.Handler.NunaliitFeature = OpenLayers.Class(OpenLayers.Handler, {

    /**
     * Property: EVENTMAP
     * {Object} A object mapping the browser events to objects with callback
     *     keys for in and out.
     */
    EVENTMAP: {
        'click': {'in': 'click', 'out': 'clickout'},
        'mousemove': {'in': 'over', 'out': 'out'},
        'dblclick': {'in': 'dblclick', 'out': null},
        'mousedown': {'in': null, 'out': null},
        'mouseup': {'in': null, 'out': null},
        'touchstart': {'in': 'click', 'out': 'clickout'}
    },

    /**
     * Property: feature
     * {<OpenLayers.Feature.Vector>} The last feature that was hovered.
     */
    feature: null,

    /**
     * Property: lastFeature
     * {<OpenLayers.Feature.Vector>} The last feature that was handled.
     */
    lastFeature: null,

    /**
     * Property: lastClickedFeature
     * {<OpenLayers.Feature.Vector>} The last feature that was clicked.
     */
    lastClickedFeature: null,

    /**
     * Property: down
     * {<OpenLayers.Pixel>} The location of the last mousedown.
     */
    down: null,

    /**
     * Property: up
     * {<OpenLayers.Pixel>} The location of the last mouseup.
     */
    up: null,
    
    /**
     * Property: clickTolerance
     * {Number} The number of pixels the mouse can move between mousedown
     *     and mouseup for the event to still be considered a click.
     *     Dragging the map should not trigger the click and clickout callbacks
     *     unless the map is moved by less than this tolerance. Defaults to 4.
     */
    clickTolerance: 4,

    /**
     * Property: geometryTypes
     * To restrict dragging to a limited set of geometry types, send a list
     * of strings corresponding to the geometry class names.
     * 
     * @type Array(String)
     */
    geometryTypes: null,

    /**
     * Property: stopClick
     * {Boolean} If stopClick is set to true, handled clicks do not
     *      propagate to other click listeners. Otherwise, handled clicks
     *      do propagate. Unhandled clicks always propagate, whatever the
     *      value of stopClick. Defaults to true.
     */
    stopClick: true,

    /**
     * Property: stopDown
     * {Boolean} If stopDown is set to true, handled mousedowns do not
     *      propagate to other mousedown listeners. Otherwise, handled
     *      mousedowns do propagate. Unhandled mousedowns always propagate,
     *      whatever the value of stopDown. Defaults to true.
     */
    stopDown: false,

    /**
     * Property: stopUp
     * {Boolean} If stopUp is set to true, handled mouseups do not
     *      propagate to other mouseup listeners. Otherwise, handled mouseups
     *      do propagate. Unhandled mouseups always propagate, whatever the
     *      value of stopUp. Defaults to false.
     */
    stopUp: false,
    
    /**
     * Constructor: OpenLayers.Handler.Feature
     *
     * Parameters:
     * control - {<OpenLayers.Control>} 
     * layer - {<OpenLayers.Layer.Vector>}
     * callbacks - {Object} An object with a 'over' property whos value is
     *     a function to be called when the mouse is over a feature. The 
     *     callback should expect to recieve a single argument, the feature.
     * options - {Object} 
     */
    initialize: function(control, layer, callbacks, options) {
        OpenLayers.Handler.prototype.initialize.apply(this, [control, callbacks, options]);
        this.layer = layer;
    },

    /**
     * Method: touchstart
     * Handle touchstart events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchstart: function(evt) {
        this.startTouch(); 
        return OpenLayers.Event.isMultiTouch(evt) ?
                true : this.mousedown(evt);
    },

    /**
     * Method: touchmove
     * Handle touchmove events. We just prevent the browser default behavior,
     *    for Android Webkit not to select text when moving the finger after
     *    selecting a feature.
     *
     * Parameters:
     * evt - {Event}
     */
    touchmove: function(evt) {
        OpenLayers.Event.preventDefault(evt);
    },

    /**
     * Method: mousedown
     * Handle mouse down.  Stop propagation if a feature is targeted by this
     *     event (stops map dragging during feature selection).
     * 
     * Parameters:
     * evt - {Event} 
     */
    mousedown: function(evt) {
        // Feature selection is only done with a left click. Other handlers may stop the
        // propagation of left-click mousedown events but not right-click mousedown events.
        // This mismatch causes problems when comparing the location of the down and up
        // events in the click function so it is important ignore right-clicks.
        if (OpenLayers.Event.isLeftClick(evt) || OpenLayers.Event.isSingleTouch(evt)) {
            this.down = evt.xy;
        }
        return this.handle(evt) ? !this.stopDown : true;
    },
    
    /**
     * Method: mouseup
     * Handle mouse up.  Stop propagation if a feature is targeted by this
     *     event.
     * 
     * Parameters:
     * evt - {Event} 
     */
    mouseup: function(evt) {
        this.up = evt.xy;
        return this.handle(evt) ? !this.stopUp : true;
    },

    /**
     * Method: click
     * Handle click.  Call the "click" callback if click on a feature,
     *     or the "clickout" callback if click outside any feature.
     * 
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    click: function(evt) {
        return this.handle(evt) ? !this.stopClick : true;
    },
        
    /**
     * Method: mousemove
     * Handle mouse moves.  Call the "over" callback if moving in to a feature,
     *     or the "out" callback if moving out of a feature.
     * 
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    mousemove: function(evt) {
        if (!this.callbacks['over'] && !this.callbacks['out']) {
            return true;
        }     
        this.handle(evt);
        return true;
    },
    
    /**
     * Method: dblclick
     * Handle dblclick.  Call the "dblclick" callback if dblclick on a feature.
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    dblclick: function(evt) {
        return !this.handle(evt);
    },

    /**
     * Method: geometryTypeMatches
     * Return true if the geometry type of the passed feature matches
     *     one of the geometry types in the geometryTypes array.
     *
     * Parameters:
     * feature - {<OpenLayers.Vector.Feature>}
     *
     * Returns:
     * {Boolean}
     */
    geometryTypeMatches: function(feature) {
        return this.geometryTypes == null ||
            OpenLayers.Util.indexOf(this.geometryTypes,
                                    feature.geometry.CLASS_NAME) > -1;
    },

    /**
     * Method: handle
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} The event occurred over a relevant feature.
     */
    handle: function(evt) {
        var type = evt.type;
        var handled = false;
        var previouslyIn = !!(this.feature); // previously in a feature
        var click = (type == "click" || type == "dblclick" || type == "touchstart");
        this.feature = this.layer.getFeatureFromEvent(evt);
        if(this.feature && !this.feature.layer) {
            // feature has been destroyed
            this.feature = null;
        }
        if(this.lastFeature && !this.lastFeature.layer) {
            // last feature has been destroyed
            this.lastFeature = null;
        }
        if(this.feature && click) {
            if(type === "touchstart") {
                // stop the event to prevent Android Webkit from
                // "flashing" the map div
                OpenLayers.Event.preventDefault(evt);
            }
            if(this.geometryTypeMatches(this.feature)) {
                // in to a feature
                this.triggerCallback(type, 'in', [this.feature]);
                this.lastClickedFeature = this.feature;
                handled = true;
            } else {
                // not in to a feature
                if(this.lastClickedFeature && this.lastClickedFeature.layer) {
                    this.triggerCallback(type, 'out', [this.lastClickedFeature]);
                } else {
                	// last clicked feature was destroyed
                    this.triggerCallback(type, 'out', []);
                }
                
                // Do not clickout again
                this.lastClickedFeature = null;
            }
        	
        } else if( click ) {
            if(this.lastClickedFeature && this.lastClickedFeature.layer) {
            	this.triggerCallback(type, 'out', [this.lastClickedFeature]);
            } else {
            	// last clicked feature was destroyed
            	this.triggerCallback(type, 'out', []);
            }
            this.lastClickedFeature = null;
        	
        } else if(this.feature) {
        	// Mouse in
            var inNew = (this.feature !== this.lastFeature);
            if(this.geometryTypeMatches(this.feature)) {
                // in to a feature
                if(previouslyIn && inNew) {
                    // out of last feature and in to another
                    if(this.lastFeature) {
                        this.triggerCallback(type, 'out', [this.lastFeature]);
                    }
                    this.triggerCallback(type, 'in', [this.feature]);
                } else if(!previouslyIn) {
                    // in feature for the first time
                    this.triggerCallback(type, 'in', [this.feature]);
                }
                this.lastFeature = this.feature;
                handled = true;
            } else {
                // not in to a feature
                if( previouslyIn && inNew ) {
                    // out of last feature for the first time
                	if( this.lastFeature ){
                        this.triggerCallback(type, 'out', [this.lastFeature]);
                	} else {
                        this.triggerCallback(type, 'out', []);
                	};
                };
                // next time the mouse goes in a feature whose geometry type
                // doesn't match we don't want to call the 'out' callback
                // again, so let's set this.feature to null so that
                // previouslyIn will evaluate to false the next time
                // we enter handle. Yes, a bit hackish...
                this.feature = null;
            }
        } else if(previouslyIn) {
        	// mouse out
        	if( this.lastFeature ){
        		this.triggerCallback(type, 'out', [this.lastFeature]);
        	} else {
                this.triggerCallback(type, 'out', []);
        	};
        };
        return handled;
    },
    
    /**
     * Method: triggerCallback
     * Call the callback keyed in the event map with the supplied arguments.
     *     For click and clickout, the <clickTolerance> is checked first.
     *
     * Parameters:
     * type - {String}
     */
    triggerCallback: function(type, mode, args) {
    	var triggered = false;
        var key = this.EVENTMAP[type][mode];
        if(key) {
            if(type == 'click' && this.up && this.down) {
                // for click/clickout, only trigger callback if tolerance is met
                var dpx = Math.sqrt(
                    Math.pow(this.up.x - this.down.x, 2) +
                    Math.pow(this.up.y - this.down.y, 2)
                );
                if(dpx <= this.clickTolerance) {
                    this.callback(key, args);
                    triggered = true;
                }
                // we're done with this set of events now: clear the cached
                // positions so we can't trip over them later (this can occur
                // if one of the up/down events gets eaten before it gets to us
                // but we still get the click)
                this.up = this.down = null;
            } else {
                this.callback(key, args);
                triggered = true;
            }
        }
        return triggered;
    },

    /**
     * Method: activate 
     * Turn on the handler.  Returns false if the handler was already active.
     *
     * Returns:
     * {Boolean}
     */
    activate: function() {
        var activated = false;
        if(OpenLayers.Handler.prototype.activate.apply(this, arguments)) {
            this.moveLayerToTop();
            this.map.events.on({
                "removelayer": this.handleMapEvents,
                "changelayer": this.handleMapEvents,
                scope: this
            });
            activated = true;
        }
        return activated;
    },
    
    /**
     * Method: deactivate 
     * Turn off the handler.  Returns false if the handler was already active.
     *
     * Returns: 
     * {Boolean}
     */
    deactivate: function() {
        var deactivated = false;
        if(OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
            this.moveLayerBack();
            this.feature = null;
            this.lastFeature = null;
            this.down = null;
            this.up = null;
            this.map.events.un({
                "removelayer": this.handleMapEvents,
                "changelayer": this.handleMapEvents,
                scope: this
            });
            deactivated = true;
        }
        return deactivated;
    },
    
    /**
     * Method: handleMapEvents
     * 
     * Parameters:
     * evt - {Object}
     */
    handleMapEvents: function(evt) {
        if (evt.type == "removelayer" || evt.property == "order") {
            this.moveLayerToTop();
        }
    },
    
    /**
     * Method: moveLayerToTop
     * Moves the layer for this handler to the top, so mouse events can reach
     * it.
     */
    moveLayerToTop: function() {
        var index = Math.max(this.map.Z_INDEX_BASE['Feature'] - 1,
            this.layer.getZIndex()) + 1;
        this.layer.setZIndex(index);
        
    },
    
    /**
     * Method: moveLayerBack
     * Moves the layer back to the position determined by the map's layers
     * array.
     */
    moveLayerBack: function() {
        var index = this.layer.getZIndex() - 1;
        if (index >= this.map.Z_INDEX_BASE['Feature']) {
            this.layer.setZIndex(index);
        } else {
            this.map.setLayerZIndex(this.layer,
                this.map.getLayerIndex(this.layer));
        }
    },

    CLASS_NAME: "OpenLayers.Handler.NunaliitFeature"
});

	
	
}; // If OpenLayers is defined
	
})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olGenericControl.js

/* Copyright (c) 2006-2008 MetaCarta, Inc., published under the Clear BSD
 * license.  See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license. */

;(function($n2){
"use strict";


if( typeof OpenLayers !== 'undefined'
 && OpenLayers.Control
 && OpenLayers.Class
 ) {
	// =================== NunaliitGazetteer ==========================
	OpenLayers.Control.NunaliitGazetteer = OpenLayers.Class(OpenLayers.Control, {

		activateListener: null,
		
	    /**
	     * Constructor: OpenLayers.Control.Navigation
	     * Create a new navigation control
	     * 
	     * Parameters:
	     * options - {Object} An optional object whose properties will be set on
	     *                    the control
	     */
	    initialize: function(options) {
	        this.handlers = {};
	        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	    },
	
	    /**
	     * Method: destroy
	     * The destroy method is used to perform any clean up before the control
	     * is dereferenced.  Typically this is where event listeners are removed
	     * to prevent memory leaks.
	     */
	    destroy: function() {
	        this.deactivate();
	
	        OpenLayers.Control.prototype.destroy.apply(this,arguments);
	    },
	    
	    /**
	     * Method: activate
	     */
	    activate: function() {
	    	if( typeof(this.activateListener) === 'function' ){
	    		this.activateListener();
	    	} else {
		        return OpenLayers.Control.prototype.activate.apply(this,arguments);
	    	};
	    },
	
	    /**
	     * Method: deactivate
	     */
	    deactivate: function() {
	        return OpenLayers.Control.prototype.deactivate.apply(this,arguments);
	    },
	    
	    CLASS_NAME: "OpenLayers.Control.NunaliitGazetteer"
	});

}; // If OpenLayers is defined

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olFeatureStrategy.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

if( typeof OpenLayers !== 'undefined'
 && OpenLayers.Strategy
 && OpenLayers.Class
 ) {
	
//+++++++++++++++++++++++++++++++++++++++++++++++
var Filtering = $n2.Class({
	
	// Boolean: if true, the set doc ids are allowed through, other
	// ones filtered out
	whiteList: null,
	
    docIdMap: null,

    initialize: function(opts_){
		var opts = $n2.extend({
			whiteList: false
		},opts_);

		this.whiteList = opts.whiteList;
		this.docIdMap = {};
	},
	
	setDocIds: function(docIds){
		var _this = this;

		this.docIdMap = {};
		if( typeof docIds === 'string' ){
			this.docIdMap[docIds] = true;
		} else {
			docIds.forEach(function(docId){
				_this.docIdMap[docId] = true;
			});
		};
	},
	
	performFiltering: function(features, filteredOutFeatures){
		var _this = this;
		
		var newFeatures = [];
		features.forEach(function(feature){
			var visible = _this._isFeatureVisible(feature);

			if( visible ){
				newFeatures.push(feature);
			} else if(filteredOutFeatures) {
				filteredOutFeatures.push(feature);
			};
		});
		
		return newFeatures;
	},
	
	_isFeatureVisible: function(feature){
		var visible = true;
		
		var id = undefined;
		if( feature && feature.data ){
			id = feature.data._id;
		};
		if( id && this.docIdMap[id] ){
			visible = false;
		};
		
		if( this.whiteList ){
			visible = !visible;
		};
		
		return visible;
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++
var MinimumSizeStrategy = $n2.Class({

	minimumLinePixelSize: 10,

	minimumPolygonPixelSize: 10,

    initialize: function(opts_){
		var opts = $n2.extend({
			minimumLinePixelSize: 10
			,minimumPolygonPixelSize: 10
		},opts_);

		this.minimumLinePixelSize = 10;
		if( typeof opts.minimumLinePixelSize === 'number' ){
			this.minimumLinePixelSize = opts.minimumLinePixelSize;
		};

		this.minimumPolygonPixelSize = 10;
		if( typeof opts.minimumPolygonPixelSize === 'number' ){
			this.minimumPolygonPixelSize = opts.minimumPolygonPixelSize;
		};
	},
	
	processFeatures: function(features, resolution){
        var clusters = [];
        var featuresToAdd = [];
        var feature, clustered, cluster;
        for(var i=0; i<features.length; ++i) {
            feature = features[i];
            if( this._shouldTurnToPoint(feature, resolution) ){
                var center = feature.geometry.getBounds().getCenterLonLat();
                var pointGeom = new OpenLayers.Geometry.Point(center.lon, center.lat);

                feature.n2MinSizeGeom = feature.geometry;
                feature.geometry = pointGeom;

            } else if( this._shouldRestore(feature, resolution) ){
                var originalGeom = feature.n2MinSizeGeom;
                feature.geometry = originalGeom;
                delete feature.n2MinSizeGeom;
            };
        };
        
        return features;
	},

	_shouldTurnToPoint: function(feature, resolution) {
    	// By default, leave as is
        var eligible = false;
        
        if( feature.geometry.CLASS_NAME.indexOf('Line') >= 0 ){
    		var bounds = feature.geometry.getBounds();
    		var pixels = this._boundsToPixels(bounds, resolution);
    		if( pixels < this.minimumLinePixelSize ) {
    			eligible = true;
    		};
    	} else if( feature.geometry.CLASS_NAME.indexOf('Polygon') >= 0 ){
    		var bounds = feature.geometry.getBounds();
    		var pixels = this._boundsToPixels(bounds, resolution);
    		if( pixels < this.minimumLinePixelSize ) {
    			eligible = true;
    		};
    	};
        
        return eligible;
	},

	_shouldRestore: function(feature, resolution) {
    	// By default, leave as is
        var eligible = false;
        
        var geometry = feature.n2MinSizeGeom;
        if( geometry ){
            if( geometry.CLASS_NAME.indexOf('Line') >= 0 ){
        		var bounds = geometry.getBounds();
        		var pixels = this._boundsToPixels(bounds, resolution);
        		if( pixels >= this.minimumPolygonPixelSize ) {
        			eligible = true;
        		};
        	} else if( geometry.CLASS_NAME.indexOf('Polygon') >= 0 ){
        		var bounds = geometry.getBounds();
        		var pixels = this._boundsToPixels(bounds, resolution);
        		if( pixels >= this.minimumPolygonPixelSize ) {
        			eligible = true;
        		};
        	};
        };
        
        return eligible;
    },
    
    _boundsToPixels: function(bounds, resolution){
		var xLen = (bounds.right - bounds.left) / resolution;
		var yLen = (bounds.top - bounds.bottom) / resolution;
		if( xLen > yLen ){
			return xLen;
		};
		return yLen;
    }
});

//+++++++++++++++++++++++++++++++++++++++++++++++
var Clustering = $n2.Class({
    /**
     * APIProperty: distance
     * {Integer} Pixel distance between features that should be considered a
     *     single cluster.  Default is 20 pixels.
     */
    distance: undefined,

    /**
     * APIProperty: minimumPolygonPixelSize
     * {Integer} Minimum pixel size that a polygon has to be so that it is
     * not converted to a point.  Default is 20 pixels.
     */
    minimumPolygonPixelSize: undefined,

    /**
     * APIProperty: minimumLinePixelSize
     * {Integer} Minimum pixel size that a line has to be so that it is
     * not converted to a point.  Default is 20 pixels.
     */
    minimumLinePixelSize: undefined,

    /**
     * APIProperty: disableDynamicClustering
     * {Boolean} If true, disable default behaviour which is to turn small
     * polygons and lines into cluster, but leaving larger ones from clustering.
     */
    disableDynamicClustering: false,

    /**
     * APIProperty: clusterPointsOnly
     * {Boolean} If true, skip lines and polygons during clustering. The option
     * "disableDynamicClustering" must be set for this option to take effect.
     */
    clusterPointsOnly: false,
    
    /**
     * APIProperty: threshold
     * {Integer} Optional threshold below which original features will be
     *     added to the layer instead of clusters.  For example, a threshold
     *     of 3 would mean that any time there are 2 or fewer features in
     *     a cluster, those features will be added directly to the layer instead
     *     of a cluster representing those features.  Default is null (which is
     *     equivalent to 1 - meaning that clusters may contain just one feature).
     */
    threshold: null,
    
    /**
     * Property: resolution
     * {Float} The resolution (map units per pixel) of the current cluster set.
     */
    resolution: null,
    
    /**
     * Property: projection
     * {<OpenLayers.Projection>} The projection currently used by the map
     */
    projection: null,
    
    /**
     * Property: clusterPrefix
     * {Integer} The string portion of the identifiers to be given to clusters.
     */
    clusterPrefix: null,
    
    /**
     * Property: clusterId
     * {Integer} The integer portion of the next identifier to be given to clusters.
     */
    clusterId: null,

    initialize: function(opts_){
		var opts = $n2.extend({
		    distance: 20,
		    minimumPolygonPixelSize: undefined,
		    minimumLinePixelSize: undefined,
		    disableDynamicClustering: false,
		    clusterPointsOnly: false,
		    threshold: null
		},opts_);
		
		this.distance = opts.distance;
		this.minimumPolygonPixelSize = opts.minimumPolygonPixelSize;
		this.minimumLinePixelSize = opts.minimumLinePixelSize;
		this.disableDynamicClustering = opts.disableDynamicClustering;
		this.clusterPointsOnly = opts.clusterPointsOnly;
		this.threshold = opts.threshold;

		this.resolution = 1;
		this.clusterPrefix = 'cluster_' + $n2.getUniqueId() + '_';
		this.clusterId = 1;
		
    	if( typeof this.minimumPolygonPixelSize === 'undefined' ){
    		this.minimumPolygonPixelSize = this.distance;
    	};
    	
    	if( typeof this.minimumLinePixelSize === 'undefined' ){
    		this.minimumLinePixelSize = this.distance;
    	};
	},

	setResolution: function(resolution){
		this.resolution = resolution;
	},

	setProjection: function(projection){
		this.projection = projection;
	},

	performClustering: function(features){
        var resolution = this.resolution;
        var clusters = [];
        var featuresToAdd = [];
        var feature, clustered, cluster;
        for(var i=0; i<features.length; ++i) {
            feature = features[i];
            if( !this._isEligibleFeature(feature) ){
            	featuresToAdd.push(feature);
            	
            } else if(feature.geometry) {
                clustered = false;
                for(var j=clusters.length-1; j>=0; --j) {
                    cluster = clusters[j];
                    if(this._shouldCluster(cluster, feature)) {
                        this._addToCluster(cluster, feature);
                        clustered = true;
                        break;
                    };
                };
                if(!clustered) {
                	var c = this._createCluster(feature);
                    clusters.push(c);
                    featuresToAdd.push(c);
                };
            };
        };

        var finalFeatures = [];
        if( this.threshold > 1 ) {
            for(var i=0, len=featuresToAdd.length; i<len; ++i) {
                var candidate = featuresToAdd[i];
                if( candidate.cluster 
                 && candidate.cluster.length < this.threshold ) {
                	candidate.cluster.forEach(function(f){
                    	finalFeatures[finalFeatures.length] = f;
                	});
                } else {
                	finalFeatures[finalFeatures.length] = candidate;
                };
            };

        } else {
        	finalFeatures = featuresToAdd;
        };
        
        return finalFeatures;
	},

	/**
     * Method: shouldCluster
     * Determine whether to include a feature in a given cluster.
     *
     * Parameters:
     * cluster - {<OpenLayers.Feature.Vector>} A cluster.
     * feature - {<OpenLayers.Feature.Vector>} A feature.
     *
     * Returns:
     * {Boolean} The feature should be included in the cluster.
     */
    _shouldCluster: function(cluster, feature) {
        var cc = cluster.geometry.getBounds().getCenterLonLat();
        var fc = feature.geometry.getBounds().getCenterLonLat();
        var distance = (
            Math.sqrt(
                Math.pow((cc.lon - fc.lon), 2) + Math.pow((cc.lat - fc.lat), 2)
            ) / this.resolution
        );
        return (distance <= this.distance);
    },
    
    /**
     * Method: addToCluster
     * Add a feature to a cluster.
     *
     * Parameters:
     * cluster - {<OpenLayers.Feature.Vector>} A cluster.
     * feature - {<OpenLayers.Feature.Vector>} A feature.
     */
    _addToCluster: function(cluster, feature) {
        cluster.cluster.push(feature);
        cluster.attributes.count += 1;
    },
    
    /**
     * Method: createCluster
     * Given a feature, create a cluster.
     *
     * Parameters:
     * feature - {<OpenLayers.Feature.Vector>}
     *
     * Returns:
     * {<OpenLayers.Feature.Vector>} A cluster.
     */
    _createCluster: function(feature) {
        var center = feature.geometry.getBounds().getCenterLonLat();
        var cluster = new OpenLayers.Feature.Vector(
            new OpenLayers.Geometry.Point(center.lon, center.lat),
            {count: 1}
        );
        cluster.cluster = [feature];
        cluster.fid = this.clusterPrefix+this.clusterId;
        ++this.clusterId;
        return cluster;
    },

	/**
	 * Method: _isEligibleFeature
	 * Returns true if a feature should be clustered
	 *
	 * Returns:
	 * {Boolean} True if the feature should be considered for clusters
	 */
	_isEligibleFeature: function(feature) {
		if( feature.n2DisableClustering ){
			return false;
		};

		// By default, cluster everything
		var eligible = true;

		if( !this.disableDynamicClustering ) {
			// Dynamic Clustering
			// Small polygons and lines are turned into a cluster
			eligible = false;
			
			var bounds = this._computeFullBoundingBox(feature);
			if( bounds ){
				// If the original bounds are larger than what is expected
				// by the resolution, do not cluster. At one point, the correct
				// geometry will arrive to show this feature.
				var xLen = (bounds.right - bounds.left) / this.resolution;
				var yLen = (bounds.top - bounds.bottom) / this.resolution;
				if( (xLen) < this.minimumLinePixelSize
				 && (yLen) < this.minimumLinePixelSize ) {
					eligible = true;
				};
			} else {
				// We are unable to compute the bounds for this feature.
				// Use the geometry for the purpose of clustering
				if( feature.geometry.CLASS_NAME.indexOf('Point') >= 0 ){
					eligible = true;
				} else if( feature.geometry.CLASS_NAME.indexOf('Line') >= 0 ){
					var bounds = feature.geometry.getBounds();
					var xLen = (bounds.right - bounds.left) / this.resolution;
					var yLen = (bounds.top - bounds.bottom) / this.resolution;
					if( (xLen) < this.minimumLinePixelSize
					 && (yLen) < this.minimumLinePixelSize ) {
						eligible = true;
					};
				} else if( feature.geometry.CLASS_NAME.indexOf('Polygon') >= 0 ){
					var bounds = feature.geometry.getBounds();
					var xLen = (bounds.right - bounds.left) / this.resolution;
					var yLen = (bounds.top - bounds.bottom) / this.resolution;
					if( (xLen) < this.minimumPolygonPixelSize
					 && (yLen) < this.minimumPolygonPixelSize ) {
						eligible = true;
					};
				};
			};

		} else if( this.clusterPointsOnly ){
			// Cluster Point Only
			// Do not cluster polygons and lines
			eligible = false;
			if( feature.geometry.CLASS_NAME.indexOf('Point') >= 0 ){
				eligible = true;
			};
		};
		
		return eligible;
	},

	/**
	 * Method: _computeFullBoundingBox
	 * Compute the bounding box of the original geometry. This may differ from
	 * the bounding box of the geometry on the feature since this can be a
	 * simplification.
	 *
	 * Returns:
	 * {<OpenLayers.Bounds>} The bounding box of the original geometry translated for
	 * the current map projection.
	 */
	_computeFullBoundingBox: function(f) {
		return $n2.mapAndControls.ComputeFeatureOriginalBboxForMapProjection(f, this.projection);
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++
var Sorting = $n2.Class({

    initialize: function(opts_){
		var opts = $n2.extend({
		},opts_);
		
	},
	
	performSorting: function(features){
		$n2.olUtils.sortFeatures(features);
		
		return features;
    }
});

//+++++++++++++++++++++++++++++++++++++++++++++++
OpenLayers.Strategy.NunaliitFeatureStrategy = OpenLayers.Class(OpenLayers.Strategy, {

    /**
     * Property: filtering
     * {Object} Component that performs white list filtering
     */
    filtering: null,
    
    /**
     * Property: editFiltering
     * {Object} Component that removes a feature because it is in the process
     * of being edited.
     */
    editFiltering: null,
    
    /**
     * Property: minimumSize
     * {Object} Component that converts lines and polygons to points if too small
     */
    minimumSize: null,
    
    /**
     * Property: clustering
     * {Object} Component that performs clustering
     */
    clustering: null,

    /**
     * Property: sorting
     * {Object} Component that performs sorting
     */
    sorting: null,
    
    /**
     * Property: addingToLayer
     * {Boolean} Set if we are currently adding features to layer
     */
    addingToLayer: null,

    /**
     * Constructor: OpenLayers.Strategy.NunaliitFeatureStrategy
     * Create a new strategy that deals with features.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function (options) {
        
    	OpenLayers.Strategy.prototype.initialize.apply(this, arguments);

    	this.addingToLayer = false;
    	
    	this.filtering = null;
    	this.editFiltering = null;
    	this.clustering = null;
    	this.sorting = new Sorting();
    },
    
    setMinimumSize: function(opts_){
    	this.minimumSize = new MinimumSizeStrategy(opts_);
    },
    
    setClustering: function(opts_){
    	this.clustering = new Clustering(opts_);
    },
    
    setWhiteListDocumentIds: function(docIds){
    	if( docIds ){
    		this.filtering = new Filtering({
    			whiteList: true
    		});
        	this.filtering.setDocIds(docIds);
    	} else {
        	this.filtering = null;
    	};
    	this.filtering.setDocIds(docIds);

    	var features = this._computeFeatureSet();
    	this._accountForFeatures(features);
    },

    setEditedFeatureIds: function(featureIds){
    	if( featureIds ){
    		this.editFiltering = new Filtering();
        	this.editFiltering.setDocIds(featureIds);
    	} else {
        	this.editFiltering = null;
    	};

    	var features = this._computeFeatureSet();
    	this._accountForFeatures(features);
    },
    
    /**
     * APIMethod: activate
     * Activate the strategy.  Register any listeners, do appropriate setup.
     * 
     * Returns:
     * {Boolean} The strategy was successfully activated.
     */
    activate: function() {
        var activated = OpenLayers.Strategy.prototype.activate.call(this);
        if(activated) {
            this.layer.events.on({
                "beforefeaturesadded": this._beforeFeaturesAdded,
                "moveend": this._moveEnd,
                scope: this
            });
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the strategy.  Unregister any listeners, do appropriate
     *     tear-down.
     * 
     * Returns:
     * {Boolean} The strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = OpenLayers.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.layer.events.un({
                "beforefeaturesadded": this._beforeFeaturesAdded,
                "moveend": this._moveEnd,
                scope: this
            });
        }
        return deactivated;
    },
    
    /**
     * Method: beforeFeaturesAdded
     * Perform operations on the features before they are added to the
     * layer. 
     *
     * Parameters:
     * event - {Object} The event that this was listening for.  This will come
     *     with a batch of features to be clustered.
     *     
     * Returns:
     * {Boolean} False to stop features from being added to the layer.
     */
    _beforeFeaturesAdded: function(event) {
    	// This process is currently adding features. Accept propagation
    	if( this.addingToLayer ) {
    		return true;
    	};

    	var features = this._computeFeatureSet(event.features);
    	this._accountForFeatures(features);
    	
    	return false;
    },
    
    /**
     * Method: cluster
     * Cluster features based on some threshold distance.
     *
     * Parameters:
     * event - {Object} The event received when cluster is called as a
     *     result of a moveend event.
     */
    _moveEnd: function(event) {
    	// Re-cluster when zoom has changed
    	if( event && event.zoomChanged ){
        	var features = this._computeFeatureSet();
        	this._accountForFeatures(features);
    	};
    },
    
    _accountForFeatures: function(features){
    	var filteredOutFeatures = [];
    	
		// Assume all features are visible
    	features.forEach(function(feature){
        	if( feature.style ){
        		delete feature.style;
        	};
        	feature.n2FilteredOut = false;
		});

    	if( this.editFiltering ){
    		features = this.editFiltering.performFiltering(features, filteredOutFeatures);
    	};

    	if( this.filtering ){
    		features = this.filtering.performFiltering(features, filteredOutFeatures);
    	};

    	if( this.minimumSize ){
            var resolution = this.layer.map.getResolution();
    		features = this.minimumSize.processFeatures(features, resolution);
    	};

    	if( this.clustering ){
            var resolution = this.layer.map.getResolution();
            this.clustering.setResolution(resolution);

            var projection = this.layer.map.getProjectionObject();
            this.clustering.setProjection(projection);

            features = this.clustering.performClustering(features);
    	};

    	if( this.sorting ){
    		features = this.sorting.performSorting(features);
    	};
		
		// Indicate which features are not visible
		if( filteredOutFeatures ){
			filteredOutFeatures.forEach(function(feature){
				feature.style = {
                	display: 'none'
                };
	        	feature.n2FilteredOut = true;

	        	// Re-insert filtered out features at the
	        	// end of the displayed features
        		features[features.length] = feature;
			});
		};
    	
    	//$n2.log('accoutForFeatures',features.length);
    	
   		this._installFeaturesOnLayer(features);
    },
    
    _computeFeatureSet: function(newFeatures){
    	// Compute the feature set
    	var features = [];
    	for(var i=0,e=this.layer.features.length; i<e; ++i){
    		var feature = this.layer.features[i];
    		if( feature.cluster ){
    			for(var j=0,k=feature.cluster.length; j<k; ++j){
    				features[features.length] = feature.cluster[j];
    			};
    		} else {
    			features[features.length] = feature;
    		};
    	};
    	if( newFeatures ){
    		for(var i=0,e=newFeatures.length; i<e; ++i) {
        		var feature = newFeatures[i];
        		if( feature.cluster ){
        			for(var j=0,k=feature.cluster.length; j<k; ++j){
        				features[features.length] = feature.cluster[j];
        			};
        		} else {
        			features[features.length] = feature;
        		};
    		};
    	};
    	
    	return features;
    },
    
    _installFeaturesOnLayer: function(features){
    	if( !this.addingToLayer ){
        	this.addingToLayer = true;

        	this.layer.removeAllFeatures({silent:true});
    		this.layer.addFeatures(features);
        	
    		this.addingToLayer = false;
    	};
    },

    CLASS_NAME: "OpenLayers.Strategy.NunaliitFeatureStrategy" 
});
	
	
}; // If OpenLayers is defined
	
})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olModelProtocol.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($n2){
"use strict";

// If OpenLayers is not included, do not process further
if( typeof OpenLayers === 'undefined' ) return;

/**
 * Class: OpenLayers.Format.Couch
 * A parser to read/write CouchDb documents.  Create a new instance with the
 *     <OpenLayers.Format.Couch> constructor.
 *
 * Inherits from:
 *  - <OpenLayers.Format>
 */
OpenLayers.Format.Model = OpenLayers.Class(OpenLayers.Format, {
	
	/**
	 * Projection that the database uses for the given geometry
	 */
	dbProj: null,
    
    /**
     * Constructor: OpenLayers.Format.Couch
     * Create a new parser for JSON.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        OpenLayers.Format.prototype.initialize.apply(this, [options]);
        
        this.dbProj = new OpenLayers.Projection('EPSG:4326');
    },

    /**
     * APIMethod: read
     * Accepts a CouchDb response and returns an array of features.
     *
     * Parameters:
     * response - {Array} CouchDb documents
     *     
     * Returns:
     * {Object} An object, array, string, or number .
     */
    read: function(docs) {

        try {
        	var results = [];
			for(var i=0,e=docs.length; i<e; ++i) {
				var doc = docs[i];
				
				var id = null;
				var geom = null;
				
				if( doc._id ) {
					id = doc._id;
				};
				
				if( doc.nunaliit_geom 
				 && doc.nunaliit_geom.wkt ) {
					geom = OpenLayers.Geometry.fromWKT(doc.nunaliit_geom.wkt);
					
					if( geom ){
						if( !$n2.olUtils.isValidGeom(geom) ) {
							geom = null;
						};
					};

					if( !geom ){
						$n2.log('Invalid WKT('+doc._id+'): '+doc.nunaliit_geom.wkt);
					};
				};
				
				if( id && geom ) {
					var f = new OpenLayers.Feature.Vector(geom,doc);
					f.fid = id;
					f.n2GeomProj = this.dbProj;
					results.push(f);
//				} else {
//					$n2.log('Invalid feature',doc);
				};
			};
			
			return results;
        } catch(e) {
            $n2.log('Error during CouchDB format read',e);
        }
        return [];
    },

    /**
     * APIMethod: write
     * Serialize an object.
     *
     * Parameters:
     * features - {Array} Features to be serialized.
     *
     * Returns:
     * {Array} Documents to be sent to CouchDb.
     */
    write: function(features) {
    	var result = [];
    	
        for(var i=0,e=features.length; i<e; ++i) {
        	var f = features[i];
        	
        	var data = f.data;
        	if( null == data ) {
        		data = {};
        	};
        	
        	// Add FID
        	if( f.fid ) {
        		data._id = f.fid;
        	};
        	
        	// Update geometry
        	var geom = f.geometry;
        	var mapProjection = f.layer.map.getProjectionObject();
        	if( f.layer.projection 
        	 && mapProjection
        	 && f.layer.projection.getCode() != mapProjection.getCode() ) {
        	 	geom = geom.clone();
        	 	geom.transform(mapProjection, f.layer.projection);
        	};
        	if( !data.nunaliit_geom ) data.nunaliit_geom = { nunaliit_type: 'geometry' };
        	data.nunaliit_geom.wkt = geom.toString();
        	var bbox = geom.getBounds();
        	data.nunaliit_geom.bbox = [bbox.left,bbox.bottom,bbox.right,bbox.top];
        	
        	if( data.nunaliit_geom.simplified ){
        		delete data.nunaliit_geom.simplified;
        	};
        	
        	result.push( data );
        };
        
        return result;
    },

    CLASS_NAME: "OpenLayers.Format.Model" 

});     


/**
 * Class: OpenLayers.Protocol.Couch
 * A basic protocol for accessing vector layers from couchDb.  Create a new instance with the
 *     <OpenLayers.Protocol.Couch> constructor.
 *
 * Inherits from:
 *  - <OpenLayers.Protocol>
 */
OpenLayers.Protocol.Model = OpenLayers.Class(OpenLayers.Protocol, {

    /**
     * Property: dispatchService
     * {Object} Instance of dispatcher use for this configuration
     */
    dispatchService: null,

    /**
     * Property: sourceModelId
     * {String} Identifier for the model which is source for documents.
     */
    sourceModelId: null,
    
    /**
     * Property: modelObserver
     * {Object} Object that keeps track of state of source model.
     */
    modelObserver: null,
    
    /**
     * Property: callback
     * {Function} Function to be called when source model has updated.
     */
    onUpdateCallback: null,

    /**
     * Property: callback
     * {Object} Function to be called when the <read>, <create>,
     *     <update>, <delete> or <commit> operation completes, read-only,
     *     set through the options passed to the constructor.
     */
    callback: null,

    /**
     * Property: scope
     * {Object} Callback execution scope, read-only, set through the
     *     options passed to the constructor.
     */
    scope: null,

    /**
     * Property: notifications
     * {Object} Set of functions to call to report on busy status
     */
    notifications: null,

    /**
     * Property: wildcarded.
     * {Boolean} If true percent signs are added around values
     *     read from LIKE filters, for example if the protocol
     *     read method is passed a LIKE filter whose property
     *     is "foo" and whose value is "bar" the string
     *     "foo__ilike=%bar%" will be sent in the query string;
     *     defaults to false.
     */
    wildcarded: false,
    
    readWasCalled: false,
    
    loading: false,

    /**
     * Constructor: OpenLayers.Protocol.Couch
     * A class for giving layers generic HTTP protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options include:
     * view - {String} Name of couchDb view, including design url.
     * format - {<OpenLayers.Format>}
     * callback - {Function}
     * scope - {Object}
     */
    initialize: function(options) {
    	var _this = this;
    	
        options = options || {};
        
        // Install default format
        if( !options.format ) {
        	options.format = new OpenLayers.Format.Model();
        };
        
       	options.projection = new OpenLayers.Projection('EPSG:4326');
        
        OpenLayers.Protocol.prototype.initialize.apply(this, arguments);
        
        this.modelObserver = new $n2.model.DocumentModelObserver({
			dispatchService: this.dispatchService
			,sourceModelId: this.sourceModelId
			,updatedCallback: function(state){
				if( _this.readWasCalled ){
					_this._modelSourceUpdated(state);
				};
			}
        });
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        OpenLayers.Protocol.prototype.destroy.apply(this);
    },
    
    _modelSourceUpdated: function(state){
    	var _this = this;
  
    	if( typeof this.onUpdateCallback === 'function' ){
    		var mapState = {
    			added: []
				,updated: []
				,removed: []
    		};
    		
    		if( typeof state.loading === 'boolean' ){
    			mapState.loading = state.loading;
   				this._reportLoading(state.loading);
    		};
    		
    		if( state.added ){
    			mapState.added = this.format.read(state.added);
    		};
    		if( state.updated ){
    			mapState.updated = this.format.read(state.updated);
    		};
    		if( state.removed ){
    			mapState.removed = this.format.read(state.removed);
    		};
    		
    		this.onUpdateCallback(mapState);
    	};
    },
   
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Valid options:
     * view - {String} Name of couchDb view, including design url.
     * filter - {<OpenLayers.Filter>} Filter to get serialized as a
     *     query string.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} A response object, whose "priv" property
     *     references the HTTP request, this object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the the features received from the server.
     */
    read: function(options) {

    	var _this = this;
    	
    	this.readWasCalled = true;

    	// Obtain layer
    	var layer = options.object;
    	
        OpenLayers.Protocol.prototype.read.apply(this, arguments);
        options = OpenLayers.Util.applyDefaults(options, this.options);
        var resp = new OpenLayers.Protocol.Response({requestType: 'read'});

		var projectionCode = null;
		var mapProjection = null;
		if( layer && layer.map ){
			mapProjection = layer.map.getProjectionObject();
			projectionCode = mapProjection.getCode();
		};

		var isLoading = this.modelObserver.isLoading();
		if( typeof isLoading === 'boolean' ){
			this._reportLoading(isLoading);
		};

		var docs = this.modelObserver.getDocuments();
		
		var fidMap = this._getFidMapFromFilter(options.filter);
		if( fidMap ){
			docs = docs.filter(function(doc){
				var docId = doc._id;
				if( fidMap[docId] ) {
					return true;
				};
				return false;
			});
		};
		
        if(options.callback) {
            resp.features = this.format.read(docs);

            // Sorting now saves on rendering a re-sorting later
	    	$n2.olUtils.sortFeatures(resp.features);

            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
        };

        return resp;
    },

    /**
     * APIMethod: create
     * Construct a request for writing newly created features.
     *
     * Parameters:
     * features - {Array({<OpenLayers.Feature.Vector>})} or
     *     {<OpenLayers.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the features received from the server.
     */
    create: function(features, options) {
        options = OpenLayers.Util.applyDefaults(options, this.options);
        
        var documents = this.format.write(features);
        
        // Apply layer name, if needed
        if( options.layerName ) {
        	for(var i=0,e=documents.length; i<e; ++i) {
        		var doc = documents[i];
        		if( !doc.nunaliit_layers ) {
        			doc.nunaliit_layers = [];
        		};
        		if( jQuery.inArray(options.layerName, doc.nunaliit_layers) < 0 ) {
        			doc.nunaliit_layers.push(options.layerName);
        		};
        	};
        };

        var resp = new OpenLayers.Protocol.Response({
            reqFeatures: features,
            requestType: "create"
        });
        
		var _this = this;
        this.db.bulkDocuments(documents,{
        	onSuccess: function(docIds){
				_this.handleCreate(resp, options, docIds);        		
        	}
			,onError: function(errorMsg){ $n2.reportError(errorMsg); }
        });

        return resp;
    },

    /**
     * Method: handleCreate
     * Called when the request issued by <create> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create call.
     */
    handleCreate: function(resp, options, docIds) {
    	
    	// Update features with FIDs and _rev
        var features = resp.reqFeatures;
        var insertedFeatures = [];
        if( features.length != docIds.length ) {
        	// There is an error
        	$n2.reportError($n2.ERROR_NO_SUPRESS, 'Invalid feature bulk create');
        } else {
        	for(var i=0,e=docIds.length; i<e; ++i) {
        		var f = features[i];
        		var d = docIds[i];
        		
        		if( d.error ) {
        			if( d.reason ) {
        				$n2.reportError($n2.ERROR_NO_SUPRESS, d.error+' : '+d.reason);
        			} else {
        				$n2.reportError($n2.ERROR_NO_SUPRESS, d.error);
        			};
        		} else {
	        		f.fid = d.id;
	        		if( f.data ) {
		        		f.data._id = d.id;
		        		f.data._rev = d.rev;
	        		};
	        		if( f.attribute ) {
		        		f.attribute._id = d.id;
		        		f.attribute._rev = d.rev;
	        		};
	        		insertedFeatures.push(f);
        		};
        	};
        };
        
        // Perform call back, if needed
        if(options.callback && insertedFeatures.length > 0) {
        	resp.features = insertedFeatures;
        	
            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * APIMethod: update
     * Construct a request updating modified feature.
     *
     * Parameters:
     * feature - {<OpenLayers.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the feature received from the server.
     */
    update: function(feature, options) {
        options = options || {};
        options = OpenLayers.Util.applyDefaults(options, this.options);

		var documents = this.format.write([feature]);

        var resp = new OpenLayers.Protocol.Response({
            reqFeatures: feature,
            requestType: "update"
        });
        
		var _this = this;
        this.db.updateDocument({
        	data: documents[0]
        	,onSuccess: function(docInfo){
				_this.handleUpdate(resp, options, docInfo);        		
        	}
			,onError: function(errorMsg){ $n2.reportError(errorMsg); }
        });

        return resp;
    },

    /**
     * Method: handleUpdate
     * Called the the request issued by <update> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the update call.
     */
    handleUpdate: function(resp, options, docInfo) {
    	
    	// Update feature with _rev
        var feature = resp.reqFeatures;
        if( feature.data ) {
        	feature.data._rev = docInfo.rev;
        };
        if( feature.attribute ) {
        	feature.attribute._rev = docInfo.rev;
        };
        
        // Perform call back, if needed
        if(options.callback) {
        	resp.features = [feature];
        	
            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * APIMethod: delete
     * Construct a request deleting a removed feature.
     *
     * Parameters:
     * feature - {<OpenLayers.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes.
     */
    "delete": function(feature, options) {
        options = options || {};
        options = OpenLayers.Util.applyDefaults(options, this.options);

        var resp = new OpenLayers.Protocol.Response({
            reqFeatures: feature,
            requestType: "delete"
        });
        
		var _this = this;
        this.db.deleteDocument({
        	data: feature.data
        	,onSuccess: function(docInfo){
				_this.handleDelete(resp, options, docInfo);        		
        	}
			,onError: function(errorMsg){ $n2.reportError(errorMsg); }
        });

        return resp;
    },

    /**
     * Method: handleDelete
     * Called the the request issued by <delete> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the delete call.
     */
    handleDelete: function(resp, options) {

        // Perform call back, if needed
        if(options.callback) {
            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * APIMethod: commit
     * Iterate over each feature and take action based on the feature state.
     *     Possible actions are create, update and delete.
     *
     * Parameters:
     * features - {Array({<OpenLayers.Feature.Vector>})}
     * options - {Object} Optional object for setting up intermediate commit
     *     callbacks.
     *
     * Valid options:
     * create - {Object} Optional object to be passed to the <create> method.
     * update - {Object} Optional object to be passed to the <update> method.
     * delete - {Object} Optional object to be passed to the <delete> method.
     * callback - {Function} Optional function to be called when the commit
     *     is complete.
     * scope - {Object} Optional object to be set as the scope of the callback.
     *
     * Returns:
     * {Array(<OpenLayers.Protocol.Response>)} An array of response objects,
     *     one per request made to the server, each object's "priv" property
     *     references the corresponding HTTP request.
     */
    commit: function(features, options) {
        options = OpenLayers.Util.applyDefaults(options, this.options);
        var resp = [], nResponses = 0;
        
        // Divide up features before issuing any requests.  This properly
        // counts requests in the event that any responses come in before
        // all requests have been issued.
        var types = {};
        types[OpenLayers.State.INSERT] = [];
        types[OpenLayers.State.UPDATE] = [];
        types[OpenLayers.State.DELETE] = [];
        var feature, list, requestFeatures = [];
        for(var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            list = types[feature.state];
            if(list) {
                list.push(feature);
                requestFeatures.push(feature); 
            }
        }
        // tally up number of requests
        var nRequests = (types[OpenLayers.State.INSERT].length > 0 ? 1 : 0) +
            types[OpenLayers.State.UPDATE].length +
            types[OpenLayers.State.DELETE].length;
        
        // This response will be sent to the final callback after all the others
        // have been fired.
        var success = true;
        var finalResponse = new OpenLayers.Protocol.Response({
            reqFeatures: requestFeatures        
        });
        
        function insertCallback(response) {
            var len = response.features ? response.features.length : 0;
            var fids = new Array(len);
            for(var i=0; i<len; ++i) {
                fids[i] = response.features[i].fid;
            }   
            finalResponse.insertIds = fids;
            callback.apply(this, [response]);
        }
 
        function callback(response) {
            this.callUserCallback(response, options);
            success = success && response.success();
            nResponses++;
            if (nResponses >= nRequests) {
                if (options.callback) {
                    finalResponse.code = success ? 
                        OpenLayers.Protocol.Response.SUCCESS :
                        OpenLayers.Protocol.Response.FAILURE;
                    options.callback.apply(options.scope, [finalResponse]);
                }    
            }
        }

        // start issuing requests
        var queue = types[OpenLayers.State.INSERT];
        if(queue.length > 0) {
            resp.push(this.create(
                queue, OpenLayers.Util.applyDefaults(
                    {callback: insertCallback, scope: this}, options.create
                )
            ));
        }
        queue = types[OpenLayers.State.UPDATE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this.update(
                queue[i], OpenLayers.Util.applyDefaults(
                    {callback: callback, scope: this}, options.update
                ))
            );
        }
        queue = types[OpenLayers.State.DELETE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this["delete"](
                queue[i], OpenLayers.Util.applyDefaults(
                    {callback: callback, scope: this}, options["delete"]
                ))
            );
        }
        return resp;
    },

    /**
     * APIMethod: abort
     * Abort an ongoing request, the response object passed to
     * this method must come from this HTTP protocol (as a result
     * of a create, read, update, delete or commit operation).
     *
     * Parameters:
     * response - {<OpenLayers.Protocol.Response>}
     */
    abort: function(response) {
        if (response) {
            //response.priv.abort();
            // not supported in CouchDb?
        }
    },

    /**
     * Method: callUserCallback
     * This method is used from within the commit method each time an
     *     an HTTP response is received from the server, it is responsible
     *     for calling the user-supplied callbacks.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>}
     * options - {Object} The map of options passed to the commit call.
     */
    callUserCallback: function(resp, options) {
        var opt = options[resp.requestType];
        if(opt && opt.callback) {
            opt.callback.call(opt.scope, resp);
        }
    },
    
    /**
     * Method: getBboxFromFilter
     * This method is used to find the bounding box filter within the given
     * filter and return the information in a format useable by the tiling system.
     *
     * Parameters:
     * filter - {<OpenLayers.Filter>}
     */
    getBboxFromFilter: function(filter) {

    	if( !filter ) return null;

    	if( filter.type === OpenLayers.Filter.Spatial.BBOX ) {
    		// This is a BBOX
    		return [filter.value.left,filter.value.bottom,filter.value.right,filter.value.top]
    	}

    	if( filter.filters ) {
    		// Logical, continue search
    		for(var i=0,e=filter.filters.length; i<e; ++i) {
    			var bounds = this.getBboxFromFilter(filter.filters[i]);
    			if( bounds ) return bounds;
    		}
    	}

    	return null;
    },

    /**
     * Method: _getFidMapFromFilter
     * This method is used to find the FID filter within the given
     * filter and return the information in a format useable by the view system.
     *
     * Parameters:
     * filter - {<OpenLayers.Filter>}
     */
    _getFidMapFromFilter: function(filter) {

    	if( !filter ) return null;

    	if( filter.CLASS_NAME === 'OpenLayers.Filter.FeatureId' ) {
    		// This is a FIDs
			var map = null;
    		if( filter.fids ){
    			filter.fids.forEach(function(fid){
    				if( null == map ){
    					map = {};
    				};
    				map[fid] = true;
    			});
    		};
    		return map;
    	}

    	if( filter.filters ) {
    		// Logical, continue search
			var map = null;
    		for(var i=0,e=filter.filters.length; i<e; ++i) {
    			var fidMap = this._getFidMapFromFilter(filter.filters[i]);
    			if( fidMap ) {
    				for(var fid in fidMap){
    					if( null === map ){
    						map = {};
    					};
    					map[fid] = true;
    				};
    			};
    		};
    		return map;
    	}

    	return null;
    },
    
    _reportLoading: function(flag){
    	if( this.loading && !flag ){
    		this.loading = false;
        	if( this.notifications 
	    	 && typeof this.notifications.readEnd === 'function'){
	    		this.notifications.readEnd();
	    	};
    	} else if( !this.loading && flag ){
    		this.loading = true;
        	if( this.notifications 
	    	 && typeof this.notifications.readStart === 'function'){
	    		this.notifications.readStart();
	    	};
    	};
    },
    
    CLASS_NAME: "OpenLayers.Protocol.Model" 
});



})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.olMap.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

if( typeof(OpenLayers) !== 'undefined' && OpenLayers.Map ) {

OpenLayers.N2Map = OpenLayers.Class(OpenLayers.Map, {
	
	initialize: function(div, options) {
		OpenLayers.Map.prototype.initialize.apply(this, arguments);
	},
	
    /** 
     * APIMethod: setBaseLayer
     * Allows user to specify one of the currently-loaded layers as the Map's
     *     new base layer.
     * 
     * Parameters:
     * newBaseLayer - {<OpenLayers.Layer>}
     */
    setBaseLayer: function(newBaseLayer) {
        
        if (newBaseLayer != this.baseLayer) {
            var oldProjection = null;
            var oldExtent = null;
            if (this.baseLayer) {
            	oldExtent = this.baseLayer.getExtent();
                oldProjection = this.getProjectionObject();
            };
          
            // ensure newBaseLayer is already loaded
            if (OpenLayers.Util.indexOf(this.layers, newBaseLayer) != -1) {

                // preserve center and scale when changing base layers
                var center = this.getCachedCenter();
                var newResolution = OpenLayers.Util.getResolutionFromScale(
                    this.getScale(), newBaseLayer.units
                );

                // make the old base layer invisible 
                if (this.baseLayer != null && !this.allOverlays) {
                    this.baseLayer.setVisibility(false);
                };

                // set new baselayer
                this.baseLayer = newBaseLayer;
                
                if(!this.allOverlays || this.baseLayer.visibility) {
                    this.baseLayer.setVisibility(true);
                    // Layer may previously have been visible but not in range.
                    // In this case we need to redraw it to make it visible.
                    if (this.baseLayer.inRange === false) {
                        this.baseLayer.redraw();
                    };
                };
                
                // Handle change in projection
                var newCenter = center;
            	var newZoom = null;
                var newProjection = this.getProjectionObject();
                if( oldProjection 
                 && !oldProjection.equals(newProjection)) {
                	if( newCenter ){
                        newCenter.transform(oldProjection, newProjection);
                	};

                	if( oldExtent ){
                    	var newExtent = this._reprojectExtent(oldExtent, oldProjection, newProjection);
                    	newZoom = this.getZoomForExtent(newExtent, true);
                	};
                };

                // recenter the map
                if (newCenter != null) {
                    // new zoom level derived from old scale
                	if( !newZoom ){
                        newZoom = this.getZoomForResolution(
                            newResolution || this.resolution, true
                        );
                	};

                	// zoom and force zoom change
                    this.setCenter(newCenter, newZoom, false, true);
                };

                this.events.triggerEvent("changebaselayer", {
                    layer: this.baseLayer
                    ,oldProjection: oldProjection
                });
            };        
        };
    },

    // The concept here is to find a rectangle of the same dimension as in the previous
    // projection, however oriented in the new projection. This does not ensure that all
    // geometries visible in the previous projection will remain in the new one. However,
    // it keeps the same center of view and similar scale.
    _reprojectExtent: function(oldExtent, sourceProj, targetProj){
    	var center = {
    		x: (oldExtent.right + oldExtent.left)/2
    		,y: (oldExtent.top + oldExtent.bottom)/2
    	};
    	var topRight = {'x': oldExtent.right, 'y': oldExtent.top};
    	var bottomLeft = {'x': oldExtent.left, 'y': oldExtent.bottom};
    	var topRightAngle = this._getAngle(center, topRight);
    	
    	var newCenter = OpenLayers.Projection.transform(center, sourceProj, targetProj);
    	var newTopRight = OpenLayers.Projection.transform(topRight, sourceProj, targetProj);
    	var newBottomLeft = OpenLayers.Projection.transform(bottomLeft, sourceProj, targetProj);
    	
    	var newTopRightAngle = this._getAngle(newCenter, newTopRight);
    	var rotateAngle = topRightAngle - newTopRightAngle;
    	
    	var rotatedTopRight = this._rotatePoint(newCenter, newTopRight, rotateAngle);
    	var rotatedBottomLeft = this._rotatePoint(newCenter, newBottomLeft, rotateAngle);
    	
    	var newExtent = new OpenLayers.Bounds(
    		rotatedBottomLeft.x // left
    		,rotatedBottomLeft.y // bottom
    		,rotatedTopRight.x // right
    		,rotatedTopRight.y // top
    	);
    	
    	return newExtent;
    },
    
    _getAngle: function(center, point){
    	var angle = null;
    	if( point.x === center.x ){
    		if( point.y > center.y ){
    			angle = Math.PI / 2;
    		} else {
    			angle = 0 - (Math.PI / 2);
    		};
    	} else if( point.x < center.x ){
    		angle = Math.PI + Math.atan((point.y - center.y) / (point.x - center.x));

    	} else {
    		angle = Math.atan((point.y - center.y) / (point.x - center.x));
    	};
    	
    	return angle;
    },
    
    _rotatePoint: function(center, point, angle){
    	var relX = point.x - center.x;
    	var relY = point.y - center.y;
    	
    	var newX = (relX * Math.cos(angle)) - (relY * Math.sin(angle));
    	var newY = (relX * Math.sin(angle)) + (relY * Math.cos(angle));
    	
    	var newPoint = {
    		x: newX + center.x
    		,y: newY + center.y
    	};
    	
    	return newPoint;
    }
});
	
}; // If OpenLayers is defined
	
})(nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.ol5LayerSwitcher.js

/* Copyright (c) 2018-2024 by ol-layerswitcher Contributors (see authors.txt for 
 * full list of contributors). Published under the MIT license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

;(function($,$n2){
"use strict";
if( typeof(ol) !== 'undefined' ) {
//default export
ol.control.N2LayerSwitcher = $n2.Construct('N2LayerSwitcher', ol.control.Control,{
	constructor: function(opt_options){
		 var options = opt_options || {};

	        var tipLabel = options.tipLabel ?
	          options.tipLabel : 'Legend';

	        this.mapListeners = [];

	        this.hiddenClassName = 'ol-unselectable ol-control layer-switcher';
	        if (ol.control.N2LayerSwitcher.isTouchDevice_()) {
	            this.hiddenClassName += ' touch';
	        }
	        this.shownClassName = 'shown';

	        var element = document.createElement('div');
	        element.className = this.hiddenClassName;

	        var button = document.createElement('button');
	        button.setAttribute('title', tipLabel);
	        element.appendChild(button);

	        this.panel = document.createElement('div');
	        this.panel.className = 'panel';
	        element.appendChild(this.panel);
	        ol.control.N2LayerSwitcher.enableTouchScroll_(this.panel);

	        var this_ = this;

	        button.onmouseover = function(e) {
	            this_.showPanel();
	        };

	        button.onclick = function(e) {
	            e = e || window.event;
	            this_.showPanel();
	            e.preventDefault();
	        };

	        this_.panel.onmouseout = function(e) {
	            e = e || window.event;
	            if (!this_.panel.contains(e.toElement || e.relatedTarget)) {
	                this_.hidePanel();
	            }
	        };

	        ol.control.Control.call(this, {
	            element: element,
	            target: options.target
	        })
	}
	, showPanel: function(){
		 if (!this.element.classList.contains(this.shownClassName)) {
	            this.element.classList.add(this.shownClassName);
	            this.renderPanel();
		 }
		
	}
	,hidePanel : function() {
        if (this.element.classList.contains(this.shownClassName)) {
            this.element.classList.remove(this.shownClassName);
        }
	}
	,renderPanel : function() {

        this.ensureTopVisibleBaseLayerShown_();

        while(this.panel.firstChild) {
            this.panel.removeChild(this.panel.firstChild);
        }

        var ul = document.createElement('ul');
        this.panel.appendChild(ul);
        this.renderLayers_(this.getMap(), ul);

		}	
	,setMap : function(map) {
        // Clean up listeners associated with the previous map
        for (var i = 0, key; i < this.mapListeners.length; i++) {
            ol.Observable.unByKey(this.mapListeners[i]);
        }
        this.mapListeners.length = 0;
        // Wire up listeners etc. and store reference to new map
        ol.control.Control.prototype.setMap.call(this, map);
        if (map) {
            var this_ = this;
            this.mapListeners.push(map.on('pointerdown', function() {
                this_.hidePanel();
            }));
            this.renderPanel();
        }
	}
	,ensureTopVisibleBaseLayerShown_ : function() {
        var lastVisibleBaseLyr;
        ol.control.N2LayerSwitcher.forEachRecursive(this.getMap(), function(l, idx, a) {
            if (l.get('type') === 'base' && l.getVisible()) {
                lastVisibleBaseLyr = l;
            }
        });
        if (lastVisibleBaseLyr) this.setVisible_(lastVisibleBaseLyr, true);
	}
	,setVisible_ : function(lyr, visible) {
        var map = this.getMap();
        lyr.setVisible(visible);
        if (visible && lyr.get('type') === 'base') {
            // Hide all other base layers regardless of grouping
            ol.control.N2LayerSwitcher.forEachRecursive(map, function(l, idx, a) {
                if (l != lyr && l.get('type') === 'base') {
                    l.setVisible(false);
                }
            });
        }
	}
	,renderLayer_ : function(lyr, idx) {

        var this_ = this;

        var li = document.createElement('li');

        var lyrTitle = lyr.get('title');
        var lyrId = ol.control.N2LayerSwitcher.uuid();

        var label = document.createElement('label');

        if (lyr.getLayers && !lyr.get('combine')) {

            li.className = 'group';
            label.innerHTML = lyrTitle;
            li.appendChild(label);
            var ul = document.createElement('ul');
            li.appendChild(ul);

            this.renderLayers_(lyr, ul);

        } else {

            li.className = 'layer';
            var input = document.createElement('input');
            if (lyr.get('type') === 'base') {
                input.type = 'radio';
                input.name = 'base';
            } else {
                input.type = 'checkbox';
            }
            input.id = lyrId;
            input.checked = lyr.get('visible');
            input.onchange = function(e) {
                this_.setVisible_(lyr, e.target.checked);
            };
            li.appendChild(input);

            label.htmlFor = lyrId;
            label.innerHTML = lyrTitle;

            var rsl = this.getMap().getView().getResolution();
            if (rsl > lyr.getMaxResolution() || rsl < lyr.getMinResolution()){
                label.className += ' disabled';
            }

            li.appendChild(label);

        }

        return li;

	}
	,renderLayers_ : function(lyr, elm) {
        var lyrs = lyr.getLayers().getArray().slice().reverse();
        for (var i = 0, l; i < lyrs.length; i++) {
            l = lyrs[i];
            if (l.get('title')) {
                elm.appendChild(this.renderLayer_(l, i));
            }
        }
	}

})
	
ol.control.N2LayerSwitcher.forEachRecursive = function(lyr, fn) {
    lyr.getLayers().forEach(function(lyr, idx, a) {
        fn(lyr, idx, a);
        if (lyr.getLayers) {
            ol.control.N2LayerSwitcher.forEachRecursive(lyr, fn);
        }
    });
};

ol.control.N2LayerSwitcher.uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });
};

ol.control.N2LayerSwitcher.enableTouchScroll_ = function(elm) {
    if(ol.control.N2LayerSwitcher.isTouchDevice_()){
        var scrollStartPos = 0;
        elm.addEventListener("touchstart", function(event) {
            scrollStartPos = this.scrollTop + event.touches[0].pageY;
        }, false);
        elm.addEventListener("touchmove", function(event) {
            this.scrollTop = scrollStartPos - event.touches[0].pageY;
        }, false);
    }
};

ol.control.N2LayerSwitcher.isTouchDevice_ = function() {
    try {
        document.createEvent("TouchEvent");
        return true;
    } catch(e) {
        return false;
    }
};

}; // if(typeof(ol) !== 'undefined')

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.sliderWithCallout.js

/*
Copyright (c) 2010,2011 Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

/*
 * Classes to build sliders with callouts.  Developed from the older
 * olkit_sliderWithCallout implementation.
 * Changes from that earlier work:
 *   - no image callouts (simply text divs for callouts - more flexible and
 *     less fussy concerning the size of the callout text)
 *   - support both single-valued slider and range slider as separate classes.
 *   - labelling the slider is not handled to simplify the classes and generated
 *     HTML - deal with that externally
 *   - dropped explicit option for a callout that does not fade in/out as that
 *     would complicate the range slider.  If you want a fixed div displaying
 *     a slider value ... this is probably overkill.
 */

;(function($,$n2){
"use strict";
	
	$n2.SLIDER_CONSTANTS = {};
	/*
	 * value types supported
	 */
	$n2.SLIDER_CONSTANTS.NUMERIC = 'numeric';
	$n2.SLIDER_CONSTANTS.DATE = 'date';
	
	/*
	 * date step constants
	 */
	$n2.SLIDER_CONSTANTS.DURATION_DAY = 1000 * 60 * 60 * 24;
	$n2.SLIDER_CONSTANTS.DURATION_WEEK = $n2.SLIDER_CONSTANTS.DURATION_DAY * 7;
	$n2.SLIDER_CONSTANTS.DURATION_YEAR = $n2.SLIDER_CONSTANTS.DURATION_DAY * 365;
	
	/*
	 * slider definition constants
	 */
	var SLIDER_MIN = 0;
	var SLIDER_STEP = 1;

	var defaultOptions = {
		containerId: '' // string: id of containing DOM element
		,idBase: '' // string: base for ID strings used in HTML for the slider.
		
		/*
		 * the type of values used by the control domain the slider is associated
		 * with.  See private valueHandler classes.
		 */
		,valueType: $n2.SLIDER_CONSTANTS.NUMERIC
		
		/*
		 * Control domain value specification: these are translated to the integer slider
		 * range needed by jQuery sliders.
		 */
		,min: null /* lowest value returned from slider - scalar */
		,max: null /* highest value returned from slider - scalar */
		,step: null /* slider increments */
		,initial: null /* default/initial value for slider control value - scalar or array - see range */
		
		/*
		 * single-handled or range slider?  See jQuery documentation and note changes
		 * required in the definitions of initial values and update values handled by 
		 * the specified changeFn (range means two-element arrays are used rather than
		 * scalar values).
		 */
		,range: false // string/boolean - see jquery slider documentation
		
		/*
		 * Display options for values.
		 */
		,format: '%d' // default integer formatting
	};

	var numericValueHandler = $n2.Class({
		/*
		 * Expected options:
		 * min: numeric
		 * max: numeric
		 * step: numeric
		 * format: string
		 */
		options: null // defaults handled by container class.
		
		,initialize: function(opt) { /* all parms numeric, real, NOT necessarily integer */
			this.options = $.extend({}, opt);
		}
	
		,convertSliderValueToDomain: function(v) { //@param v integer slider value
			return(this.options.min + ((v - SLIDER_MIN) * this.options.step));
		}
		
		,convertDomainValueToSlider: function(v) { // @param v numeric domain value - not necessarily integer
			return(Math.floor((v - this.options.min) / this.options.step));
		}
		
		,toString: function(value) {
			var target = this.options.format.slice(0);
			return($.format(target, [ value ])); // pass array so 0 is not rejected - slightly stunned code in plugin
		}
		
		,domainMaxToSliderMax: function(v) { // @param v numeric domain max - not necessarily int
			return(this.convertDomainValueToSlider(v));
		}

		,equals: function(v1, v2) {
			return(v1 == v2);
		}
		
	});
	
	var dateValueHandler = $n2.Class({
		/*
		 * Expected options:
		 * min: date object
		 * max: date object
		 * step: milliseconds increments
		 * format: string
		 * 
		 * Note: uses jquery datepicker to format the date for output to callout.
		 */
		options: null // defaults handled by container class.
	
		,initialize: function(opt) { /* all parms numeric, real, NOT necessarily integer */
			this.options = $.extend({}, opt);
		}

		,convertSliderValueToDomain: function(v) { //@param v integer slider value
			var newDate = new Date(this.options.min);
			var diff = (v - SLIDER_MIN) * this.options.step;
			newDate.setMilliseconds(newDate.getMilliseconds() + diff);
			return newDate;
		}
	
		,convertDomainValueToSlider: function(v) { // @param v numeric domain value - not necessarily integer
			return(Math.floor((v - this.options.min) / this.options.step));
		}
	
		,toString: function(value) {
			var target = this.options.format.slice(0);
			return($.datepicker.formatDate(target, value));
		}
	
		,domainMaxToSliderMax: function(v) { // @param v numeric domain max - not necessarily int
			return(this.convertDomainValueToSlider(v));
		}
		
		,equals: function(v1, v2) {
			return(v1.valueOf() == v2.valueOf());
		}
		
	});
	
	var sliderBase = $n2.Class({
		/*
		 * sliderBase - responsibilities:
		 * - construct the HTML
		 * - create slider object
		 * - deal with callout positioning computations and callout text updating.
		 * 
		 * Note that a single callout is managed for both the single-handle and range slider cases
		 * because only one handle is moved at any given time anyway.  
		 */
		options: null

		,configuredValue: null
		
		,valueHandler: null
		
		,computedSliderProperties: null
	
		,initialize: function(/* ... variable argument list ... */) { // duplicates? - rightmost take precedence
			this.options = $.extend({}, defaultOptions);
			for (var i=0; i < arguments.length; i++) { // update o with properties from objects in variable arg list.
				var o = arguments[i];
				if ($n2.isDefined(o)) {
					this.options = $.extend(true, this.options, o);
				};
			};
			
			if ($n2.SLIDER_CONSTANTS.DATE == this.options.valueType) {
				this.valueHandler = new dateValueHandler({
					min: this.options.min
					,max: this.options.max
					,step: this.options.step
					,format: this.options.format
				});
			} else { // make numeric the default
				this.valueHandler = new numericValueHandler({
					min: this.options.min
					,max: this.options.max
					,step: this.options.step
					,format: this.options.format
				});
			};
			
			var prop = {}; /* jQuery slider parameters */
			prop.min = SLIDER_MIN; /* always use zero-based */
			prop.step = SLIDER_STEP; /* always step size one - translate in/out */
			prop.max = this.valueHandler.domainMaxToSliderMax(this.options.max);
			this.computedSliderProperties = prop;
		}
	
		,changeFn: function() {} // function to notify app of changed control value - changeFn(newValue)

		,latestValue: function() {
			return($n2.isDefined(this.configuredValue) ? this.configuredValue : this.options.initial);
		}
		
		/*
		 * callout management: positioning, fading/hiding, text updating and centering
		 */
		,_computeCallOutLeftValue: function(newVal) { // based on slider values - not domain values - then independent of domains data type
			var percentage =
				(newVal - this.computedSliderProperties.min) / 
				(this.computedSliderProperties.max - this.computedSliderProperties.min) * 100;
//			$n2.log('computeCallOutLeftValue - returning: '+percentage);
			return(percentage);
		}
		
		,_setText: function(t1, t2, value) {
			var t = this.valueHandler.toString(value);
			var l = Math.floor(t.length / 2);
			var a = new Array();
			var tt;
			if (l > 0) {
				tt = t.slice(0,l);
				
				// handle string segment terminated by space ... replace with &nbsp; so not ignored
				var lastCharIndex = tt.length-1;
				if (tt[lastCharIndex] == ' ') {
					tt = tt.slice(0, -1) + '&nbsp;';
				};
				
				a.push(tt);
			} else {
				a.push('');
			};

			if ((t.length - l) > 0) {
				tt = t.slice(l);
				
				// handle string segment beginning with space ... replace with &nbsp; so not ignored
				if (tt[0] == ' ') {
					tt = '&nbsp;' + tt.slice(1);
				}
				
				a.push(tt);
			} else {
				a.push('');
			};

			$(t1).text(a[0]);
			$(t2).text(a[1]);
		}

		,_callout_hideImmed: function(t1, t2) {
			$(t1).hide();
			$(t2).hide();
		}

		,_callout_fadeIn: function(t1, t2) {
			$(t1).fadeIn('fast', function(){});
			$(t2).fadeIn('fast', function(){});
		}

		,_callout_fadeOut: function(t1, t2, fn) {
			$(t1).fadeOut('slow', function() {});
			$(t2).fadeOut('slow', fn);
		}

		/**
		 * slider building routines
		 * @return slider jquery DOM object
		 * 
		 * Notes:
		 * - slider is a styled DIV - manage that with CSS
		 * - id + '_callout" is the call-out DIV used to position the value text during updates
		 * - the call-out DIV contains two text DIVs that contain the value text split into two
		 *   as a rough means of centering.
		 */
		,_createHtml: function() {
			var container = $('#' + this.options.containerId).empty();
			var slider = $('<div>')
				.addClass('slider_wrapper slider_wrapper_callout')
				.appendTo(container);
			var sliderCallout = $('<div>')
				.attr('id',this.options.idBase + '_callout')
				.addClass('slider_callout')
				.attr('style','width:0px;height:0px;padding:0px;margin:0px;border:none')
				.appendTo(slider);
			$('<div>')
				.attr('id',this.options.idBase)
				.addClass('slider_bar')
				.appendTo(slider);
			/*
			 * Some browsers (e.g., Safari) may break a text element at a dash/minus sign unless a large enough
			 * width is specified.  If needed, add a width element to the CSS tied to the slider IDs assigned below.
			 * The elements below properly left or right align things so specifying the width is hopefully all that
			 * is required.
			 */
			$('<div>')
				.attr('id',this.options.idBase + '_calloutTextLeft')
				.addClass('slider_callout_text_left')
				.attr('style','position:absolute;right:0px;bottom:0px;text-align:right;')
				.appendTo(sliderCallout);
			$('<div>')
				.attr('id',this.options.idBase + '_calloutTextRight')
				.addClass('slider_callout_text_right')
				.attr('style','position:absolute;left:0px;bottom:0px;text-align:left;')
				.appendTo(sliderCallout);
			return slider;
		}
		
		,create: function() {
			var _self = this;

			var slider = this._createHtml();
			var c = '#' + this.options.idBase + '_callout'; // callout ID
			var t1 = '#' + this.options.idBase + '_calloutTextLeft';
			var t2 = '#' + this.options.idBase + '_calloutTextRight';

			var calloutVisible = false;
			this._callout_hideImmed(t1, t2);

			var sliderOpts = {
					min: this.computedSliderProperties.min
					,max: this.computedSliderProperties.max
					,step: this.computedSliderProperties.step
					,start: function(e, ui) {
						var i = _self._positionCalloutForUpdate(c, ui);
						if (i >= 0) { /* one of handles changed */
							calloutVisible = true;
							_self._callout_fadeIn(t1, t2);
						};
					}
					,slide  : function(e, ui) {
						var i = _self._positionCalloutUpdateText(c, t1, t2, ui);
						if (false == calloutVisible && i >= 0) { /* callout not yet visibe and a handle changed */
							calloutVisible = true;
							_self._callout_fadeIn(t1, t2);							
						}
						_self._storeUpdateAndNotify(ui);
					}
					,change : function (e, ui) { // fired at end of slide or when changed programmatically
						var i = _self._positionCalloutUpdateText(c, t1, t2, ui);
						if (false == calloutVisible && i >= 0) { // if programmed change
							calloutVisible = true;
							_self._callout_fadeIn(t1, t2);
						};
						if (true == calloutVisible) {
							_self._callout_fadeOut(t1, t2, function() { calloutVisible = false; });							
						}
						_self._storeUpdateAndNotify(ui);	
					}
			};
			
			if (false == this.options.range) {
				/* note use of value - ensure appropriate derived class handling this....  single-handled ... */
				sliderOpts.value = this.valueHandler.convertDomainValueToSlider(this.latestValue());
			} else if ('min' == this.options.range || 'max' == this.options.range) {
				/* note use of value - ensure appropriate derived class handling this....  single-handled ... */
				sliderOpts.range = this.options.range;
				sliderOpts.value = this.valueHandler.convertDomainValueToSlider(this.latestValue());
			} else if (true == this.options.range) {
				/* note use of values (PLURAL) - ensure appropriate derived class handling this....  DOUBLE-HANDLED ... */
				sliderOpts.range = true;
				var l = this.latestValue();
				sliderOpts.values = [
					this.valueHandler.convertDomainValueToSlider(l[0]),
					this.valueHandler.convertDomainValueToSlider(l[1])
				];
			};
			
			$('#' + this.options.idBase).slider(sliderOpts);
		}

	});

	$n2.SingleHandleSliderWithCallout = $n2.Class(sliderBase, {

		setConfiguredValue: function(newValue) { // @param: domain value - not necessarily integer
			this.configuredValue = newValue; // stored as is - same range of values as this.options.initialValue
		}

		,getCurrentValue: function() {
			return(this.latestValue());
		}
		
		,programmedUpdate: function(newValue) {
			this.setConfiguredValue(newValue);
			$('#' + this.options.idBase).slider('value', this.valueHandler.convertDomainValueToSlider(this.latestValue()));
		}
		
		,_positionCalloutForUpdate: function(c, ui) {
			$(c).css('left', this._computeCallOutLeftValue(ui.value) + '%');	
			return 0; /* always index 0 with one handle */
		}
		
		,_positionCalloutUpdateText: function(c, t1, t2, ui) { // for range slider this needs to be smarter - which handle? - which value?
			this._positionCalloutForUpdate(c, ui);
			this._setText(t1, t2, this.valueHandler.convertSliderValueToDomain(ui.value));
			return 0; /* always index 0 with one handle */
		}
		
		,_storeUpdateAndNotify: function(ui) {
			var newValue = this.valueHandler.convertSliderValueToDomain(ui.value);
			if (newValue != this.configuredValue) {
				this.configuredValue = newValue;
				this.options.changeFn(newValue); // notify application in domain values
			};
			
		}
		
	});

	$n2.RangeSliderWithCallout = $n2.Class(sliderBase, {

		setConfiguredValue: function(newValues) { // @param: aray contain lower, upper domain values - not necessarily integer
			this.configuredValue = newValues; // stored as is - same range of values as this.options.initialValue
		}

		,getCurrentValue: function() {
			return(this.latestValue());
		}
		
		,programmedUpdate: function(newValues) {
			this.setConfiguredValue(newValues);
			var lower = this.valueHandler.convertDomainValueToSlider(newValues[0]);
			var upper = this.valueHandler.convertDomainValueToSlider(newValues[1]);
			$('#' + this.options.idBase).slider('values', [ lower, upper ]);
		}
		
		,_whichIsChanging: function(ui) {
			/*
			 * check if lower handle value has changed - if not, must be upper handle changing.
			 */
			var old = this.latestValue();
			var convertedUi = [
				this.valueHandler.convertSliderValueToDomain(ui.values[0]),
				this.valueHandler.convertSliderValueToDomain(ui.values[1])
			];
			if (this.valueHandler.equals(old[0], convertedUi[0]) && 
				this.valueHandler.equals(old[1], convertedUi[1])) { // no change..
				return -1;
			};
			return(this.valueHandler.equals(old[0], convertedUi[0]) ? 1 : 0);
		}
		
		,_positionCalloutForUpdate: function(c, ui) {
			var index = this._whichIsChanging(ui);
			if (index >= 0) { /* only update position if one handle has moved. */
				$(c).css('left', this._computeCallOutLeftValue(ui.values[index]) + '%');				
			};
			return index;
		}
		
		,_positionCalloutUpdateText: function(c, t1, t2, ui) {
			var index = this._positionCalloutForUpdate(c, ui);
			if (index >= 0) { /* only update text if one handle has moved. */
				this._setText(t1, t2, this.valueHandler.convertSliderValueToDomain(ui.values[index]));				
			};
			return index;
		}
		
		,_storeUpdateAndNotify: function(ui) {
			var newValues = [
				this.valueHandler.convertSliderValueToDomain(ui.values[0]),
				this.valueHandler.convertSliderValueToDomain(ui.values[1])
			];
			if (! isDefined(this.configuredValue) ||
				! this.valueHandler.equals(newValues[0], this.configuredValue[0]) ||
				! this.valueHandler.equals(newValues[1], this.configuredValue[1])) {
				this.configuredValue = newValues;
				this.options.changeFn(newValues); // notify application in domain values
			};	
		}
		
	});

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.timelineDateMarks.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

/*
 * Class to decorate a div background with date marks appropriate to 
 * a timeline.  Horizontal scaling is handled here by absolutely positioning
 * divs using "left:x%" CSS.
 * 
 * Could be used with a n2.sliderWithCallout because the horizontal scaling
 * is computed to be compatible but could also be used with other elements.
 * 
 */

;(function($,$n2){
"use strict";

	var DAY_MS = 1000 * 60 * 60 * 24; // in milliseconds
	$n2.TIMELINE_DATE_MARKS_Durations_DAY = DAY_MS;
	$n2.TIMELINE_DATE_MARKS_Durations_WEEK = DAY_MS * 7;
	$n2.TIMELINE_DATE_MARKS_Durations_YEAR = DAY_MS * 365;
	
	var defaultOptions = {
			containerId: '' // string: id of containing DOM element
			,idBase: '' // string: base for ID strings used in HTML for the slider.
			
			/*
			 * Date range specification.
			 */
			,min: null /* lowest date - scalar */
			,max: null /* highest  - scalar */
			
			/*
			 * incremental marks: multiples of base to get approximately 'steps' increments
			 */
			,base: $n2.TIMELINE_DATE_MARKS_Durations_WEEK
			,steps: null /* increment base between marks (last may be shorter and marks be multiples) */
			
			/*
			 * Display options for values.
			 */
			,format: 'M d' // default date formatting: MMM d
		};
	
	function range(min, max) { // date range in days
		return(Math.floor((max - min) / DAY_MS));
	};
	
	var debugDateFormat = 'yy-mm-dd';
	function dateAsString(f, d) {
		var target = f.slice(0);
		return($.datepicker.formatDate(target, d));
	};
	
	/**
	 * @param min Date
	 * @param max Date
	 * @param base Date duration in milliseconds
	 * @param steps integer number of steps to try to mark on timeline
	 */
	function computeDatesArray(min, max, base, steps) {
		function pkg(d, l) {
			return {date: d, labelled: l };
		};
		
		var days = range(min, max);
		
		if (0 >= steps) {
			$n2.log('$n2.TimelineDateMarks: invalid steps value: ' + steps);
		};
		if (0 >= base) {
			$n2.log('$n2.TimelineDateMarks: invalid base value: ' + base);
		};
		if (0 >= days) { // min >= max?
			$n2.log('$n2.TimelineDateMarks: invalid date range: ' +
					dateAsString(debugDateFormat, min) + ' : ' +
					dateAsString(debugDateFormat, max));
		};
		var baseUnits = Math.floor((days * DAY_MS) / base);
		var multiples = Math.floor(baseUnits / steps);
		var inc, labelInc;
		if (multiples < 1) {
			inc = base;
			labelInc = 1;
			if (baseUnits < 1) {
				inc = DAY_MS; // revert to days in this case
				labelInc = Math.floor(days / steps);
			}
		} else {
			inc = base;
			labelInc = multiples;
		}
		
		var dates = [];
		dates.push(pkg(new Date(min), true));
		var tempDate = new Date(min);
		var dec = labelInc;
		while (tempDate < max) {
			tempDate.setMilliseconds(tempDate.getMilliseconds() + inc);
			if (tempDate < max) {
				var label = false; // assume not labelling this one.
				if (--dec == 0) {
					if (labelInc <= 1) { // from above - label every tick
						label = true;
					} else {
						/*
						 * not labelling all - label this one?  Don't if this would leave two labels at the 
						 * end of the range too close together...
						 * 
						 * The minimum check should be 'labelInc times duration of a tick' but to allow a 
						 * labelled tick to encroach on the end range a bit it is adjusted to about 3/4 of
						 * that.
						 */
						var adjustedCheck = Math.floor(0.75 * labelInc);
						if ((max - tempDate) >= (adjustedCheck * inc)) {
							label = true;
						}
					}
				};
				
				if (label) {
					dates.push(pkg(new Date(tempDate), true));
				} else {
					dates.push(pkg(new Date(tempDate), false));
				}
				if (dec <= 0) {
					dec = labelInc;
				}
			} else {
				dates.push(pkg(new Date(max), true));
			};
		};
		return dates;
	};
	
	/**
	 * @param d date to be positioned proportionally along the div
	 * @param min minimum date for range
	 * @param max maximum date for range
	 * @return CSS left value computed as a percentage
	 */
	function computeLeftValue(d, min, max) { 
		var percentage = (d - min) / (max - min) * 100;
//		$n2.log('computeLeftValue - returning: '+percentage);
		return(percentage);
	}

	/**
	 * @param txt text string
	 * @return array containing the original string split into two (approximate) halves
	 */
	function splitText(txt) {
		var l = Math.floor(txt.length / 2);
		var a = new Array();
		var tt;
		if (l > 0) {
			tt = txt.slice(0,l);
			
			// handle string segment terminated by space ... replace with &nbsp; so not ignored
			var lastCharIndex = tt.length-1;
			if (tt[lastCharIndex] == ' ') {
				tt = tt.slice(0, -1) + '&nbsp;';
			};
			
			a.push(tt);
		} else {
			a.push('');
		};

		if ((txt.length - l) > 0) {
			tt = txt.slice(l);
			
			// handle string segment beginning with space ... replace with &nbsp; so not ignored
			if (tt[0] == ' ') {
				tt = '&nbsp;' + tt.slice(1);
			}
			
			a.push(tt);
		} else {
			a.push('');
		};
		return a;
	}

	/**
	 * @param wrapper DOM element to which label is added
	 * @param lft CSS left value as a percentage
	 * @param txt string to be used as label (only used if lFlag == true)
	 * @param lFlag boolean indicating whether this is really a labelled tick or
	 *              just a minor tick mark.
	 */
	function addLabel(wrapper, lft, txt, lFlag) {
		var labelPosition = $(
				'<div class="TimelineDateMarks_label" ' +
				'style="width:0px;padding:0px;margin:0px;border:none"></div>'
		);
		wrapper.append(labelPosition);
		$(labelPosition).css('left', lft + '%');
		
		if (lFlag) {
			/*
			 * Some browsers (e.g., Safari) may break a text element at a dash/minus sign unless a large enough
			 * width is specified.  If needed, add a width element to the CSS tied to the label classes defined below.
			 * The elements below properly left or right align things so specifying the width is hopefully all that
			 * is required.
			 */
			var txtArray = splitText(txt);
			labelPosition.append(
					'<div class="TimelineDateMarks_labelLeft" ' +
					'style="position:absolute;right:0px;bottom:0px;text-align:right;">' +
					txtArray[0] +
					'</div>' +
					'<div class="TimelineDateMarks_labelRight" ' +
					'style="position:absolute;left:0px;bottom:0px;text-align:left;">' +
					txtArray[1] +
					'</div>'
			);
		}
		labelPosition.append(
				'<div class="TimelineDateMarks_labelTick ' + 
					(lFlag ? 'TimelineDateMarks_labelTick_large' : 'TimelineDateMarks_labelTick_small') + '" ' +
					'style="position:absolute;left:0px;bottom:0px;text-align:left;">|</div>'
		);
	}

	$n2.TimelineDateMarks = $n2.Class({
		options: null		
		
		,dates: null
	
		,initialize: function(/* ... variable argument list ... */) { // duplicates? - rightmost take precedence
			this.options = $.extend({}, defaultOptions);
			for (var i=0; i < arguments.length; i++) { // update o with properties from objects in variable arg list.
				var o = arguments[i];
				if ($n2.isDefined(o)) {
					this.options = $.extend(true, this.options, o);
				};
			};
			
			if ($n2.isDefined(this.options.min) &&
					$n2.isDefined(this.options.max) &&
					$n2.isDefined(this.options.base) &&
					$n2.isDefined(this.options.steps)) {
				this.dates = computeDatesArray(
						this.options.min, 
						this.options.max, 
						this.options.base, 
						this.options.steps);
			}
		}
	
		,setDateRangeParms: function(min, max, base, steps) {
			this.options.min = min;
			this.options.max = max;
			this.options.base = base;
			this.options.steps = steps;
			
			this.dates = computeDatesArray(
					this.options.min,
					this.options.max, 
					this.options.base, 
					this.options.steps);
		}
		
		,draw: function() {
			var wrapper = $('<div class="TimelineDateMarks_wrapper"></div>');
			$('#' + this.options.containerId).empty().append(wrapper);
			
			for (var i=0; i < this.dates.length; i++) {
				var d = this.dates[i];
				var lft = computeLeftValue(d.date, this.options.min, this.options.max);
				if (d.labelled) {
					addLabel(wrapper, lft, dateAsString(this.options.format, d.date), true);
				} else {
					addLabel(wrapper, lft, '', false);
				}
			};
		}
	});

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.progress.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

var ProgressKeyCache = $n2.Class({
	
	options: null
	
	,progressKeyCache: null
	
	,initialize: function(options_) {
		this.options = options_;
		
		this.progressKeyCache = [];
	}

	,getKey: function(callback) {
		var key = this.progressKeyCache.shift();
		if( key ) {
			callback(key);
		} else {
			this.refresh(callback);
		}
	}
	
	/*
	 * This function calls the progress servlet to get a set of 
	 * unique keys for tracking progress of various activities. This
	 * function does not return anything. Instead, it is an 
	 * asynchronous function that performs a callback when keys
	 * are available. The callback should be in the form of:
	 *    function keyCallback(key) { ... };
	 * where <key> is one unique key.
	 */
	,refresh: function(callback) {
		var cache = this;
		
		$.ajax({
	    	url: this.options.url + 'getIds'
	    	,type: 'get'
	    	,async: true
	    	,data: { count: 20 }
	    	,dataType: 'json'
	    	,success: function(res) {
	    		if( res && res.progressIds ) {
    				var key;
    				while( key = res.progressIds.shift() ) {
    					cache.progressKeyCache.push(key);
    				};

    				var id = cache.progressKeyCache.shift();
    				if( id ) callback(id);

	    		} else {
	    			cache.options.onError( _loc('Error occurred with progress service') );
	    			$n2.log('Progress service did not return any results');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				cache.options.onError( _loc('Error occurred with progress service') );
    			$n2.log('Progress service returned error',textStatus, errorThrown);
	    	}
		});
	}
});

var nextProgressTrackerId = 0;

var ProgressTrackerDefaultOptions = {
	progressKey: null
	,onStart: function(tracker){}
	,onUpdate: function(tracker){}
	,onComplete: function(tracker){}
	,onRemove: function(tracker){}
};

var ProgressTracker = $n2.Class({
	
	options: null
	
	,id: null
	
	,progressServer: null
	
	,progressKey: null

	,startSent: false

	,completedSent: false
	
	,info: {
		count: 0
		,total: 0
		,completed: false
	}
	
	,initialize: function(progressServer, options_) {
		this.progressServer = progressServer;
		this.options = options_;
		
		this.id = 'progressTracker' + nextProgressTrackerId;
		++nextProgressTrackerId;
	}

	,getId: function() {
		return this.id;
	}

	,getProgressKey: function() {
		return this.options.progressKey;
	}
	
	,cancel: function() {
		this.progressServer._unregisterProgressTracker(this);
	}
	
	,getTotal: function() {
		return this.info.total;
	}
	
	,getCurrent: function() {
		return this.info.current;
	}
	
	,isCompleted: function() {
		return this.info.completed;
	}
	
	,_update: function(info) {
		this.info = info;
		
		if( this.completedSent ) return;
			
		if( false == this.startSent ) {
			this.options.onStart(this);
			this.startSent = true;
		}

		this.options.onUpdate(this);
		
		if( info.completed ) {
			this.options.onComplete(this);
			this.completedSent = true;
		}
	}
});


var ProgressServerDefaultOptions = {
	url: null
	,pollingIntervalInMs: 750
	,onError: function(str){ $n2.reportError(str); }
};

var ProgressServer = $n2.Class({
	
	options: null
	
	,progressKeyCache: null
	
	,progressTrackers: null
	
	,pollingInProgress: false
	
	,initialize: function(options_) {
		this.options = $n2.extend({},ProgressServerDefaultOptions,options_);
		this.progressKeyCache = new ProgressKeyCache(this.options);
		
		this.progressTrackers = {};
	}

	/*
	 * This function is used to get a unique progress key. Progress
	 * keys are given by the progress servlet, are unique and used
	 * to track the progress of activities via the servlet. Other
	 * services, such as file upload, use this service.
	 * This is an asynchronous function and it does not return 
	 * anything. Instead, it performs a callback with the requested
	 * key when one is available. The callback should be in the form of:
	 *    function keyCallback(key) { ... };
	 * where <key> is one unique key.
	 */
	,requestProgressKey: function(callback) {
		this.progressKeyCache.getKey(callback);
	}
	
	,createProgressTracker: function(options_) {
		var opts = $n2.extend({},ProgressTrackerDefaultOptions,options_);
		if( ! opts.progressKey ) {
			return null;
		}
		
		var progressTracker = new ProgressTracker(this, opts);
		
		this._registerProgressTracker(progressTracker);
		
		return progressTracker;
	}
	
	,_registerProgressTracker: function(progressTracker) {
		var progressKey = progressTracker.getProgressKey();
		var progressTrackerId = progressTracker.getId();
		
		var keyTrackers = this.progressTrackers[progressKey];
		if( !keyTrackers ) {
			keyTrackers = {};
			this.progressTrackers[progressKey] = keyTrackers;
		}
		
		var tracker = keyTrackers[progressTrackerId];
		if( !tracker ) {
			keyTrackers[progressTrackerId] = progressTracker;
		}
		
		this._initiatePolling();
	}
	
	,_unregisterProgressTracker: function(progressTracker) {
		var progressKey = progressTracker.getProgressKey();
		var progressTrackerId = progressTracker.getId();
		
		var keyTrackers = this.progressTrackers[progressKey];
		if( !keyTrackers ) {
			// Nothing to do
			return;
		}
		
		var tracker = keyTrackers[progressTrackerId];
		if( tracker ) {
			delete keyTrackers[progressTrackerId];
		}
		
		// Count number of trackers left
		var count = 0;
		for(var trackerId in keyTrackers) {
			++count;
		};
		
		if( count < 1 ) {
			delete this.progressTrackers[progressKey];
		};
	}
	
	,_initiatePolling: function() {
		if( this.pollingInProgress ) return;
		
		// Accumulate keys
		var keys = [];
		for(var key in this.progressTrackers) {
			keys.push(key);
		}
		
		if( keys.length < 1 ) return;
		
		// Make request
		var server = this;
		$.ajax({
	    	url: this.options.url + 'getProgresses'
	    	,type: 'get'
	    	,async: true
			,traditional: true
	    	,data: { progressId: keys }
	    	,dataType: 'json'
	    	,success: function(data) {
	    		if( server._processProgressResults(data) ) {
	    			setTimeout(function(){ server._initiatePolling(); }, server.options.pollingIntervalInMs);
	    		} else {
	    			server.pollingInProgress = false;
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
    			server.pollingInProgress = false;
				server.options.onError( _loc('Error occurred with progress service') );
    			$n2.log('Progress service returned error on getProgresses',textStatus, errorThrown);
	    	}
		});
	}
	
	// Returns true if polling should be continued
	,_processProgressResults: function(data) {
		//$n2.log('_processProgressResults',data);
		
		var trackingInProgress = false;
		
		if( data && data.results ) {
			// Update all tracked activities
			var trackersToUnregister = [];
			var reportedKeys = {};
			for(var i=0,e=data.results.length; i<e; ++i) {
				var info = data.results[i];
				var key = info.id;
				
				// Remember which keys were reported
				reportedKeys[key] = info;
				
				var trackers = this.progressTrackers[key];
				if( trackers ) {
					for(var trackerId in trackers) {
						var tracker = trackers[trackerId];
						if( tracker ) {
							tracker._update(info);
							if( info.completed ) {
								trackersToUnregister.push(tracker);
							} else {
								trackingInProgress = true;
							};
						};
					};
				};
			};

			// Forget all trackers that are done
			for(var i=0,e=trackersToUnregister.length; i<e; ++i) {
				var tracker = trackersToUnregister[i];
				this._unregisterProgressTracker(tracker);
			};
			
			// Check end condition. If there is no tracking left, it
			// is possible that a new tracker was added during the last request
			if( !trackingInProgress ) {
				for(var key in this.progressTrackers) {
					var trackers = this.progressTrackers[key];
					if( trackers ) {
						for(var trackerId in trackers) {
							if( !reportedKeys[key] ) {
								// This is a new tracker since last call
								trackingInProgress = true;
							}
						};
					};
				};
			};
		};
		
		return trackingInProgress;
	}

});
	
$n2.progress = {
	ProgressServer: ProgressServer
	
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/jquery-progress-1.0.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
(function($){
"use strict";
	var uniqueId = 0;
	var polling = false;
	var progressKeyCache = [];
	var trackedKeys = {};
	var trackerElements = [];

	var getId = function() {
		var result = 'progress_id_' + uniqueId;
		++uniqueId;
		return result;
	}
	
	/*
	 * This function calls the progress servlet to get a set of 
	 * unique keys for tracking progress of various activities. This
	 * function does not return anything. Instead, it is an 
	 * asynchronous function that performs a callback when keys
	 * are available. The callback should be in the form of:
	 *    function keyCallback(key) { ... };
	 * where <key> is one unique key.
	 */
	var refreshProgressKeyCache = function(callback) {
		$.get("progress/getIds?count=5", function(data) {
			if (!data) {
				if( window.console && window.console.log ) window.console.log('No data returned by progress service');
				return;
			}
	 
			var response;
			eval ("response = " + data);
	 
			if (!response) {
				if( window.console && window.console.log ) window.console.log('No response returned by progress service');
				return;
			}

			if( response.progressIds ) {
				var key;
				while( key = response.progressIds.shift() ) {
					progressKeyCache.push(key);
				}
			}
			
			if( callback ) {
				var id = progressKeyCache.shift();
				if( id ) callback(id);
			}
		});
	};

	var onStartDefault = function(keyInfo,options) {
		var key = options.id + '_' + keyInfo.key;
		var elem = $(
			'<div id="progress_'+key+'">'+
				'<div id="progressbar_'+key+'"></div>'+
				'<div>'+
					'<span class="progress-x" id="progressa_'+key+'">X</span>'+keyInfo.desc+
					'<span id="progresstext_'+key+'">Starting...</span>'+
				'</div>'+
			'</div>');
		var parent = $('#'+options.trackerId);
		elem.appendTo(parent);
		$('#progressbar_'+key).progressbar();
		$('#progressa_'+key).click(function(evt){
			$.progress.removeDisplayOn(keyInfo.key);
			return false;
		});

	};
	 
	var onCompleteDefault = function(keyInfo,options) {
		var key = options.id + '_' + keyInfo.key;
		$('#progressbar_'+key).progressbar('value',100);
		$('#progresstext_'+key).text('Done.');
	};

	var onUpdateDefault = function(keyInfo,options) {
		var key = options.id + '_' + keyInfo.key;
		$('#progressbar_'+key).progressbar('value',keyInfo.value);
		$('#progresstext_'+key).text(''+keyInfo.value+'%');
	};

	var onRemoveDefault = function(key,options) {
		var key = options.id + '_' + key;
		$('#progress_'+key).remove();
	};

	var createActivity = function(keyInfo, trackerOptions) {
		if( trackerOptions.onStart ) {
			trackerOptions.onStart(keyInfo, trackerOptions);
		}
	}

	var updateActivity = function(keyInfo, trackerOptions) {
		if( trackerOptions.onUpdate ) {
			trackerOptions.onUpdate(keyInfo, trackerOptions);
		}
	}
	
	var forEachTracker = function(callback) {
		var loop;
		for(loop=0; loop<trackerElements.length; ++loop) {
			var trackerOptions = trackerElements[loop];
			callback(trackerOptions);
		};
	};
	
	var forEachActivity = function(callback) {
		for(var activityKey in trackedKeys) {
			var keyInfo = trackedKeys[activityKey];

			callback(activityKey, keyInfo);
		};
	};
	
	// Access progress servlet and get counters
	// for tracked activities. Update various
	// trackers when results are available
	var pollProgress = function() {
		// Check if any activity is being tracked
		var params = null;
		for(var key in trackedKeys) {
			if(!params) {
				params = '?progressId=' + key;
			} else {
				params += '&progressId=' + key;
			}
		}
		if( !params ) {
			polling = false;
			return;
		};

		// Check if any tracker are displayed
		var trackerDisplayed = false;
		forEachTracker(function(trackerOptions){
			trackerDisplayed = true;
		});
		if( !trackerDisplayed ) {
			polling = false;
			return;
		};

		polling = true;
		
		$.get('progress/getProgresses' + params, function(data) {
			if (!data) {
				if(window.console && window.console.log)window.console.log('No data');
				polling = false;
				return;
			}
	 
			var response;
			eval ('response = ' + data);
	 
			if (!response) {
				if(window.console && window.console.log)window.console.log('Empty response');
				polling = false;
				return;
			}

			var array = response.results;
			while( array.length > 0 ) {
				var info = array.shift();

				// Compute percentage
				var key = info.id;
				var total = 1 * info.total;
				var current = 1 * info.current;
				var percentage = 0;
				if( 0 != total ) {
					percentage = Math.floor(100 * current / total);
				}
				
				// Detect chained activities
				if( info.chained ) {
					var chainedInfos = info.chained;
					for(var loop=0; loop<chainedInfos.length; ++loop) {
						var chainedInfo = chainedInfos[loop];
						if( !trackedKeys[chainedInfo.id] ) {
							$.progress.startProgressTrackingOn(chainedInfo.id, chainedInfo.description);
						}
					}
				}
				
				// Update data
				var keyInfo = trackedKeys[key];
				if( keyInfo ) {
					if( keyInfo.value == percentage ) {
						keyInfo.duplicates = keyInfo.duplicates + 1;
					} else {
						keyInfo.duplicates = 0;
					};
					
					keyInfo.value = percentage;
					if( info.data ) {
						keyInfo.data = info.data;
					}

					forEachTracker(function(trackerOptions){
						updateActivity(keyInfo, trackerOptions);
					});
					
					// When activity is completed, stop tracking it
					if( info.completed ) {
						keyInfo.completed = true;
						
						$.progress.stopProgressTrackingOn(key);
					} else if( keyInfo.duplicates > 15 ) {
						// This activity is not moving, kill it
						$.progress.stopProgressTrackingOn(key);
					};
				}
			}
			 
			setTimeout(pollProgress, 750);
		});
	};
	
	/*
	 * This is the public API. Access via $.progress.XXX();
	 */
	$.progress = {
			/*
			 * This function is used to get a unique progress key. Progress
			 * keys are given by the progress servlet, are unique and used
			 * to track the progress of activities via the servlet. Other
			 * services, such as file upload, use this service.
			 * This is an asynchronous function and it does not return 
			 * anything. Instead, it performs a callback with the requested
			 * key when one is available. The callback should be in the form of:
			 *    function keyCallback(key) { ... };
			 * where <key> is one unique key.
			 */
			getProgressKey: function(callback) {
				var key = progressKeyCache.shift();
				if( key ) {
					callback(key);
				} else {
					refreshProgressKeyCache(callback);
				}
			}
				
			,startProgressTrackingOn: function(key,desc) {
				var keyInfo = trackedKeys[key] = {
					value: 0
					,key: key
					,desc: desc
					,duplicates: 0
				};

				forEachTracker(function(trackerOptions){
					createActivity(keyInfo, trackerOptions);
				});

				// Start polling for progress, if needed
				if( !polling ) {			
					pollProgress();
				}
			}
			
			,stopProgressTrackingOn: function(key) {
				var keyInfo = trackedKeys[key];
				
				if( keyInfo ) {
					forEachTracker(function(trackerOptions){
						if( trackerOptions.onComplete ) {
							trackerOptions.onComplete(keyInfo, trackerOptions);
						}
					});
					
					delete trackedKeys[key];
				}
			}
			
			,removeDisplayOn: function(key) {
				$.progress.stopProgressTrackingOn(key);
				
				forEachTracker(function(trackerOptions){
					if( trackerOptions.onRemove ) {
						trackerOptions.onRemove(key, trackerOptions);
					}
				});
			}
			
			/*
			 * Default options
			 */
			,progressTrackerDefaultOptions: {
				onStart: onStartDefault 
				,onUpdate: onUpdateDefault 
				,onComplete: onCompleteDefault
				,onRemove: onRemoveDefault
			}
			
			,addProgressTracker: function(trackerOptions){
				var options = $.extend({},$.progress.progressTrackerDefaultOptions,trackerOptions);

				trackerElements.push(options);
	
				forEachActivity(function(activityKey, keyInfo){
					createActivity(keyInfo, options);
					updateActivity(keyInfo, options);
				});
	
				// Start polling for progress, if needed
				if( !polling ) {			
					pollProgress();
				};
			}
	};

	
	/*
	 * This is the jquery function that is called for each object
	 * found returned by a query. "this" is a set of elements returned
	 * by jquery.
	 * To use:
	 *   $('#id').progressTracker();
	 */
	$.fn.progressTracker = function(options_) {
		return this.each(function(){
			var self = this;
			var id = getId();
			var tracker = $('<div id="'+id+'"></div>').appendTo(this);
			options_.trackerId = id;

			$.progress.addProgressTracker(options_);
		});
	};

	/*
	 * This function installs a button on an element when a progress
	 * key is available. This button is used to open a file upload
	 * dialog.
	 * The reason that the button is created only when a progress key
	 * is available is that:
     * - The file upload servlet is co-located with the progress servlet
     * - If the progress servlet is not available, then the file upload servlet
     *   is not, either
     * - there is little point in created a useless element
     * - progress keys are used to track the progress of uploading the file,
     *   we should wait for a key before allowing a user to load a file to have
     *   a consistent look and feel.
	 */
	var installButton = function(elem, currentButton, key, options) {
		var button = $('<input type="button" value="'+options.message+'">');
		button.click(function(evt){

			options.onClick(elem,key);
			
			// Remove button and add a new one
			setTimeout(function(){
				$.progress.getProgressKey(function(newKey){
					installButton(elem, button, newKey, options);
				});
			},0);
		});
		if( currentButton ) {
			currentButton.after(button);
			currentButton.remove();
		} else {
			$(elem).append(button);
		}
	};

	/*
	 * Default options
	 */
	var keyedButtonDefaultOptions = {
		onClick: function(){} 
		,message: "OK" 
	};
	
	/*
	 * This is the jquery function that is called for each object
	 * found returned by a query. "this" is a set of elements returned
	 * by jquery.
	 * To use:
	 *   $('#id').keyedButton();
	 */
	$.fn.keyedButton = function(options_) {
		return this.each(function(){
			var options = $.extend({},keyedButtonDefaultOptions,options_);
			var self = this;
			$.progress.getProgressKey(function(key){
				installButton(self, null, key, options);
			});
		});
	};
})(jQuery);


// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/jquery-progress-slide-1.0.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
(function($){
"use strict";

	function CreateHolder() {
		var $holder = $('#progress-slider');
		if( $holder.size() === 0 ) {
			$holder = $('<div id="progress-slider" class="prog-holder">' +
			'<div id="progress-slider-background" class="prog-background" style="position:absolute;top:0px;left:0px;width:100%;height:100%;">' +
			'</div>' +
			'</div>' );
			
			$(document.body).append($holder);
		}
		var $holder = $('#progress-slider');
	};
	
	function PutAway(elemId) {
	    var elem = $('#'+elemId);
		elem.animate({
			left:"0px"
			,bottom:"0px"
			}
			,function(){
				elem.one('click',function(){
					PutUp(elemId);
				});
				elem.attr('prog-slider-viewed',0);
				CheckReadyRemove(elemId);
			}
		);
	};
	       
	function Close(elemId) {
	    var $downElem = $('#'+elemId+'_down');
	
	    if( $downElem.size() > 0 ) {
		    $downElem.slideUp(function(){
				PutAway(elemId);
			});
	    } else {
			PutAway(elemId);
	    }
	};
	       
	function PutUp(elemId) {
	    var elem = $('#'+elemId);
	    var win = $(window);
		    
		// Figure out center of screen
		var screenCenterX = win.width() / 2;
		var screenCenterY = win.height() / 2;
	
		// Figure out offset of element
		var elemOffset = elem.offset();
	
		// Figure out dimension of object
		var elemWidth = elem.width();
		var elemHeight = elem.height();
	
		var elemFinalPosX = Math.floor(screenCenterX - (elemWidth / 2));
		var elemFinalPosY = Math.floor(screenCenterY - (elemHeight / 2));
	    
	    elem.attr('prog-slider-viewed',1);
		elem.animate({
			left:''+elemFinalPosX+'px'
			,bottom:''+elemFinalPosY+'px'
			}
			,function(){
				Open(elemId);
			});
	};
	
	function Open(elemId) {
	    var elem = $('#'+elemId);
	    elem.one("click",function(){
			Close(elemId);
		});
	    
		$('#'+elemId+'_down').slideDown();
	};
	
	function AddBar(id,description) {

		CreateHolder();
		
		var newBar = $('<div id="'+id+'" title="'+description+'" class="prog-moveBar" style="position:relative;left:0px;bottom:0px;">' +
			'<div id="'+id+'_value" class="prog-moveBar-colour" style="width:0%"></div>' +
			'<div id="'+id+'_down" style="position:absolute;display:none;left:-200px;top:-2px;width:600px;margin:0px;background:#ffffff;border:1px solid #000000">' +
				'<div id="'+id+'_value2" class="prog-moveBar-colour" style="width:0%"></div>' +
				'<table class="prog-description-table"><tr><th>Description:</th><td id="'+id+'_description">'+description+'</td></tr>' +
				'<tr><th>Progress:</th><td id="'+id+'_percent"></td></tr>' +
				'<tr><th></th><td><a id="'+id+'_cancel" href="#">Cancel Reporting</a></td></tr></table>' +
			'</div>' +
		'</div>');
	
		$('#progress-slider-background').after(newBar);
		$('#'+id+'_cancel').click(function(evt){
			RemoveBar(id);
			return false;
		});
	
		newBar.one('click',function(){
			PutUp(id);
		});
		newBar.attr('prog-slider-viewed',0);
	
		return id;
	}
	
	function RemoveBar(elemId) {
	    var $elem = $('#'+elemId);
	    $elem.slideUp(function(){
		    $elem.remove();
		});
	}
	
	function SetValue(elemId,percent) {
	    if( percent > 100 ) percent = 100;
	    if( percent < 0 ) percent = 0;
	    $('#'+elemId+'_value').css({width:''+percent+'%'});
	    $('#'+elemId+'_value2').css({width:''+percent+'%'});
	    $('#'+elemId+'_percent').text(''+percent+'%');
	}
	
	function CheckReadyRemove(elemId) {
		var $elem = $('#'+elemId);
		
		if( $elem.size() > 0 ) {
			var ready = 1 * $elem.attr('prog-slider-ready-remove');
			var viewed = 1 * $elem.attr('prog-slider-viewed');
			
			if( ready && !viewed ) {
				RemoveBar(elemId);
			};
		};
	}
	
	var onStartDefault = function(keyInfo,options) {
		var key = 'prog-slider_' + keyInfo.key;
		AddBar(key,keyInfo.desc);
	};
	 
	var onCompleteDefault = function(keyInfo,options) {
		var key = 'prog-slider_' + keyInfo.key;
		SetValue(key,100);
	    $('#'+key+'_percent').text('Done');
	    $('#'+key).attr('title',keyInfo.desc+'. Done.');
	    
	    // Remember to remove this bar after a delay
	    $('#'+key)
	    	.attr('prog-slider-stopped',1)
	    	.attr('prog-slider-ready-remove',0);
	    
	    setTimeout(function(){
		    $('#'+key).attr('prog-slider-ready-remove',1);
	    	CheckReadyRemove(key);
	    },5000); // 5 seconds
	};

	var onUpdateDefault = function(keyInfo,options) {
		var key = 'prog-slider_' + keyInfo.key;
		SetValue(key,keyInfo.value);
	    $('#'+key).attr('title',keyInfo.desc+' ('+keyInfo.value+'%)');
	};

	var onRemoveDefault = function(key,options) {
		var key = 'prog-slider_' + key;
		RemoveBar(key);
	};
	
	// Install global tracker
	if( $.progress && $.progress.addProgressTracker ) {
		var trackerOptions = {
			onStart: onStartDefault
			,onUpdate: onUpdateDefault 
			,onComplete: onCompleteDefault
			,onRemove: onRemoveDefault
		};
		
		$.progress.addProgressTracker(trackerOptions);
	};
})(jQuery);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/comet/json2.js

/*
    http://www.JSON.org/json2.js
    2011-01-18

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/comet/jquery.cometd.js

/**
 * Copyright 2008 Mort Bay Consulting Pty. Ltd.
 * Dual licensed under the Apache License 2.0 and the MIT license.
 * ----------------------------------------------------------------------------
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http: *www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------
 * Licensed under the MIT license;
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ----------------------------------------------------------------------------
 * $Revision: 8165 $ $Date: 2012-05-31 09:14:37 -0400 (Thu, 31 May 2012) $
 */
(function($)
{
    /**
     * The constructor for a Comet object.
     * There is a default Comet instance already created at the variable <code>$.cometd</code>,
     * and hence that can be used to start a comet conversation with a server.
     * In the rare case a page needs more than one comet conversation, a new instance can be
     * created via:
     * <pre>
     * var url2 = ...;
     * var cometd2 = new $.Cometd();
     * cometd2.init(url2);
     * </pre>
     */
    $.Cometd = function(name)
    {
        var _name = name || 'default';
        var _logPriorities = { debug: 1, info: 2, warn: 3, error: 4 };
        var _logLevel = 'info';
        var _url;
        var _xd = false;
        var _transport;
        var _status = 'disconnected';
        var _messageId = 0;
        var _clientId = null;
        var _batch = 0;
        var _messageQueue = [];
        var _listeners = {};
        var _backoff = 0;
        var _backoffIncrement = 1000;
        var _maxBackoff = 60000;
        var _scheduledSend = null;
        var _extensions = [];
        var _advice = {};
        var _handshakeProps;

        /**
         * Returns the name assigned to this Comet object, or the string 'default'
         * if no name has been explicitely passed as parameter to the constructor.
         */
        this.getName = function()
        {
            return _name;
        };

        /**
         * Configures the initial comet communication with the comet server.
         * @param cometURL the URL of the comet server
         */
        this.configure = function(cometURL)
        {
            _configure(cometURL);
        };

        function _configure(cometURL)
        {
            _url = cometURL;
            _debug('Initializing comet with url: {}', _url);

            // Check immediately if we're cross domain
            // If cross domain, the handshake must not send the long polling transport type
            var urlParts = /(^https?:)?(\/\/(([^:\/\?#]+)(:(\d+))?))?([^\?#]*)/.exec(cometURL);
            if (urlParts[3]) _xd = urlParts[3] != location.host;

            // Temporary setup a transport to send the initial handshake
            // The transport may be changed as a result of handshake
            if (_xd)
                _transport = newCallbackPollingTransport();
            else
                _transport = newLongPollingTransport();
            _debug('Initial transport is {}', _transport.getType());
        };

        /**
         * Configures and establishes the comet communication with the comet server
         * via a handshake and a subsequent connect.
         * @param cometURL the URL of the comet server
         * @param handshakeProps an object to be merged with the handshake message
         * @see #configure(cometURL)
         * @see #handshake(handshakeProps)
         */
        this.init = function(cometURL, handshakeProps)
        {
            _configure(cometURL);
            _handshake(handshakeProps);
        };

        /**
         * Establishes the comet communication with the comet server
         * via a handshake and a subsequent connect.
         * @param handshakeProps an object to be merged with the handshake message
         */
        this.handshake = function(handshakeProps)
        {
            _handshake(handshakeProps);
        };

        /**
         * Disconnects from the comet server.
         * @param disconnectProps an object to be merged with the disconnect message
         */
        this.disconnect = function(disconnectProps)
        {
            var bayeuxMessage = {
                channel: '/meta/disconnect'
            };
            var message = $.extend({}, disconnectProps, bayeuxMessage);
            // Deliver immediately
            // The handshake and connect mechanism make use of startBatch(), and in case
            // of a failed handshake the disconnect would not be delivered if using _send().
            _setStatus('disconnecting');
            _deliver([message], false);
        };

        /**
         * Marks the start of a batch of application messages to be sent to the server
         * in a single request, obtaining a single response containing (possibly) many
         * application reply messages.
         * Messages are held in a queue and not sent until {@link #endBatch()} is called.
         * If startBatch() is called multiple times, then an equal number of endBatch()
         * calls must be made to close and send the batch of messages.
         * @see #endBatch()
         */
        this.startBatch = function()
        {
            _startBatch();
        };

        /**
         * Marks the end of a batch of application messages to be sent to the server
         * in a single request.
         * @see #startBatch()
         */
        this.endBatch = function()
        {
            _endBatch(true);
        };

        /**
         * Subscribes to the given channel, performing the given callback in the given scope
         * when a message for the channel arrives.
         * @param channel the channel to subscribe to
         * @param scope the scope of the callback
         * @param callback the callback to call when a message is delivered to the channel
         * @param subscribeProps an object to be merged with the subscribe message
         * @return the subscription handle to be passed to {@link #unsubscribe(object)}
         */
        this.subscribe = function(channel, scope, callback, subscribeProps)
        {
            var subscription = this.addListener(channel, scope, callback);

            // Send the subscription message after the subscription registration to avoid
            // races where the server would deliver a message to the subscribers, but here
            // on the client the subscription has not been added yet to the data structures
            var bayeuxMessage = {
                channel: '/meta/subscribe',
                subscription: channel
            };
            var message = $.extend({}, subscribeProps, bayeuxMessage);
            _send(message);

            return subscription;
        };

        /**
         * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.
         * @param subscription the subscription to unsubscribe.
         */
        this.unsubscribe = function(subscription, unsubscribeProps)
        {
            // Remove the local listener before sending the message
            // This ensures that if the server fails, this client does not get notifications
            this.removeListener(subscription);
            var bayeuxMessage = {
                channel: '/meta/unsubscribe',
                subscription: subscription[0]
            };
            var message = $.extend({}, unsubscribeProps, bayeuxMessage);
            _send(message);
        };

        /**
         * Publishes a message on the given channel, containing the given content.
         * @param channel the channel to publish the message to
         * @param content the content of the message
         * @param publishProps an object to be merged with the publish message
         */
        this.publish = function(channel, content, publishProps)
        {
            var bayeuxMessage = {
                channel: channel,
                data: content
            };
            var message = $.extend({}, publishProps, bayeuxMessage);
            _send(message);
        };

        /**
         * Adds a listener for bayeux messages, performing the given callback in the given scope
         * when a message for the given channel arrives.
         * @param channel the channel the listener is interested to
         * @param scope the scope of the callback
         * @param callback the callback to call when a message is delivered to the channel
         * @returns the subscription handle to be passed to {@link #removeListener(object)}
         * @see #removeListener(object)
         */
        this.addListener = function(channel, scope, callback)
        {
            // The data structure is a map<channel, subscription[]>, where each subscription
            // holds the callback to be called and its scope.

            // Normalize arguments
            if (!callback)
            {
                callback = scope;
                scope = undefined;
            }

            var subscription = {
                scope: scope,
                callback: callback
            };

            var subscriptions = _listeners[channel];
            if (!subscriptions)
            {
                subscriptions = [];
                _listeners[channel] = subscriptions;
            }
            // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.
            // Note that if:
            // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');
            // then:
            // hc==3, a.join()=='a',,'c', a.length==3
            var subscriptionIndex = subscriptions.push(subscription) - 1;
            _debug('Added listener: channel \'{}\', callback \'{}\', index {}', channel, callback.name, subscriptionIndex);

            // The subscription to allow removal of the listener is made of the channel and the index
            return [channel, subscriptionIndex];
        };

        /**
         * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.
         * @param subscription the subscription to unsubscribe.
         */
        this.removeListener = function(subscription)
        {
            var subscriptions = _listeners[subscription[0]];
            if (subscriptions)
            {
                delete subscriptions[subscription[1]];
                _debug('Removed listener: channel \'{}\', index {}', subscription[0], subscription[1]);
            }
        };

        /**
         * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or
         * {@link #subscribe(channel, scope, callback)}.
         */
        this.clearListeners = function()
        {
            _listeners = {};
        };

        /**
         * Returns a string representing the status of the bayeux communication with the comet server.
         */
        this.getStatus = function()
        {
            return _status;
        };

        /**
         * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
         * Default value is 1 second, which means if there is a persistent failure the retries will happen
         * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of
         * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).
         * @param period the backoff period to set
         * @see #getBackoffIncrement()
         */
        this.setBackoffIncrement = function(period)
        {
            _backoffIncrement = period;
        };

        /**
         * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
         * @see #setBackoffIncrement(period)
         */
        this.getBackoffIncrement = function()
        {
            return _backoffIncrement;
        };

        /**
         * Returns the backoff period to wait before retrying an unsuccessful or failed message.
         */
        this.getBackoffPeriod = function()
        {
            return _backoff;
        };

        /**
         * Sets the log level for console logging.
         * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
         * less verbose to more verbose.
         * @param level the log level string
         */
        this.setLogLevel = function(level)
        {
            _logLevel = level;
        };

        /**
         * Registers an extension whose callbacks are called for every incoming message
         * (that comes from the server to this client implementation) and for every
         * outgoing message (that originates from this client implementation for the
         * server).
         * The format of the extension object is the following:
         * <pre>
         * {
         *     incoming: function(message) { ... },
         *     outgoing: function(message) { ... }
         * }
         * Both properties are optional, but if they are present they will be called
         * respectively for each incoming message and for each outgoing message.
         * </pre>
         * @param name the name of the extension
         * @param extension the extension to register
         * @return true if the extension was registered, false otherwise
         * @see #unregisterExtension(name)
         */
        this.registerExtension = function(name, extension)
        {
            var existing = false;
            $.each(_extensions, function(index, extension)
            {
                if (extension.name == name)
                {
                    existing = true;
                    return false;
                }
            });
            if (!existing)
            {
                _extensions.push({
                    name: name,
                    extension: extension
                });
                _debug('Registered extension \'{}\'', name);
                return true;
            }
            else
            {
                _info('Could not register extension with name \'{}\': another extension with the same name already exists');
                return false;
            }
        };

        /**
         * Unregister an extension previously registered with
         * {@link #registerExtension(name, extension)}.
         * @param name the name of the extension to unregister.
         * @return true if the extension was unregistered, false otherwise
         */
        this.unregisterExtension = function(name)
        {
            var unregistered = false;
            $.each(_extensions, function(index, extension)
            {
                if (extension.name == name)
                {
                    _extensions.splice(index, 1);
                    unregistered = true;
                    _debug('Unregistered extension \'{}\'', name);
                    return false;
                }
            });
            return unregistered;
        };

        /**
         * Sends new messages to subscribe to all channels expected by
         * current listeners. This might be needed in case the server lost
         * the state of the client (crash, timeout, network issues)
         */
        function _resubscribe()
        {
        	for(var channel in _listeners) {
                var bayeuxMessage = {
                    channel: '/meta/subscribe',
                    subscription: channel
                };
                var message = $.extend({}, bayeuxMessage);
                _send(message);
        	};
        };
        
        /**
         * Starts a the batch of messages to be sent in a single request.
         * @see _endBatch(deliverMessages)
         */
        function _startBatch()
        {
            ++_batch;
        };

        /**
         * Ends the batch of messages to be sent in a single request,
         * optionally delivering messages present in the message queue depending
         * on the given argument.
         * @param deliverMessages whether to deliver the messages in the queue or not
         * @see _startBatch()
         */
        function _endBatch(deliverMessages)
        {
            --_batch;
            if (_batch < 0) _batch = 0;
            if (deliverMessages && _batch == 0 && !_isDisconnected())
            {
                var messages = _messageQueue;
                _messageQueue = [];
                if (messages.length > 0) _deliver(messages, false);
            }
        };

        function _nextMessageId()
        {
            return ++_messageId;
        };

        /**
         * Converts the given response into an array of bayeux messages
         * @param response the response to convert
         * @return an array of bayeux messages obtained by converting the response
         */
        function _convertToMessages(response)
        {
            if (response === undefined) return [];
            if (response instanceof Array) return response;
            if (response instanceof String || typeof response == 'string') return eval('(' + response + ')');
            if (response instanceof Object) return [response];
            throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
        };

        function _setStatus(newStatus)
        {
            _debug('{} -> {}', _status, newStatus);
            _status = newStatus;
        };

        function _isDisconnected()
        {
            return _status == 'disconnecting' || _status == 'disconnected';
        };

        /**
         * Sends the initial handshake message
         */
        function _handshake(handshakeProps)
        {
            _debug('Starting handshake');
            _clientId = null;

            // Start a batch.
            // This is needed because handshake and connect are async.
            // It may happen that the application calls init() then subscribe()
            // and the subscribe message is sent before the connect message, if
            // the subscribe message is not held until the connect message is sent.
            // So here we start a batch to hold temporarly any message until
            // the connection is fully established.
            _batch = 0;
            _startBatch();

            // Save the original properties provided by the user
            // Deep copy to avoid the user to be able to change them later
            _handshakeProps = $.extend(true, {}, handshakeProps);

            var bayeuxMessage = {
                version: '1.0',
                minimumVersion: '0.9',
                channel: '/meta/handshake',
                supportedConnectionTypes: _xd ? ['callback-polling'] : ['long-polling', 'callback-polling']
            };
            // Do not allow the user to mess with the required properties,
            // so merge first the user properties and *then* the bayeux message
            var message = $.extend({}, handshakeProps, bayeuxMessage);

            // We started a batch to hold the application messages,
            // so here we must bypass it and deliver immediately.
            _setStatus('handshaking');
            _deliver([message], false);
        };

        function _findTransport(handshakeResponse)
        {
            var transportTypes = handshakeResponse.supportedConnectionTypes;
            if (_xd)
            {
                // If we are cross domain, check if the server supports it, that's the only option
                if ($.inArray('callback-polling', transportTypes) >= 0) return _transport;
            }
            else
            {
                // Check if we can keep long-polling
                if ($.inArray('long-polling', transportTypes) >= 0) return _transport;

                // The server does not support long-polling
                if ($.inArray('callback-polling', transportTypes) >= 0) return newCallbackPollingTransport();
            }
            return null;
        };

        function _delayedHandshake()
        {
            _setStatus('handshaking');
            _delayedSend(function()
            {
                _handshake(_handshakeProps);
            });
        };

        function _delayedConnect()
        {
            _setStatus('connecting');
            _delayedSend(function()
            {
                _connect();
            });
        };

        function _delayedSend(operation)
        {
            _cancelDelayedSend();
            var delay = _backoff;
            _debug("Delayed send: backoff {}, interval {}", _backoff, _advice.interval);
            if (_advice.interval && _advice.interval > 0)
                delay += _advice.interval;
            _scheduledSend = _setTimeout(operation, delay);
        };

        function _cancelDelayedSend()
        {
            if (_scheduledSend !== null) clearTimeout(_scheduledSend);
            _scheduledSend = null;
        };

        function _setTimeout(funktion, delay)
        {
            return setTimeout(function()
            {
                try
                {
                    funktion();
                }
                catch (x)
                {
                    _debug('Exception during scheduled execution of function \'{}\': {}', funktion.name, x);
                }
            }, delay);
        };

        /**
         * Sends the connect message
         */
        function _connect()
        {
            _debug('Starting connect');
            var message = {
                channel: '/meta/connect',
                connectionType: _transport.getType()
            };
            _setStatus('connecting');
            _deliver([message], true);
            _setStatus('connected');
        };

        function _send(message)
        {
            if (_batch > 0)
                _messageQueue.push(message);
            else
                _deliver([message], false);
        };

        /**
         * Delivers the messages to the comet server
         * @param messages the array of messages to send
         */
        function _deliver(messages, comet)
        {
            // We must be sure that the messages have a clientId.
            // This is not guaranteed since the handshake may take time to return
            // (and hence the clientId is not known yet) and the application
            // may create other messages.
            $.each(messages, function(index, message)
            {
                message['id'] = _nextMessageId();
                if (_clientId) message['clientId'] = _clientId;
                messages[index] = _applyOutgoingExtensions(message);
            });

            var self = this;
            var envelope = {
                url: _url,
                messages: messages,
                onSuccess: function(request, response)
                {
                    try
                    {
                        _handleSuccess.call(self, request, response, comet);
                    }
                    catch (x)
                    {
                        _debug('Exception during execution of success callback: {}', x);
                    }
                },
                onFailure: function(request, reason, exception)
                {
                    try
                    {
                        _handleFailure.call(self, request, messages, reason, exception, comet);
                    }
                    catch (x)
                    {
                        _debug('Exception during execution of failure callback: {}', x);
                    }
                }
            };
            _debug('Sending request to {}, message(s): {}', envelope.url, JSON.stringify(envelope.messages));
            _transport.send(envelope, comet);
        };

        function _applyIncomingExtensions(message)
        {
            $.each(_extensions, function(index, extension)
            {
                var callback = extension.extension.incoming;
                if (callback && typeof callback === 'function')
                {
                    _debug('Calling incoming extension \'{}\', callback \'{}\'', extension.name, callback.name);
                    message = _applyExtension(extension.name, callback, message) || message;
                }
            });
            return message;
        };

        function _applyOutgoingExtensions(message)
        {
            $.each(_extensions, function(index, extension)
            {
                var callback = extension.extension.outgoing;
                if (callback && typeof callback === 'function')
                {
                    _debug('Calling outgoing extension \'{}\', callback \'{}\'', extension.name, callback.name);
                    message = _applyExtension(extension.name, callback, message) || message;
                }
            });
            return message;
        };

        function _applyExtension(name, callback, message)
        {
            try
            {
                return callback(message);
            }
            catch (x)
            {
                _debug('Exception during execution of extension \'{}\': {}', name, x);
                return message;
            }
        };

        function _handleSuccess(request, response, comet)
        {
            var messages = _convertToMessages(response);
            _debug('Received response {}', JSON.stringify(messages));
            var success = true;
            $.each(messages, function(index, message)
            {
                message = _applyIncomingExtensions(message);
                if (message.advice) _advice = message.advice;

                // Plain user messages do not have the successful property
                var successful = message.successful;
                success = success && (successful === undefined || successful);

                var channel = message.channel;
                switch (channel)
                {
                    case '/meta/handshake':
                        _handshakeSuccess(message);
                        break;
                    case '/meta/connect':
                        _connectSuccess(message);
                        break;
                    case '/meta/disconnect':
                        _disconnectSuccess(message);
                        break;
                    case '/meta/subscribe':
                        _subscribeSuccess(message);
                        break;
                    case '/meta/unsubscribe':
                        _unsubscribeSuccess(message);
                        break;
                    default:
                        _messageSuccess(message);
                        break;
                }
            });
            _transport.complete(request, success, comet);
        };

        function _handleFailure(request, messages, reason, exception, comet)
        {
            var xhr = request.xhr;
            _debug('Request failed, status: {}, reason: {}, exception: {}', xhr && xhr.status, reason, exception);
            $.each(messages, function(index, message)
            {
                var channel = message.channel;
                switch (channel)
                {
                    case '/meta/handshake':
                        _handshakeFailure(xhr, message);
                        break;
                    case '/meta/connect':
                        _connectFailure(xhr, message);
                        break;
                    case '/meta/disconnect':
                        _disconnectFailure(xhr, message);
                        break;
                    case '/meta/subscribe':
                        _subscribeFailure(xhr, message);
                        break;
                    case '/meta/unsubscribe':
                        _unsubscribeFailure(xhr, message);
                        break;
                    default:
                        _messageFailure(xhr, message);
                        break;
                }
            });
            _transport.complete(request, false, comet);
        };

        function _handshakeSuccess(message)
        {
            if (message.successful)
            {
                _debug('Handshake successful');
                // Save clientId, figure out transport, then follow the advice to connect
                _clientId = message.clientId;

                var newTransport = _findTransport(message);
                if (newTransport === null)
                {
                    throw 'Could not agree on transport with server';
                }
                else
                {
                    if (_transport.getType() != newTransport.getType())
                    {
                        _debug('Changing transport from {} to {}', _transport.getType(), newTransport.getType());
                        _transport = newTransport;
                    }
                }

                // Notify the listeners
                // Here the new transport is in place, as well as the clientId, so
                // the listener can perform a publish() if it wants, and the listeners
                // are notified before the connect below.
                _notifyListeners('/meta/handshake', message);

                var action = _advice.reconnect ? _advice.reconnect : 'retry';
                switch (action)
                {
                    case 'retry':
                        _delayedConnect();
                        break;
                    default:
                        break;
                }
            }
            else
            {
                _debug('Handshake unsuccessful');

                var retry = !_isDisconnected() && _advice.reconnect != 'none';
                if (!retry) _setStatus('disconnected');

                _notifyListeners('/meta/handshake', message);
                _notifyListeners('/meta/unsuccessful', message);

                // Only try again if we haven't been disconnected and
                // the advice permits us to retry the handshake
                if (retry)
                {
                    _increaseBackoff();
                    _debug('Handshake failure, backing off and retrying in {} ms', _backoff);
                    _delayedHandshake();
                }
            }
        };

        function _handshakeFailure(xhr, message)
        {
            _debug('Handshake failure');

            // Notify listeners
            var failureMessage = {
                successful: false,
                failure: true,
                channel: '/meta/handshake',
                request: message,
                xhr: xhr,
                advice: {
                    action: 'retry',
                    interval: _backoff
                }
            };

            var retry = !_isDisconnected() && _advice.reconnect != 'none';
            if (!retry) _setStatus('disconnected');

            _notifyListeners('/meta/handshake', failureMessage);
            _notifyListeners('/meta/unsuccessful', failureMessage);

            // Only try again if we haven't been disconnected and the
            // advice permits us to try again
            if (retry)
            {
                _increaseBackoff();
                _debug('Handshake failure, backing off and retrying in {} ms', _backoff);
                _delayedHandshake();
            }
        };

        function _connectSuccess(message)
        {
            var action = _isDisconnected() ? 'none' : (_advice.reconnect ? _advice.reconnect : 'retry');
            if (!_isDisconnected()) _setStatus(action == 'retry' ? 'connecting' : 'disconnecting');

            if (message.successful)
            {
                _debug('Connect successful');

                // End the batch and allow held messages from the application
                // to go to the server (see _handshake() where we start the batch).
                // The batch is ended before notifying the listeners, so that
                // listeners can batch other cometd operations
                _endBatch(true);

                // Notify the listeners after the status change but before the next connect
                _notifyListeners('/meta/connect', message);

                // Connect was successful.
                // Normally, the advice will say "reconnect: 'retry', interval: 0"
                // and the server will hold the request, so when a response returns
                // we immediately call the server again (long polling)
                switch (action)
                {
                    case 'retry':
                        _resetBackoff();
                        _delayedConnect();
                        break;
                    default:
                        _resetBackoff();
                        _setStatus('disconnected');
                        break;
                }
            }
            else
            {
                _debug('Connect unsuccessful');

                // Notify the listeners after the status change but before the next action
                _notifyListeners('/meta/connect', message);
                _notifyListeners('/meta/unsuccessful', message);

                // Connect was not successful.
                // This may happen when the server crashed, the current clientId
                // will be invalid, and the server will ask to handshake again
                switch (action)
                {
                    case 'retry':
                        _increaseBackoff();
                        _delayedConnect();
                        break;
                    case 'handshake':
                    	// Need to handshake again, meaning we probably need to 
                    	// resubscribe. Make sure that requests are batched
                    	if(0==_batch) _startBatch();
                    	_resubscribe();
                        // End the batch but do not deliver the messages until we connect successfully
                        _endBatch(false);
                        _resetBackoff();
                        _delayedHandshake();
                        break;
                    case 'none':
                        _resetBackoff();
                        _setStatus('disconnected');
                        break;
                }
            }
        };

        function _connectFailure(xhr, message)
        {
            _debug('Connect failure');

            // Notify listeners
            var failureMessage = {
                successful: false,
                failure: true,
                channel: '/meta/connect',
                request: message,
                xhr: xhr,
                advice: {
                    action: 'retry',
                    interval: _backoff
                }
            };
            _notifyListeners('/meta/connect', failureMessage);
            _notifyListeners('/meta/unsuccessful', failureMessage);

            if (!_isDisconnected())
            {
                var action = _advice.reconnect ? _advice.reconnect : 'retry';
                switch (action)
                {
                    case 'retry':
                        _increaseBackoff();
                        _debug('Connect failure, backing off and retrying in {} ms', _backoff);
                        _delayedConnect();
                        break;
                    case 'handshake':
                        _resetBackoff();
                        _delayedHandshake();
                        break;
                    case 'none':
                        _resetBackoff();
                        break;
                    default:
                        _debug('Unrecognized reconnect value: {}', action);
                        break;
                }
            }
        };

        function _disconnectSuccess(message)
        {
            if (message.successful)
            {
                _debug('Disconnect successful');
                _disconnect(false);
                _notifyListeners('/meta/disconnect', message);
            }
            else
            {
                _debug('Disconnect unsuccessful');
                _disconnect(true);
                _notifyListeners('/meta/disconnect', message);
                _notifyListeners('/meta/usuccessful', message);
            }
        };

        function _disconnect(abort)
        {
            _cancelDelayedSend();
            if (abort) _transport.abort();
            _clientId = null;
            _setStatus('disconnected');
            _batch = 0;
            _messageQueue = [];
            _resetBackoff();
        };

        function _disconnectFailure(xhr, message)
        {
            _debug('Disconnect failure');
            _disconnect(true);

            var failureMessage = {
                successful: false,
                failure: true,
                channel: '/meta/disconnect',
                request: message,
                xhr: xhr,
                advice: {
                    action: 'none',
                    interval: 0
                }
            };
            _notifyListeners('/meta/disconnect', failureMessage);
            _notifyListeners('/meta/unsuccessful', failureMessage);
        };

        function _subscribeSuccess(message)
        {
            if (message.successful)
            {
                _debug('Subscribe successful');
                _notifyListeners('/meta/subscribe', message);
            }
            else
            {
                _debug('Subscribe unsuccessful');
                _notifyListeners('/meta/subscribe', message);
                _notifyListeners('/meta/unsuccessful', message);
            }
        };

        function _subscribeFailure(xhr, message)
        {
            _debug('Subscribe failure');

            var failureMessage = {
                successful: false,
                failure: true,
                channel: '/meta/subscribe',
                request: message,
                xhr: xhr,
                advice: {
                    action: 'none',
                    interval: 0
                }
            };
            _notifyListeners('/meta/subscribe', failureMessage);
            _notifyListeners('/meta/unsuccessful', failureMessage);
        };

        function _unsubscribeSuccess(message)
        {
            if (message.successful)
            {
                _debug('Unsubscribe successful');
                _notifyListeners('/meta/unsubscribe', message);
            }
            else
            {
                _debug('Unsubscribe unsuccessful');
                _notifyListeners('/meta/unsubscribe', message);
                _notifyListeners('/meta/unsuccessful', message);
            }
        };

        function _unsubscribeFailure(xhr, message)
        {
            _debug('Unsubscribe failure');

            var failureMessage = {
                successful: false,
                failure: true,
                channel: '/meta/unsubscribe',
                request: message,
                xhr: xhr,
                advice: {
                    action: 'none',
                    interval: 0
                }
            };
            _notifyListeners('/meta/unsubscribe', failureMessage);
            _notifyListeners('/meta/unsuccessful', failureMessage);
        };

        function _messageSuccess(message)
        {
            if (message.successful === undefined)
            {
                if (message.data)
                {
                    // It is a plain message, and not a bayeux meta message
                    _notifyListeners(message.channel, message);
                }
                else
                {
                    _debug('Unknown message {}', JSON.stringify(message));
                }
            }
            else
            {
                if (message.successful)
                {
                    _debug('Publish successful');
                    _notifyListeners('/meta/publish', message);
                }
                else
                {
                    _debug('Publish unsuccessful');
                    _notifyListeners('/meta/publish', message);
                    _notifyListeners('/meta/unsuccessful', message);
                }
            }
        };

        function _messageFailure(xhr, message)
        {
            _debug('Publish failure');

            var failureMessage = {
                successful: false,
                failure: true,
                channel: message.channel,
                request: message,
                xhr: xhr,
                advice: {
                    action: 'none',
                    interval: 0
                }
            };
            _notifyListeners('/meta/publish', failureMessage);
            _notifyListeners('/meta/unsuccessful', failureMessage);
        };

        function _notifyListeners(channel, message)
        {
            // Notify direct listeners
            _notify(channel, message);

            // Notify the globbing listeners
            var channelParts = channel.split("/");
            var last = channelParts.length - 1;
            for (var i = last; i > 0; --i)
            {
                var channelPart = channelParts.slice(0, i).join('/') + '/*';
                // We don't want to notify /foo/* if the channel is /foo/bar/baz,
                // so we stop at the first non recursive globbing
                if (i == last) _notify(channelPart, message);
                // Add the recursive globber and notify
                channelPart += '*';
                _notify(channelPart, message);
            }
        };

        function _notify(channel, message)
        {
            var subscriptions = _listeners[channel];
            if (subscriptions && subscriptions.length > 0)
            {
                $.each(subscriptions, function(index, subscription)
                {
                    // Subscriptions may come and go, so the array may have 'holes'
                    if (subscription)
                    {
                        try
                        {
                            _debug('Notifying subscription: channel \'{}\', callback \'{}\'', channel, subscription.callback.name);
                            subscription.callback.call(subscription.scope, message);
                        }
                        catch (x)
                        {
                            // Ignore exceptions from callbacks
                            _warn('Exception during execution of callback \'{}\' on channel \'{}\' for message {}, exception: {}', subscription.callback.name, channel, JSON.stringify(message), x);
                        }
                    }
                });
            }
        };

        function _resetBackoff()
        {
            _backoff = 0;
        };

        function _increaseBackoff()
        {
            if (_backoff < _maxBackoff) _backoff += _backoffIncrement;
        };

        var _error = this._error = function(text, args)
        {
            _log('error', _format.apply(this, arguments));
        };

        var _warn = this._warn = function(text, args)
        {
            _log('warn', _format.apply(this, arguments));
        };

        var _info = this._info = function(text, args)
        {
            _log('info', _format.apply(this, arguments));
        };

        var _debug = this._debug = function(text, args)
        {
            _log('debug', _format.apply(this, arguments));
        };

        function _log(level, text)
        {
            var priority = _logPriorities[level];
            var configPriority = _logPriorities[_logLevel];
            if (!configPriority) configPriority = _logPriorities['info'];
            if (priority >= configPriority)
            {
                if (window.console) window.console.log(text);
            }
        };

        function _format(text)
        {
            var braces = /\{\}/g;
            var result = '';
            var start = 0;
            var count = 0;
            while (braces.test(text))
            {
                result += text.substr(start, braces.lastIndex - start - 2);
                var arg = arguments[++count];
                result += arg !== undefined ? arg : '{}';
                start = braces.lastIndex;
            }
            result += text.substr(start, text.length - start);
            return result;
        };

        function newLongPollingTransport()
        {
            return $.extend({}, new Transport('long-polling'), new LongPollingTransport());
        };

        function newCallbackPollingTransport()
        {
            return $.extend({}, new Transport('callback-polling'), new CallbackPollingTransport());
        };

        /**
         * Base object with the common functionality for transports.
         * The key responsibility is to allow at most 2 outstanding requests to the server,
         * to avoid that requests are sent behind a long poll.
         * To achieve this, we have one reserved request for the long poll, and all other
         * requests are serialized one after the other.
         */
        var Transport = function(type)
        {
            var _maxRequests = 2;
            var _requestIds = 0;
            var _cometRequest = null;
            var _requests = [];
            var _packets = [];

            this.getType = function()
            {
                return type;
            };

            this.send = function(packet, comet)
            {
                if (comet)
                    _cometSend(this, packet);
                else
                    _send(this, packet);
            };

            function _cometSend(self, packet)
            {
                if (_cometRequest !== null) throw 'Concurrent comet requests not allowed, request ' + _cometRequest.id + ' not yet completed';

                var requestId = ++_requestIds;
                _debug('Beginning comet request {}', requestId);
                var request = {id: requestId};
                self.deliver(packet, request);
                _cometRequest = request;
            };

            function _send(self, packet)
            {
                var requestId = ++_requestIds;
                _debug('Beginning request {}, {} other requests, {} queued requests', requestId, _requests.length, _packets.length);

                var request = {id: requestId};
                // Consider the comet request which should always be present
                if (_requests.length < _maxRequests - 1)
                {
                    _debug('Delivering request {}', requestId);
                    self.deliver(packet, request);
                    _requests.push(request);
                }
                else
                {
                    _packets.push([packet, request]);
                    _debug('Queued request {}, {} queued requests', requestId, _packets.length);
                }
            };

            this.complete = function(request, success, comet)
            {
                if (comet)
                    _cometComplete(request);
                else
                    _complete(this, request, success);
            };

            function _cometComplete(request)
            {
                var requestId = request.id;
                if (_cometRequest !== request) throw 'Comet request mismatch, completing request ' + requestId;

                // Reset comet request
                _cometRequest = null;
                _debug('Ended comet request {}', requestId);
            };

            function _complete(self, request, success)
            {
                var requestId = request.id;
                var index = $.inArray(request, _requests);
                // The index can be negative the request has been aborted
                if (index >= 0) _requests.splice(index, 1);
                _debug('Ended request {}, {} other requests, {} queued requests', requestId, _requests.length, _packets.length);

                if (_packets.length > 0)
                {
                    var packet = _packets.shift();
                    if (success)
                    {
                        _debug('Dequeueing and sending request {}, {} queued requests', packet[1].id, _packets.length);
                        _send(self, packet[0]);
                    }
                    else
                    {
                        _debug('Dequeueing and failing request {}, {} queued requests', packet[1].id, _packets.length);
                        packet[0].onFailure(packet[1], 'error');
                    }
                }
            };

            this.abort = function()
            {
                $.each(_requests, function(index, request)
                {
                    _debug('Aborting request {}', request.id);
                    if (request.xhr) request.xhr.abort();
                });
                if (_cometRequest)
                {
                    _debug('Aborting comet request {}', _cometRequest.id);
                    if (_cometRequest.xhr) _cometRequest.xhr.abort();
                }
                _cometRequest = null;
                _requests = [];
                _packets = [];
            };
        };

        var LongPollingTransport = function()
        {
            this.deliver = function(packet, request)
            {
                request.xhr = $.ajax({
                    url: packet.url,
                    type: 'POST',
                    contentType: 'text/json;charset=UTF-8',
                    beforeSend: function(xhr)
                    {
//                        xhr.setRequestHeader('Connection', 'Keep-Alive');
                        return true;
                    },
                    data: JSON.stringify(packet.messages),
                    success: function(response) { packet.onSuccess(request, response); },
                    error: function(xhr, reason, exception) { packet.onFailure(request, reason, exception); }
                });
            };
        };

        var CallbackPollingTransport = function()
        {
            var _maxLength = 2000;
            this.deliver = function(packet, request)
            {
                // Microsoft Internet Explorer has a 2083 URL max length
                // We must ensure that we stay within that length
                var messages = JSON.stringify(packet.messages);
                // Encode the messages because all brackets, quotes, commas, colons, etc
                // present in the JSON will be URL encoded, taking many more characters
                var urlLength = packet.url.length + encodeURI(messages).length;
                _debug('URL length: {}', urlLength);
                // Let's stay on the safe side and use 2000 instead of 2083
                // also because we did not count few characters among which
                // the parameter name 'message' and the parameter 'jsonp',
                // which sum up to about 50 chars
                if (urlLength > _maxLength)
                {
                    var x = packet.messages.length > 1 ?
                            'Too many bayeux messages in the same batch resulting in message too big ' +
                            '(' + urlLength + ' bytes, max is ' + _maxLength + ') for transport ' + this.getType() :
                            'Bayeux message too big (' + urlLength + ' bytes, max is ' + _maxLength + ') ' +
                            'for transport ' + this.getType();
                    // Keep the semantic of calling response callbacks asynchronously after the request
                    _setTimeout(function() { packet.onFailure(request, 'error', x); }, 0);
                }
                else
                {
                    $.ajax({
                        url: packet.url,
                        type: 'GET',
                        dataType: 'jsonp',
                        jsonp: 'jsonp',
                        beforeSend: function(xhr)
                        {
//                            xhr.setRequestHeader('Connection', 'Keep-Alive');
                            return true;
                        },
                        data:
                        {
                            // In callback-polling, the content must be sent via the 'message' parameter
                            message: messages
                        },
                        success: function(response) { packet.onSuccess(request, response); },
                        error: function(xhr, reason, exception) { packet.onFailure(request, reason, exception); }
                    });
                }
            };
        };
    };

    /**
     * The JS object that exposes the comet API to applications
     */
    $.cometd = new $.Cometd(); // The default instance

})(jQuery);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/jquery.auth-cookie.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

	// Localization
	var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

// === AUTH ====================================	

	var loginFormSchema = new $n2.form.Schema({
		attributes: [
			{
				name: 'user'
				,label: _loc('E-mail')
				,type: 'text'
			}
			,{
				name: 'password'
				,label: _loc('Password')
				,type: 'password'
			}
		]
		,buttons: [
			{ name: 'ok', label: _loc('OK') }
			,{ name: 'cancel', label: _loc('Cancel') }
		]
	});

	var loginFormSchemaWithGuest = new $n2.form.Schema({
		attributes: [
			{
				name: 'user'
				,label: _loc('E-mail')
				,type: 'text'
			}
			,{
				name: 'password'
				,label: _loc('Password')
				,type: 'password'
			}
		]
		,buttons: [
			{ name: 'ok', label: _loc('OK') }
			,{ name: 'cancel', label: _loc('Cancel') }
			,{ name: 'anonym', label: _loc('Guest Login') }
		]
	});

	var index = 0;
	var loginStateListeners = [];

	var addListeners = function(listeners) {
		var cUser = getCurrentUser();
		
		if( typeof listeners == "function" ) {
			addListener(listeners);
			
		} else if( listeners.constructor == Array ) {
			for(var loop=0; loop<listeners.length; ++loop) {
				var listener = listeners[loop];
				addListener(listener);
			};
		};
		
		function addListener(listener) {
			loginStateListeners.push(listener);
			try {
				listener(cUser);
			} catch(e) {
				log('$.NUNALIIT_AUTH: EXCEPTION caught in listener (add): '+e);
			};
		};
	};

	var notifyListeners = function() {
		var user = getCurrentUser();
		for(var loop=0; loop<loginStateListeners.length; ++loop) {
			var listener = loginStateListeners[loop];
			if( listener ) {
				try {
					listener(user);
				} catch(e) {
					log('$.NUNALIIT_AUTH: EXCEPTION caught in listener (notify): '+e);
				};
			};
		};
	};
	
	var _userLogin = function(options, anonymousFlag, username, password) {
		
		function doLogin() {
			$.ajax({
				type: 'GET'
				,url: options.url + '/login'
				,dataType: 'json'
				,data: {
					name: username
					,password: password
				}
				,async: true
				,success: onSuccess
				,error: onError
			});
		};
		
		var loginRetries = 0;
		var loginRetryLimit = 3;
		/*
		 * @return: true => login retry initiated.
		 */
		function retryLogin() {
			loginRetries++;
			if (loginRetries <= loginRetryLimit) {
				doLogin();
				return(true);
			};
			return(false);
		};
		
		function clearLoginForm() {
			if (!options.autoAnonymousLogin || !anonymousFlag) { // hide user-visible form...
				options.dialog.dialog('close');
			};
		};
		
		function doErrorNotification(causeObj) {
			if (options.autoAnonymousLogin && anonymousFlag) {
				/*
				 * if autoAnonymousLogin in process, attempt to suppress error notification
				 * and retry the login.  If limit reached, notification is sent.
				 */
				var retrying = retryLogin();
				if (retrying) {
					return;
				};
			};
				
			var err = {
				message: 'Invalid e-mail and/or password'
			};
			if (null != causeObj) {
				err.cause = causeObj;
			};
			clearLoginForm();
			options.onError(err,options);
			notifyListeners();
		};
		
		function onSuccess(result) {

			log("Login successful",result,options);
			
			if( result && result.logged ) {
			
				clearLoginForm();
				options.onSuccess(result,options);
				notifyListeners();

			} else {
				doErrorNotification(null);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			log("Login error", xmlHttpRequest, textStatus, errorThrown);
			doErrorNotification({ message: textStatus });
		};
		
		if( anonymousFlag ) {
			username = options.anonymousUser;
			password = options.anonymousPw;
		};
		doLogin();
	};
	
	var defaultError = function(err, options) {
		var acc = [];
		
		if( err ) {
			acc.push(''+err.message);
			var cause = err.cause;
			while( cause ) {
				acc.push('\n>'+cause.message);
				cause = cause.cause;
			};
		} else {
			acc.push('<Unknown error>');
		};
		
		alert(acc.join(''));
	};
	
	var initOptions = {};
	var defaultOptions = {
		onSuccess: function(result,options) {}
		,onError: defaultError
		,anonymousLoginAllowed: false
		,anonymousUser: 'anonymous'
		,anonymousPw: 'anonymous'
		,autoAnonymousLogin: false
		,prompt: 'Please login'
		,url: './auth'
	};

	/**
	 * This function should be called when a page is first loading.
	 * It performs a special version of 'login' where 401 is never
	 * returned. This allows to adjust the cookie in case the authentication
	 * was lost but the cookie was not. This happens in certain cases
	 * where the browser crashes.
	 *
	 * In the case of autoAnonymousLogin, this function also ensures that the
	 * identified anonymous user is logged in before returning.  This is used to ensure
	 * that the application has basic access to the server database before full application
	 * initialization is launched.  Technically, this could be done in the callback but
	 * that would mean every application desiring that service would need to write a
	 * callback to initiate a login and this seems like a useful service to provide
	 * here.  To make autoAnonymousLogin behave as if the user has not logged in, because
	 * they are unaware that it has happened, this needs to retain some logic concerning
	 * the option anyway (e.g., whether or not to show the guest login button which serves
	 * no purpose if auto anonymous login is being maintained) so it may
	 * as well live here.
	 *
	 * Note that the callbacks (onSuccess, onError) in the initOptions are
	 * really specific to the init (for example, in many cases triggering application
	 * initilization once database access is ready) and should NOT be maintained
	 * as callbacks for use by all auth interactions.  So on a init completion, 
	 * these callback options are deleted.  The other auth interfaces (login,
	 * logout) can include context specific callbacks as parameters when needed.
	 * 
	 * Similarly, once auth listeners are added, they are deleted from the initOptions.
	 *
	 * The interface to the auth package is still flexible enough:
	 * 1) Other interfaces include options and can include call-specific callbacks as
	 *    needed.
	 * 2) Listeners can be added post-initialization using the addListener() interface.
	 */
	var init = function(options_) {
		
		initOptions = $.extend({},defaultOptions,options_);
		
		// Install login state listeners - don't retain as stored options.
		if( initOptions.listeners ) {
			addListeners(initOptions.listeners);
			delete initOptions.listeners;
		};
		
		/*
		 * carry either default or provided fns for onSuccess or onError
		 * and remove these from the stored options ... they are usually
		 * not appropriate for use as login and logout callbacks.
		 */
		var initOnSuccess = initOptions.onSuccess;
		delete initOptions.onSuccess;
		var initOnError = initOptions.onError;
		delete initOptions.onError;
		
		var optWithCallbacks = $.extend({}, // use this as init callback
			initOptions,
			{
				onSuccess: initOnSuccess
				,onError: initOnError
			}
		);
		
		$.ajax({
			type: 'GET'
			,url: initOptions.url + '/adjust'
			,dataType: 'json'
			,async: true
			,success: onSuccess
			,error: onError
		});
				
		function onSuccess(result) {
			$n2.log("Login(adjustCookies) successful", result, initOptions);
			if( false == result.logged && initOptions.autoAnonymousLogin ) {
				/*
				 * auto login will do notifications when appropriate so it is alright
				 * to skip notifyListeners() in this case.
				 */
				_userLogin(optWithCallbacks, true);
			} else {
				initOnSuccess(result, optWithCallbacks);
				notifyListeners();
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			log("Login(adjustCookies) error", xmlHttpRequest, textStatus, errorThrown);
			
			if (initOptions.autoAnonymousLogin) { // auto login will do notifications when appropriate
				_userLogin(optWithCallbacks, true);
			} else {
				var err = {
					message: 'Problem initializing authentication library'
					,cause: {
						message: textStatus
					}
				};
				initOnError(err, optWithCallbacks);
				notifyListeners();
			};
		};
	};
	
	var autoAnonLogin = function(options_) {
		var options = $.extend({}, defaultOptions, initOptions, options_);
		_userLogin(options, true);
	};
		
	var showLoginForm = function(options_) {
		
		var options = $.extend({}, defaultOptions, initOptions, options_);
		
		var myIndex = index;
		++index;
		options.index = myIndex;
		
		var $dialog = $('<div></div>');
		options.dialog = $dialog;
		$(document.body).append($dialog);

		var formOptions = {
			buttonPressed: function(loginForm, buttonName){
				if( 'ok' === buttonName ) {
					var user = loginForm.getInputFromName('user').getCurrentValue();
					var password = loginForm.getInputFromName('password').getCurrentValue();

					_userLogin(options, false, user, password);

				} else if( 'cancel' === buttonName ) {
					$dialog.dialog('close');

				} else if( 'anonym' === buttonName ) {
					_userLogin(options, true);
				}
			}
		};

		if( options.anonymousLoginAllowed 
		 && !options.autoAnonymousLogin ) { // no need for guest button if auto logged in
			var $n2Form = loginFormSchemaWithGuest.createForm($dialog,{},formOptions);
		} else {
			var $n2Form = loginFormSchema.createForm($dialog,{},formOptions);
		};
		
		var dialogOptions = {
			autoOpen: true
			,modal: true
			,width: 'auto'
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		if( options.prompt ) {
			dialogOptions.title = options.prompt;
		}
		$dialog.dialog(dialogOptions);
	};
	
	var logout = function(options_) {
		
		var options = $.extend({}, defaultOptions, initOptions, options_);

		// Provide bogus credentials in order to wipe the valid
		// ones stored in the browser.
		$.ajax({
			type: 'GET'
			,url: options.url + '/logout'
			,username: '_'
			,password: '_'
			,dataType: 'json'
			,data: {
				name: '_'
			}
			,async: true
			,success: onSuccess
			,error: onError
		});
		
		function onSuccess(result) {

			log("Logout successful",result,options);
			
			if( result && !result.logged ) {
				
				options.onSuccess(result,options);
		
				notifyListeners();

			} else {
				var err = {message:'Error on logout'};
				options.onError(err,options);
				
				notifyListeners();
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			log("Logout error", xmlHttpRequest, textStatus, errorThrown);
			
			var err = {
				message:'Error on logout'
				,cause: {
					message: textStatus
				}
			};
			options.onError(err,options);
			
			notifyListeners();
		};
	};
	
	var getCurrentUser = function() {
		var user = null;

		var authContext = getAuthContext();
		if( authContext && authContext.logged ) {
			user = authContext.user;
		};

		return user;
	};

	var getAuthContext = function() {
		var context = null;
		var cookie = $.cookie('nunaliit-auth');

		if( cookie ) {
			eval('context = '+cookie+';');
		};
		
		if( !context ) {
			context = {
				logged: false	
			};
		};
		
		return context;
	};
	
	function isDeleteAllowed() {
		var user = getCurrentUser();
		return(null != user && user.admin); 
	}
	
	function isUpdateAllowed(contribCreatorDisplayName) {
		var allowed = false;
		var user = getCurrentUser();
		if (null != user) {
			if (user.admin) {
				allowed = true;
			} else if (!user.anonymous &&
				"" != contribCreatorDisplayName && // specific case for undefined contributor info
				user.display == contribCreatorDisplayName) {
				allowed = true;
			}
		}
		return(allowed); 
	}
	
	var isLoggedIn = function() {
		var authContext = getAuthContext();
		if( authContext && authContext.logged ) {
			return true;
		};

		return false;
	};
	
	var isUser = function() {
		if( !isLoggedIn() ) return false;
		
		var user = getCurrentUser();
		if( user.anonymous ) return false;
		
		return true;
	};
	
	var isAdmin = function() {
		if( !isLoggedIn() ) return false;
		
		var user = getCurrentUser();
		if( user.admin ) return true;
		
		return false;
	};
	
	var isAnonymous = function() {
		if( !isLoggedIn() ) return false;
		
		var user = getCurrentUser();
		if( user.anonymous ) return true;
		
		return false;
	};
    
	function userLoggedInAndNotAnonymous() {
		var user = getCurrentUser();
		return(null != user && !user.anonymous);
	}
	
	function autoAnonymousBehaviour() {
		return(isDefined(initOptions.autoAnonymousLogin) && initOptions.autoAnonymousLogin);
	}
	
	$.NUNALIIT_AUTH = {
		getUser: getCurrentUser

		,getAuthContext: getAuthContext
		
		,init: init
	
		,login: showLoginForm
		
		,logout: logout
		
		,addListener: addListeners
		
		,isDeleteAllowed: isDeleteAllowed
		
		,isUpdateAllowed: isUpdateAllowed
		
		,isLoggedIn: isLoggedIn
		
		,isUser: isUser
		
		,isAdmin: isAdmin
		
		,isAnonymous: isAnonymous
		
		,userLoggedInAndNotAnonymous: userLoggedInAndNotAnonymous
		
		,autoAnonymousBehaviour: autoAnonymousBehaviour
		
		,autoAnonLogin: autoAnonLogin
	};
})(jQuery,nunaliit2);


// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/dbweb.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($) {
"use strict";

//**************************
// Requires:
//     json2.js (http://www.JSON.org/js.html)

// === Error ====================================	

	// Given an error returned on xmlHttpRequest, attempt to recover
	// text error returned, if any is available	
	var convertXmlHttpRequestError = function(xmlHttpRequest, textStatus) {
		try {
			var responseText = xmlHttpRequest.responseText;
			var msg = null;
			eval('msg = '+responseText+';');
			if( msg.error ) {
				return msg.error;
			}
		} catch(e) {
		}
		return { message: 'Server error: '+textStatus };
	};
	
	
// === DBWEB ====================================	

	var defaultOptions = {
		url: './dbWeb'
		,onSuccess: function(result,options){}
		,onError: function(result,options){}
	};
	
	var addTable = function(data,options) {
		data.table = options.tableName;
	};

	var addWhereClauses = function(data,options) {
		if( options.whereClauses ) { // whereClauses is an array (can't use field name as key - it could be repeated with different tests)
			data.where = []; // these are actually SQL where constructs
			for(var i=0; i<options.whereClauses.length; i++) {
				data.where.push(options.whereClauses[i]);
			};
		};
	};
	
	var addSelects = function(data,options) {
		if( options.selects ) {
			data.select = []; // list of columns to include in query response
			for(var i=0; i<options.selects.length; i++) {
				data.select.push(options.selects[i]);
			};
		};
	};

	var addGrouping = function(data,options) {
		if( options.groupBys ) {
			data.groupBy = []; // list of columns to group by
			for(var i=0; i<options.groupBys.length; i++) {
				data.groupBy.push(options.groupBys[i]);
			};
		};
	};

	var addOrder = function(data,options) {
		if( options.orderBy ) {
			data.orderBy = options.orderBy;
		};
	};

	var addLimit = function(data,options) {
		if( options.limit ) {
			data.limit = options.limit;
		};
		if( options.offset ) {
			data.offset = options.offset;
		};
	};

	var addSetters = function(data,options) {
		if( options.setters ) {
			data.set = [];
			for( var key in options.setters ) {
				var value = options.setters[key];
				data.set.push(''+key+','+value);
			};
		};
	};
	
	var configure = function(options_) {
		var options = $.extend({},defaultOptions,options_);
		defaultOptions = options;
	};
	
	var getCapabilities = function(options_) {
		var options = $.extend({},defaultOptions,options_);

		var data = {};
		
		$.ajax({
			type: 'GET'
			,url: options.url + '/getCapabilities'
			,data: data
			,dataType: 'json'
			,async: true
			,success: onSuccess
			,error: onError
		});

		function onSuccess(result) {

			if( result.error ) {
				options.onError(result.error,options);
				
			} else if( result.capabilities ) {
				options.onSuccess(result.capabilities,options);
				
			} else {
				options.onError({message:'Capabilities not returned'},options);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			var e = convertXmlHttpRequestError(xmlHttpRequest, textStatus);
			options.onError(e,options);
		};
	};
	
	var getSchema = function(options_) {
		var options = $.extend({},defaultOptions,options_);

		var data = {};
		
		addTable(data,options);
		
		$.ajax({
			type: 'GET'
			,url: options.url + '/getSchema'
			,data: data
			,dataType: 'json'
			,async: true
			,success: onSuccess
			,error: onError
		});

		function onSuccess(result) {
			if( result.error ) {
				options.onError(result.error,options);
			} else {
				options.onSuccess(result,options);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			var e = convertXmlHttpRequestError(xmlHttpRequest, textStatus);
			options.onError(e,options);
		};
	};
	
	var query = function(options_) {
		var options = $.extend({},defaultOptions,options_);

		var data = {};
		
		addTable(data,options);
		addWhereClauses(data,options);
		addSelects(data,options);
		addGrouping(data,options);
		addOrder(data,options);
		addLimit(data,options);

		$.ajax({
			type: 'POST'
			,url: options.url + '/query'
			,data: data
			,dataType: 'json'
			,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
			,async: true
			,traditional: true
			,success: onSuccess
			,error: onError
		});

		function onSuccess(result) {
			if( result.error ) {
				options.onError(result.error,options);
				
			} else if( result.queried ) {
				options.onSuccess(result.queried,options);
				
			} else {
				options.onError({message:'Queried objects not returned'},options);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			var e = convertXmlHttpRequestError(xmlHttpRequest, textStatus);
			options.onError(e,options);
		};
	};
	
	var queries = function(options_) {
		var options = $.extend({},defaultOptions,options_);

		var queries = options.queries;
		if( null == queries ) {
			options.onError({
				message: '"queries" not specified'
				},options_);
			return;
		};

		// loop over queries
		var request = {};
		for(var queryIndex=0; queryIndex<queries.length; ++queryIndex) {
			var query = queries[queryIndex];
			var queryObj = {};

			// Associate query with key			
			request['q'+queryIndex] = queryObj;

			// Add table name
			queryObj.table = query.tableName;
			if( !queryObj.table ) {
				options.onError({
					message: 'Missing table name'
					},options_);
				return;
			}

			// Add field selectors
			if( query.selects ) {
				queryObj.select = query.selects;
			}
			
			// Add record selectors
			if( query.whereClauses ) {
				queryObj.where = query.whereClauses;
			}
			
			// Add grouping
			if( query.groupBys ) {
				queryObj.groupBy = query.groupBys;
			}
			
			// Add orderBy
			if( query.orderBy ) {
				queryObj.orderBy = query.orderBy;
			}
			
			// Add limit
			if( query.limit ) {
				queryObj.limit = query.limit;
			}
			
			// Add offset
			if( query.offset ) {
				queryObj.offset = query.offset;
			}
		}

		var jsonString = JSON.stringify(request);
		var data = {
			queries: jsonString
		};
		
		$.ajax({
			type: 'POST'
			,url: options.url + '/queries'
			,data: data
			,dataType: 'json'
			,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
			,async: true
			,success: onSuccess
			,error: onError
			,traditional: true
		});

		function onSuccess(result) {
			if( result.error ) {
				options.onError(result.error,options_);
				
			} else {
				for(var queryIndex=0; queryIndex<queries.length; ++queryIndex) {
					var query = queries[queryIndex];
					var key = 'q'+queryIndex;
					var response = result[key];
					
					if( null == response ) {
						query.error = {message:'No Response'};
						
					} else if( typeof response == 'object'
					  && typeof response.length == 'number' ) {
						// Success
						query.results = response;
					  
					} else if( typeof response == 'object'
					  && typeof response.message == 'string' ) {
						query.error = response;
					  
					} else {
						query.error = {message:'Unrecognized response'};
					} 
				};
				
				options.onSuccess(queries,options_);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			var e = convertXmlHttpRequestError(xmlHttpRequest, textStatus);
			options.onError(e,options);
		};
	};
	
	var insert = function(options_) {
		var options = $.extend({},defaultOptions,options_);

		var data = {};
		
		addTable(data,options);
		addSetters(data,options);
		
		$.ajax({
			type: 'POST'
			,url: options.url + '/insert'
			,data: data
			,dataType: 'json'
			,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
			,async: true
			,success: onSuccess
			,error: onError
			,traditional: true
		});

		function onSuccess(result) {
			if( result.error ) {
				options.onError(result.error,options);
				
			} else if( result.inserted ) {
				options.onSuccess(result.inserted,options);
				
			} else {
				options.onError({message:'Inserted objects not returned'},options);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			var e = convertXmlHttpRequestError(xmlHttpRequest, textStatus);
			options.onError(e,options);
		};
	};
	
	var update = function(options_) {
		var options = $.extend({},defaultOptions,options_);

		var data = {};
		
		addTable(data,options);
		addWhereClauses(data,options);
		addSetters(data,options);
		
		$.ajax({
			type: 'POST'
			,url: options.url + '/update'
			,data: data
			,dataType: 'json'
			,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
			,async: true
			,success: onSuccess
			,error: onError
			,traditional: true
		});

		function onSuccess(result) {
			if( result.error ) {
				options.onError(result.error,options);
				
			} else if( result.updated ) {
				options.onSuccess(result.updated,options);
				
			} else {
				options.onError({message:'Updated objects not returned'},options);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			var e = convertXmlHttpRequestError(xmlHttpRequest, textStatus);
			options.onError(e,options);
		};
	};
	
	var remove = function(options_) {
		var options = $.extend({},defaultOptions,options_);

		var data = {};
		
		addTable(data,options);
		addWhereClauses(data,options);
		
		$.ajax({
			type: 'POST'
			,url: options.url + '/delete'
			,data: data
			,dataType: 'json'
			,contentType: 'application/x-www-form-urlencoded; charset=utf-8'
			,async: true
			,success: onSuccess
			,error: onError
			,traditional: true
		});

		function onSuccess(result) {
			if( result.error ) {
				options.onError(result.error,options);
				
			} else {
				options.onSuccess(result,options);
			};
		};
		
		function onError(xmlHttpRequest, textStatus, errorThrown) {
			var e = convertXmlHttpRequestError(xmlHttpRequest, textStatus);
			options.onError(e,options);
		};
	};
	
	// where clause: comparison enum values
	var whereComparison_eq = 'eq'; // equal
	var whereComparison_ne = 'ne'; // not equal
	var whereComparison_ge = 'ge'; // greater than or equal
	var whereComparison_le = 'le'; // less than or equal
	var whereComparison_gt = 'gt'; // greater than
	var whereComparison_lt = 'lt'; // less than
	var whereStatus_null   = 'null';
	var whereStatus_notNull = 'notNull';
	var orderByAscending = 'a';
	var orderByDescending = 'd';
	
	
	var formatWhereClause = function(column, compEnum, value) {
		/*
		 * value may be null in which case, this should be a non comparison where (eg., is null).
		 *
		 * In either case, first two parameters should be strings, one of which is provided by
		 * the enums above...
		 */
		if (null == value) {
			return compEnum + '(' + column + ')';
		} else {
			return compEnum + '(' + column + ')' + value;
		};
	};

	var formatSearchStringRecordSelector = function(searchString, column1, column2) {

		var selector = 'search(';
		for(var loop=1; loop<arguments.length; ++loop) {
			if( 1 != loop ) { selector += ','; }
			selector += arguments[loop];			
		}
		selector += ')';
		selector += searchString;
		return selector;
	};
	
	var formatFieldSelectorColumn = function(column) {
		return ''+column;
	};
	
	// select clause: aggregation functions
	var selectAggregator_min = 'min'; // minimum
	var selectAggregator_max = 'max'; // maximum
	var selectAggregator_sum = 'sum'; // summation
	var formatFieldSelectorFunction = function(column, aggEnum) {
		/*
		 * aggEnum may be null in which case the column name is unmodified (no aggregation requested)
		 *
		 * In either case, first two parameters if provided should be strings,
		 * one of which is provided by the enums above...
		 */
		if (null == aggEnum) {
			return(column);
		} else {
			return(aggEnum + '(' + column + ')');
		};
	};
	
	var formatFieldSelectorScoreSubstring = function(searchString) {
		var selector = 'score(';
		for(var loop=1; loop<arguments.length; ++loop) {
			if( 1 != loop ) { selector += ','; }
			selector += arguments[loop];			
		}
		selector += ')';
		selector += searchString;
		return selector;
	};
	
	var formatFieldSelectorCentroid = function(axis,fieldName) {
		return 'centroid('+axis+','+fieldName+')';
	};
	
	var formatOrderBy = function(type, fieldSelector) {
		return type+','+fieldSelector;
	};
	
	$.NUNALIIT_DBWEB = {
		// main async data operations
		getCapabilities: getCapabilities
		,getSchema: getSchema
		,query: query
		,queries: queries
		,insert: insert
		,update: update
		,remove: remove
		,configure: configure
		
		// enums for formatting where clause entries
		,whereComparison_eq: whereComparison_eq
		,whereComparison_ne: whereComparison_ne
		,whereComparison_ge: whereComparison_ge
		,whereComparison_le: whereComparison_le
		,whereComparison_gt: whereComparison_gt
		,whereComparison_lt: whereComparison_lt
		,whereStatus_null: whereStatus_null
		,whereStatus_notNull: whereStatus_notNull
		,orderByAscending: orderByAscending
		,orderByDescending: orderByDescending
		
		// enums for formatting select clause entries
		,selectAggregator_min: selectAggregator_min
		,selectAggregator_max: selectAggregator_max
		,selectAggregator_sum: selectAggregator_sum
		
		// formatting helpers
		,formatWhereClause: formatWhereClause
		,formatSearchStringRecordSelector: formatSearchStringRecordSelector
		,formatFieldSelectorColumn: formatFieldSelectorColumn
		,formatFieldSelectorFunction: formatFieldSelectorFunction
		,formatFieldSelectorScoreSubstring: formatFieldSelectorScoreSubstring
		,formatFieldSelectorCentroid: formatFieldSelectorCentroid
		,formatOrderBy: formatOrderBy
	};
	
	//===========================================================================================
	// dbWebForm
	$.fn.dbWebForm = function(options_) {
		var jqSet = this;

		var options = $.extend(
			{}
			,defaultOptions
			,{
				installButtons: null
				,data: {}
				,fieldOpts: {} // defaultValue in here can be value or function returning a value
				,onAlert: function(str){ alert(str); }
				,onError: printError
			}
			,options_
			);

		// Request schema
		var getSchemaOptions = $.extend({},defaultOptions,options_,{
			onSuccess: onGetSchemaSuccess
			,onError: onSchemaError
		});
		getSchema(getSchemaOptions);

		// Query objects if required
		if( options.whereClauses ) {
			var queryOptions = $.extend({},defaultOptions,options_,{
				onSuccess: onQuerySuccess
				,onError: onQueryError
			});
			query(queryOptions);
		};
		
		var data = {};
		
		function onGetSchemaSuccess(schema) {
			//log('schema',schema);
			data.schema = schema;
			
			// Check that table can be queried
			if( schema.isQueryAllowed ) {
				// OK
			} else {
				reportError({message:'User does not have privilege to query this data'});
				return;
			}
			
			// In case of update, check that update is allowed
			if( options.whereClauses ) { 
				if( schema.isUpdateAllowed ) {
					// OK
				} else {
					reportError({message:'User does not have privilege to update this data'});
					return;
				};
			} else {
				// In case of insert, check that insert is allowed
				if( schema.isInsertAllowed ) {
					// OK
				} else {
					reportError({message:'User does not have privilege to insert new data'});
					return;
				};
			};
			
			onDataAvailable();
		};
		
		function onSchemaError(cause) {
			error = {
				message: 'Error while retrieving schema'
				,cause: cause
			};
			//log('error',error);
			options.onError(error,options);
		};
		
		function onQuerySuccess(queriedObjects) {
			//log('queriedObjects',queriedObjects);
			data.queriedObjects = queriedObjects;
			onDataAvailable();
		};
		
		function onQueryError(cause) {
			error = {
				message: 'Error while querying for data'
				,cause: cause
			};
			//log('error',error);
			options.onError(error,options);
		};
		
		function reportError(error) {
			options.onError(error,options);
		};
		
		function printError(error) {
			var elem = $( jqSet.get(0) );

			var html = [];
			html.push('<div class="dbweb-error">');
			html.push('Error: ');
			html.push(error.message);
			html.push('</div>');
			
			elem.empty();
			elem.html( html.join('') );
		};
		
		function onDataAvailable() {
			if( data.error ) {
				reportError(data.error);
				return;
			};
			
			// A schema is needed
			if( !data.schema ) {
				return;
			};

			// Check if a queried object is required
			if( options.whereClauses ) {
				// A set of selectors were specified. Then, we need to wait for
				// the query request to return
				if( !data.queriedObjects ) {
					return;
				};
				
				// Check returned query request
				if( data.queriedObjects.length < 1 ) {
					reportError({message:'Data can not be edited by current user.'});
					return;
				};
				if( data.queriedObjects.length > 1 ) {
					reportError({message:'Multiple records were returned. Can not proceed with editing.'});
					return;
				};
				
				// Quicker access
				data.queryData = data.queriedObjects[0];
			} else {
				// Insert mode. Use data provided by caller
				data.queryData = options.data;
			};
			
			var elem = $( jqSet.get(0) );

			elem.empty();

			var div = $('<div class="dbweb-form"></div>');
			elem.append(div);
			
			var form = $('<form></form>');
			div.append(form);

			var ul = $('<ul></ul>');
			form.append(ul);

			data.form = {};
			var columns = data.schema.columns;
			for(var loop=0; loop<columns.length; ++loop) {
				var column = columns[loop];
				var columnName = column.column;

				if( column.write ) {
					if( options.fieldOpts[columnName] ) {
						// Special handling specified by caller
						var fieldOpts = options.fieldOpts[columnName];
						
						var mustHide = fieldOpts.hide;
						if( typeof mustHide === 'function' ) {
							mustHide = mustHide();
						};

						if( mustHide ) {
							// Nothing to do
							
						} else if( fieldOpts.choices ) {
							addChoicesInput(form, ul, columnName, fieldOpts);
							
						} else if( fieldOpts.select ) {
							addCallbackInput(form, ul, columnName, fieldOpts);
							
						} else if( 'DATE' == column.type ) { // date could have defaultValue
							addDateInput(form, ul, columnName, fieldOpts);

						} else {
							// Just regular input - but could have defaultValue
							addRegularInput(form, ul, columnName, fieldOpts);

						};
					} else if( 'DATE' == column.type ) {
						addDateInput(form, ul, columnName, {});

					} else {
						// Just regular input
						addRegularInput(form, ul, columnName, {});
					};
				};
			};
			
			// Add buttons
			var buttons = {};

			if( options.whereClauses ) {
				buttons['Save'] = function(saveOptions) {
					updateRecord(data.form,saveOptions);
				};
			} else {
				buttons['Save'] = function(saveOptions) {
					insertRecord(data.form,saveOptions);
				};
			};
			
			// Delete button is available only on update to users
			// allowed to delete
			if( data.schema.isDeleteAllowed && options.whereClauses ) {
				buttons['Delete'] = function(delOptions) {
					delRecord(data.form,delOptions);
				};
			};
			
			if( options.installButtons ) {
				// Tell caller to install buttons since form was
				// created
				options.installButtons(buttons);
			} else {
				var btnDiv = $('<div class="dbweb-buttons"></div>');
				div.append(btnDiv);
				
				if( buttons['Save'] ) {
					var btn = $('<input type="button" value="'+(options.whereClauses?'Update':'Insert')+'"/>');
					btn.click(function(evt){
						buttons['Save']();
						return false;
					});
					btnDiv.append(btn);
				}
				
				if( buttons['Delete'] ) {
					var btn = $('<input type="button" value="Delete"/>');
					btn.click(function(evt){
						buttons['Delete']();
						return false;
					});
					btnDiv.append(btn);
				}
			}
		};

		function retrieveDefaultValue(fieldOpts) {
			var ret = null;
			if ('function' == typeof(fieldOpts.defaultValue)) {
				ret = fieldOpts.defaultValue();
			} else {
				ret = fieldOpts.defaultValue;
			};
			return ret;
		};
		
		function addRegularInput(formElem, ulElem, columnName, fieldOpts) {
			var value = '';
			var valueAttr = '';
			if( "undefined" != typeof( data.queryData[columnName] ) ) {
				value = data.queryData[columnName];
				valueAttr = ' value="'+value+'"';
			} else if( "undefined" != typeof( fieldOpts.defaultValue ) ) {
				value = retrieveDefaultValue(fieldOpts);
				valueAttr = ' value="'+value+'"';
			};
			
			var li = $('<li></li>');
			appendLabel(li,columnName);
			
			var input = $('<input class="dbWebFormInput" type="text" name="'+columnName+'"'+valueAttr+'/>');
			li.append(input);
			
			saveInput(columnName, input, value);

			ulElem.append(li);
		};
		
		function addDateInput(formElem, ulElem, columnName, fieldOpts) {
			var value = '';
			var valueAttr = '';
			if (isDefined(data.queryData[columnName]) && isDefined(data.queryData[columnName].formatted)) {
				// object returned in JSON query - OBJECT
				value = data.queryData[columnName].formatted;
				valueAttr = ' value="'+value+'"';
			} else if (isDefined(fieldOpts.defaultValue)) { // provide in client side code as STRING
				value = retrieveDefaultValue(fieldOpts);
				valueAttr = ' value="'+value+'"';
			};
			
			var li = $('<li></li>');
			appendLabel(li,columnName);
			
			var input = $('<input class="dbWebFormInput" type="text" name="'+columnName+'"'+valueAttr+'/>');
			input.datepicker({
				dateFormat: 'yy-mm-dd'
				,gotoCurrent: true
				,changeYear: true
			});
			li.append(input);
			saveInput(columnName, input, value);

			ulElem.append(li);
		};

		function addChoicesInput(formElem, ulElem, columnName, fieldOpts) {
			var value = '';
			if( "undefined" != typeof( data.queryData[columnName] ) ) {
				value = data.queryData[columnName];
			} else if( "undefined" != typeof( fieldOpts.defaultValue ) ) {
				value = retrieveDefaultValue(fieldOpts);
			};

			var li = $('<li></li>');
			appendLabel(li,columnName);
			
			var input = $('<select class="dbWebFormSelect"></select>');
			for(var loop=0; loop<fieldOpts.choices.length; ++loop) {
				var choice = fieldOpts.choices[loop];
				
				var html = [];
				html.push('<option value="'+choice.value);
				if( value == choice.value ) {
					html.push('" selected="true');
				};
				html.push('">');
				if( choice.label ) {
					html.push(choice.label);
				} else {
					html.push(choice.value);
				};
				html.push('</option>');
				
				input.append( $(html.join('')) );
			};
			li.append(input);
			
			saveInput(columnName, input, value);

			ulElem.append(li);
		};
		
		function addCallbackInput(formElem, ulElem, columnName, fieldOpts) {
			var value = '';
			var valueAttr = '';
			if( "undefined" != typeof( data.queryData[columnName] ) ) {
				value = data.queryData[columnName];
				valueAttr = ' value="'+value+'"';
			} else if( "undefined" != typeof( fieldOpts.defaultValue ) ) {
				value = retrieveDefaultValue(fieldOpts);
				valueAttr = ' value="'+value+'"';
			};

			var li = $('<li></li>');
			appendLabel(li,columnName);
			
			var input = $('<input class="dbWebFormInput" type="text" name="'+columnName+'"'+valueAttr+'/>');
			li.append(input);
			
			// Add a button to select via the callback
			var button = $('<input class="dbWebFormSelectButton" type="button" value="..."/>');
			button.click(function(evt){
				fieldOpts.select(onSelect);
				return false;
			});
			li.append(button);

			saveInput(columnName, input, value);

			ulElem.append(li);

			function onSelect(value_) {
				input.val(value_);
			};
		};

		function appendLabel(liElem, columnName) {
			var label = $('<label>'+columnName+':</label>');
			liElem.append(label);
		};

		function saveInput(columnName, inputElem, initialValue) {
			inputElem.attr('_initialValue',initialValue);
			data.form[columnName] = inputElem;
		};

		function insertRecord(form, saveOptions) {
			var insertOptions = $.extend({},defaultOptions,options_,saveOptions);
			
			insertOptions.setters = {};
			for(var columnName in form) {
				var input = form[columnName];
				var value = input.val();
				insertOptions.setters[columnName] = value;
			};
			
			insert(insertOptions);
		};
		
		function updateRecord(form, saveOptions) {
			var updateOptions = $.extend({},defaultOptions,options_,saveOptions);
			
			var updating = false;
			updateOptions.setters = {};
			for(var columnName in form) {
				var input = form[columnName];
				var value = input.val();
				var initialValue = input.attr('_initialValue');
				if( value != initialValue ) {
					updateOptions.setters[columnName] = value;
					updating = true;
				};
			};
			
			if( !updating ) {
				options.onAlert('Data left unchanged. No updating required.');
			} else {
				update(updateOptions);
			};
		};
		
		function delRecord(form,delOptions) {
			var removeOptions = $.extend({},defaultOptions,options_,delOptions);
			
			remove(removeOptions);
		};
		
		function updateData(columnName, value) {
			if( data && data.form && data.form[columnName] ) {
				var input = data.form[columnName];
				input.val(value);
			};
		};
		
		// Return an object that can be used to modify the form
		return {
			updateData: updateData 
		};
	};
})(jQuery);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.mapAndControls.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

	// Localization
	var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };
	var DH = 'n2.mapAndControls';

// **************************************************
// Generic bridge between document model and map
var MapBridge = $n2.Class({

    sourceModelId: null,
    
    dispatchService: null,
    
    mapControl: null,
    
    initialize: function (opts_) {
        var opts = $n2.extend({
            dispatchService: null
            
            // From configuration object
            ,sourceModelId: null
        }, opts_);

        var _this = this;
        
        this.sourceModelId = opts.sourceModelId;
        this.dispatchService = opts.dispatchService;

        // Register to events
        if( this.dispatchService ) {
            var f = function (m, addr, dispatcher){
                _this._handle (m, addr, dispatcher);
            };
            this.dispatchService.register(DH, 'modelStateUpdated', f);
            this.dispatchService.register(DH, 'reportModuleDisplay', f);
            this.dispatchService.register(DH, 'mapInitialized', f);
            this.dispatchService.register(DH, 'start', f);
            
            if( this.sourceModelId ){
                // Initialize state
                var m = {
                    type:'modelGetState'
                    ,modelId: this.sourceModelId
                };
                this.dispatchService.synchronousCall(DH, m);
                if (m.state) {
                    this._sourceModelUpdated(m.state);
                };
            };
        };
    },
    
    _handle: function (m, addr, dispatcher) {
    	if( 'modelStateUpdated' === m.type ) {
            // Does it come from one of our sources?
            if (this.sourceModelId === m.modelId) {
                this._sourceModelUpdated(m.state);

                // Redraw map
            	this._updateMap();
            };

    	} else if( 'reportModuleDisplay' === m.type ) {
    		if( m.moduleDisplay 
    		 && m.moduleDisplay.mapControl 
    		 && !this.mapControl ){
    			this.mapControl = m.moduleDisplay.mapControl;
            	this._updateMap();
    		};

    	} else if( 'mapInitialized' === m.type ) {
    		if( m.mapControl 
    		 && !this.mapControl ){
    			this.mapControl = m.mapControl;
            	this._updateMap();
    		};

    	} else if( 'start' === m.type ) {
            this._updateMap();
        };
    },
    
    _sourceModelUpdated: function(sourceState) {
    	throw 'Subclasses must implement _sourceModelUpdated()'
    },
    
    /**
     * Returns array of document ids that are currently visible
     */
    _getVisibleDocumentIds: function(){
    	throw new Error('Subclasses must implement _getVisibleDocumentIds()');
    },
    
    _updateMap: function() {
        var mapControl = this._getMapControl();
        if( mapControl 
         && mapControl.infoLayers ){
        	var visibleDocIds = this._getVisibleDocumentIds();
        	
        	// Iterate over all layers
    		for(var loop=0; loop<mapControl.infoLayers.length; ++loop) {
    			var layerInfo = mapControl.infoLayers[loop];
                
                // Interested only in vector layers
                if( layerInfo 
                 && layerInfo.featureStrategy ) {
                	layerInfo.featureStrategy.setWhiteListDocumentIds(visibleDocIds);
                };
            };
        };
    },
    
    _getMapControl: function(){
    	var _this = this;
    	
    	return this.mapControl;
    }
});

var TimeTransformMapBridge = $n2.Class(MapBridge, {

    docStateById: null,

    initialize: function (opts_) {
        var opts = $n2.extend({
            dispatchService: null
            
            // From configuration object
            ,sourceModelId: null
        }, opts_);

        this.docStateById = {};
        
        MapBridge.prototype.initialize.apply(this, arguments);

        $n2.log('timeTransformToMapAndControlBridge', this);
    },
    
    _sourceModelUpdated: function(sourceState) {
    	var _this = this;
    	
        // Update the nodes according to changes in source model
    	if( sourceState ){
    		if( sourceState.added && sourceState.added.length ){
    			for(var i=0,e=sourceState.added.length; i<e; ++i){
    				var doc = sourceState.added[i];
    				updateDoc(doc);
    			};
    		};

    		if( sourceState.updated && sourceState.updated.length ){
    			for(var i=0,e=sourceState.updated.length; i<e; ++i){
    				var doc = sourceState.updated[i];
    				updateDoc(doc);
    			};
    		};

    		if( sourceState.removed && sourceState.removed.length ){
    			for(var i=0,e=sourceState.removed.length; i<e; ++i){
    				var doc = sourceState.removed[i];
    				var docId = doc._id;
    				if( this.docStateById[docId] ){
    					delete this.docStateById[docId];
    				};
    			};
    		};
    	};
    	
    	function updateDoc(doc){
    		var docId = doc._id;
    		
    		if( doc._n2TimeTransform ){
    			if( !_this.docStateById[docId] ){
    				_this.docStateById[docId] = {};
    			};
    			
    			if( doc._n2TimeTransform.intervalSize <= 0 ){
    				// The document does not contain any time intervals. By default,
    				// show
    				_this.docStateById[docId].visible = true;
    			} else {
        			_this.docStateById[docId].visible = doc._n2TimeTransform.intersects;
    			};
    			
    		} else if( _this.docStateById[docId] ){
    			delete _this.docStateById[docId];
    		}
    	};
    },
    
    _getVisibleDocumentIds: function(){
    	var docIds = [];
    	for(var docId in this.docStateById){
    		if( this.docStateById[docId].visible ){
    			docIds.push(docId);
    		};
    	};
    	return docIds;
    }
});

var ModelMapBridge = $n2.Class(MapBridge, {

    docStateById: null,

    initialize: function (opts_) {
        var opts = $n2.extend({
            dispatchService: null
            
            // From configuration object
            ,sourceModelId: null
        }, opts_);

        this.docStateById = {};
        
        MapBridge.prototype.initialize.apply(this, arguments);

        $n2.log('modelToMapAndControlBridge', this);
    },
    
    _sourceModelUpdated: function(sourceState) {
    	var _this = this;
    	
        // Update the nodes according to changes in source model
    	if( sourceState ){
    		if( sourceState.added && sourceState.added.length ){
    			for(var i=0,e=sourceState.added.length; i<e; ++i){
    				var doc = sourceState.added[i];
    				var docId = doc._id;
    				this.docStateById[docId] = true;
    			};
    		};

    		if( sourceState.updated && sourceState.updated.length ){
    			for(var i=0,e=sourceState.updated.length; i<e; ++i){
    				var doc = sourceState.updated[i];
    				var docId = doc._id;
    				this.docStateById[docId] = true;
    			};
    		};

    		if( sourceState.removed && sourceState.removed.length ){
    			for(var i=0,e=sourceState.removed.length; i<e; ++i){
    				var doc = sourceState.removed[i];
    				var docId = doc._id;
    				if( this.docStateById[docId] ){
    					delete this.docStateById[docId];
    				};
    			};
    		};
    	};
    },
    
    _getVisibleDocumentIds: function(){
    	var docIds = [];
    	for(var docId in this.docStateById){
   			docIds.push(docId);
    	};
    	return docIds;
    }
});

function HandleWidgetAvailableRequests(m){
    if( m.widgetType === 'timeTransformToMapAndControlBridge' ){
        m.isAvailable = true;
    } else if( m.widgetType === 'modelToMapAndControlBridge' ){
        m.isAvailable = true;
    };
};

function HandleWidgetDisplayRequests(m){
    if( m.widgetType === 'timeTransformToMapAndControlBridge' ){
        var options = {};
        
        if( m.widgetOptions ) {
        	for(var key in m.widgetOptions){
        		options[key] = m.widgetOptions[key];
        	};
        };
        
        if( m.config ){
            if( m.config.directory ){
            	options.dispatchService = m.config.directory.dispatchService;
            };
        };
        
        new TimeTransformMapBridge(options);

    } else if( m.widgetType === 'modelToMapAndControlBridge' ){
        var options = {};
        
        if( m.widgetOptions ) {
        	for(var key in m.widgetOptions){
        		options[key] = m.widgetOptions[key];
        	};
        };
        
        if( m.config ){
            if( m.config.directory ){
            	options.dispatchService = m.config.directory.dispatchService;
            };
        };
        
        new ModelMapBridge(options);
    };
};

//**************************************************
var GazetteerProcess = $n2.Class({
	
	geoNamesService: null,
	
	inputId: null,
	
	initialize: function(geoNamesService_){
		this.geoNamesService = geoNamesService_;
	},

	initiateCapture: function(mapControl){
		var _this = this;
		
		var dialogId = $n2.getUniqueId();
		var $dialog = $('<div></div>')
			.attr('id',dialogId)
			.addClass('n2MapAndControls_gazette_dialog');
		
		this.inputId = $n2.getUniqueId();
		$('<div><input id="'+this.inputId+'" type="text"/></div>')
			.appendTo($dialog);

		$('<div class="n2MapAndControls_gazette_results"></div>')
			.appendTo($dialog);

		var dialogOptions = {
			autoOpen: true
			,modal: true
			,title: _loc('Create feature from name')
			,width: 'auto'
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$dialog.dialog(dialogOptions);
		
		var $input = $('#'+this.inputId);
		
		this.geoNamesService.installAutoComplete({
			input: $input
		});

		var request = {
			mapControl: mapControl
			,dialogId: dialogId
			,val: null
			,location: null
		};
		
		$input.keydown(function(e){
			var key = e.which;
			
			// $n2.log('key',key);
			
			var $input = $('#'+_this.inputId);
			if( key === 13 ) {
				var val = $input.val();
				
				if( $input.autocomplete ){
					$input.autocomplete('close');
					$input.autocomplete('option','disabled',true);
				};

				request.name = val;
				
				_this._searchForName(request);
			} else {
				if( $input.autocomplete ){
					$input.autocomplete('option','disabled',false);
				};
			};
			
			return true;
		});
		
		// Get centre of map to find biased country
		this._findCurrentLocation(request);
	},
	
	_searchForName: function(request){
		var _this = this;
		
		var countryBias = null;
		if( request.location
		 && request.location.countryCode ){
			countryBias = request.location.countryCode;
		};
		
		$('#'+request.dialogId).find('.n2MapAndControls_gazette_results').empty();
		
		this.geoNamesService.getName({
			name: request.name
			,featureClass: $n2.GeoNames.FeatureClass.PLACES
			,maxRows: 25
			,countryBias: countryBias
			,onSuccess: function(results){
				var $div = $('#'+request.dialogId).find('.n2MapAndControls_gazette_results')
					.empty();
				
				for(var i=0,e=results.length; i<e; ++i){
					var entry = results[i];
					
					if( entry.geonameId ) {
						var $entry = $('<div></div>')
							.addClass('n2MapAndControls_gazette_result')
							.appendTo($div);
						
						var name = entry.name;
						if( entry.adminName1 ){
							name += ', ' + entry.adminName1;
						};
						if( entry.countryName ){
							name += ', ' + entry.countryName;
						};
						$('<div></div>')
							.addClass('n2MapAndControls_gazette_result_name')
							.text(name)
							.appendTo($entry);
						
						_this._installOnClick(request, $entry, entry);

						if( entry.lng && entry.lat ) {
							var longLat = entry.lng + ',' + entry.lat;
							$('<div></div>')
								.addClass('n2MapAndControls_gazette_result_location')
								.text(longLat)
								.appendTo($entry);
						};
					};
				};
			}
		});
	},
	
	_installOnClick: function(request, $entry, entry){
		var _this = this;
		
		$entry.click(function(){
			_this._selectEntry(request, entry);
		});
	},
	
	_selectEntry: function(request, entry){
		var $dialog = $('#'+request.dialogId);
		$dialog.dialog('close');
		
		var editLayer = request.mapControl.editLayer;
		var map = request.mapControl.map;
		
		var geom = new OpenLayers.Geometry.Point(1 * entry.lng, 1 * entry.lat);

		// Reproject geometry
		var mapProjection = map.getProjectionObject();
		var gazetteProjection = new OpenLayers.Projection('EPSG:4326');
		if( gazetteProjection.getCode() != mapProjection.getCode() ) {
			geom.transform(gazetteProjection, mapProjection);
		};
		
		// Center map on geometry
		var ll = new OpenLayers.LonLat(geom.x, geom.y);
		map.setCenter(ll);

		// Create and add feature
		var feature = new OpenLayers.Feature.Vector(geom);
		
		feature.data.nunaliit_gazetteer = {};
		for(var key in entry){
			var value = entry[key];
			feature.data.nunaliit_gazetteer[key] = value;
		};
		
		editLayer.addFeatures([feature]);
	},
	
	_findCurrentLocation: function(request){
		var map = request.mapControl.map;
		var ll = map.getCenter();
		if( ll ) {
			// Reproject geometry
			var mapProjection = map.getProjectionObject();
			var gazetteProjection = new OpenLayers.Projection('EPSG:4326');
			if( gazetteProjection.getCode() != mapProjection.getCode() ) {
				ll.transform(mapProjection, gazetteProjection);
			};

			this.geoNamesService.findNearby({
				lng: ll.lon
				,lat: ll.lat
				,maxRows: 1
				,onSuccess: function(results){
					if(results && results.length){
						var entry = results[0];
						request.location = entry;
					};
				}
				,onError: function(err){
					// Ignore
				}
			});
		};
	}
});

//**************************************************
//**************************************************

var zoomInClusterClickCallback = function(feature, mapAndControls){
	var clusterGeom = feature.geometry;
	
	var newCenter = null;
	if( clusterGeom ){
		newCenter = clusterGeom.getBounds().getCenterLonLat();
	};
    
	if( newCenter ){
		mapAndControls.map.setCenter(newCenter, mapAndControls.map.zoom + 1);
		//var xy = mapAndControls.map.getPixelFromLonLat(newCenter);
		//mapAndControls.map.zoomTo(mapAndControls.map.zoom + 1, xy);
		mapAndControls._endHover();
	};
};

var multiSelectClusterClickCallback = function(feature, mapAndControls){
	var docIds = [];
	
	if( feature.cluster ) {
		for(var i=0,e=feature.cluster.length; i<e; ++i){
			var f = feature.cluster[i];
			if( f && f.data && f.data._id ){
				docIds.push(f.data._id);
			};
		};
	};
	
	if( docIds.length ) {
		mapAndControls._dispatch({
			type: 'userSelect'
			,docIds: docIds
		});
	};
};

//**************************************************
//**************************************************

function suppressPopupHtmlFunction(opts_){
	var opts = $n2.extend({
		feature: null
		,layerInfo: null
		,onSuccess: null
		,onError: null
	},opts_);
	
	// Do not display anything
	opts.onSuccess(null);
};

//**************************************************
//**************************************************

function ComputeFeatureOriginalBboxForMapProjection(f, mapProj){
	// Each feature has a projection stored at f.n2GeomProj
	// that represents the original projection for a feature
	//
	// Each feature has a property named 'n2ConvertedBbox' that contains
	// the full geometry bbox converted for the map projection, if 
	// already computed.

	if( f && f.n2ConvertedBbox ){
		return f.n2ConvertedBbox;
	};

	var geomBounds = undefined;
	if( f.data 
	 && f.data.nunaliit_geom
	 && f.data.nunaliit_geom.bbox 
	 && f.n2GeomProj
	 && mapProj ){
		
		var bbox = f.data.nunaliit_geom.bbox;
		if( $n2.isArray(bbox) 
		 && bbox.length >= 4 ){
			geomBounds = new OpenLayers.Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);

			if( mapProj.getCode() !== f.n2GeomProj.getCode ){
				geomBounds.transform(f.n2GeomProj, mapProj);
			};

			f.n2ConvertedBbox = geomBounds;
		};
	};
	
	return geomBounds;
};

//**************************************************
//**************************************************
var LayerInfo = $n2.Class({

	customService: null,
	
	id: null,
	
	type: null,
	
	options: null,

	sourceSrsName: null,
	
	sourceProjection: null,
		
	featurePrefix: null,

	featureType: null,
	
	featureNS: null,
	
	name: null,
	
	filter: null,
	
	featurePopupHtmlFn: null,

	featurePopupDelay: null,

	visibility: null,
	
	styleMapFn: null,

	styleMap: null,

	selectListener: null,
	
	clusterClickCallback: null,
	
	// Options relating to clustering process
	clustering: null,

	// Boolean
	useHoverSound: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			customService: null,
			
			// Type of layer: 'couchdb', 'wfs', ...
			type: null,

			// Options related ot type
			options: null,
			
			// String to identify this layer among others
			id: null,
			
			 /*
			  * sourceSrsName: default source projection of WFS feature data - Geoserver can reproject but cannot
			  * handle a bbox param on a GetFeature in reprojected coordinates.  This is used to tell the atlas 
			  * what coordinates to use when request the vector layer features.
			  */
			sourceSrsName: 'EPSG:4326',
			
			// featurePrefix and featureType jointly form the WFS typename for this layer but because we now
			// use filtering on layers, this typename (featurePrefix:featureType) is not unique.
			featurePrefix: null,
			featureType: null,
			
			// Full name space associated with prefix
			featureNS: null,
			
			// name should be unique - doesn't have to be but this is used in the layer switcher so
			// the map designer should be selecting something to differentiate ... this is used for
			// regenerating a specific layers style map.
			name: null,
			
			// filter for selection of features from the WFS layer
			filter: null,
			
			featurePopupHtmlFn: null,
			featurePopupDelay: 0,
			visibility: true,
			
			// Style Map fn - returns an OpenLayers style map to be installed
			// on the layer.  
			//
			// If not specified, a style map based on a defaults and extended
			// using the property 'styleMap' is created.
			styleMapFn: null,

			// To update the default style associated with a layer, insert an object containing the
			// named styles e.g.
			// layerInfo.styleMap: {
			//   normal: {
			//     strokeColor: "#f4f4f4"		
			//   }
			//   ,clicked: {
			//     strokeColor: "#ff0000"
			//   }
			// }
			// The style names in use are:
			// - normal -> default style for features
			// - hovered -> style when a feature is moused over
			// - clicked -> style when a feature is currently selected (clicked on)
			// - hoveredClicked -> style when a feature is currently selected (clicked on) and moused over
			// - filteredOut -> style when a feature does not fall within a filter
			// 
			// If the property 'styleMapFn' is provided, then this property is most
			// likely going to be ignored. 
			styleMap: null,

			selectListener: function(isSelected, layerInfo){},
			
			// This is the function called back when a cluster with
			// more than one feature is clicked
			clusterClickCallback: null,
			
			clustering: null,
			
			useHoverSound: false
			
		},opts_);
		
		var _this = this;

		this.id = opts.id;
		this.type = opts.type;
		this.options = opts.options;
		this.customService = opts.customService;
		this.sourceSrsName = opts.sourceSrsName;
		this.featurePrefix = opts.featurePrefix;
		this.featureType = opts.featureType;
		this.featureNS = opts.featureNS;
		this.name = opts.name;
		this.filter = opts.filter;
		this.featurePopupHtmlFn = opts.featurePopupHtmlFn;
		this.featurePopupDelay = opts.featurePopupDelay;
		this.visibility = opts.visibility;
		this.styleMapFn = opts.styleMapFn;
		this.styleMap = opts.styleMap;
		this.selectListener = opts.selectListener;
		this.clusterClickCallback = opts.clusterClickCallback;
		this.clustering = opts.clustering;
		this.useHoverSound = opts.useHoverSound;

		// Derive database projection from name
		if( this.sourceSrsName ){
			this.sourceProjection = new OpenLayers.Projection(this.sourceSrsName);
		};

		// Localize name
		if( this.name ){
			this.name = _loc(this.name);
		};

		// Popup function
		if( !this.featurePopupHtmlFn ){
			if( this.customService ){
				var cb = this.customService.getOption('mapFeaturePopupCallback');
				if( typeof cb === 'function' ) {
					this.featurePopupHtmlFn = cb;
				};
			};
		};
		if( !this.featurePopupHtmlFn ){
			this.featurePopupHtmlFn = $n2.mapAndControls.DefaultPopupHtmlFunction;
		};
		
		// Cluster click callback
		if( !this.clusterClickCallback ){
			if( this.customService ){
				var cb = this.customService.getOption('mapClusterClickCallback');
				if( typeof cb === 'function' ) {
					this.clusterClickCallback = cb;
				};
			};
		};
		if( !this.clusterClickCallback ){
			this.clusterClickCallback = $n2.mapAndControls.ZoomInClusterClickCallback;
		};
	},
	
	forEachFeature: function(callback){
		if( typeof callback === 'function'
		 && this.olLayer 
		 && this.olLayer.features ){
			for(var i=0,e=this.olLayer.features.length; i<e; ++i){
				var feature = this.olLayer.features[i];
				if( feature.cluster ){
					for(var j=0,k=feature.cluster; j<k; ++j){
						var cf = feature.cluster[j];
						callback.call(this,cf,feature);
					};
				} else {
					callback.call(this,feature);
				};
			};
		};
	},
	
	accumulateMapStylesInUse: function(stylesInUse){
		// Loop over drawn features (do not iterate in clusters)
		if( this.olLayer 
		 && this.olLayer.features ){
			for(var i=0,e=this.olLayer.features.length; i<e; ++i){
				var feature = this.olLayer.features[i];
				if( feature._n2Style 
				 && typeof feature._n2Style.id === 'string'){
					var style = feature._n2Style;
					
					var styleInfo = stylesInUse[style.id];
					if( !styleInfo ){
						styleInfo = {
							style: style
						};
						stylesInUse[style.id] = styleInfo;
					};
					
					var geometryType = feature.n2_geometry;
					if( geometryType && !styleInfo[geometryType] ){
						styleInfo[geometryType] = feature;
					};
				};
			};
		};
	}
});


//**************************************************
//**************************************************

/**
	Creates an atlas and all associated controls. An
	elaborate set of options are provided to configure
	the atlas. The returning map contains functions that
	can be used to control the atlas after it is created.

 	@name mapAndControls
 	@function
 	@memberOf nunaliit2
 	@param {Object} options_ 
 		Object that describes options to configure the map and controls.
    	
    	{Object} mapCoordinateSpecifications
    	Optional specification of map coordinate parameters, including:
    	- srsName: the coordinate system in which these parameters are expressed.
		- maxExtent: maximum geographical extent of the map - an array [ minX, minY, maxX, maxY ]
		- initialBounds: initially displayed map extent - an array [ minX, minY, maxX, maxY ]
		- useForMapControls: true => use projection specified by above srsName for map
		  controls (mouse position, etc.).

    	{Object} mapDisplay
    	Option specification of the map display (projection, resolution, background layers, units, optional display handler hook)
    
		{Boolean} addPointsOnly=false
    	If true, editing the map can only add points.
	
		{Boolean} showSRSAttribution
		If true, the SRS Code will be added to the map attribution
		
		{Object} scaleLine
    	Defines properties for the scale line control

		{Boolean} enableWheelZoom=false
    	If true, mouse wheel zooms in and out.
    
    	{Object} placeDisplay
    	Options for the display handler.
    
    	{Object} background
    	Options for the display of background layers.

		{Object} saveFeature
    	Defines how features are saved via the editing interface. Or, instance of editor.
    
		{String} sidePanelName='side' 
    	Identifier of the &lt;div&gt; element where the textual display should be rendered.
    
		{String} filterPanelName
    	Identifier of the &lt;div&gt; element where local map filters should be displayed.
		If not specified (null), then local map filtering is disabled.
    
		{Boolean} toggleClick=true 
    	If set, then clicking on a feature in a clicked 'state' turns off
		the clicking state. When turning off this way, the event 'unselected' is
		dispatched. If reset, clicking on a feature multiple
		times is ignored.
    
		{String} uniqueIdentifier='place_id'
		Name of the feature attribute which uniquely identifies the feature.
		This is important to coordinate all the map extensions. It defaults to 'place_id'
		for legacy reasons.
    
    	{Object} dbSearchEngine
		Options to configure the database search engine (@link nunaliit2#dbSearchEngine). 
    
    	{Object} contributionDb
		Options to configure the contribution database.
    
    	{Array} layerInfo
		Object or Array of Objects. Each object represents the options for one displayed layer.
    
    	{String} layerInfo.sourceSrsName
		Projection name used in WFS requests. Defaults to 'EPSG:4326'
    
    	{Number} layerInfo.displayInLayerSwitcher
		Show layer in Layer Switcher (true, default) or hide layer in switcher (true).
		Applied in WMS layers only.
    
    	{String} layerInfo.featurePrefix
		Short name used in WFS request as 'namespace' or 'workspace'.
    
		{String} layerInfo.featureType
		Name used in WFS request to identify a particular layer. 
    
		{String} layerInfo.featureNS
		Full namespace for layer used in WFS requests.
    
		{String} layerInfo.name
		Label by which layer should be referred to.
    
    	{Object} layerInfo.filter
		Null if not used. Null by default. This is a JSON object
		that represents a filter for the layer. If specified,
		the filter is sent during WFS requests. Syntax for
		filters is defined by nunaliit2.CreateOpenLayersFilter().
    
		{Function} layerInfo.featurePopupHtmlFn
		Function called when a feature pop up is displayed. This function
		is called with an object contain the feature being hovered and
		a call back function (onSuccess). The onSuccess callback should
		be called with the generated HTML when it is available. If no
		popup should be created for this feature, then onSuccess should not
		be called. By default this option is null and popups are not
		generated.
    	
    	{Number} layerInfo.featurePopupDelay
		Amount of time, in milliseconds, that should elapse between the
		time a user hovers a feature and the time the popup is generated for it.
		Defaults to 0.
    
    	{Number} layerInfo.gutter
		Extra sapce, specified in pixels, to add around images fetched from WMS.
		Useful for WMS labelling in use with tiled service.
    
		{Boolean} layerInfo.visibility=true
		If set, the layer is initially visible. If false, the layer is
 		initially turned off.
    
		{Function} layerInfo.styleMapFn
		Function called to retrieve a style map for the layer.
		If not specified, a style map based on defaults and extended using
		the property 'styleMap' is built.
    
    	{Object} layerInfo.styleMap
		Options to override default styles for a layer. If property
		'styleMapFn' is specified, then this property is probably ignored.
    
		{Function} layerInfo.selectListener
		This function is called when the visibility of a layer
		is changed. Protoype is: function(isSelected, layerInfo)

    @returns {Object} Map of function that can be called
                      to control the behaviour of the 
                      atlas after it is created.
 */

var MapAndControls = $n2.Class({
	
	options: null,
	dbSearchEngine: null,
	contributionDb: null,
	mapId: null,
	map: null,
	editLayer: null,
	html: null,
 	lastMapXy: null,
 	mapMouseMoveListeners: null,
	olkitDisplayOptions: null,
	pendingMarkInfo: null,
	currentPopup: null,
	dhtmlSoundDivId: null,
	initialZoomBounds: null,

    // HOVER and CLICK
	selectFeatureControl: null,
	hoverInfo: null,
	clickedInfo: null,
	focusInfo: null,
	findFeatureInfo: null,

    // MODES
	modes: null,
	currentMode: null,

	// MAP MODES
	navigationControls: null,
	editControls: null,
	editFeatureControls: null,

 	// EDIT mode callbacks
	editModeAddFeatureEnabled: null,
	editModeAddFeatureCallback: null,
    convertToMultiGeometry: null,
    
    // EDIT_FEATURE mode
    editFeatureInfo: undefined,

    // COMETD
    cometEnabled: null,
    fidChannel: null,
    contributionChannel: null,

    // STYLE
	defaultStyleMap: null,
	styleFilterIndex: null,
	styleFilters: null,

	// map layers
	mapLayers: null,
	vectorLayers: null,
	infoLayers: null,
	layers: null,
	mapBusyCount: null,
	busyMapControl: null,
	
	initialize: function(options_){
		var _this = this;
		
		this.mapId = 'map_' + $n2.getUniqueId();
		
		if( typeof(OpenLayers) == 'undefined' ) {
			$n2.reportError('OpenLayers is required.');
			return null;
		};
		
		var defaultOptions = {
			mapCoordinateSpecifications: {
				/*
				 * The set of (internally) consistent defaults for describing the map display.  Note that the default
				 * map display is set up for Google backgrounds and uses Google's spherical Mercator (900913).  So this
				 * is a description of the map coordinate space for Google's projection BUT specified in WGS84 lat long
				 * coordinate space.  It is transformed as needed to the actual target coordinate space.
				 */
				srsName: 'EPSG:4326'
				,maxExtent: [-180,-85.05,180,85.05] // Max extent provided by Google imagery
				,restrictedExtent: null
				,initialBounds: [-180,-90,180,90]
				
				/*
				 * Use this coordinate space for map controls (such as the mouse position tracker)?  By default,
				 * OpenLayers will use the map projection but, if specified, this reprojects back to a different
				 * projection for user displays (this is supposed to be LESS confusing).
				 *
				 * Default is TRUE because the original atlases used this behaviour to display Google map backgrounds
				 * (using the default mapDisplay.srsName projection below which is in meter units) with the controls 
				 * configured to display NAD83 lat lon (EPSG:4326).  Perfectly reasonable if the user is used to
				 * working with their data in lat/long (as evidenced by the boundng box, etc. being specified in
				 * lat/long).
				 */ 
				,useForMapControls: true
			}
			,mapDisplay: {
				srsName: 'EPSG:900913' // the projection the map is actually displayed in.
				,background: null
				,maxResolution: 156543.0339 // if not using Google proj, compute as maxExtent / expected map display size (in pixels).
				,units: 'm' // map units
			}
			,addPointsOnly: false
			,showSRSAttribution: false
			,scaleLine: {
				visible: false
			}
			,enableWheelZoom: false
			,placeDisplay: { // place info panel display options.
				attribDisplayType: 'attributes' // default - just list the attributes in a table	
				,attribTableHeading: "Place Data:" // display heading for place attributes table format.
				,attribTableDiv: "side_attrib" /* this div is created dynamically */
				,attribTableClassBase: "attrib" /* modified as needed to create columns - see $n2.placeInfo */
				,attribHtmlFn: null // attribHtmlFn(divName, options, attributeObj) - returns html string 

				,contribTableDiv: "side_contrib"  /* this div is created dynamically */
				,contribTableClassBase: "contrib" /* modified as needed to create columns - see $n2.placeInfo */
				,contribTableShowAuthor: true // default - show the contributor id
				,contribTableShowCreateTS: true // default - show creation timestamp
				,contribEmbedAudioDirectly: false // default - link to modal display for contribution audio player
				,contribShowLastEditInfo: true // default - show id and time for last update
				,contribMediaDisplayVideoHeight: 240
				,contribMediaDisplayVideoWidth: 320
				,contribAdditionalFields: [] // default none - see contributionDisplayFormatter for format comment
				,contribIndexingType: 'default' // standard contributions (with related responses) sorting
				
				// should the atlas auto-add a contribution record when a feature is added?
				,contribInsertedReloadAddContrib: true // yes by default
				,contribInsertedReloadDataFn: null // use built-in by default which makes assumptions about the structure of contributions records

				,contributionOptions: { // mostly form layout and db exchange handling - see contributions.js
					anonymousAllowed: true
				}
			}
			,saveFeature: {} // save feature details
			,canvasName: null
			,sidePanelName: 'side'
			,filterPanelName: null
			,toggleClick: true
			,uniqueIdentifier: 'place_id'
			,layerSwitcher: {
				suppress: false
				,initiallyOpened: false
			}
			,directory: null // service directory
			,mapIdentifier: 'map'
			,mapInteractionDivName: 'map_interaction_div'
			,keepPopUpsOpen: false
			,keepPopUpsStatic: false
		};
		this.options = $.extend(true, {}, defaultOptions, options_);

		this.dbSearchEngine = $n2.dbSearchEngine( (options_ ? options_.dbSearchEngine : null) );

		this.contributionDb = $n2.contributionDb( (options_ ? options_.contributionDb : null) );

		this.map = null;
		this.editLayer = null;
		this.html = "";
		this.lastMapXy = null;
		this.mapMouseMoveListeners = [];
		this.olkitDisplayOptions = {};
		this.pendingMarkInfo = null;
		this.mapBusyCount = 0;
		this.dhtmlSoundDivId = $n2.getUniqueId();
		this.editFeatureInfo = {
			original: {}
		};

	    // HOVER and CLICK
		this.selectFeatureControl = null;
	    this.hoverInfo = {
	    	feature: null
			,endFn: []
		};
		this.clickedInfo = {
			features: []
			,endFn: []
			,fids: {}
			,selectedId: null
		};
		this.focusInfo = {
			fids: {}
			,features: []
		};
		this.findFeatureInfo = {
			fid: null
			,features: []
		};
		
		var addOrEditLabel = _loc('Add or Edit a Map Feature');
		var cancelLabel = _loc('Cancel Feature Editing');
		var customService = this._getCustomService();
		if( customService ){
			var customAdd = customService.getOption('mapLabelEditFeature',null);
			if( customAdd ){
				addOrEditLabel = customAdd;
			};

			var customCancel = customService.getOption('mapLabelCancelEdit',null);
			if( customCancel ){
				cancelLabel = customCancel;
			};
		};

		// MODES
		this.modes = {
			NAVIGATE: {
				name        : "NAVIGATE"
				,buttonValue : addOrEditLabel
				,onStartHover: function(feature, layer) {
					_this._hoverFeature(feature, layer);
					_this._hoverFeaturePopup(feature, layer);
				}
				,onStartClick: function(feature, mapFeature) {
					_this.initAndDisplayClickedPlaceInfo(feature);
				}
				,onEndClick: function(feature) {
				}
				,featureAdded: function(feature) {
					
				}
			}
			,ADD_OR_SELECT_FEATURE: {
				name        : "ADD_OR_SELECT"
				,buttonValue : cancelLabel
				,onStartHover: function(feature, layer) {
					_this._hoverFeature(feature, layer);
					_this._hoverFeaturePopup(feature, layer);
				}
				,onStartClick: function(feature, mapFeature) {

					var editAllowed = true;
					if( mapFeature.cluster && mapFeature.cluster.length > 1 ) {
						alert( _loc('This feature is a cluster and can not be edited directly. Please, zoom in to see features within cluster.') );
						editAllowed = false;
					};
					
					if( editAllowed ) {
			    		_this._dispatch({
			    			type: 'editInitiate'
			    			,doc: feature.data
			    		});
					};
				}
				,onEndClick: function(feature) {
				}
				,featureAdded: function(feature) {
					_this.editFeatureInfo.original = {};
					_this.editFeatureInfo.fid = undefined;
					_this.editFeatureInfo.suppressZoom = true;
					
					var mapProj = feature.layer.map.getProjectionObject();

		    		_this._dispatch({
		    			type: 'editCreateFromGeometry'
		    			,geometry: feature.geometry.clone()
		    			,projection: mapProj
		    			,_origin: _this
		    		});
				}
			}
			,ADD_GEOMETRY: {
				name        : "ADD_GEOMETRY"
				,buttonValue : cancelLabel
				,onStartHover: function(feature, layer) {
					_this._hoverFeature(feature, layer);
					_this._hoverFeaturePopup(feature, layer);
				}
				,featureAdded: function(feature) {
					var proj = null;
					if( feature 
					 && feature.layer 
					 && feature.layer.map ){
						proj = feature.layer.map.getProjectionObject();
					};
					
		    		_this._dispatch({
		    			type: 'mapGeometryAdded'
		        		,geometry: feature.geometry
		        		,projection: proj
		    		});
				}
			}
			,EDIT_FEATURE: {
				name        : "EDIT_FEATURE"
				,buttonValue : cancelLabel
				,featureAdded: function(feature) {
				}
			}
		};
		this.currentMode = this.modes.NAVIGATE;

	 	// COMETD
	    this.cometEnabled = true;
	    this.fidChannel = '/fid';
	    this.contributionChannel = '/contribution';
	    
	    this._registerDispatch('documentVersion');
	    this._registerDispatch('documentDeleted');
	    this._registerDispatch('cacheRetrieveDocument');
	    this._registerDispatch('documentContentCreated');
	    this._registerDispatch('documentContentUpdated');
	    this._registerDispatch('addLayerToMap');
	    this._registerDispatch('selected');
	    this._registerDispatch('selectedSupplement');
	    this._registerDispatch('unselected');
	    this._registerDispatch('focusOn');
	    this._registerDispatch('focusOff');
	    this._registerDispatch('focusOnSupplement');
	    this._registerDispatch('findIsAvailable');
	    this._registerDispatch('find');
	    this._registerDispatch('searchInitiate');
	    this._registerDispatch('editInitiate');
	    this._registerDispatch('editClosed');
	    this._registerDispatch('editGeometryModified');
	    this._registerDispatch('editReportOriginalDocument');
	    this._registerDispatch('mapRedrawLayer');
	    this._registerDispatch('mapSetInitialExtent');
	    this._registerDispatch('mapSetExtent');
	    this._registerDispatch('mapResetExtent');
	    this._registerDispatch('mapGetLayers');
	    this._registerDispatch('setMapLayerVisibility');
	    this._registerDispatch('mapSwitchToEditMode');
	    this._registerDispatch('simplifiedGeometryReport');
	    this._registerDispatch('canvasGetStylesInUse');
	    
		// Layers
		this.infoLayers = [];
		
		if( typeof(this.options.layerInfo) === 'object' && !$n2.isArray(this.options.layerInfo) ) {
			this.options.layerInfo = [this.options.layerInfo];
		};
		
		// STYLE
		//
		// This is the default style used by the atlas. Each layer is built
		// using this style, unless an attribute "styleMap" is defined. If
		// "styleMap" is defined, then the default map is extended using the
		// provided one and the OpenLayers StyleMap is created from it.
		//
		this.defaultStyleMap = {
			'normal': {
				fillColor: "#ffffff",
				fillOpacity: 0.4,
				strokeColor: "#ee9999",
				strokeOpacity: 1,
				strokeWidth: 1,
				strokeLinecap: "round", //[butt | round | square]
				strokeDashstyle: "solid", //[dot | dash | dashdot | longdash | longdashdot | solid]
				pointRadius: 6,
				pointerEvents: "visiblePainted"
			}
			,'clicked': {
				fillColor: "#ffffff",
				fillOpacity: 0.1,
				strokeColor: "#ff2200",
				strokeOpacity: 1,
				strokeWidth: 3,
				strokeLinecap: "round", //[butt | round | square]
				strokeDashstyle: "solid", //[dot | dash | dashdot | longdash | longdashdot | solid]
				pointRadius: 8,
				pointerEvents: "visiblePainted"
			}
			,'hovered': {
				fillColor: "#0000ff",
				fillOpacity: 0.4,
				strokeColor: "#0000ff",
				strokeOpacity: 1,
				strokeWidth: 1,
				strokeLinecap: "round", //[butt | round | square]
				strokeDashstyle: "solid", //[dot | dash | dashdot | longdash | longdashdot | solid]
				pointRadius: 6,
				pointerEvents: "visiblePainted",
				cursor: "pointer"
			}
			,'hoveredClicked': {
				fillColor: "#0000ff",
				fillOpacity: 0.4,
				strokeColor: "#ff2200",
				strokeOpacity: 1,
				strokeWidth: 3,
				strokeLinecap: "round", //[butt | round | square]
				strokeDashstyle: "solid", //[dot | dash | dashdot | longdash | longdashdot | solid]
				pointRadius: 8,
				pointerEvents: "visiblePainted",
				cursor: "pointer"
			}
			,'filteredOut': {
				display: 'none'
			}
		};
		this.styleFilterIndex = 0;
		this.styleFilters = {};

		// Create switch before installing auth listener 
		// as to have constant behaviour
		this.createMapInteractionSwitch();

	    /*
	     * Install login listener - it is run when first added
	     * Note that initialization of auth happens in app specific code.
	     */
		var authService = this._getAuthService();
	    if( authService ) {
	    	authService.addListeners(function(currentUser){
				_this.loginStateChanged(currentUser);
			});
	    };
	    
	    // EDIT mode callbacks
	    this.editModeAddFeatureEnabled = true;
		this.editModeAddFeatureCallback = function(evt) {
			// This function is called when a feature is added
			// to the edit layer. This happens when a toolbar adds
			// a new feature i.e. when the user selects to add a new
			// point, line or polygon.
	    	if( _this.editModeAddFeatureEnabled ) {
		    	var feature = evt.feature;
		    	var previousMode = _this.currentMode;
	    		_this.switchToEditFeatureMode(feature.fid, feature);
	    		previousMode.featureAdded(feature);
	    	};
		};
	    this.convertToMultiGeometry = function(evt) {
			for (var i=0; i<evt.features.length; ++i) {
				if( evt.features[i].geometry.CLASS_NAME === OpenLayers.Geometry.Point.prototype.CLASS_NAME ) {
					evt.features[i].geometry = new OpenLayers.Geometry.MultiPoint([evt.features[i].geometry]);
					
				} else if( evt.features[i].geometry.CLASS_NAME === OpenLayers.Geometry.LineString.prototype.CLASS_NAME ) {
					evt.features[i].geometry = new OpenLayers.Geometry.MultiLineString([evt.features[i].geometry]);
					
				} else if( evt.features[i].geometry.CLASS_NAME === OpenLayers.Geometry.Polygon.prototype.CLASS_NAME ) {
					evt.features[i].geometry = new OpenLayers.Geometry.MultiPolygon([evt.features[i].geometry]);
				};
			};
	    };

		var mapProjection = new OpenLayers.Projection(this.options.mapDisplay.srsName);
		var userCoordProjection = new OpenLayers.Projection(this.options.mapCoordinateSpecifications.srsName);

		// Convert initial bounds to the map's projection
		this.initialZoomBounds = new OpenLayers.Bounds(
			this.options.mapCoordinateSpecifications.initialBounds[0]
			,this.options.mapCoordinateSpecifications.initialBounds[1]
			,this.options.mapCoordinateSpecifications.initialBounds[2]
			,this.options.mapCoordinateSpecifications.initialBounds[3]
		);
		if( userCoordProjection.getCode() != mapProjection.getCode() ) {
			this.initialZoomBounds.transform(userCoordProjection, mapProjection);
		};
		
		// Convert max extent from map coord specification space to map display projection
		var maxExt = new OpenLayers.Bounds(
				this.options.mapCoordinateSpecifications.maxExtent[0]
				,this.options.mapCoordinateSpecifications.maxExtent[1]
				,this.options.mapCoordinateSpecifications.maxExtent[2]
				,this.options.mapCoordinateSpecifications.maxExtent[3]
				);
		if( userCoordProjection.getCode() != mapProjection.getCode() ) {
			maxExt.transform(userCoordProjection, mapProjection);
		};
		
		// Convert restrictedExtent
		var restrictedExtent = null;
		if( this.options.mapCoordinateSpecifications.restrictedExtent ){
			restrictedExtent = new OpenLayers.Bounds(
					this.options.mapCoordinateSpecifications.restrictedExtent[0]
					,this.options.mapCoordinateSpecifications.restrictedExtent[1]
					,this.options.mapCoordinateSpecifications.restrictedExtent[2]
					,this.options.mapCoordinateSpecifications.restrictedExtent[3]
					);
			if( userCoordProjection.getCode() != mapProjection.getCode() ) {
				restrictedExtent.transform(userCoordProjection, mapProjection);
			};
		};
		this.map = new OpenLayers.N2Map(this.options.mapIdentifier, {
			projection: mapProjection
			,displayProjection: (this.options.mapCoordinateSpecifications.useForMapControls ? userCoordProjection : mapProjection)
			,units: this.options.mapDisplay.units
			,maxResolution: this.options.mapDisplay.maxResolution
			,maxExtent: maxExt
			,restrictedExtent: restrictedExtent
			,theme: null // Let host page control loading of appropriate CSS style sheet
			,zoomMethod: null  // Zoom with features does not look good
		});

		// Create Scale line 
		if( this.options.scaleLine && this.options.scaleLine.visible ){
			// Default OpenLayers Scale Line Properties:
			// ------------------------------------
			// bottomOutUnits: mi
			// bottomInUnits: ft
			// topOutUnits: km
			// topInUnits: m
			// maxWidth: 100 (in pixels)
			// geodesic: false

			var scaleLine = new OpenLayers.Control.ScaleLine({
				bottomOutUnits: this.options.scaleLine.bottomOutUnits
				,bottomInUnits: this.options.scaleLine.bottomInUnits
				,topOutUnits: this.options.scaleLine.topOutUnits
				,topInUnits: this.options.scaleLine.topInUnits
				,maxWidth: this.options.scaleLine.maxWidth
				,geodesic: this.options.scaleLine.geodesic
			});
			this.map.addControl(scaleLine);
		};

		// Disable zoom on mouse wheel
		if( this.options.enableWheelZoom ) {
			// Do nothing. Enabled by default
		} else {
			// Turn off wheel
			var navControls = this.map.getControlsByClass('OpenLayers.Control.Navigation');
			for(var i=0,e=navControls.length; i<e; ++i) {
				navControls[i].disableZoomWheel();
			};
		};

		if( this.map.div ){
			var $map = $(this.map.div);
			$map.find('.olControlZoomIn').attr('title', _loc('Zoom In'));
			$map.find('.olControlZoomOut').attr('title', _loc('Zoom Out'));
		};
		
		// Fix zoomToMaxExtent to zoom to initial extent
		this.map.zoomToMaxExtent = function(){
	        this.zoomToExtent(this.initialZoomBounds);
		};

		// Create control before layers start loading
		this.busyMapControl = new OpenLayers.Control.N2LoadingPanel();

		// Create map layers
		this.mapLayers = [];
		this.vectorLayers = [];
		this.infoLayers = [];
		
		// Re-project vector layer features when base layer is changed
        this.map.events.register('changebaselayer',null,function(evt){
        	// var baseLayer = evt.layer;
        	var lastProjectionObj = evt.oldProjection;
        	var currentProjectionObj = _this.map.getProjectionObject();
			
			// If showSRSAttribution option is true 
			// update the SRS layer attribution
			if( _this.options.showSRSAttribution ) {
				_this._updateSRSAttribution();
			};

        	// Makes sense only when projection is changed
        	if( currentProjectionObj 
           	 && lastProjectionObj 
           	 && currentProjectionObj.getCode() !== lastProjectionObj.getCode() ){
        		
        		// Loop over vector layers
        		for(var li=0,le=_this.vectorLayers.length; li<le; ++li) {
        			var vectorLayer = _this.vectorLayers[li];

        			// Process each feature
            		var features = vectorLayer.features;
            		
            		vectorLayer.removeAllFeatures({silent:true});
            		
            		for(var fi=0,fe=features.length; fi<fe; ++fi){
            			var f = features[fi];
            			f.geometry.transform(lastProjectionObj, currentProjectionObj);
            			
            			// Convert members of cluster, as well, if present
            			if( f.cluster && f.cluster.length ){
                    		for(var ci=0,ce=f.cluster.length; ci<ce; ++ci){
                    			var clustered = f.cluster[ci];
                    			clustered.geometry.transform(lastProjectionObj, currentProjectionObj);
                    		};
            			};
            		};
            		
            		vectorLayer.addFeatures(features,{silent:true});
            	};
    		};
        });
		
		// Generate background layers
		this._genBackgroundMapLayers(this.options);
		
		// Create edit layer
		var editLayerStyleMap = this._createEffectiveStyleMap(null);
		this.editLayer = new OpenLayers.Layer.Vector(
			'Edit'
			,{
				//styleMap: generateDefaultFeatureLayerStyleMap()
				styleMap: editLayerStyleMap
				,displayInLayerSwitcher:false
				,projection: new OpenLayers.Projection('EPSG:4326')
				//,renderers: ['Canvas','SVG','VML']
				,renderers: ['SVG','VML']
			}
		);
		this.mapLayers.push(this.editLayer);
		this.vectorLayers.push(this.editLayer);
		var modifiedHandler = this._createFeatureModifiedHandler(this.editLayer);
		this.editLayer.events.register('featuremodified', null, modifiedHandler);
		
		// Create vector layer for user defined layers (legacy)
		this.layers = {};
		if( this.options.layerInfo ) {
			for(var loop=0; loop<this.options.layerInfo.length; ++loop) {
				var layerOptions = this.options.layerInfo[loop];
				var lInfo = this.createLayerFromOptions(layerOptions);
				if( lInfo && lInfo.olLayer ){
					this.mapLayers.push(lInfo.olLayer);
				};
			};
		};
		
		// Create overlay layers based on layer definition used in couchModule
		if( this.options.overlays ) {
			for(var loop=0; loop<this.options.overlays.length; ++loop) {
				var layerDefinition = this.options.overlays[loop];
				var l = this._createOLLayerFromDefinition(layerDefinition,false);
				if( l ){
					this.mapLayers.push(l);
				};
			};
		};
		
		// Detect if all layers are invisible set to be invisible
		var allLayersInitiallyInvisible = true;
		for(var i=0,e=this.infoLayers.length; i<e; ++i){
			var olLayer = this.infoLayers[i].olLayer;
			if( true == olLayer.visibility ) {
				allLayersInitiallyInvisible = false;
			};
		};
		
		this.map.addLayers(this.mapLayers);

		// Install mouse position widget
		var precisionLevel = 5;
		var mousePositionProjection = this.options.mapCoordinateSpecifications.useForMapControls ? 
				userCoordProjection : mapProjection;

		if( this.options.mapCoordinateSpecifications.mousePositionSrsName ){
			mousePositionProjection = new OpenLayers.Projection(
				this.options.mapCoordinateSpecifications.mousePositionSrsName
			);
		};

		// Reduce level of precision for mouse position to 0 decimal places if the units are in metres
		if( mousePositionProjection.proj.units === 'm'){
			precisionLevel = 0;
		};

		this.map.addControl(new OpenLayers.Control.MousePosition({
			displayProjection: mousePositionProjection,
			numDigits: precisionLevel
		}));
		
		// Layer switcher control
		var showLayerSwitcher = true;
		if( this.options.layerSwitcher
		 && this.options.layerSwitcher.suppress ) {
			showLayerSwitcher = false;
		};
		if( showLayerSwitcher ) {
			var layerSwitcherControl = null;
			if( OpenLayers.Control.NunaliitLayerSwitcher ){
				layerSwitcherControl = new OpenLayers.Control.NunaliitLayerSwitcher();
			} else {
				layerSwitcherControl = new OpenLayers.Control.LayerSwitcher();
			};
			this.map.addControl(layerSwitcherControl);
			if( layerSwitcherControl 
			 && layerSwitcherControl.div ) {
				layerSwitcherControl.div.setAttribute('title', _loc('Layer Selector'));
			};
			if( this.options.layerSwitcher
			 && this.options.layerSwitcher.initiallyOpened ) {
				layerSwitcherControl.maximizeControl();
			} else if( allLayersInitiallyInvisible ) {
				layerSwitcherControl.maximizeControl();
			};
		};

		// Zoom to initial bounds
		this.map.zoomToExtent(this.initialZoomBounds);

		// Draw controls
		this.navigationControls = {
		};
		this.editControls = {
		};
		this.editFeatureControls = {
		};
		
		// Handle feature events
		this._installFeatureSelector();
		
    	// Select adding of new features
    	if( this.options.addPointsOnly ) {
    		// Maps with points only
    		this.editControls.addPoints = new OpenLayers.Control.DrawFeature(this.editLayer,OpenLayers.Handler.Point);
    		this.map.addControl(this.editControls.addPoints);
    	} else {
    		// Maps with all geometry types
    		this.editControls.toolbar = new OpenLayers.Control.EditingToolbar(this.editLayer, {autoActivate: false});
    		if( OpenLayers.Control.NunaliitGazetteer
    		 && this.options.directory
    		 && this.options.directory.geoNamesService ) {
    			var geoNamesService = this.options.directory.geoNamesService;
    			var gazetteerProcess = new GazetteerProcess(geoNamesService);
    			var control = new OpenLayers.Control.NunaliitGazetteer({
    				activateListener: function(){
    					gazetteerProcess.initiateCapture(_this);
    				}
    			});
    			this.editControls.toolbar.addControls([ control ]);
    		};
    		this.map.addControl(this.editControls.toolbar);
    		this.editControls.toolbar.deactivate();
        	
        	// Work around for bug in EditingToolbar (http://trac.openlayers.org/ticket/2182)
    		this.editControls.toolbar.defaultControl = this.editControls.toolbar.controls[0];
    	};
		
		// Busy map control should be last so it is drawn on top
		this.map.addControl(this.busyMapControl);
		
    	this.map.events.register( 'mousemove', null, function(evt){
    		_this._handleMapMousePosition(evt);
		});
		
    	// When changing zoom, check if new simpilified geometries should be loaded
    	this.map.events.register( 'zoomend', null, function(evt){
    		_this._refreshSimplifiedGeometries();
    		_this._updatedStylesInUse();
		});
		
    	// When changing zoom, check if new simpilified geometries should be loaded
    	this.map.events.register( 'move', null, function(evt){
    		_this._mapMoved();
		});

		this.initCometChannels();
		
		var dispatcher = this._getDispatchService();
		if( dispatcher ) {
			dispatcher.send(DH,{
				type: 'mapInitialized'
				,mapControl: this
			});
		};
	},
	
	getCanvasName: function(){
		if( this.options ){
			return this.options.canvasName;
		};
		return undefined;
	},

	getNamedLayerInfo: function(name) {
		for(var i=0,e=this.infoLayers.length; i<e; ++i) {
			var layer = this.infoLayers[i];
			if( layer.name === name ) {
				return layer;
			} else if( layer.id === name ) {
				return layer;
			};
		}
		return null;
	},

	insertSound: function(surl) {
		var $dhtmlSoundDiv = $('#'+this.dhtmlSoundDivId);
		if( $dhtmlSoundDiv.length < 1 ){
			$dhtmlSoundDiv = $('<div></div>')
				.attr('id',this.dhtmlSoundDivId)
				.appendTo( $('body') )
				;
		};
		if (surl) {
			var effectiveUrl = this.dbSearchEngine.getRelMediaPath(surl);
			$dhtmlSoundDiv.html('<embed src="'+effectiveUrl+'" hidden="true" autostart="true" loop="false"/>');
		} else {
			$dhtmlSoundDiv.empty();
		};
	},
	
	initAndDisplayClickedPlaceInfo: function(feature) {
		var dispatchService = this._getDispatchService();
		if( dispatchService ) {
			dispatchService.send(DH, {
				type: 'userSelect'
				,docId: feature.data._id
				,doc: feature.data
				,feature: feature
	 		});
		};
	},
	
	forEachVectorLayer: function(callback){
		if( this.infoLayers && typeof callback === 'function' ){
			for(var i=0,e=this.infoLayers.length; i<e; ++i){
				var layerInfo = this.infoLayers[i];
				var layer = layerInfo.olLayer;
				callback.call(this,layerInfo,layer);
			};
		};
	},

	_updateSRSAttribution: function(){
		var _this = this;
		var currentProjection = this.map.getProjectionObject();
		var srsCode = currentProjection.projCode;
		var projDef = currentProjection.proj.defData.replace(/ /g, ",");

		// Create a new hidden OpenLayers.Layer object with SRS attribution
		var srsAttribution = new OpenLayers.Layer("SRS",{
			attribution:'SRS: <span title='+ projDef +'>' + srsCode +'</span>',
			visibility: true,
			displayInLayerSwitcher: false
		});

		// Remove old SRS attribution layers
		var oldSRSLayer = this.map.getLayersByName("SRS");
		if( oldSRSLayer.length > 0 ){
			oldSRSLayer.forEach(function(srsLayer){
				_this.map.removeLayer(srsLayer);
			});
		};

		// Add SRS attribution layer
		this.map.addLayers([srsAttribution]);
	},

	_getMapFeaturesIncludingFid: function(fid){
		var fidMap = {};
		fidMap[fid] = true;
		
		var features = this._getMapFeaturesIncludingFidMap(fidMap);
		return features;
	},
	
	_getMapFeaturesIncludingFids: function(fids){
		var fidMap = {};
		for(var i=0,e=fids.length; i<e; ++i){
			var fid = fids[i];
			fidMap[fid] = true;
		};
		
		var features = this._getMapFeaturesIncludingFidMap(fidMap);
		return features;
	},
	
	_getMapFeaturesIncludingFidMap: function(fidMap){
		var features = [];
		
		for(var loop=0; loop<this.infoLayers.length; ++loop) {
			var layerInfo = this.infoLayers[loop];
			var feature = this._getLayerFeatureIncludingFidMap(layerInfo.olLayer,fidMap);
			if( feature ) {
				features.push(feature);
			};
		};
		
		return features;
	},
	
	_getLayerFeatureIncludingFid: function(layer, fid){
		var map = {};
		map[fid] = true;
		return this._getLayerFeatureIncludingFidMap(layer, map);
	},
	
	_getLayerFeatureIncludingFidMap: function(layer,fidMap) {
		
		if( layer && layer.features ) {
			var loop;
			var features = layer.features;
			for(loop=0;loop<features.length;++loop) {
				var feature = features[loop];
				if( feature.fid && fidMap[feature.fid] ) {
					return feature;
				} else if( feature.cluster ) {
					for(var j=0,k=feature.cluster.length; j<k; ++j){
						var f = feature.cluster[j];
						if( f.fid && fidMap[f.fid] ){
							return feature;
						};
					};
				};
			};
		};
		
		return null;
	},
	
	_getLayerFeaturesFromFilter: function(layer,filter) {
		var r = [];
		
		if( layer && layer.features ) {
			var features = layer.features;
			for(var i=0,e=features.length; i<e; ++i) {
				var f = features[i];
				if( filter.matches(f) ) {
					r.push(f);
				};
			};
		};
		
		return r;
	},
	
	_reloadFeature: function(filter,options_) {
		// Figure out which layers to reload
		var reloadInfoLayers = [];
		for(var loop=0; loop<this.infoLayers.length; ++loop) {
			var layerInfo = this.infoLayers[loop];
			var features = this._getLayerFeaturesFromFilter(layerInfo.olLayer,filter);
			if( features.length > 0 ) {
				reloadInfoLayers.push(layerInfo);
			};
		};
		
		// If no layer was selected, then it must be a new feature.
		// Attempt reloading all
		if( 0 == reloadInfoLayers.length ) {
			for(var loop=0; loop<this.infoLayers.length; ++loop) {
				var layerInfo = this.infoLayers[loop];
				reloadInfoLayers.push(layerInfo);
			};
		};
		
		// Reload selected layers		
		for(var loop=0; loop<reloadInfoLayers.length; ++loop) {
			var layerInfo = reloadInfoLayers[loop];
			
			this._loadFeatureOnLayer(layerInfo, filter, options_);
		};
	},
	
	/*
	 * Attempts to reload features given a specified layer and filter
	 */
	_loadFeatureOnLayer: function(layerInfo,filter,options_){
		var _this = this;
		
		// Figure out options
		var reloadOptions = $n2.extend({
			onReloaded: function(feature){}
		},options_);

		var protocol = layerInfo.protocol;
		
		// Create filter
		var olFilter = filter.getOpenLayerFilter();
		
        protocol.read({
	        filter: olFilter
	        ,callback: createCallback(layerInfo, reloadOptions)
	        //,scope: this
        });
		
		function createCallback(layerInfo, reloadOptions) {
			var cb = function(resp) {
				if( resp.code !== OpenLayers.Protocol.Response.SUCCESS ) {
					alert('Error while obtaining a new feature.\n'
						 +'Map might not display up-to-date information.\n'
						 +'You might need to refresh your page.');
				};

				// Filter features
				var features = [];
				if( resp.features ) {
					for(var featureLoop=0; featureLoop<resp.features.length; ++featureLoop) {
						var feature = resp.features[featureLoop];
						if( null != layerInfo.olFilter ) {
							if( false == layerInfo.olFilter.evaluate(feature.attributes) ) {
								feature = null;
							};
						};
						if( null != feature ) {
							features.push(feature);
						};
					};
				};
				
				// Reproject features, if needed
		        if( features.length > 0) {
		            var remote = layerInfo.olLayer.projection;
        		    var local = layerInfo.olLayer.map.getProjectionObject();
		            if( false == local.equals(remote) ) {
		                for(var featureLoop=0; featureLoop<features.length; ++featureLoop) {
        		            var geom = features[featureLoop].geometry;
                		    if( null != geom ) {
                        		geom.transform(remote, local);
		                    };
        		        };
		            };
		        };
		        
				// Analyze features
		        var featuresToAdd = [];
		        var featuresToDestroy = [];
				for(var featureLoop=0; featureLoop<features.length; ++featureLoop) {
					// Read in feature
					var loadedFeature = features[featureLoop];
					featuresToAdd.push(loadedFeature);
					
					var feature = _this._getLayerFeatureIncludingFid(layerInfo.olLayer,loadedFeature.fid);
					if( feature ) {
						if( feature.cluster ){
							for(var j=0,k=feature.cluster.length; j<k; ++j){
								var cf = feature.cluster[j];
								if( cf.fid !== loadedFeature.fid ){
									featuresToAdd.push(cf);
								};
							};
						};
						
						featuresToDestroy.push(feature);
					}
				};
				
				// Remove features
				if( featuresToDestroy.length > 0 ){
					layerInfo.olLayer.destroyFeatures(featuresToDestroy);
				};
					
				// Add feature to layer
				// If in edit mode, first disable editAttribute widget
				if( _this.currentMode === _this.modes.ADD_OR_SELECT_FEATURE 
				 || _this.currentMode === _this.modes.ADD_GEOMETRY ) {
					_this.editModeAddFeatureEnabled = false;
					
					layerInfo.olLayer.addFeatures(featuresToAdd);
					
					_this.editModeAddFeatureEnabled = true;
				} else {
					layerInfo.olLayer.addFeatures(featuresToAdd);
				};

				// Report feature reloaded
				for(var featureLoop=0; featureLoop<features.length; ++featureLoop) {
					// Read in feature
					var loadedFeature = features[featureLoop];
					reloadOptions.onReloaded(loadedFeature);
				};
				
				// Refresh styles
				_this._updatedStylesInUse();
			};
			
			return cb;
		};
	},
	
	_removeFeature: function(fid) {
		for(var loop=0; loop<this.vectorLayers.length; ++loop) {
			var mapLayer = this.vectorLayers[loop];
			var feature = this._getLayerFeatureIncludingFid(mapLayer,fid);
			if( feature ) {
				if( feature.fid === fid ){
					mapLayer.destroyFeatures(feature);
					
				} else if( feature.cluster ){
					// Accumulate left over features from cluster
					var remainingFeatures = null;
					for(var j=0,k=feature.cluster.length; j<k; ++j){
						var cf = feature.cluster[j];
						if( cf.fid !== fid ){
							if( !remainingFeatures ) remainingFeatures = [];
							remainingFeatures.push(cf);
						};
					};
					
					// Destroy cluster feature
					mapLayer.destroyFeatures(feature);
					
					// Add remaining features, if needed
					if( remainingFeatures ){
						mapLayer.addFeatures(remainingFeatures);
					};
				};
			};
		};
	},
	
	_centerMapOnFeature: function(feature) {
    	var geom = feature.geometry;
    	var bbox = geom.getBounds();
		var x = (bbox.left + bbox.right) / 2;
		var y = (bbox.bottom + bbox.top) / 2;
		
		this._centerMapOnXY(x,y,null); // same projection as map
	},

	_centerMapOnXY: function(x, y, projCode) {
		var ll = new OpenLayers.LonLat(x, y);
		
		var mapProj = this.map.getProjectionObject();
		
		if( projCode 
		 && projCode != mapProj.getCode() ) {
			var proj = new OpenLayers.Projection(projCode);
			ll.transform(proj, mapProj); // transform in place
		};
		
		var z = this.map.getZoom();
		this.map.setCenter(ll, z, false, false);
	},
	
	_installGeometryEditor: function(feature){
		// Remove previous editor
		this._removeGeometryEditor();
		
   		var modifyFeatureGeometry = new OpenLayers.Control.ModifyFeature(
   			this.editLayer
   			,{
   				'displayClass': 'olControlMoveFeature'
   				,standalone: true
   				,clickout: false
   			}
   		);
   		modifyFeatureGeometry.mode = OpenLayers.Control.ModifyFeature.RESHAPE;
		this.map.addControl(modifyFeatureGeometry);
		modifyFeatureGeometry.activate();
    	this.editFeatureControls.modifyFeatureGeometry = modifyFeatureGeometry;
    	
    	if( feature ){
    		// This is a new feature that is on the EDIT layer
    		modifyFeatureGeometry.selectFeature(feature);
    	};
	},
	
	_updateGeometryEditor: function(olGeom, proj){
		// Reproject, if needed
		var mapProj = this.map.getProjectionObject();
		if( olGeom 
		 && proj 
		 && mapProj.getCode() != proj.getCode() ) {
			olGeom = olGeom.clone();
			olGeom.transform(proj, mapProj);
		} else if( olGeom ) {
			olGeom = olGeom.clone();
		};

		var modifyFeatureControl = this.editFeatureControls.modifyFeatureGeometry;
		
		var editFeature = modifyFeatureControl.feature;
		if( editFeature ) {
			// Redraw
			modifyFeatureControl.unselectFeature(editFeature);
			editFeature.layer.eraseFeatures([editFeature]);
			editFeature.geometry = olGeom;
			editFeature.layer.drawFeature(editFeature);
			modifyFeatureControl.selectFeature(editFeature);
		} else {
			// Add
	    	editFeature = new OpenLayers.Feature.Vector(olGeom);
	    	editFeature.fid = this.editFeatureInfo.fid;

	    	// Add to edit layer
	    	this.editModeAddFeatureEnabled = false;
	    	this.editLayer.addFeatures([editFeature]);
	    	this.editModeAddFeatureEnabled = true;

	    	modifyFeatureControl.selectFeature(editFeature);
		};
	},
	
	_removeGeometryEditor: function(){
		var editFeature = undefined;
		if( this.editFeatureControls.modifyFeatureGeometry ) {
			editFeature = this.editFeatureControls.modifyFeatureGeometry.feature;
    		if( editFeature ) {
    			this.editFeatureControls.modifyFeatureGeometry.unselectFeature(editFeature);
    		};
    		this.editFeatureControls.modifyFeatureGeometry.deactivate();
    		this.map.removeControl( this.editFeatureControls.modifyFeatureGeometry );
    		this.editFeatureControls.modifyFeatureGeometry.destroy();
    		this.editFeatureControls.modifyFeatureGeometry = null;

    		// Remove feature from edit layer
			if( editFeature && editFeature.layer ) {
				editFeature.layer.destroyFeatures([editFeature]);
			};
		};
		
		return editFeature;
	},

	// @param bounds Instance of OpenLayers.Bounds
	convertBoundsToMapProjection: function(bounds, srsName) {
		// TBD: Can we get the projection directly from the map?
		var mapProjection = new OpenLayers.Projection(this.options.mapDisplay.srsName);
		var userCoordProjection = new OpenLayers.Projection(srsName);

		if (userCoordProjection.getCode() != mapProjection.getCode()) {
			bounds.transform(userCoordProjection, mapProjection);
		};
	},
	
	redrawMap: function() {
		var layers = this.map.layers;
		for(var loop=0; loop<layers.length; ++loop) {
	        if (layers[loop].isBaseLayer )  {
	        	// nothing
	        } else {
	            layers[loop].redraw();
	        };
		};
		
		this._updatedStylesInUse();
	},

	_createOverlayFromDefinition: function(layerDefinition, isBaseLayer) {
		var _this = this;
		var cs = this._getCustomService();

		// Create LayerInfo
		var layerInfoOptions = $.extend({
			styleMapFn: function(layerInfo){ 
				return _this._createStyleMapFromLayerInfo(layerInfo); 
			}
		}, layerDefinition);
		layerInfoOptions.customService = cs; 
		var layerInfo = new LayerInfo(layerInfoOptions);
		
		var layerOptions = {
			name: layerInfo.name
			,projection: layerInfo.sourceProjection
			,visibility: layerInfo.visibility
			,_layerInfo: layerInfo
		};

		if( 'couchdb' === layerDefinition.type ) {
			// This is a couch layer
			var couchProtocolOpt = $n2.extend({},layerDefinition.options,{
				notifications: {
					readStart: function(){
						_this._mapBusyStatus(1);
					}
					,readEnd: function(){
						_this._mapBusyStatus(-1);
					}
				}
			});
			layerInfo.protocol = new OpenLayers.Protocol.Couch(couchProtocolOpt);
			layerOptions.protocol = layerInfo.protocol;
			layerInfo.cachingAllowed = true;
			
		} else if( 'model' === layerDefinition.type ) {
			var modelProtocolOptions = $n2.extend({},layerDefinition.options);
			modelProtocolOptions.dispatchService = this._getDispatchService();
			modelProtocolOptions.onUpdateCallback = function(state){
				_this._modelLayerUpdated(layerOptions, state);
			};
			modelProtocolOptions.notifications = {
				readStart: function(){
					_this._mapBusyStatus(1);
				}
				,readEnd: function(){
					_this._mapBusyStatus(-1);
				}
			};
			
			layerInfo.protocol = new OpenLayers.Protocol.Model(modelProtocolOptions);
			layerOptions.protocol = layerInfo.protocol;

		} else if( 'wfs' === layerDefinition.type ) {
			// This is a WFS layer
			
			var wfsProtocolOptions = {
				url:null
				,featurePrefix: null
				,featureType: null
				,featureNS: null
				,version: '1.1.0'
				,geometryName: 'the_geom'
			};
			
			// Parse layer options
			if( layerDefinition.options ){
				for(var key in layerDefinition.options){
					// Options associated with protocol
					if( 'url' === key
					 || 'featurePrefix' === key 
					 || 'featureType' === key 
					 || 'featureNS' === key 
					 || 'version' === key 
					 || 'geometryName' === key 
					 ){
						wfsProtocolOptions[key] = layerDefinition.options[key];
					};
				};
			};
			
			// Protocol to output in JSON format
			wfsProtocolOptions.readFormat = new OpenLayers.Format.GeoJSON();
			wfsProtocolOptions.outputFormat = 'json';
			
			// Compute schema name
			layerInfo.typename = layerInfo.featurePrefix + ':' + layerInfo.featureType;
			layerInfo.schema = wfsProtocolOptions.url 
				+ '?service=WFS&version=' + wfsProtocolOptions.version 
				+ '&request=DescribeFeatureType&typeName=' + layerInfo.typename;

			layerInfo.protocol = new OpenLayers.Protocol.WFS(wfsProtocolOptions);
			layerOptions.protocol = layerInfo.protocol;
			
		} else {
			// Unrecognized layer
			$n2.reportError('Unrecognized type ('+layerInfo.type+') for layer: '+layerInfo.name);
		};

		// Create style map
		var layerStyleMap = this._createEffectiveStyleMap(layerInfo);
		layerOptions.styleMap = layerStyleMap;

		// Filter
		layerInfo.olFilter = null;
		if( layerInfo.filter ) {
			layerInfo.olFilter = $n2.olFilter.CreateOpenLayersFilter(layerInfo.filter);

			if( null == layerInfo.olFilter ) {
				alert('Encountered invalid filter');
			} else {
				layerOptions.filter = layerInfo.olFilter;
			};
		};

		if( layerInfo.useFixedStrategy ) {
			// Compute bbox string in the source coordinate space of the vector layer
			var vecSourceExtent = new OpenLayers.Bounds(
				options.mapCoordinateSpecifications.maxExtent[0]
				,options.mapCoordinateSpecifications.maxExtent[1]
				,options.mapCoordinateSpecifications.maxExtent[2]
				,options.mapCoordinateSpecifications.maxExtent[3]
				);
			if( userCoordProjection.getCode() != layerInfo.sourceProjection.getCode() ) {
				/*
				 * if the user coordinate space is different from the source projection of the vector layer
				 * then project the max extent bounding box back to the source projection of the vector layer.
				 * The WFS request can reproject the data but it cannot handle a bbox request in the reprojected
				 * coordinate space.
				 */
				vecSourceExtent.transform(userCoordProjection, layerInfo.sourceProjection);
			}

			// Add a BBOX filter
			var bboxFilter = new OpenLayers.Filter.Spatial({
				type: OpenLayers.Filter.Spatial.BBOX
				,property:  layerInfo.geometryName
				,value: vecSourceExtent
			});

			// Add filter
			if( null == layerOptions.filter ) {
				layerOptions.filter = bboxFilter;
			} else {
				var andFilter = new OpenLayers.Filter.Logical({
					type: OpenLayers.Filter.Logical.AND
					,filters: [ layerOptions.filter, bboxFilter ]
				});
				layerOptions.filter = andFilter;
			}

			// Installing strategies make sense only if a protocol is provided
			if( layerOptions.protocol ) {
				layerOptions.strategies = [ new OpenLayers.Strategy.Fixed() ];
			};

		} else {
			// Installing strategies make sense only if a protocol is provided
			if( layerOptions.protocol ) {
				if( 'couchdb' === layerDefinition.type ) {
					layerOptions.strategies = [ new OpenLayers.Strategy.N2BBOX() ];
				} else if( 'model' === layerDefinition.type ){
					// no bounding box strategies for model layers
					layerOptions.strategies = [ new OpenLayers.Strategy.Fixed() ];
				} else {
					layerOptions.strategies = [ new OpenLayers.Strategy.BBOX() ];
				};
			};
		};
		
		if( !layerOptions.strategies ){
			layerOptions.strategies = [];
		};
		layerInfo.featureStrategy = new OpenLayers.Strategy.NunaliitFeatureStrategy();
		layerOptions.strategies.push( layerInfo.featureStrategy );
		if( typeof layerDefinition.minimumLinePixelSize === 'number' 
		 || typeof layerDefinition.minimumPolygonPixelSize === 'number' ){
			var minimumSizeOptions = {};
			if( typeof layerDefinition.minimumLinePixelSize === 'number' ){
				minimumSizeOptions.minimumLinePixelSize = layerDefinition.minimumLinePixelSize;
			};
			if( typeof layerDefinition.minimumPolygonPixelSize === 'number' ){
				minimumSizeOptions.minimumPolygonPixelSize = layerDefinition.minimumPolygonPixelSize;
			};
			layerInfo.featureStrategy.setMinimumSize(minimumSizeOptions);
		};
		if( layerInfo.clustering ) {
			var clusterOptions = {};
			
			if( typeof layerDefinition.minimumLinePixelSize === 'number' ){
				clusterOptions.minimumLinePixelSize = layerDefinition.minimumLinePixelSize;
			};
			if( typeof layerDefinition.minimumPolygonPixelSize === 'number' ){
				clusterOptions.minimumPolygonPixelSize = layerDefinition.minimumPolygonPixelSize;
			};
			
			for(var cProp in layerInfo.clustering){
				var cValue = layerInfo.clustering[cProp];
				if( 'distance' === cProp
				 || 'threshold' === cProp
				 || 'disableDynamicClustering' === cProp
				 || 'minimumPolygonPixelSize' === cProp
				 || 'minimumLinePixelSize' === cProp
				 || 'clusterPointsOnly' === cProp ){
					clusterOptions[cProp] = cValue;
				};
			};
			layerInfo.featureStrategy.setClustering(clusterOptions);
		};
		
		//layerOptions.renderers = ['Canvas','SVG','VML'];
		layerOptions.renderers = ['SVG','VML'];

		layerInfo.olLayer = new OpenLayers.Layer.Vector(layerInfo.name, layerOptions);

		// Add events to layer
		this._registerLayerForEvents(layerInfo);

		// Remember
		this.infoLayers.push( layerInfo );
		this.vectorLayers.push( layerInfo.olLayer );
		
		// Allow caller to access layers
		if( layerInfo.id ) {
			this.layers[layerInfo.id] = layerInfo.olLayer;
		} else {
			this.layers[layerInfo.name] = layerInfo.olLayer;
		};
		
		return layerInfo.olLayer;
	},
	
	/*
	 * Creates a Layer from OpenLayers given the layer definition.
	 */
	_createOLLayerFromDefinition: function(layerDefinition, isBaseLayer){
		var name = _loc(layerDefinition.name);
		
		if( 'Bing' == layerDefinition.type ){
			var options = layerDefinition.options;
			if( options
			 && options.key ) {
				var opts = $n2.extend({
					name: name
				},options);
				var l = new OpenLayers.Layer.Bing(opts);
				return l;
				
			} else {
				$n2.reportError('Bad configuration for layer: '+name);
				return null;
			};
			
		} else if( 'Google Maps' == layerDefinition.type ){
			//this._checkGoogleMapAPI();
			
			var options = layerDefinition.options;
			
			if( options && 'string' === typeof(options.type) ){
				var mapTypeId = null;
				if( typeof google !== 'undefined' 
				 && google.maps 
				 && google.maps.MapTypeId ){
					mapTypeId = google.maps.MapTypeId[options.type];
				};
				if( mapTypeId ) {
					options.type = mapTypeId;
				} else {
					$n2.reportError('Attempting to load a Google Map background. A map API key must be configured');
					$n2.logError('Unable to load Google Map type: '+options.type);
					return null;
				};
			};
			
			if( options
			 && options.type ) {
				var l = new OpenLayers.Layer.Google(name, options);
				return l;
				
			} else {
				$n2.reportError('Bad configuration for layer: '+name);
				return null;
			};
			
		} else if( 'couchdb' === layerDefinition.type
		 || 'model' === layerDefinition.type
		 || 'wfs' === layerDefinition.type ){
			if( isBaseLayer ) {
				$n2.reportError('Layer type not suitable for background: '+layerDefinition.type);
			} else {
				return this._createOverlayFromDefinition(layerDefinition, isBaseLayer);
			};
			
		} else if( 'wms' === layerDefinition.type ){
			var options = layerDefinition.options;
			
			if( options ) {
				var wmsUrl = null;
				var wmsOptions = {};
				var layerOptions = {
					isBaseLayer: isBaseLayer
				};
				if( typeof(layerDefinition.visibility) === 'boolean' ){
					layerOptions.visibility = layerDefinition.visibility;
				};
				if ($n2.isDefined(layerDefinition.gutter)) {
					layerOptions.gutter = layerDefinition.gutter;
				};
				if ($n2.isDefined(layerDefinition.displayInLayerSwitcher)) {
					layerOptions.displayInLayerSwitcher = layerDefinition.displayInLayerSwitcher;
				};
				for(var key in options){
					if( 'url' === key ) {
						wmsUrl = options[key];

					} else if( 'srsName' === key ) {
						var proj = new OpenLayers.Projection( options[key] );
						layerOptions.projection = proj;

					} else if( 'opacity' === key
							|| 'scales' === key 
							|| 'resolutions' === key 
							|| 'maxScale' === key
							|| 'minScale' === key
							|| 'maxResolution' === key
							|| 'minResolution' === key
							|| 'numZoomLevels' === key
							|| 'maxZoomLevel' === key ) {
						layerOptions[key] = options[key];
						
					} else {
						wmsOptions[key] = options[key];
					};
				};
				var l = new OpenLayers.Layer.WMS(name, wmsUrl, wmsOptions, layerOptions);
				
				return l;
				
			} else {
				$n2.reportError('Bad configuration for layer: '+name);
				return null;
			};
			
		} else if( 'osm' === layerDefinition.type ){
			var url = null;
			var layerOptions = {
				isBaseLayer: isBaseLayer
			};

			if( typeof(layerDefinition.visibility) === 'boolean' ){
				layerOptions.visibility = layerDefinition.visibility;
			};

			var options = layerDefinition.options;
			if( options ) {
				for(var optionKey in options){
					var optionValue = options[optionKey];
					
					if( optionKey === 'url' ){
						url = optionValue;
					} else {
						layerOptions[optionKey] = optionValue;
					};
				};
			};

			var l = new OpenLayers.Layer.OSM(name, url, layerOptions);
			return l;
			
		} else if( 'stamen' === layerDefinition.type ){
			var layerName = null;
			var layerOptions = {
				isBaseLayer: isBaseLayer
			};

			if( typeof(layerDefinition.visibility) === 'boolean' ){
				layerOptions.visibility = layerDefinition.visibility;
			};

			var options = layerDefinition.options;
			if( options ) {
				for(var optionKey in options){
					var optionValue = options[optionKey];
					
					if( optionKey === 'layerName' ){
						layerName = optionValue;
					} else {
						layerOptions[optionKey] = optionValue;
					};
				};
			};

			if( OpenLayers.Layer.Stamen ) {
				if( !layerName ){
					$n2.reportError('Option layerName must be specified for a Stamen background.');
				}else{
					var l = new OpenLayers.Layer.Stamen(layerName, layerOptions);
					if( name ) {
						l.name = name;
					};
					return l;
				};
			} else {
				$n2.log('Stamen layer can not be added since Javascript library is not included');
			};
			
		} else if( 'image' === layerDefinition.type ){
			var url = null;
			var height = null;
			var width = null;
			var extent = null;
			var layerOptions = {
				isBaseLayer: isBaseLayer
			};

			if( typeof(layerDefinition.visibility) === 'boolean' ){
				layerOptions.visibility = layerDefinition.visibility;
			};

			var options = layerDefinition.options;
			if( options ) {
				for(var optionKey in options){
					var optionValue = options[optionKey];
					
					if( optionKey === 'url' ){
						url = optionValue;
					} else if( optionKey === 'height' ){
							height = 1 * optionValue;
					} else if( optionKey === 'width' ){
						width = 1 * optionValue;
					} else if( optionKey === 'extent' ){
						extent = optionValue;
					} else {
						layerOptions[optionKey] = optionValue;
					};
				};
			};

			if( OpenLayers.Layer.Image ) {
				var effectiveExtent = null;
				if( extent
				 && $n2.isArray(extent)
				 && extent.length == 4 ) {
					effectiveExtent = new OpenLayers.Bounds(extent[0], extent[1], extent[2], extent[3]);
				};
				
				if( !url ){
					$n2.reportError('Option url must be specified for an Image background.');
				} else if( !height ) {
					$n2.reportError('Option height must be specified for an Image background.');
				} else if( !width ) {
					$n2.reportError('Option width must be specified for an Image background.');
				} else if( !effectiveExtent ) {
					$n2.reportError('Option extent must be specified as an array of four numbers for an Image background.');
				} else {
					var size = new OpenLayers.Size(width,height);
					
					var l = new OpenLayers.Layer.Image(name, url, effectiveExtent, size, layerOptions);
					return l;
				};
				
			} else {
				$n2.log('Image layer can not be added since OpenLayers does not support this type of background');
			};
			
		} else {
			$n2.reportError('Unknown layer type: '+layerDefinition.type);
		};
		
		return null;
	},
	
	_registerLayerForEvents: function(layerInfo){
		var _this = this;
		
		// Report change in visibility for the layer
		layerInfo.olLayer.events.register('visibilitychanged', null, function(evt_){
			var selected = evt_.object.visibility;
			layerInfo.selectListener(selected,layerInfo);
		});
		
		// Adjust isClicked and isHovered attributes before the feature is added to the layer
		layerInfo.olLayer.events.register('beforefeaturesadded', null, function(evt_){
			var features = evt_.features;
			if( features ){
				for(var i=0,e=features.length;i<e;++i){
					var f = features[i];
					if( _this.clickedInfo.fids[f.fid] ){
						var featureInfo = _this.clickedInfo.fids[f.fid];
						
						_this.clickedInfo.features.push(f);
						
						if( featureInfo.clicked ) {
							f.isClicked = true;
						};
						
						if( featureInfo.intent ) {
							f.n2SelectIntent = featureInfo.intent;
						};
					};
					if( _this.focusInfo.fids[f.fid] ){
						_this.focusInfo.features.push(f);
						f.isHovered = true;
					};
					if( _this.findFeatureInfo.fid === f.fid ){
						_this.findFeatureInfo.features.push(f);
						f.n2Intent = 'find';
					};
					if( f.cluster ){
						for(var j=0,k=f.cluster.length; j<k; ++j){
							var clusterFeature = f.cluster[j];
							if( _this.clickedInfo.fids[clusterFeature.fid] ){
								var featureInfo = _this.clickedInfo.fids[clusterFeature.fid];
								_this.clickedInfo.features.push(f);
								if( featureInfo.clicked ) {
									f.isClicked = true;
								};
								if( featureInfo.intent ) {
									f.n2SelectIntent = featureInfo.intent;
								};
							};
							if( _this.focusInfo.fids[clusterFeature.fid] ){
								_this.focusInfo.features.push(f);
								f.isHovered = true;
							};
							if( _this.findFeatureInfo.fid === clusterFeature.fid ){
								_this.findFeatureInfo.features.push(f);
								f.n2Intent = 'find';
							};
						};
					};
				};
			};
			
			return true;
		});
		
		layerInfo.olLayer.events.register('featuresadded', null, function(evt_){

			// Clear the cache associated with the layer.
			var layer = null;
			var infoLayer = null;
			if( evt_ 
			 && evt_.features 
			 && evt_.features.length 
			 && evt_.features[0] 
			 && evt_.features[0].layer ) {
				layer = evt_.features[0].layer;
			};
			if( layer ) {
				infoLayer = layer._layerInfo;
			};
			if( infoLayer ) {
				_this._clearValueCache(infoLayer);
			};

			// When features are added, check the map for new simplified geometries
			_this._refreshSimplifiedGeometries();
			
			_this._updatedStylesInUse();
		});
		
		// When features are removed, clear the cache associated with the layer.
		layerInfo.olLayer.events.register('featuresremoved', null, function(evt_){
			var layer = null;
			var infoLayer = null;
			if( evt_ 
			 && evt_.features 
			 && evt_.features.length 
			 && evt_.features[0] 
			 && evt_.features[0].layer ) {
				layer = evt_.features[0].layer;
			};
			if( layer ) {
				infoLayer = layer._layerInfo;
			};
			
			if( infoLayer ) {
				_this._clearValueCache(infoLayer);
			};

			_this._updatedStylesInUse();
		});
	},
    
    _createFeatureModifiedHandler: function(olLayer){
    	var _this = this;
    	
        // Called when the feature on the map is modified
    	return function(evt){
        	var feature = evt.feature;
        	
        	_this._dispatch({
        		type: 'editGeometryModified'
        		,docId: feature.fid
        		,geom: feature.geometry
        		,proj: olLayer.map.getProjectionObject()
        		,_origin: _this
        	});
    	};
    },

	_genBackgroundMapLayers: function(options) {
		var _this = this;
		var bg = null;
		
		if( options
		 && options.mapDisplay
		 && options.mapDisplay.backgrounds ) {
			// This is the method used when background layers are specified
			// via couchModule
			for(var i=0,e=options.mapDisplay.backgrounds.length; i<e; ++i){
				var layerDefiniton = options.mapDisplay.backgrounds[i];
			
				var l = this._createOLLayerFromDefinition(layerDefiniton, true);
				if( l && !bg ) bg = [];
				if( l ) bg[bg.length] = l;
			};
			
		} else if( options
		 && options.mapDisplay
		 && options.mapDisplay.background ) {
			// Legacy code calling map/control directly
			
			var background = options.mapDisplay.background;
			
			if( typeof(background.callback) === 'function' ) {
				bg = background.callback(background);
				
			} else if( 'Bing' == background.type ) {
				if( background.key
				 && OpenLayers
				 && OpenLayers.Layer
				 && OpenLayers.Layer.Bing
				 ) {
					if( background.layers
					 && $n2.isArray(background.layers)
					 ) {
						bg = [];
						for(var i=0,e=background.layers.length; i<e; ++i) {
							var lOpt = $n2.extend({
								key: background.key
							},background.layers[i]);
							var l = new OpenLayers.Layer.Bing(lOpt);
							bg.push(l);
						};
					} else {
						// Default layers
						bg = [];
						bg.push( new OpenLayers.Layer.Bing({name:'Satellite',type:'Aerial',key:background.key}) );
						bg.push( new OpenLayers.Layer.Bing({name:'Road',type:'Road',key:background.key}) );
						bg.push( new OpenLayers.Layer.Bing({name:'Hybrid',type:'AerialWithLabels',key:background.key}) );
					};
				} else {
					$n2.reportError('Bad configuration for background type: '+background.type);
				};
				
			} else if( 'Google Maps' == background.type ) {
					if( OpenLayers
					 && OpenLayers.Layer
					 && OpenLayers.Layer.Google
					 ) {
						this._checkGoogleMapAPI();
						
						if( background.layers
						 && $n2.isArray(background.layers) 
						 ) {
							bg = [];
							for(var i=0,e=background.layers.length; i<e; ++i) {
								var lOpt = background.layers[i];
								var l = new OpenLayers.Layer.Google(lOpt.name, lOpt);
								bg.push(l);
							};
						} else {
							// Default layers
							bg = getDefaultGoogleLayers();
						};
					} else {
						$n2.reportError('Bad configuration for background type: '+background.type);
					};
					
			} else {
				$n2.reportError('Unknown background type: '+background.type);
			};
			
		} else {
			// Not specified...
			bg = getDefaultGoogleLayers();
		};
		
		if( bg ) {
			for(var i=0,e=bg.length;i<e;++i){
				var bgLayer = bg[i];
				
				this.mapLayers.push( bgLayer );
			};
		};
		
		return(bg);
		
		function getDefaultGoogleLayers() {
			var bg = null;
			// GMap version 2
			if( typeof(GMap2) === 'function' ) {
				bg = [];
				
				bg.push( new OpenLayers.Layer.Google("Google Satellite",{type:G_SATELLITE_MAP,'sphericalMercator': true}) );
				bg.push( new OpenLayers.Layer.Google("Google Physical",{type: G_PHYSICAL_MAP,'sphericalMercator': true}) );
				bg.push( new OpenLayers.Layer.Google("Google Hybrid",{type: G_HYBRID_MAP,'sphericalMercator': true}) );
				
			} else if( typeof google !== 'undefined'
				&& google.maps
				&& google.maps.MapTypeId 
				) {
				
				if( google.maps.Map ) {
					// disable annoying pop up
					google.maps.Map.disableDefaultUI = true;
				};
				
				// GMap v3
				bg = [];
				bg.push( new OpenLayers.Layer.Google("Google Satellite",{type:google.maps.MapTypeId.SATELLITE,numZoomLevels: 20}) );
				bg.push( new OpenLayers.Layer.Google("Google Physical",{type:google.maps.MapTypeId.TERRAIN,numZoomLevels:20}) );
				bg.push( new OpenLayers.Layer.Google("Google Hybrid",{type:google.maps.MapTypeId.HYBRID,numZoomLevels: 20}) );
			};
			return bg;
		};
	},
	
	_checkGoogleMapAPI: function(){
		var googleMapApiLoaded = false;
		if( typeof window === 'object' 
		 && window.google 
		 && window.google.maps ){
			googleMapApiLoaded = true;
		};
		if( !googleMapApiLoaded ){
			$n2.logError('Google Map API is not loaded. Please, configure a Google Map API key');
		};
	},

	getBaseLayers: function() {
		var baseLayers = [];
		
		if( this.map 
		 && this.map.layers ){
			for(var i=0,e=this.map.layers.length; i<e; ++i){
				var layer = this.map.layers[i];
				if( layer.isBaseLayer ){
					var layerInfo = {
						id: layer.id
						,projection: layer.projection
					};
					
					baseLayers.push( layerInfo );
				};
			};
		};
		
		return baseLayers;
	},

	setBaseLayer: function(layerId) {

		var baseLayer = null;
		if( this.map 
		 && this.map.layers ){
			for(var i=0,e=this.map.layers.length; i<e; ++i){
				var layer = this.map.layers[i];
				if( layer.isBaseLayer 
				 && layer.id === layerId ){
					baseLayer = layer;
					break;
				};
			};
		};
		
		if( baseLayer ){
			this.map.setBaseLayer(baseLayer);
		};
	},
	
    // === HOVER AND CLICK START ========================================================

   	_startClicked: function(mapFeature, forced) {
   		var feature = mapFeature;
   		if( feature && feature.cluster && feature.cluster.length == 1 ){
   			feature = feature.cluster[0];
   		};
   		
		var clickedAgain = false;
   		if( !forced ) {
			clickedAgain = (feature && feature.fid && this.clickedInfo.selectedId === feature.fid);
   		};
		if( !forced && !this.options.toggleClick && clickedAgain ) {
			// ignore click again
			return;
		};
		
		if( feature.cluster ){
			var layerInfo = feature.layer._layerInfo;

			layerInfo.clusterClickCallback(feature, this);
			
			return;
		};
		
		this._endClicked();
		
		if( !forced && this.options.toggleClick && clickedAgain ) {
			this._dispatch({type:'userUnselect',docId:feature.fid});
			
		} else if( feature.fid ) {
			this.clickedInfo.features = [feature];

			this.clickedInfo.fids = {};
			this.clickedInfo.fids[feature.fid] = { clicked: true };
			this.clickedInfo.selectedId = feature.fid;
			
			feature.isClicked = true;
			if( feature.layer ) {
				feature.layer.drawFeature(feature);
			}
			
			if( this.currentMode.onStartClick ) {
				this.currentMode.onStartClick(feature, mapFeature);
			};
		};
	},
	
	_endClicked: function() {
		this._endFindFeature();
		
		if( this.clickedInfo.features ) {
			for(var i=0,e=this.clickedInfo.features.length;i<e;++i){
				var feature = this.clickedInfo.features[i];
				
				if( feature.isClicked ) {
					feature.isClicked = false;
					feature.n2SelectIntent = null;
					if( feature.layer ) {
						feature.layer.drawFeature(feature);
					};
				
					if( this.currentMode.onEndClick ) {
						this.currentMode.onEndClick(feature);
					};
				};
			};
		};

		if( this.clickedInfo.endFn ) {
			for(var i=0,e=this.clickedInfo.endFn.length; i<e; ++i) {
				//try{
				this.clickedInfo.endFn[i](); 
				//} catch(e){};
			};
		};

		this.clickedInfo.endFn = [];
		this.clickedInfo.features = [];
		this.clickedInfo.fids = {};
		this.clickedInfo.selectedId = null;
	},
	
	_selectedFeatures: function(features, fids){
		if( this.currentMode !== this.modes.NAVIGATE ){
			this._switchMapMode(this.modes.NAVIGATE);
		};
		
		this._endClicked();
		
		this.clickedInfo.fids = {};
		if( fids ) {
			for(var i=0,e=fids.length; i<e; ++i){
				var fid = fids[i];
				
				this.clickedInfo.fids[fid] = { clicked: true };
				
				if( !this.clickedInfo.selectedId ){
					this.clickedInfo.selectedId = fid;
				};
			};
		};
		
		if( features ) {
			for(var i=0,e=features.length; i<e; ++i){
				var feature = features[i];

				this.clickedInfo.features.push(feature);

				feature.isClicked = true;
				if( feature.layer ) {
					feature.layer.drawFeature(feature);
				};
			};
		};
	},

	/**
	 * Add map selection to current selection.
	 */
	_selectedFeaturesSupplement: function(opts){
		
		if( this.currentMode !== this.modes.NAVIGATE ){
			this._switchMapMode(this.modes.NAVIGATE);
		};
		
		if( opts.fid ) {
			this.clickedInfo.fids[opts.fid] = {
				clicked: true
			};
			if( opts.intent ){
				this.clickedInfo.fids[opts.fid].intent = opts.intent;
			};
		};
		
		if( opts.features ) {
			for(var i=0,e=opts.features.length; i<e; ++i){
				var f = opts.features[i];

				this.clickedInfo.features.push(f);

				f.isClicked = true;

				if( opts.intent ){
					f.n2SelectIntent = opts.intent;
				};
				
				if( f.layer ) {
					f.layer.drawFeature(f);
				};
			};
		};
	},

	/**
	 * Unselect the currently selected feature
	 */
   	_unselectFeature: function(){
   		if( this.clickedInfo.selectedId ) {
   			this._dispatch({
   				type:'userUnselect'
   				,docId:this.clickedInfo.selectedId
   			});
   		};
   		
		this._endClicked();
   	},
	
	_startHover: function(feature) {
		var layer = feature.layer;
   		if( feature && feature.cluster && feature.cluster.length == 1 ){
   			feature = feature.cluster[0];
   		};
   		
		// Check if anything is needed
		if( this.hoverInfo.feature === feature ) {
		 	// Nothing to do. This one is already the hover
		 	// feature.
		 	return;
		};
	
		// If a feature is still marked as "hovered", quit
		// it. This one is taking over.
		this._endHover();
		
		// Remember this new feature as "hovered"
		this.hoverInfo.feature = feature;

		// Perform mode specific hover actions
		if( this.currentMode.onStartHover ) {
			this.currentMode.onStartHover(feature, layer);
		};
	},
	
	_endHover: function() {

		for(var i=0,e=this.hoverInfo.endFn.length; i<e; ++i) {
			//try{
			this.hoverInfo.endFn[i](); 
			//} catch(e){};
		};
		
		this.hoverInfo.feature = null;
		this.hoverInfo.endFn = [];
	},
	
	_registerEndHoverFn: function(fn) {
		this.hoverInfo.endFn.push(fn);
	},

	_startFocus: function(fids){
		this._endFocus();
		
		this.focusInfo.origin = {};
		for(var i=0,e=fids.length; i<e; ++i){
			var fid = fids[i];
			this.focusInfo.origin[fid] = true;
		};
		
		this._addFocus({
			fids: fids
		});
	},

	_addFocus: function(opts_){
		var opts = $n2.extend({
			fids: null
			,intent: null
		},opts_);

		if( opts.fids ){
			for(var i=0,e=opts.fids.length; i<e; ++i){
				var fid = opts.fids[i];
				this.focusInfo.fids[fid] = true;
			};
		};
		
		var features = this._getMapFeaturesIncludingFidMap(this.focusInfo.fids);
		
		for(var i=0,e=features.length; i<e; ++i){
			var f = features[i];
			if( f && !f.isHovered ) {
				f.isHovered = true;
				if( opts.intent ){
					f.n2HoverIntent = opts.intent;
				};
				if( f.layer ) f.layer.drawFeature(f);
				this.focusInfo.features.push( f );
			};
		};
	},
	
	_endFocus: function() {
		for(var i=0,e=this.focusInfo.features.length;i<e;++i) {
			var feature = this.focusInfo.features[i];
			if( feature.isHovered ) {
				feature.isHovered = false;
				feature.n2HoverIntent = null;
				if( feature.layer ) feature.layer.drawFeature(feature);
			};
		};

		this.focusInfo.features = [];
		this.focusInfo.fids = {};
		this.focusInfo.origin = null;
	},
	
	_startFindFeature: function(fid, features){
		this._endFindFeature();

		this.findFeatureInfo.fid = fid;
		this.findFeatureInfo.features = features;

		if( features ){
			for(var i=0,e=features.length; i<e; ++i){
				var f = features[i];
				if( f ){
					f.n2Intent = 'find';
					if( f.layer ) f.layer.drawFeature(f);
				};
			};
		};
	},
	
	_endFindFeature: function(){
		
		for(var i=0,e=this.findFeatureInfo.features.length; i<e; ++i){
			var f = this.findFeatureInfo.features[i];
			if( f ) {
				f.n2Intent = null;
				if( f.layer ) f.layer.drawFeature(f);
			};
		};
		
		this.findFeatureInfo.fid = null;
		this.findFeatureInfo.features = [];
	},

	activateSelectFeatureControl: function() {
		if( this.selectFeatureControl ) {
			this.selectFeatureControl.activate();
		};
	},

	deactivateSelectFeatureControl: function() {
		if( this.selectFeatureControl ) {
			this.selectFeatureControl.unselectAll();
			this.selectFeatureControl.deactivate();
		};
		this._endHover();
		this._endClicked();
	},

	_hoverFeature: function(feature, layer) {
		if( !feature ) {
			return;
		};
		if( !layer ) {
			return;
		};
		
		var layerInfo = layer._layerInfo;
		if( !layerInfo ) {
			return;
		};

		var dispatchService = this._getDispatchService();
		
		var docIds = [];
		var docs = [];
		if( feature.cluster ){
			for(var ci=0,ce=feature.cluster.length; ci<ce; ++ci){
				var f = feature.cluster[ci];
				docIds.push( f.fid );
				docs.push( f.data );
			};
			
		} else {
			docIds.push( feature.fid );
			docs.push( feature.data );
		};

		this._registerEndHoverFn(function(){
			dispatchService.send(DH, {
				type: 'userFocusOff'
				,docIds: docIds
				,docs: docs
				,feature: feature
	 		});
		});

		if( docIds.length > 1 ){
			dispatchService.send(DH, {
				type: 'userFocusOn'
				,docIds: docIds
				,docs: docs
				,feature: feature
	 		});
		} else if( docIds.length > 0 ){
			dispatchService.send(DH, {
				type: 'userFocusOn'
				,docId: docIds[0]
				,doc: docs[0]
				,feature: feature
	 		});
		};
	},
	
	_hoverFeaturePopup: function(feature, layer) {
		var _this = this;
		
		if( null == feature ) {
			return;
		};
		if( null == layer ) {
			return;
		};
	
		var layerInfo = layer._layerInfo;
		if( null == layerInfo ) {
			return;
		};
		
		var popupHtmlFn = layerInfo.featurePopupHtmlFn;
		if( null == popupHtmlFn ) {
			return;
		};

		// Figure out delay
		var delay = 0;
		if( typeof(layerInfo.featurePopupDelay) === 'number' ){
			delay = Math.floor(layerInfo.featurePopupDelay);
		};
		
		// Start or delay popup
		if( delay > 0 ) {
			window.setTimeout(function(){
				// Is it still relevant?
				if( isPopupCurrent() ) {
					initiatePopup();
				};
			},delay);
		} else {
			// immediate
			initiatePopup();
		};
		
		function isPopupCurrent(){
			// Asynchronous call. Check that the popup we want
			// to generate is still the one associated with the
			// feature being hovered.
			var hoveredFid = null;
			if( _this.hoverInfo.feature ) {
				hoveredFid = _this.hoverInfo.feature.fid;
			};
			if( hoveredFid !== feature.fid ) {
				// We have been called for a feature that is no longer
				// hovered
				return false;
			};
			
			return true; // still good
		};
		
		function computePopupPosition(){
	    	var popup_lonlat = null;
			var lastMapXy = _this.lastMapXy;
	    	if( null != lastMapXy ) {    	
	            var lonLat = _this.map.getLonLatFromPixel(lastMapXy);
	            if( lonLat ) { 
	            	popup_lonlat = lonLat;
	            };
	    	};
	    	if( !popup_lonlat ) {
	    		// Take centre of geometry
		    	popup_lonlat = feature.geometry.getBounds().getCenterLonLat();
	    	};
	    	return popup_lonlat;
		};
		
		function initiatePopup(){
			// Variables to manage wait pop-up
			var needWaitingPopup = true;
			
			// Call client function to generate HTML for popup
			popupHtmlFn({
				feature: feature
				,layerInfo: layerInfo
				,onSuccess: function(html){
					// We do not need to show a waiting pop-up
					// if it is not already up.
					needWaitingPopup = false;
					
					displayPopup(html);
				}
				,onError: function(){}//ignore
			});
			
			// If the popupHtmlFn() calls onSuccess before we
			// get here, then the variable needWaitingPopup is
			// false. In that situation, we do not need to create
			// a waiting pop-up (not waiting, the main pop-up is already
			// drawn). If the popupHtmlFn() is truly asynchronous (need
			// to fetch data over the network, for example), then
			// this code is reached before the onSuccess is called and
			// the variable needWaitingPopup is true.
			if( needWaitingPopup ) {
				displayPopup('<div class="olkit_wait"></div>');
			};
		};
	
		function displayPopup(popupHtml){
			if( !isPopupCurrent() ) {
				// Took too long. We are now displaying a popup for a
				// different feature.
				return;
			};
			
			// Destroy current pop-up if one is up
			destroyCurrentPopup();
			
			if( null === popupHtml || '' === popupHtml ) {
				// No error. Nothing to display.
				return;
			};

			// Figure out popup position
	    	var popup_lonlat = computePopupPosition();
	    	
	    	// Create pop-up
	    	var popup = new OpenLayers.Popup.Anchored(
	    		null // Let OpenLayers assign id
	    		,popup_lonlat
	    		,null
	    		,popupHtml
	    		,{
	    			size: new OpenLayers.Size(10,10)
	    			,offset: new OpenLayers.Pixel(-5,-5)
				}
				,false
				,onPopupClose
			);
	    	popup.autoSize = true;
	    	popup.panMapIfOutOfView = true;
			popup.setOpacity("80");

			// Set maximum pop-up size
			var mapSize = _this.map.getSize();
			if( mapSize ){
				popup.maxSize = new OpenLayers.Size(
					Math.floor(mapSize.w/3),
					Math.floor(mapSize.h/3)
				);
			};
			
			// Install new pop-up
			_this.currentPopup = popup;
			_this.map.addPopup(popup);

			// Add clean up routine
			if( _this.options && _this.options.keepPopUpsOpen ){
				// Leave opened (debugging)
			} else {
				_this._registerEndHoverFn(destroyCurrentPopup);
			};
			
			// Add routine to adjust popup position, once
			if( _this.options && _this.options.keepPopUpsStatic ){
				// Leave opened (debugging)
			} else {
				_this.addMapMousePositionListener(function(evt){
					if( _this.currentPopup === popup && _this.lastMapXy ) {
						_this.currentPopup.lonlat = _this.map.getLonLatFromPixel(_this.lastMapXy);
						_this.currentPopup.updatePosition();
						return true; // keep listener
					};
					
					return false; // remove listener
				});
			};
		};
		
		
		function destroyCurrentPopup() {
			var map = _this.map;
			var popup = _this.currentPopup;
			if( popup ) {
				map.removePopup(popup);
				popup.destroy();
				_this.currentPopup = null;
			};
		};
		
		function onPopupClose(evt) {
	    };
	},

    // === LOGIN STUFF START ========================================================

    /*
     * function: auth module listener for login state changes.  Only called if the auth
     * module is loaded so checks of that inside this function are not useful.
     * 
     * Once installed by the subsequent call to addListener(), this is immediately
     * called and then whenever a login state change is detected.
     */
    loginStateChanged: function(currentUser) {
    	var showLogin = false;

		if( null == currentUser ) {
    		showLogin = true;
    	};
    	
    	if( showLogin ) {
    		this.hideMapInteractionSwitch();
			this._switchMapMode(this.modes.NAVIGATE);
    	} else {
   			this.showMapInteractionSwitch();
    	};
    },
    	
    // === LOGIN STUFF END ========================================================
	
    // === MAP MODES START ========================================================
    
 	createMapInteractionSwitch: function() {
 		var _this = this;
 		var mapInteractionButton = $('<input type="button" class="n2map_map_interaction_switch"/>')
 			.val(this.modes.NAVIGATE.buttonValue)
 			.click( function(evt) { 
 				_this._clickedMapInteractionSwitch(evt);
 			})
 			;
		$("#"+this.options.mapInteractionDivName)
			.empty()
			.append(mapInteractionButton);
	},
 	
 	_getMapInteractionSwitch: function(){
 		return $("#"+this.options.mapInteractionDivName)
 			.find('.n2map_map_interaction_switch');
 	},
	
	_clickedMapInteractionSwitch: function(e){
		if( this.currentMode === this.modes.NAVIGATE ) {
			this.switchToEditMode();
			
		} else if( this.currentMode === this.modes.ADD_OR_SELECT_FEATURE ) {
			this._switchMapMode(this.modes.NAVIGATE);
			
		} else if( this.currentMode === this.modes.ADD_GEOMETRY ) {
			this._cancelEditFeatureMode();
			
		} else if( this.currentMode === this.modes.EDIT_FEATURE ) {
			this._cancelEditFeatureMode();
		};
		return false;
	},
	
 	hideMapInteractionSwitch: function() {
 		this._getMapInteractionSwitch().hide();
	},
	
	showMapInteractionSwitch: function() {
 		this._getMapInteractionSwitch().show();
	},
	
	activateControl: function(control) {
		if( control ) control.activate();
	},
	
	deactivateControl: function(control) {
		if( control ) control.deactivate();
	},
			
    _switchMapMode: function(mode, opts) {
    	if( this.currentMode === mode ) {
    		// nothing to do
    		return;
    	};
    	
    	// Remove current mode
    	if( this.currentMode === this.modes.ADD_OR_SELECT_FEATURE ) {
    		this.deactivateControl( this.editControls.addPoints );
    		this.deactivateControl( this.editControls.toolbar );
    		this.deactivateControl( this.editControls.modifyFeature );
    		this.editLayer.events.unregister('featureadded', null, this.editModeAddFeatureCallback);
            this.editLayer.events.unregister('beforefeaturesadded', null, this.convertToMultiGeometry);

            this.deactivateSelectFeatureControl();
            
    	} else if( this.currentMode === this.modes.ADD_GEOMETRY ) {
    		this.deactivateControl( this.editControls.addPoints );
    		this.deactivateControl( this.editControls.toolbar );
    		this.deactivateControl( this.editControls.modifyFeature );
    		this.editLayer.events.unregister('featureadded', null, this.editModeAddFeatureCallback);
            this.editLayer.events.unregister('beforefeaturesadded', null, this.convertToMultiGeometry);

            this.deactivateSelectFeatureControl();
            
    	} else if( this.currentMode === this.modes.EDIT_FEATURE ) {
    		this._removeGeometryEditor();
            
    	} else if( this.currentMode === this.modes.NAVIGATE ) {
    		this.deactivateSelectFeatureControl();
    	};

    	// Apply new mode
    	this.currentMode = mode;
    	this._getMapInteractionSwitch().val(mode.buttonValue);
    	if( this.currentMode === this.modes.ADD_OR_SELECT_FEATURE ) {
    		this.editLayer.events.register('featureadded', null, this.editModeAddFeatureCallback);
    		this.editLayer.events.register('beforefeaturesadded', null, this.convertToMultiGeometry);
    		this.activateControl( this.editControls.addPoints );
    		this.activateControl( this.editControls.toolbar );
    		this.activateControl( this.editControls.modifyFeature );
    		
    		this.activateSelectFeatureControl();
    		
    		if( this.editControls.toolbar 
    		 && this.editControls.toolbar.div ){
    			var $toolbar = $(this.editControls.toolbar.div);
    			$toolbar.find('.olControlNavigationItemActive').attr('title',_loc('Scroll Map'));
    			$toolbar.find('.olControlDrawFeaturePointItemInactive').attr('title',_loc('Add a point to the map'));
    			$toolbar.find('.olControlDrawFeaturePathItemInactive').attr('title',_loc('Add a line to the map'));
    			$toolbar.find('.olControlDrawFeaturePolygonItemInactive').attr('title',_loc('Add a polygon to the map'));
    			$toolbar.find('.olControlNunaliitGazetteerItemInactive').attr('title',_loc('Add a feature to the map based on a gazetteer service'));
    		};
            
    	} else if( this.currentMode === this.modes.ADD_GEOMETRY ) {
    		this.editLayer.events.register('featureadded', null, this.editModeAddFeatureCallback);
    		this.editLayer.events.register('beforefeaturesadded', null, this.convertToMultiGeometry);
    		this.activateControl( this.editControls.addPoints );
    		this.activateControl( this.editControls.toolbar );
    		this.activateControl( this.editControls.modifyFeature );
    		
    		if( this.editControls.toolbar 
    		 && this.editControls.toolbar.div ){
    			var $toolbar = $(this.editControls.toolbar.div);
    			$toolbar.find('.olControlNavigationItemActive').attr('title',_loc('Scroll Map'));
    			$toolbar.find('.olControlDrawFeaturePointItemInactive').attr('title',_loc('Add a point to the map'));
    			$toolbar.find('.olControlDrawFeaturePathItemInactive').attr('title',_loc('Add a line to the map'));
    			$toolbar.find('.olControlDrawFeaturePolygonItemInactive').attr('title',_loc('Add a polygon to the map'));
    			$toolbar.find('.olControlNunaliitGazetteerItemInactive').attr('title',_loc('Add a feature to the map based on a gazetteer service'));
    		};
            
    	} else if( this.currentMode === this.modes.EDIT_FEATURE ) {
    		var editFeature = opts.feature;
   			this._installGeometryEditor(editFeature);
            
    	} else if( this.currentMode === this.modes.NAVIGATE ) {
    		this.activateSelectFeatureControl();
    	};

    	// Broadcast mode change
		var dispatcher = this._getDispatchService();
		if( dispatcher ) {
			dispatcher.send(DH,{
				type: 'mapReportMode'
				,mapControl: this
				,mode: this.currentMode.name
			});
		};
    },
    
    switchToEditMode: function() {
    	var _this = this;
    	
    	var authService = this._getAuthService();
    	if( authService ) {
    		var logInRequired = true;
    		
    		// The auth module is present, check if user logged in
    		// and is not anonymous
    		var userNotAnonymous = authService.isLoggedIn();
    		if( userNotAnonymous ) {
    			logInRequired = false;
    		};
    		
    		if( logInRequired ) {
    			// User is not logged in
    			authService.showLoginForm({
    				prompt: '<p>You must log in as a registered user to add a point to the map.</p>'
    				,anonymousLoginAllowed: false
    				,onSuccess: function(){ _this.switchToEditMode(); }
    			});
    		} else {
    			// Already logged in, just switch
    	    	this._switchMapMode(this.modes.ADD_OR_SELECT_FEATURE);
    		};
    	} else {
    		alert("Authentication module not installed.");
    	};
    },
    
    switchToEditFeatureMode: function(fid, feature) {
    	this._switchMapMode(this.modes.EDIT_FEATURE,{
    		fid: fid
    		,feature: feature
    	});
    },
    
    switchToAddGeometryMode: function(docId) {
    	this._switchMapMode(this.modes.ADD_GEOMETRY,{
    		fid: docId
    	});
    },
    
    _cancelEditFeatureMode: function() {
   		this._dispatch({
   			type: 'editCancel'
   		});
    },
    
    // === NAVIGATION MODE ========================================================


    // === ADD OR SELECT FEATURE MODE =============================================

    // ======= EDIT_FEATURE MODE ==================================================

    _geometryModified: function(fid, olGeom, proj){
		// Check that this relates to the right feature
		if( fid && fid !== this.editFeatureInfo.fid ) return;
		if( !fid && this.editFeatureInfo.fid ) return;
    	
		if( this.currentMode === this.modes.EDIT_FEATURE 
		 && !olGeom ){
			// Geometry was deleted by external editor
			
			// Remove feature. By switching out of EDIT mode,
			// the feature on the EDIT layer will be removed. 
			this.switchToAddGeometryMode(fid);

		} else if( this.currentMode === this.modes.EDIT_FEATURE 
		 && olGeom ){
			// Normal mode: we are editing a feature and the geometry was updated
			this._updateGeometryEditor(olGeom, proj);

		} else if( this.currentMode !== this.modes.EDIT_FEATURE 
		 && olGeom ){
			// A geometry was added and the map is not yet in edit mode
			this.switchToEditFeatureMode(fid);
			this._updateGeometryEditor(olGeom, proj);
		};
    },

    onAttributeFormClosed: function(editedFeature) {
    	// When closing the dialog with the user, the feature
    	// must be removed from the map if it is a new one, since it does
    	// not have a valid fid. The feature will be reloaded, anyway. However,
    	// in the case of an INSERT, the currently drawn feature will not
    	// be repopulated since it can not be matched via fid.
		if( editedFeature && editedFeature.state === OpenLayers.State.INSERT ) {
			this.editLayer.destroyFeatures(editedFeature);
		};
		
		this._switchMapMode(this.modes.NAVIGATE);
    },

	onAttributeFormCancelled: function(editedFeature) {
		this._switchMapMode(this.modes.NAVIGATE);
	},
    
	onAttributeFormInserted: function(fid, feature) {
		var _this = this;
		
		// This is an insert

		// Remove feature which is on the edit layer. Feature
		// will be reloaded on the correct layer.
		if( feature && feature.layer ) {
			feature.layer.destroyFeatures([feature]);
		};

		this.fidAdded(fid);
	},
    
	onAttributeFormUpdated: function(fid, feature) {
		// This is an update
		var fid = feature.fid;
		this.fidUpdated(fid);
		var filter = $n2.olFilter.fromFid(fid);
		this._reloadFeature(filter);
	},
	
	onAttributeFormDeleted: function(fid, feature) {
		this.fidDeleted(fid);
		var layer = feature.layer;
		if( layer ) {
			layer.destroyFeatures([feature]);
		};
	},
    
	selectAudioMedia: function(feature, onSelectCallback) {
		var _this = this;
		
		var placeId = null;
		if( feature && feature.attributes && feature.attributes.place_id ) {
			placeId = feature.attributes.place_id;
		};
		
		var selectWindow = null;
		if( placeId ) {
			this.insertSound();
			
			selectWindow = $('<div class="selectMedia" style="z-index:3005"></div>');
			
			var head = $('<h1>Select a hover audio file</h2>');
			selectWindow.append(head);
			
			var listElem = $('<div></div>');
			selectWindow.append(listElem);
			
			// Buttons
			var cancelButton = $('<input type="button" value="Cancel"/>');
			cancelButton.click(function(){
				selectWindow.dialog('close');
			});
			selectWindow.append(cancelButton);

			var dialogOptions = {
				autoOpen: true
				,modal: true
				,title: _loc('Select a media')
				,width: 'auto'
				,close: function(event, ui){
					var diag = $(event.target);
					diag.dialog('destroy');
					diag.remove();
				}
			};
			selectWindow.dialog(dialogOptions);
			
			this.dbSearchEngine.getAudioMediaFromPlaceId(placeId,function(mediaArray){
				if( 0 == mediaArray.length ) {
					listElem.html('<span>There are no audio files available</span>');
				} else {
					var tableElem = $('<table class="mediaSelection"></table>');
					listElem.append(tableElem);
					
					for(var loop=0; loop<mediaArray.length; ++loop) {
						var media = mediaArray[loop];
						addMedia(tableElem, media);
					};
				};
			});
		} else {
			alert('No media to select');
		};
		
		function addMedia(tableElem, media) {
			var trElem = $('<tr></tr>');

			var tdElem = $('<td></td>');
			
			if( media.title ) {
				var html = $('<span>'+'title: '+media.title+'</span>');
				tdElem.append(html);
				tdElem.append( $('<br/>') );
			};
			
			if( media.mimetype ) {
				var html = $('<span>'+'MIME type: '+media.mimetype+'</span>');
				tdElem.append(html);
				tdElem.append( $('<br/>') );
			};
			
			if( media.filename ) {
				var html = $('<span>'+'file: '+media.filename+'</span>');
				tdElem.append(html);
				tdElem.append( $('<br/>') );
			};
			
			trElem.hover(function(){
				var value = media.filename?media.filename:'';
				_this.insertSound(value);
			},function(){
				_this.insertSound();
			});
			trElem.click(function(){
				var value = media.filename?media.filename:'';
				_this.insertSound();
				onSelectCallback(value);
				selectWindow.dialog('close');
				return false;
			});

			trElem.append(tdElem);

			tableElem.append(trElem);
		};
	},
	
    // === EDIT MODE STUFF END ======================================================================

    // === COMETD MODE STUFF START ========================================================
    
    initCometChannels: function() {
    	var _this = this;
    	if( this.cometEnabled && $.cometd ) {
			$.cometd.init('./cometd');
			$.cometd.subscribe(
				this.fidChannel
				,function(msg){ _this.fidHandler(msg); }
			);
    	}
    },
    
	fidHandler: function(msg) {
		//log('fidHandler',msg);
		if( msg.data && msg.data.type && msg.data.fid ) {
			// Invalidate cache
			this._cacheInvalidateFeature(msg.data.fid);
			
			// Reload feature
			if( msg.data.type == 'added' ) {
				var filter = $n2.olFilter.fromFid(msg.data.fid);
				this._reloadFeature(filter);
				
			} else if( msg.data.type == 'updated' ) {
				var filter = $n2.olFilter.fromFid(msg.data.fid);
				this._reloadFeature(filter);
				
			} else if( msg.data.type == 'deleted' ) {
				this._removeFeature(msg.data.fid);
			};
		};
	},	
    	
	fidAdded: function(fid) {
		if( this.cometEnabled && $.cometd ) {
			var msg = {
				fid: fid
				,type: 'added'
			};
			$.cometd.publish(this.fidChannel,msg);
		};
	},
	
	fidUpdated: function(fid) {
		if( this.cometEnabled && $.cometd ) {
			var msg = {
				fid: fid
				,type: 'updated'
			};
			$.cometd.publish(this.fidChannel,msg);
		}
	},
	
	fidDeleted: function(fid) {
		if( this.cometEnabled && $.cometd ) {
			var msg = {
				fid: fid
				,type: 'deleted'
			};
			$.cometd.publish(this.fidChannel,msg);
		};
	},
	
    // === COMETD MODE STUFF END ========================================================

    // === STYLE MAP STUFF START ========================================================

	adjustFilterProperties: function(feature) {
	
		feature.isFilteredIn = false;
		feature.isFilteredOut = false;
		
		for(var key in this.styleFilters) {
			feature.isFilteredIn = true;
			
			var f = this.styleFilters[key].matchFn;
			if( !f(feature) ) {
				feature.isFilteredIn = false;
				feature.isFilteredOut = true;
				return true;
			};
		};
		return false;
	},
	
	_createStyleMap: function(styleOptions) {
	
		var providedMap = styleOptions 
			? $.extend(true,{},this.defaultStyleMap,styleOptions)
			: this.defaultStyleMap;
			
		var normalStyle = new OpenLayers.Style( providedMap.normal );
		var clickedStyle = new OpenLayers.Style( providedMap.clicked );
		var hoveredStyle = new OpenLayers.Style( providedMap.hovered );
		var hoveredClickedStyle = new OpenLayers.Style( providedMap.hoveredClicked );
		var filteredOutStyle = new OpenLayers.Style( providedMap.filteredOut );
		var styles = {
			'normal': normalStyle 
			,'clicked': clickedStyle 
			,'hovered': hoveredStyle
			,'hoveredClicked': hoveredClickedStyle
			,'filteredOut': filteredOutStyle
		};
		
		
		var styleMap = new OpenLayers.StyleMapCallback(function(feature,intent){ 
		        
		        var effectiveIntent = null;
		        
		        if( null == effectiveIntent && feature.isFilteredOut ) {
		        	effectiveIntent = 'filteredOut';
		        };
		        
	        	if( null == effectiveIntent && feature.isHovered ) {
			        if( feature.isClicked ) {
		        		effectiveIntent = 'hoveredClicked';
		        	} else {
		        		effectiveIntent = 'hovered';
			        };
	        	};
	        	
	        	if( null == effectiveIntent && feature.isClicked ) {
	        		effectiveIntent = 'clicked';
	        	};

				var style = styles[effectiveIntent];
				if( null == style ) {
					style = styles.normal;
				};
		        
		        return style.createSymbolizer(feature);
			});
			
		return styleMap;
	},
	
	_createStyleMapFromLayerInfo: function(layerInfo) {
	
		var styleOptions = null;
		if( layerInfo && layerInfo.styleMap ) {
			styleOptions = layerInfo.styleMap;
		};
		return this._createStyleMap(styleOptions);
	},
	
	_createEffectiveStyleMap: function(layerInfo) {
	
		var _this = this;
		
		// The caller can specify a style map in multiple ways:
		// 1. provide a style map function (layerInfo.styleMapFn)
		// 2. provide a style extension (layerInfo.styleMapFn === _createStyleMapFromLayerInfo)
		//    and styleMap object is used.
		// Either way, a style map wrapping the caller's is needed to perform
		// some work prior to calling the caller's style map. This function creates
		// this wrapper. 
	
		// Determine the style map function for this layer
		var innerStyleMap = null;
		if( layerInfo ) {
			innerStyleMap = layerInfo.styleMapFn(layerInfo);
		} else {
			// Editing layer currently has no options for styling. Use
			// defaults.
			innerStyleMap = this._createStyleMap();
		};
	
		// Create wrapping style map based on StyleMapCallback. Perform
		// some work and then defer to caller's style map.
		var styleMap = new OpenLayers.StyleMapCallback(function(feature,intent){

			// A virtual style is requested when feature is null.
			// ModifyFeature control requests a virtual style for
			// its virtual vertices. Always return a style on
			// null feature.
			if( null == feature ) {
				return {
					fillColor: "#0000ff",
					fillOpacity: 0.4,
					strokeColor: "#0000ff",
					strokeOpacity: 1,
					strokeWidth: 1,
					strokeLinecap: "round", //[butt | round | square]
					strokeDashstyle: "solid", //[dot | dash | dashdot | longdash | longdashdot | solid]
					pointRadius: 6,
					pointerEvents: "visiblePainted",
					cursor: "pointer"
				};
			};
	
			// If a feature is being edited by the ModifyFeature control,
			// then vertices and handles are drawn on the map. Those vertices
			// and handles are marked as "_sketch". In that case, offer the style
			// for editing.
			if( feature._sketch ) {
				return {
					fillColor: "#0000ff",
					fillOpacity: 0.4,
					strokeColor: "#0000ff",
					strokeOpacity: 1,
					strokeWidth: 1,
					strokeLinecap: "round", //[butt | round | square]
					strokeDashstyle: "solid", //[dot | dash | dashdot | longdash | longdashdot | solid]
					pointRadius: 6,
					pointerEvents: "visiblePainted",
					cursor: "pointer"
				};
			};
	        
	        _this.adjustFilterProperties(feature);
	        
	        var symbolizer = innerStyleMap.createSymbolizer(feature,intent);
	        
	        return symbolizer;
		});

		// Add styles that are expected to be hard coded
		if( !styleMap.styles ) {
			styleMap.styles = {};
		}
		
		// This style is needed by the DrawFeature control in sketch
		// mode (while editing)
		if( !styleMap.styles['temporary'] ) {
			styleMap.styles['temporary'] = {
		        fillColor: "#66cccc",
		        fillOpacity: 0.2, 
		        hoverFillColor: "white",
		        hoverFillOpacity: 0.8,
		        strokeColor: "#66cccc",
		        strokeOpacity: 1,
		        strokeLinecap: "round",
		        strokeWidth: 2,
		        strokeDashstyle: "solid",
		        hoverStrokeColor: "red",
		        hoverStrokeOpacity: 1,
		        hoverStrokeWidth: 0.2,
		        pointRadius: 6,
		        hoverPointRadius: 1,
		        hoverPointUnit: "%",
		        pointerEvents: "visiblePainted",
		        cursor: "inherit"
		    };
		};
		
		// I have no idea if this is needed. I put it here for completeness.
		if( !styleMap.styles['delete'] ) {
			styleMap.styles['delete'] = {
		        display: "none"
		    };
		};
			
		return styleMap;
	},
	
	turnOffStyleFilter: function( label ) {
		if( this.styleFilters[label] ) {
			delete this.styleFilters[label];
			
			this.redrawMap();
		};
	},
	
	removeStyleFilter: function( filter ) {
		var label = null;
		if( typeof(filter) === 'string' ) {
			label = filter;
		} else if( typeof(filter) === 'string' ) {
			label = filter.label;
		};
		if( null == label ) {
			return;
		};
		turnOffStyleFilter(label);
		$('#_olkit_styleFilter_'+label).remove();
	},
	
	addStyleFilter: function( filter_ ) {
		var _this = this;
		
		var defaultFilter = {
			description: 'Unknown Filter'
			,refreshFunction: function(options_){}
		};
		var filter = $.extend(defaultFilter, filter_);
	
		// This method returns a label to be used in removing
		// an installed filter
		var filterLabel = ''+this.styleFilterIndex;
		++this.styleFilterIndex;
		filter.label = filterLabel;

		var span = $('<span id="_olkit_styleFilter_'+filterLabel+'"></span>');
		
		var filterPanelId = this.options.filterPanelName;
		if( null == filterPanelId ) {
			return false;
		};
		$('#'+filterPanelId).append(span);
		
		var cb = $('<input type="checkbox"/>');
		var warning = $('<span></span>');
		var text = $('<span>'+filter.description+'</span>');
		var removeButton = $('<input type="button" value="Delete"/>');
		var br = $('<br/>');
		span.append(cb);
		span.append(removeButton);
		span.append(warning);
		span.append(text);
		span.append(br);
		
		cb.bind('change',function(){
			var checked = cb.attr('checked');
			if( checked ) {
				refreshFilter();
			} else {
				removeFilter();
			};
		});
		removeButton.click(function(){
			deleteFilter();
			return false;
		});
		
		refreshFilter();
		
		function onError() {
			warning.text('!!!');
			cb.attr('checked',false);
			disableAll(span, false);
			if( null != filterLabel ) {
				this.removeStyleFilter(filterLabel);
				filterLabel = null;
			};
		};
		
		function refreshFilter() {
			warning.empty();
			disableAll(span, true);
			
			filter.refreshFunction({
				onError: onError
				,filterOnFids: filterFids 
			});
		};
		
		function filterFids(fids) {
			// Make map for faster access
			var fidMap = {};
			for(var loop=0; loop<fids.length; ++loop) {
				fidMap[fids[loop]] = 1;
			};
			
			filter.matchFn = function(feature) {
				if( fidMap[feature.attributes.id] ) {
					return true;
				};
				return false;
			}; 
			styleFilters[filter.label] = filter;

			cb.attr('checked',true);
			disableAll(span, false);
			
			_this.redrawMap();
		};
	
		function removeFilter() {
			warning.empty();
			_this.turnOffStyleFilter(filterLabel);
		};
		
		function deleteFilter() {
			if( null != filterLabel ) {
				_this.removeStyleFilter(filterLabel);
				filterLabel = null;
			};
		};
		
		function disableAll(jQuerySet, flag) {
			if( flag ) {
				jQuerySet
					.attr('disabled',true)
					.addClass('olkitDisabled')
					;
			} else {
				jQuerySet
					.removeAttr('disabled')
					.removeClass('olkitDisabled')
					;
			};
			
			jQuerySet.children().each(function(i,elem){ disableAll($(elem), flag); });
		};
		
		return false; 
	},

    // === STYLE MAP STUFF END ========================================================

	// === START -- LAYER MANAGEMENT ========================================================

	// Legacy method
	createLayerFromOptions: function(opt_) {
		var _this = this;
		
		var cs = this._getCustomService();
		
		// Create LayerInfo
		var layerInfoOptions = $.extend({
			styleMapFn: function(layerInfo){ 
				return _this._createStyleMapFromLayerInfo(layerInfo); 
			}
		}, opt_);
		layerInfoOptions.customService = cs; 
		var layerInfo = new LayerInfo(layerInfoOptions);
		
		layerInfo.typename = layerInfo.featurePrefix + ':' + layerInfo.featureType;
		layerInfo.schema = layerInfo.wfsUrl 
			+ '?service=WFS&version=' + layerInfo.wfsVersion 
			+ '&request=DescribeFeatureType&typeName=' + layerInfo.typename;
		
		var layerOptions = {
			projection: layerInfo.sourceProjection
			,visibility: layerInfo.visibility
			,_layerInfo: layerInfo
		};

		if( layerInfo.couchDb ) {
			// This is a couch layer
			var couchProtocolOpt = $n2.extend({},opt_.couchDb,{
				notifications: {
					readStart: function(){
						_this._mapBusyStatus(1);
					}
					,readEnd: function(){
						_this._mapBusyStatus(-1);
					}
				}
			});
			layerInfo.protocol = new OpenLayers.Protocol.Couch(couchProtocolOpt);
			layerOptions.protocol = layerInfo.protocol;
		} else if( layerInfo.wfsUrl ) {
			// This is a WFS layer
			layerInfo.protocol = new OpenLayers.Protocol.WFS.v1_1_0({
					url: layerInfo.wfsUrl
					,featureType: layerInfo.featureType
					,featureNS: layerInfo.featureNS
					,featurePrefix: layerInfo.featurePrefix
					,geometryName: layerInfo.geometryName
					,readFormat: new OpenLayers.Format.GeoJSON()
					,outputFormat: 'json'
				});
			layerOptions.protocol = layerInfo.protocol;
		} else {
			// Unrecognized layer
			$n2.reportError('Unrecognized layer: '+layerInfo.name);
		};

		// Create style map
		var layerStyleMap = this._createEffectiveStyleMap(layerInfo);
		layerOptions.styleMap = layerStyleMap;

		// Filter
		layerInfo.olFilter = null;
		if( layerInfo.filter ) {
			layerInfo.olFilter = $n2.olFilter.CreateOpenLayersFilter(layerInfo.filter);

			if( null == layerInfo.olFilter ) {
				alert('Encountered invalid filter');
			} else {
				layerOptions.filter = layerInfo.olFilter;
			};
		};

		if( layerInfo.useFixedStrategy ) {
			// Compute bbox string in the source coordinate space of the vector layer
			var vecSourceExtent = new OpenLayers.Bounds(
				options.mapCoordinateSpecifications.maxExtent[0]
				,options.mapCoordinateSpecifications.maxExtent[1]
				,options.mapCoordinateSpecifications.maxExtent[2]
				,options.mapCoordinateSpecifications.maxExtent[3]
				);
			if( userCoordProjection.getCode() != layerInfo.sourceProjection.getCode() ) {
				/*
				 * if the user coordinate space is different from the source projection of the vector layer
				 * then project the max extent bounding box back to the source projection of the vector layer.
				 * The WFS request can reproject the data but it cannot handle a bbox request in the reprojected
				 * coordinate space.
				 */
				vecSourceExtent.transform(userCoordProjection, layerInfo.sourceProjection);
			}

			// Add a BBOX filter
			var bboxFilter = new OpenLayers.Filter.Spatial({
				type: OpenLayers.Filter.Spatial.BBOX
				,property:  layerInfo.geometryName
				,value: vecSourceExtent
			});

			// Add filter
			if( null == layerOptions.filter ) {
				layerOptions.filter = bboxFilter;
			} else {
				var andFilter = new OpenLayers.Filter.Logical({
					type: OpenLayers.Filter.Logical.AND
					,filters: [ layerOptions.filter, bboxFilter ]
				});
				layerOptions.filter = andFilter;
			}

			// Installing strategies make sense only if a protocol is provided
			if( layerOptions.protocol ) {
				layerOptions.strategies = [ new OpenLayers.Strategy.Fixed() ];
			};

		} else {
			// Installing strategies make sense only if a protocol is provided
			if( layerOptions.protocol ) {
				if( layerInfo.couchDb ) {
					layerOptions.strategies = [ new OpenLayers.Strategy.N2BBOX() ];
				} else {
					layerOptions.strategies = [ new OpenLayers.Strategy.BBOX() ];
				};
			};
		};
		
		if( !layerOptions.strategies ){
			layerOptions.strategies = [];
		}
		layerOptions.strategies.push( new OpenLayers.Strategy.NunaliitLayerSorting() );
		
		//layerOptions.renderers = ['Canvas','SVG','VML'];
		layerOptions.renderers = ['SVG','VML'];

		layerInfo.olLayer = new OpenLayers.Layer.Vector(layerInfo.name, layerOptions);

		// Add events to layer
		this._registerLayerForEvents(layerInfo);

		// Remember
		this.infoLayers.push( layerInfo );
		this.vectorLayers.push( layerInfo.olLayer );
		
		// Allow caller to access layers
		if( layerInfo.id ) {
			this.layers[layerInfo.id] = layerInfo.olLayer;
		} else {
			this.layers[layerInfo.name] = layerInfo.olLayer;
		};
		
		return layerInfo;
	},
	
	findLayerFromId:  function(id) {
		return this.layers[id];
	},
	
	addLayer: function(layerDefinition, isBaseLayer) {
		var olLayer = this._createOLLayerFromDefinition(layerDefinition, isBaseLayer);
		this.map.addLayer( olLayer );
		this._installFeatureSelector();
	},
	
	_uninstallFeatureSelector: function() {
		if( this.selectFeatureControl ) {
			this.selectFeatureControl.deactivate();
			this.map.removeControl(this.selectFeatureControl);
			this.selectFeatureControl = null;
		};
	},
	
	_installFeatureSelector: function() {
		var _this = this;
		
		if( this.selectFeatureControl ) this._uninstallFeatureSelector();
		
		// The callbacks defined below are passed to an internal instance
		// of Feature handler
		var navHighlightOptions = {
			hover: true
			,callbacks: {
			}
		};
		this.selectFeatureControl = new OpenLayers.Control.SelectFeature(
			this.vectorLayers
			,navHighlightOptions
		);

		// Overwrite the feature handler used by SelectFeature control
		// This is necessary until fixes are ported to OpenLayers.Handler.Feature
		this.selectFeatureControl.handlers.feature = new OpenLayers.Handler.NunaliitFeature(
			{} // null generates an error
			,this.selectFeatureControl.layer
			,{
	            click: function(feature) {
					_this._startClicked(feature, false);
				}
	            ,clickout: function(feature){
					_this._unselectFeature();
				}
	            ,over: function(feature){ 
					_this._startHover(feature); 
				}
	            ,out: function(feature){ 
					_this._endHover(); 
				}
			}
			,{
				geometryTypes: this.selectFeatureControl.geometryTypes
			}
	    );

		this.map.addControl(this.selectFeatureControl);
		this.selectFeatureControl.activate();
	},
	
	_mapBusyStatus: function(delta){
		var previous = this.mapBusyCount;
		this.mapBusyCount += delta;
		if( previous < 1 && this.mapBusyCount > 0 ) {
			$n2.log('Start map busy');
		};
		if( previous > 0 && this.mapBusyCount < 1 ) {
			$n2.log('End map busy');
		};
		if( this.busyMapControl && delta < 0 ) {
			this.busyMapControl.decreaseCounter();
		} else if( this.busyMapControl && delta > 0 ) {
			this.busyMapControl.increaseCounter();
		}
	},
	
	// === END -- LAYER MANAGEMENT ========================================================

	// === START -- SIMPLIFIED GEOMETRIES =================================================
	
	_refreshSimplifiedGeometries: function(){
		var _this = this;

		var epsg4326Proj = new OpenLayers.Projection('EPSG:4326');
		var epsg4326Resolution = this._getResolutionInProjection(epsg4326Proj);
		//$n2.log('epsg4326Resolution',epsg4326Resolution);
		var mapProjection = this.map.getProjectionObject();
		
		// Accumulate all geometries that are required
		var geomsNeeded = {};
		
		// Figure out extent of the map
		var mapExtent = this.map.getExtent();
		
		// Iterate over layers
		var layers = this.map.layers;
		for(var li=0,le=layers.length; li<le; ++li){
			var layer = layers[li];

			// Iterate features
			if( layer.features ){
				for(var fi=0,fe=layer.features.length; fi<fe; ++fi){
					var feature = layer.features[fi];
					
					// If feature is a cluster, skip it. No need to fetch the
					// components as they are hidden in a cluster
					if( feature.cluster ){

					} else {
						checkFeature(feature,epsg4326Resolution,geomsNeeded,mapExtent,mapProjection);
					};
				};
			};
		};

		// Requested geometries for features that need them
		var geometriesRequested = [];
		var simplificationsReported = [];
		for(var id in geomsNeeded){
			var request = geomsNeeded[id];
			var attName = request.attName;
			
			// Check if we already have the simplification in memory
			if( '__inline' === attName ){
				var simplification = {
    				id: id
    				,attName: attName
    				,wkt: request.doc.nunaliit_geom.wkt
    				,proj: request.feature.n2GeomProj
				};
				simplificationsReported[simplificationsReported.length] = simplification;
				
			} else if( request.feature 
			 && request.feature.n2SimplifiedGeoms 
			 && request.feature.n2SimplifiedGeoms[attName] ){
				var simplification = request.feature.n2SimplifiedGeoms[attName];
				simplificationsReported[simplificationsReported.length] = simplification;
			
			} else {
				if( geomsNeeded[id].feature && geomsNeeded[id].feature.n2FilteredOut ){
					// Do not fetch simplifications for features not currently shown
				} else {
					geometriesRequested[geometriesRequested.length] = geomsNeeded[id];
				};
			};
		};
		if( simplificationsReported.length ){
			// These are all the geometries already in memory
			//$n2.log('simplificationsReported',simplificationsReported);
			window.setTimeout(function(){
				_this._updateSimplifiedGeometries(simplificationsReported);
			},0);
		};
		if( geometriesRequested.length ){
			var mapCenter = this.map.getCenter();
			if( mapCenter ){
				if( mapProjection 
				 && mapProjection.getCode() !== epsg4326Proj.getCode ){
					mapCenter.transform(mapProjection, epsg4326Proj);
				};
				
				// Sort the requested geometries so that the ones closest to the
				// center of the view port are listed first
				for(var i=0,e=geometriesRequested.length; i<e; ++i){
					var geometryRequest = geometriesRequested[i];
					var x = (geometryRequest.bbox[0] + geometryRequest.bbox[2]) / 2;
					var y = (geometryRequest.bbox[1] + geometryRequest.bbox[3]) / 2;
					
					var dx = x - mapCenter.lon;
					var dy = y - mapCenter.lat;
					
					geometryRequest.d = (dx * dx) + (dy * dy); // do not bother with Math.sqrt()
				};
				
				geometriesRequested.sort(function(a,b){
					var aSeen = true;
					var bSeen = true;
					
					if( a.feature && a.feature.n2FilteredOut ){
						aSeen = false;
					};
					if( b.feature && b.feature.n2FilteredOut ){
						bSeen = false;
					};
					
					if( aSeen && !bSeen ) return -1;
					if( bSeen && !aSeen ) return 1;
					
					if( a.d < b.d ) return -1;
					if( a.d > b.d ) return 1;

					return 0;
				});
			};
			
			//$n2.log('geometriesRequested',geometriesRequested);
			this._dispatch({
				type: 'simplifiedGeometryRequest'
				,geometriesRequested: geometriesRequested
				,requester: this.mapId
			});
		};
		// Report wait
		this._dispatch({
			type: 'waitReport'
			,requester: this.mapId
			,name: 'simplifiedGeometries'
			,label: 'Simplified Geometries'
			,count: geometriesRequested.length
		});
		
		function checkFeature(f, res, geomsNeeded, mapExtent, mapProjection){
			// Check if feature falls within viewable boundaries of
			// map
			if( !mapExtent ) {
				// Can not continue
				return;
			};
			var geomBound = ComputeFeatureOriginalBboxForMapProjection(f, mapProjection);
			if( !geomBound ){
				// Can not process this feature
				return;
			};
			if( geomBound.intersectsBounds(mapExtent) ){
				// We should continue and get a simplified geometry
				// for this feature. Its BBOX intersects with the visible
				// portion of the map.
			} else {
				// Not on screen. Do not bother
				return;
			};
			
			// Operate only on features that have simplification information
			if( f.data 
			 && f.data.nunaliit_geom
			 && f.data.nunaliit_geom.simplified
			 && f.data.nunaliit_geom.simplified.resolutions ){
				// Compute which attachment name and resolution would be
				// ideal for this feature. The best resolution is the greatest
				// one defined which is smaller than the one requested by the map
				var bestAttName = undefined;
				var bestResolution = undefined;
				for(var attName in f.data.nunaliit_geom.simplified.resolutions){
					var attRes = 1 * f.data.nunaliit_geom.simplified.resolutions[attName];
					if( attRes < res ){
						if( typeof bestResolution === 'undefined' ){
							bestResolution = attRes;
							bestAttName = attName;
						} else if( attRes > bestResolution ){
							bestResolution = attRes;
							bestAttName = attName;
						};
					};
				};
				
				// If the best resolution is the one given inline, no need to
				// fetch it
				if( typeof bestResolution !== 'undefined' ){
					if( f.data.nunaliit_geom.simplified.reported_resolution === bestResolution ){
						bestAttName = '__inline';
					};
				};

				// If we can not determine an optimal resolution, it is because
				// the maps resolution is better than the best simplification. Go
				// with original geometry
				if( !bestAttName ){
					if( f.data.nunaliit_geom.simplified.original ){
						bestAttName = f.data.nunaliit_geom.simplified.original;
					};
				};
				
				// If we still can not figure out the best resolution, something
				// went wrong and ignore this feature
				if( !bestAttName ) return;
				
				// Check what geometry is currently displayed on the map
				var currentGeomAttName = undefined;
				if( f.n2CurrentGeomAttName ){
					currentGeomAttName = f.n2CurrentGeomAttName;
				};
				
				// If the best geometry and the current geometry do not match, add
				// an entry in the dictionary
				if( currentGeomAttName !== bestAttName ){
					geomsNeeded[f.fid] = {
						id: f.fid
						,attName: bestAttName
						,doc: f.data
						,feature: f
						,bbox: f.data.nunaliit_geom.bbox
					};
					
					// Save that we have requested the best geometry
					f.n2TargetGeomAttName = bestAttName;
				};
			};
		};
	},
	
	/*
	   simplifiedGeometries is an array of object like this:
	   {
	   		id: <docId or fid>
	   		,attName: <string, attachment name>
	   		,wkt: <string, well known text of simplified geometry>
	   		,proj: <object(OpenLayers.Projection), projection of simplified geometry>
	   }
	 */
	_updateSimplifiedGeometries: function(simplifiedGeometries){
		var _this = this;
		//$n2.log('_updateSimplifiedGeometries '+simplifiedGeometries.length+' at '+Date.now());
		
		// Often used
		var wktFormat = new OpenLayers.Format.WKT();

		// Make a map of all simplified geometries based on id (fid)
		var simplifiedGeometriesById = {};
		for(var i=0,e=simplifiedGeometries.length; i<e; ++i){
			var simplifiedGeometry = simplifiedGeometries[i];
			simplifiedGeometriesById[simplifiedGeometry.id] = simplifiedGeometry;
		};
		
		// Look for which layers need to be reloaded
		var layersToReload = {};
		var layers = this.map.layers;
		for(var li=0,le=layers.length; li<le; ++li){
			var layer = layers[li];

			// Iterate features and find those that must be modified
			if( layer.features ){
				for(var fi=0,fe=layer.features.length; fi<fe; ++fi){
					var feature = layer.features[fi];
					
					// If feature is a cluster, iterate over its components
					if( feature.cluster ){
						for(var ci=0,ce=feature.cluster.length; ci<ce; ++ci){
							var f = feature.cluster[ci];
							updateFeature(layer,f,simplifiedGeometriesById,layersToReload);
						};
					} else {
						updateFeature(layer,feature,simplifiedGeometriesById,layersToReload);
					};
				};
			};
		};
		
		// Reload layers that need it
		var layerReloaded = false;
		for(var layerId in layersToReload){
			var layer = layersToReload[layerId];
			
			// Accumulate all features
			var features = [];
			for(var fi=0,fe=layer.features.length; fi<fe; ++fi){
				var feature = layer.features[fi];
				
				// If feature is a cluster, iterate over its components
				if( feature.cluster ){
					for(var ci=0,ce=feature.cluster.length; ci<ce; ++ci){
						features[features.length] = feature.cluster[ci];
					};
				} else {
					features[features.length] = feature;
				};
			};
			
			// Remove all features
			layer.removeAllFeatures({silent:true});
			
			// Add them again so that clustering and drawing is based on the
			// new geometry
//			$n2.log('Reload features');
//			for(var i=0;i<features.length;++i){
//				var f = features[i];
//				var g = f.geometry;
//				$n2.log(''+g);
//			};
			layer.addFeatures(features);
			
			layerReloaded = true;
		};
		
		if( !layerReloaded ){
			// No work this time around.
			this._refreshSimplifiedGeometries();
		};
		
		if( layerReloaded ){
			this._updatedStylesInUse();
		};
		
		function updateFeature(layer, f, simplifiedGeometryById, layersToReload){
			var simplifiedGeometry = simplifiedGeometryById[f.fid];
			if( simplifiedGeometry ){
				// Save this information
				if( !f.n2SimplifiedGeoms ){
					f.n2SimplifiedGeoms = {};
				};
				f.n2SimplifiedGeoms[simplifiedGeometry.attName] = simplifiedGeometry;
				
				// If this simplification is already installed, then there is nothing
				// to do
				if( simplifiedGeometry.attName 
				 && simplifiedGeometry.attName !== f.n2CurrentGeomAttName ){
					// If this simplification is not the target simplification,
					// then there is nothing to do
					if( simplifiedGeometry.attName 
					 && simplifiedGeometry.attName === f.n2TargetGeomAttName ){
						// OK, we must install this simplification
						if( simplifiedGeometry.wkt ){
							var f2 = wktFormat.read(simplifiedGeometry.wkt);
							
							var projectedGeom = undefined;
							
							// wktFormat.read() returns an array when WKT is GEOMETRYCOLLECTION
							if( $n2.isArray(f2) ){
								var components = [];
								for(var i=0,e=f2.length; i<e; ++i){
									var vectorFeature = f2[i];
									if( vectorFeature.geometry ){
										components.push(vectorFeature.geometry);
									};
								};
								projectedGeom = new OpenLayers.Geometry.Collection(components);
								
							} else if( f2 && f2.geometry ) {
								projectedGeom = f2.geometry;
							};
							
							if( projectedGeom ){
								// Reproject geometry
								if( simplifiedGeometry.proj ){
									projectedGeom = 
										_this._reprojectGeometryForMap(projectedGeom, simplifiedGeometry.proj);
								};
								
								// Swap geometry
								f.geometry = projectedGeom;
								f.n2CurrentGeomAttName = simplifiedGeometry.attName;
								
								// Mark this layer for reload
								layersToReload[layer.id] = layer;
							};
						};
					};
				};
			};
		};
	},
    
	_getResolutionInProjection: function(proj){
    	var targetResolution = this.map.resolution;
    	
    	if( this.map.projection.getCode() !== proj.getCode() ){
    		// Convert [0,0] and [0,1] to proj
    		var p0 = OpenLayers.Projection.transform({x:0,y:0},this.map.projection,proj);
    		var p1 = OpenLayers.Projection.transform({x:0,y:1},this.map.projection,proj);
    		
    		var factor = Math.sqrt( ((p0.x-p1.x)*(p0.x-p1.x)) + ((p0.y-p1.y)*(p0.y-p1.y)) );
    		
    		targetResolution = this.map.resolution * factor;
    	};
    	
    	return targetResolution;
    },
    
	_reprojectGeometryForMap: function(geom, proj){
    	var targetGeometry = geom;
    	
    	if( this.map.projection.getCode() !== proj.getCode() ){
    		geom.transform(proj,this.map.projection);
    	};
    	
    	return targetGeometry;
    },
	
	// === END -- SIMPLIFIED GEOMETRIES ===================================================

    // === START -- MAP STYLES IN USE ===================================================

    _getMapStylesInUse: function(){
    	var mapStylesInUse = {};

    	for(var i in this.infoLayers){
    		var layerInfo = this.infoLayers[i];
    		layerInfo.accumulateMapStylesInUse(mapStylesInUse);
    	};
		
		return mapStylesInUse;
    },
    
    // Called when the map detects that features have been redrawn
    _updatedStylesInUse: function(){
    	var mapStylesInUse = this._getMapStylesInUse();
    	
    	this._dispatch({
    		type: 'canvasReportStylesInUse'
    		,canvasName: this.getCanvasName()
    		,stylesInUse: mapStylesInUse
    	});
    },
    
    // === END -- MAP STYLES IN USE ===================================================

	redefineFeatureLayerStylesAndRules : function(layerName) {
		var layerInfo = this.getNamedLayerInfo(layerName);
		if (null == layerInfo) {
			alert('redefineFeatureLayerStylesAndRules: unknown layer name: ' + layerName);
		} else {
    		//this._endClicked();
    		layerInfo.olLayer.redraw();    			
		};
	},
	
	recentreMap: function (ll) { // @param ll OpenLayers LonLat in map projection for centre of map
		var z = this.map.getZoom();
		this.map.setCenter(ll, z, false, false);
	},
	
	getResolution: function(){
		return this.map.getResolution();
	},
	
	/**
	 * This is called when the map has moved. 
	 */
	_mapMoved: function(){
		var _this = this;

		if( this.mapWasMoved ) return;
		
		this.mapWasMoved = true;
		setTimeout(function(){
			_this.mapWasMoved = false;
			_this._refreshSimplifiedGeometries();
			_this._updatedStylesInUse();
		},200);
	},
	
	/*
	 * Returns map to initial bounds/extent
	 */
	resetExtent: function(){
		if( this.initialZoomBounds ){
			this.map.zoomToExtent(this.initialZoomBounds);
		};
	},
	
	setInitialExtent: function(bounds, srsName, reset) {

		var initialExt = new OpenLayers.Bounds(bounds[0], bounds[1], bounds[2], bounds[3]);
	
		if( null != srsName ) {
			this.convertBoundsToMapProjection(initialExt, srsName);
		};
	
		this.initialZoomBounds = initialExt;
		
		if( reset ){
			this.resetExtent();
		};
	},
	
	setNewExtent: function(bounds, srsName) { // @param bounds OpenLayers Bounds values in array (in map projection coordinates)

		var maxExt = new OpenLayers.Bounds(bounds[0], bounds[1], bounds[2], bounds[3]);
	
		if( null != srsName ) {
			this.convertBoundsToMapProjection(maxExt, srsName);
		};
	
		this.map.zoomToExtent(
			maxExt
			,true
		);
	},
	
	getMediaPath: function() {
		return this.dbSearchEngine.getRelMediaPath();
	},
	
	getSidePanelName: function() {
		return this.options.sidePanelName;
	},

	getFilterPanelName: function() {
		return this.options.filterPanelName;
	},

	/**
	 * Add a listener that receives information about the mouse position
	 * on the map.
	 * 
	 * @param listener Function that is called on every event that updates
	 *                 the mouse position. This function should accept two arguments:
	 *                 the first is the browser event; the second is the instance of
	 *                 map and control. For example: f(event, mapAndControl). To obtain
	 *                 the current position, retrieve it from the mapAndControl instance
	 *                 (mapAndControl.lastMapXy).
	 *                 If the listener returns true, then it will be kept on the listener queue.
	 *                 If the listener returns false, then it is removed from subsequent calls.
	 * 
	 */
	addMapMousePositionListener: function(listener){
		if( typeof(listener) === 'function' ) {
			this.mapMouseMoveListeners.push(listener);
		};
	},

	initiateEditFromGeometry: function(opts_){
		var opts = $n2.extend({
			geometry: null
			,suppressCenter: false
		},opts_);

		if( !opts.geometry ){
			throw 'Geometry must be provided';
		};

    	if( this.currentMode === this.modes.ADD_OR_SELECT_FEATURE ) {
    		this._switchMapMode(this.modes.ADD_OR_SELECT_FEATURE);
    	};
		
		if( opts.suppressCenter ){
			this.editFeatureInfo.suppressCenter = true;
		};
		
		var editLayer = this.editLayer;

		var feature = new OpenLayers.Feature.Vector(opts.geometry);
		editLayer.addFeatures([feature]);

	},
	
	// === START -- DOCUMENT CACHE ===================================================
	
	_retrieveCachedValue: function(id) {
		// Look through the layers
		for(var i=0,e=this.infoLayers.length; i<e; ++i){
			var layerInfo = this.infoLayers[i];
			var valueMap = this._getCachedValueMap(layerInfo);
			if( valueMap 
			 && valueMap[id]
			 && !valueMap[id].__n2_cache_invalid
			 ) {
				// Make a copy for the caller
				return $n2.document.clone(valueMap[id]);
			};
		};
		
		return null;
	},
	
	_getCachedValueMap: function(layerInfo) {
		var valueMap = undefined;

		if( layerInfo.cachingAllowed ) {
			if( layerInfo.cachedValues ) {
				valueMap = layerInfo.cachedValues;
			} else {
				valueMap = {};
				layerInfo.cachedValues = valueMap;
				
				var olLayer = layerInfo.olLayer;
				var features = olLayer.features;
				for(var i=0,e=features.length; i<e; ++i){
					var feature = features[i];
					if( feature.fid ) {
						valueMap[feature.fid] = feature.data;
					};
					if( feature.cluster ){
						for(var j=0,k=feature.cluster.length;j<k;++j){
							var cf = feature.cluster[j];
							if( cf.fid ){
								valueMap[cf.fid] = cf.data;
							};
						};
					};
				};
			};
		};
		
		return valueMap;
	},
	
	_clearValueCache: function(layerInfo){
		layerInfo.cachedValues = null;
	},
	
	_cacheInvalidateFeature: function(id) {
		// Invalidate feature on each layer
		for(var i=0,e=this.infoLayers.length; i<e; ++i){
			var layerInfo = this.infoLayers[i];
			var valueMap = this._getCachedValueMap(layerInfo);
			if( valueMap && valueMap[id] ) {
				valueMap[id].__n2_cache_invalid = true;
			};
		};
	},
	
	_cacheUpdateDocumentVersion: function(id,rev){
		// Iterate over all layers
		for(var i=0,e=this.infoLayers.length; i<e; ++i){
			var layerInfo = this.infoLayers[i];
			var valueMap = this._getCachedValueMap(layerInfo);

			// Invalidate feature if revision has changed
			if( valueMap && valueMap[id] ) {
				if( valueMap[id]._rev !== rev ) {
					valueMap[id].__n2_cache_invalid = true;
				};
			};
		};
	},

	// === END -- DOCUMENT CACHE ===================================================

	_handleMapMousePosition: function(evt){
		if( null == evt ) {
			this.lastMapXy = null;
		} else {
			this.lastMapXy = this.map.events.getMousePosition(evt);
		};
		
		// Call listeners, removing those that do not need to be called again
		var newListeners = [];
		for(var i=0,e=this.mapMouseMoveListeners.length; i<e; ++i){
			var l = this.mapMouseMoveListeners[i];
			try {
				var keep = l(evt, this);
				if( keep ) {
					newListeners.push(l);
				};
			} catch(e){
				// ignore error. remove listener
			};
		};
		this.mapMouseMoveListeners = newListeners;
	},
	
	_getAuthService: function(){
		var auth = null;
		
		if( this.options.directory ) {
			auth = this.options.directory.authService;
		};
		
		return auth;
	},
	
	_getCustomService: function(){
		var cs = null;
		
		if( this.options.directory ) {
			cs = this.options.directory.customService;
		};
		
		return cs;
	},
	
	_getDispatchService: function(){
		var d = null;
		if( this.options.directory ) {
			d = this.options.directory.dispatchService;
		};
		
		return d;
	},
	
	_dispatch: function(m){
		var dispatcher = this._getDispatchService();
		if( dispatcher ) {
			dispatcher.send(DH,m);
		};
	},
	
	_registerDispatch: function(event, fn){
		var dispatcher = this._getDispatchService();
		if( dispatcher ) {
			var _this = this;
			if( !fn ) {
				fn = this._handleDispatch_;
			};
			if( !fn ){
				fn = function(m){
					_this._handleDispatch(m);
				};
			};

			dispatcher.register(DH,event,fn);
		};
	},
	
	_handleDispatch: function(m){
		var _this = this;

		var type = m.type;
		if( 'documentVersion' === type ) {
			this._cacheUpdateDocumentVersion(m.docId,m.rev);
			
		} else if( 'documentDeleted' === type ) {
			this._removeFeature(m.docId);

		} else if( 'cacheRetrieveDocument' === type ) {
			var doc = this._retrieveCachedValue(m.docId);
			if( doc ){
				m.doc = doc;
			};
			
		} else if( 'documentContentCreated' === type ) {
			var doc = m.doc;
			
			if( doc && doc.nunaliit_geom ){
				// Compute map of layer ids
				var layerIdMap = {};
				if( doc.nunaliit_layers ){
					for(var i=0,e=doc.nunaliit_layers.length; i<e; ++i){
						layerIdMap[ doc.nunaliit_layers[i] ] = true;
					};
				};
				
				// Check added to layer
				for(var i=0,e=this.infoLayers.length; i<e; ++i) {
					var infoLayer = this.infoLayers[i];
					var layerId = infoLayer.id;
					if( layerIdMap[layerId] ){
						var feature = this._getLayerFeatureIncludingFid(infoLayer.olLayer,doc._id);
						var mustLoad = true;
						if( feature && feature.data ){
							if( feature.data._rev === doc._rev ){
								// Feature already present
								mustLoad = false;
							};
						};
						
						if( mustLoad ) {
							// This feature belongs on this layer. Load it.
							var filter = $n2.olFilter.fromFid(m.docId);
							this._loadFeatureOnLayer(infoLayer, filter);
						};
					};
				};
			};
			
		} else if( 'documentContentUpdated' === type ) {
			var doc = m.doc;
			var reloaded = false;

			// Compute map of layer ids
			var layerIdMap = {};
			if( doc && doc.nunaliit_layers ){
				for(var i=0,e=doc.nunaliit_layers.length; i<e; ++i){
					layerIdMap[ doc.nunaliit_layers[i] ] = true;
				};
			};
			
			// Check removed from layer
			for(var i=0,e=this.infoLayers.length; i<e; ++i) {
				var infoLayer = this.infoLayers[i];
				var layerId = infoLayer.id;
				if( !layerIdMap[layerId] ){
					// This feature does not belong on this layer. If
					// this feature id is found on the layer, then remove
					// it (it was removed from layer)
					var feature = this._getLayerFeatureIncludingFid(infoLayer.olLayer,doc._id);
					if( feature ) {
						var featuresToAdd = null;
						if( feature.cluster ){
							for(var j=0,k=feature.cluster.length; j<k; ++j){
								var cf = feature.cluster[j];
								if( cf.fid !== doc._id ){
									if( !featuresToAdd ) featuresToAdd= [];
									featuresToAdd.push(cf);
								};
							};
						};
						
						// Remove features
						infoLayer.olLayer.destroyFeatures(feature);
						
						// If cluster, add back 
						if( featuresToAdd ){
							infoLayer.olLayer.addFeatures(featuresToAdd);
						};
						
						reloaded = true;
					};
				};
			};
			
			// Check updated on layer
			for(var i=0,e=this.infoLayers.length; i<e; ++i) {
				var infoLayer = this.infoLayers[i];
				var layerId = infoLayer.id;
				if( layerIdMap[layerId] ){
					var mustUpdate = true;
					if( doc && doc._rev ){
						var feature = this._getLayerFeatureIncludingFid(infoLayer.olLayer,doc._id);
						if( feature 
						 && feature.fid === doc._id 
						 && feature.data 
						 && feature.data._rev === doc._rev ){
							// Feature is present and revision is already
							// up to date. No need to update
							mustUpdate = false;
							
						} else if( feature && feature.cluster ){
							for(var j=0,k=feature.cluster.length; j<k; ++j){
								var cf = feature.cluster[j];
								if( cf 
								 && cf.fid === doc._id 
								 && cf.data 
								 && cf.data._rev === doc._rev ){
									mustUpdate = false;
								};
							};
						};
					};
					
					if( mustUpdate ) {
						// This feature belongs on this layer. Update it.
						// This takes care if geometry was modified or if feature
						// was recently added to the layer.
						var filter = $n2.olFilter.fromFid(m.docId);
						this._loadFeatureOnLayer(infoLayer, filter);
					};
				};
			};
			
			if( reloaded ){
				this._updatedStylesInUse();
			};
			
		} else if( 'addLayerToMap' === type ) {
			this._handleAddLayerToMap(m);
			
		} else if( 'selected' === type ) {
			if( m.docId ) {
				var features = this._getMapFeaturesIncludingFid(m.docId);
				this._selectedFeatures(features, [m.docId]);
				
			} else if( m.docIds ) {
				var features = this._getMapFeaturesIncludingFids(m.docIds);
				this._selectedFeatures(features, m.docIds);
			};
			
		} else if( 'selectedSupplement' === type ) {
			var fid = m.docId;
			if( fid ) {
				var features = this._getMapFeaturesIncludingFid(fid);
				this._selectedFeaturesSupplement({
					fid: fid
					,features: features
					,intent: m.intent
				});
			};
			
		} else if( 'unselected' === type ) {
			this._endClicked();
			
		} else if( 'focusOn' === type ) {
			if( m.docId ){
				this._startFocus([m.docId]);
			} else if( m.docIds ){
				this._startFocus(m.docIds);
			};
			
		} else if( 'focusOff' === type ) {
			this._endFocus();
			
		} else if( 'focusOnSupplement' === type ) {
			var fid = m.docId;
			
			// Check if this is still valid
			var valid = true;
			if( m.origin ){
				valid = false;
				if( this.focusInfo 
				 && this.focusInfo.origin
				 && this.focusInfo.origin[m.origin] ){
					valid = true;
				};
			};
			
			if( fid && valid ) {
				this._addFocus({
					fids: [fid]
					,intent: m.intent
				});
			};
			
		} else if( 'findIsAvailable' === type ) {
			// Synchronous call. Response sent on message.
			var doc = m.doc;
			if( doc.nunaliit_geom 
			 && doc.nunaliit_layers ){
				for(var i=0,e=this.infoLayers.length; i<e; ++i) {
					var infoLayer = this.infoLayers[i];
					var layerId = infoLayer.id;
					if( doc.nunaliit_layers.indexOf(layerId) >= 0 ){
						m.isAvailable = true;
						break;
					};
				};
			};
			
		} else if( 'find' === type ) {
			var doc = m.doc;
			if( doc && doc.nunaliit_geom ){
				var x = (doc.nunaliit_geom.bbox[0] + doc.nunaliit_geom.bbox[2]) / 2;
				var y = (doc.nunaliit_geom.bbox[1] + doc.nunaliit_geom.bbox[3]) / 2;
				this._centerMapOnXY(x, y, 'EPSG:4326');
			};
			
			// Remember that this feature is looked for by user
			var fid = m.docId;
			var features = this._getMapFeaturesIncludingFid(fid);
			this._startFindFeature(fid, features);
			
			// Check if we need to turn a layer on
			if( doc && doc.nunaliit_layers ) {
				var visible = false;
				var olLayerToTurnOn = null;
				for(var i=0,e=this.infoLayers.length; i<e; ++i) {
					var infoLayer = this.infoLayers[i];
					var layerId = infoLayer.id;
					var olLayer = infoLayer.olLayer;

					if( doc.nunaliit_layers.indexOf(layerId) >= 0 
					 && olLayer ) {
						if( olLayer.visibility ) {
							visible = true;
						} else {
							olLayerToTurnOn = olLayer;
						};
					};
				};
	
				// Turn on layer
				if( !visible && olLayerToTurnOn ){
					olLayerToTurnOn.setVisibility(true);
				};
			};
			
		} else if( 'searchInitiate' === type ) {
			this._endClicked();
			
		} else if( 'editInitiate' === type ) {
			
			var fid = undefined;
			if( m.doc ){
				fid = m.doc._id;
			};
			
			var feature = null;
			var addGeometryMode = true;
			
			if( fid ){
				var features = this._getMapFeaturesIncludingFid(fid);
				
				if( features.length > 0 ){
					feature = features[0];
				};
				
				if( feature ) {
					this._centerMapOnFeature(feature);
					addGeometryMode = false;
					
				} else {
					// must center map on feature, if feature contains
					// a geometry
					if( m.doc 
					 && m.doc.nunaliit_geom 
					 && m.doc.nunaliit_geom.bbox 
					 && m.doc.nunaliit_geom.bbox.length >= 4 ) {
						var bbox = m.doc.nunaliit_geom.bbox;
						var x = (bbox[0] + bbox[2]) / 2;
						var y = (bbox[1] + bbox[3]) / 2;
						this._centerMapOnXY(x, y, 'EPSG:4326');

						addGeometryMode = false;
					};
				};
			};
			
			// Remove feature from map
			this.infoLayers.forEach(function(layerInfo){
				if( layerInfo.featureStrategy ){
					layerInfo.featureStrategy.setEditedFeatureIds([fid]);
				};
			});
			
			this.editFeatureInfo = {};
    		this.editFeatureInfo.fid = fid;
			this.editFeatureInfo.original = {
				data: $n2.document.clone(m.doc)
			};
	    	var effectiveFeature = null;
			if( feature ){
		    	// Remove feature from current layer
		    	var featureLayer = feature.layer;

		    	// Compute the actual underlying feature
		    	if( fid === feature.fid ){
		        	effectiveFeature = feature;
		        	
		    	} else if( feature.cluster ){
		    		for(var i=0,e=feature.cluster.length; i<e; ++i){
		    			if( fid === feature.cluster[i].fid ){
		    	    		effectiveFeature = feature.cluster[i];
		    			};
		    		};
		    	};
		    	
		    	this.editFeatureInfo.original.layer = featureLayer;
		    	this.editFeatureInfo.original.feature = effectiveFeature;
			};
			
			if( addGeometryMode ){
				// Edit a document that does not have a geometry.
				// Allow adding a geometry.
				this.switchToAddGeometryMode(fid);
			} else {
				// Do not provide the effective feature. The event 'editReportOriginalDocument'
				// will provide the original geometry. The effective feature might have a simplified
				// version of the geometry
				this.switchToEditFeatureMode(fid);
			};
			
		} else if( 'editClosed' === type ) {

			var fid = this.editFeatureInfo.fid;
			if( !fid ){
				fid = m.docId;
			};
			var reloadRequired = true;
			if( m.cancelled ){
				reloadRequired = false;
			};
			
			// By switching to the navigate mode, the feature on the
			// edit layer will be removed.
			var editFeature = this._removeGeometryEditor();
			this._switchMapMode(this.modes.NAVIGATE);

			// Add back feature to map
			this.infoLayers.forEach(function(layerInfo){
				if( layerInfo.featureStrategy ){
					layerInfo.featureStrategy.setEditedFeatureIds(null);
				};
			});
			
			// If feature was deleted, then remove it from map
			if( m.deleted && fid ){
				reloadRequired = false;

				this.forEachVectorLayer(function(layerInfo, layer){
					var reloadLayer = false;
					var featuresToAdd = [];
					layerInfo.forEachFeature(function(f){
						if( f.fid === fid ){
							reloadLayer = true;
						} else {
							featuresToAdd.push(f);
						};
					});
					
					if( reloadLayer ){
						layer.removeAllFeatures({silent:true});
						layer.addFeatures(featuresToAdd);
					};
				});
			};
			
			this.editFeatureInfo = {};
			this.editFeatureInfo.original = {};
			
			// Reload feature
			if( reloadRequired ){
				var filter = $n2.olFilter.fromFid(fid);
				this._reloadFeature(filter);
			};
			
		} else if( 'editGeometryModified' === type ) {
			if( m._origin !== this ){
				this._geometryModified(m.docId, m.geom, m.proj);
			};

		} else if( 'editReportOriginalDocument' === type ) {
			if( m.geometry 
			 && m.docId === this.editFeatureInfo.fid ){
				// Adjust geometry
				this._geometryModified(m.docId, m.geometry, m.projection);

				var zoomRequired = true;
				if( this.editFeatureInfo.suppressZoom ){
					zoomRequired = false;
				};

				// Zoom/Center
				if( m.doc
				 && m.doc.nunaliit_geom
				 && m.doc.nunaliit_geom.bbox 
				 && m.projection ){
					var xmin = m.doc.nunaliit_geom.bbox[0];
					var ymin = m.doc.nunaliit_geom.bbox[1];
					var xmax = m.doc.nunaliit_geom.bbox[2];
					var ymax = m.doc.nunaliit_geom.bbox[3];
					
					var xdiff = (xmax - xmin) / 3;
					var ydiff = (ymax - ymin) / 3;
					
					// Do not zoom on points
					if( xdiff <= 0 && ydiff <= 0 ){
						zoomRequired = false;
					};
					
					if( zoomRequired ){
						xmin = xmin - xdiff;
						xmax = xmax + xdiff;
						ymin = ymin - ydiff;
						ymax = ymax + ydiff;
						
						this.setNewExtent(
							[xmin,ymin,xmax,ymax]
							,m.projection.getCode()
						);
					} else if( !this.editFeatureInfo.suppressCenter ) {
						// Center on geometry
						var x = (xmin + xmax)/2;
						var y = (ymin + ymax)/2;
						this._centerMapOnXY(x,y,m.projection.getCode());
					};
				};
			};
			
		} else if( 'mapRedrawLayer' === type ) {
			var layerId = m.layerId;
			this.redefineFeatureLayerStylesAndRules(layerId);
			
		} else if( 'mapSetInitialExtent' === type ) {
			var extent = m.extent;
			var srsName = m.srsName;
			var reset = m.reset;
			this.setInitialExtent(extent, srsName, reset);
			
		} else if( 'mapSetExtent' === type ) {
			var extent = m.extent;
			var srsName = m.srsName;
			this.setNewExtent(extent, srsName);
			
		} else if( 'mapResetExtent' === type ) {
			this.resetExtent();
			
		} else if( 'mapGetLayers' === type ) {
			// Synchronous call. Response sent on message.
			if( !m.layers ){
				m.layers = {};
			};
			for(var i=0,e=this.infoLayers.length; i<e; ++i) {
				var infoLayer = this.infoLayers[i];
				var layerId = infoLayer.id;
				var olLayer = infoLayer.olLayer;

				var report = m.layers[layerId];
				if( !report ){
					report = {
						id: layerId
					};
					m.layers[layerId] = report;
				};
				
				if( olLayer && olLayer.visibility ) {
					report.visible = true;
				};
			};
		} else if( 'setMapLayerVisibility' === type ) {
			var layerId = m.layerId;
			var visible = m.visible;
			
			if( this.layers[layerId] ){
				this.layers[layerId].setVisibility(visible);
			};
		} else if( 'mapSwitchToEditMode' === type ) {
			this.switchToEditMode();
			
		} else if( 'simplifiedGeometryReport' === type ) {
			this._updateSimplifiedGeometries(m.simplifiedGeometries);

		} else if( 'canvasGetStylesInUse' === type ) {
			if( this.getCanvasName() === m.canvasName ){
				m.stylesInUse = this._getMapStylesInUse();
			};
		};
	},
	
	_modelLayerUpdated: function(layerOptions, state){
		//$n2.log('_modelLayerUpdated',layerOptions, state);
		
		var _this = this;
		var layerInfo = layerOptions._layerInfo;
		var mapLayer = layerInfo.olLayer;

		var mustReproject = false;
        var remoteProjection = mapLayer.projection;
	    var localProjection = layerInfo.olLayer.map.getProjectionObject();
        if( localProjection 
         && false == localProjection.equals(remoteProjection) ) {
        	mustReproject = true;
        };
		
		// Remove features. Remove features that are to be updated
        var featureIdsToRemoveMap = {};
        state.removed.forEach(function(f){
        	featureIdsToRemoveMap[f.fid] = true;
        });
        state.updated.forEach(function(f){
        	featureIdsToRemoveMap[f.fid] = true;
        });
        var featuresToRemove = [];
        var featuresToAdd = [];
		if( mapLayer && mapLayer.features ) {
			var loop;
			var features = mapLayer.features;
			for(loop=0;loop<features.length;++loop) {
				var feature = features[loop];
				if( feature.fid && featureIdsToRemoveMap[feature.fid] ) {
					featuresToRemove.push(feature);
				} else if( feature.cluster ) {
					var removeCluster = false;
					for(var j=0,k=feature.cluster.length; j<k; ++j){
						var f = feature.cluster[j];
						if( f.fid && featureIdsToRemoveMap[f.fid] ){
							removeCluster = true;
						};
					};
					if( removeCluster ){
						featuresToRemove.push(feature);
						for(var j=0,k=feature.cluster.length; j<k; ++j){
							var f = feature.cluster[j];
							if( f.fid && !featureIdsToRemoveMap[f.fid] ){
								featuresToAdd.push(f);
							};
						};
					};
				};
			};
		};
			
		// Prepare features to be added to layer
        state.added.forEach(function(f){
			if( mustReproject ){
	            var geom = f.geometry;
			    if( geom ) {
	        		geom.transform(remoteProjection, localProjection);
	            };
			};
        	featuresToAdd.push(f);
        });
        state.updated.forEach(function(f){
			if( mustReproject ){
	            var geom = f.geometry;
			    if( geom ) {
	        		geom.transform(remoteProjection, localProjection);
	            };
			};
        	featuresToAdd.push(f);
        });

        // Remove features
        if( featuresToRemove.length ){
			mapLayer.destroyFeatures(featuresToRemove);
		};

		// Add features
		if( featuresToAdd.length > 0 ){
			// If in edit mode, first disable editAttribute widget
			this.editModeAddFeatureEnabled = false;

			mapLayer.addFeatures(featuresToAdd);
			
			this.editModeAddFeatureEnabled = true;
		};
		
		// Update styles
		this._updatedStylesInUse();
	},
	
	_handleAddLayerToMap: function(m){
		var layerDef = m.layer;
		var isBaseLayer = false;
		if( typeof(m.isBaseLayer) !== 'undefined' ){
			isBaseLayer = m.isBaseLayer;
		};
		
		var olLayer = this.findLayerFromId(layerDef.id);
		if( !olLayer ) {
			this.addLayer(layerDef,isBaseLayer);
			olLayer = this.findLayerFromId(layerDef.id);
		};
		
		// Turn on
		if( olLayer ) {
			olLayer.setVisibility(true);
		};

		// Zoom
		if( m.options && m.options.setExtent ) {
			var bounds = m.options.setExtent.bounds;
			var srsName = m.options.setExtent.crs;
			this.setNewExtent(bounds, srsName);
		};
	}
});

$n2.mapAndControls = function(opts_){
	return new MapAndControls(opts_);
};
$n2.mapAndControls.MapAndControls = MapAndControls;

// Utilities
$n2.mapAndControls.ComputeFeatureOriginalBboxForMapProjection = ComputeFeatureOriginalBboxForMapProjection;

// Pop-up management
$n2.mapAndControls.DefaultPopupHtmlFunction = null;
$n2.mapAndControls.SuppressPopupHtmlFunction = suppressPopupHtmlFunction;

// Cluster click callback
$n2.mapAndControls.ZoomInClusterClickCallback = zoomInClusterClickCallback;
$n2.mapAndControls.MultiSelectClusterClickCallback = multiSelectClusterClickCallback;

// Widgets
$n2.mapAndControls.TimeTransformMapBridge = TimeTransformMapBridge;
$n2.mapAndControls.ModelMapBridge = ModelMapBridge;
$n2.mapAndControls.HandleWidgetAvailableRequests = HandleWidgetAvailableRequests;
$n2.mapAndControls.HandleWidgetDisplayRequests = HandleWidgetDisplayRequests;

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.mapStyles.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

// Localization
//var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

//=========================================================================
/*
 
      Each style comprises 4 states: normal, hovered, clicked, hoveredClicked. In each,
      style, the states are computed according to the diagram below
      
        normal
          V
          |-------------|--------------|----------------|
          |             |              |                |
          |       hovered delta  clicked delta  hoveredClicked delta
          |             |              |                |
          V             V              V                V
        Normal       Hovered        Clicked       HoveredClicked   (4 states constitute
        State         State          State            State          a style)
      
 
      Base style
          V
          |-------------|--------------|-------------|
          |             |              |             |
          |        point delta     line delta  polygon delta
          |             |              |             |
          |             V              V             V
          |        Point Style     Line Style  Polygon Style     (default styles)
          |
     layer delta
          V
          |-------------|--------------|-------------|
                        |              |             |
                   point delta     line delta  polygon delta
                        |              |             |
                   layer point     layer line   layer polygon
                      delta          delta         delta
                        |              |             |
                        V              V             V
                   Layer Point     Layer Line   Layer Polygon  (styles for layer)
                      Style           Style        Style

     Schema styles are computed the same way as layer styles.
     
     Styles are selected in the following order:
     - if a schema name matches a style, then the matching style is selected
     - if a layer name matches a style, then the matching style is selected
     - the default style is selected
          
*/
	
var defaultDefinition = { 
	base: {
		normal:{
			fillColor: '#ffffff'
			,strokeColor: '#ee9999'
			,strokeWidth: 2
			,fillOpacity: 0.4
			,strokeOpacity: 1
			,strokeLinecap: "round"
			,strokeDashstyle: "solid"
			,pointRadius: 6
			,pointerEvents: "visiblePainted"
		}
		,clicked:{
			strokeColor: "#ff2200"
		}
		,hovered:{
			fillColor: "#0000ff"
		}
		,hoveredClicked:{
			fillColor: "#0000ff"
			,strokeColor: "#ff2200"
		}
	}
	,point: null
	,line: {
		hovered:{
			strokeColor: "#0000ff"
		}
		,hoveredClicked:{
			strokeColor: "#0000ff"
		}
	}
	,polygon: null
	,layers: null
	,schemas: null
	,intents: {
		cluster: {
			base: {
				normal: {
					fillColor: '#ffff33'
					,pointRadius: 8
					,graphicName: 'square'
				}
			}
		}
		,find: {
			base: {
				normal: {
					strokeColor: "#ffff00"
				}
			}
		}
	}
};
	
var MapFeatureStyles = $n2.Class({

	activeStyles: null
	
	,initialize: function(userStyles){

		var descriptors = this._parseDefinition(userStyles);
		
		this.activeStyles = {};
		for(var i=0,e=descriptors.length;i<e;++i){
			var descriptor = descriptors[i];
			var args = [];
			args.push(descriptor,this.activeStyles);
			if( descriptor.layer ){
				args.push({
					category: 'layers'
					,name: descriptor.layer
				});
			};
			if( descriptor.schema ){
				args.push({
					category: 'schemas'
					,name: descriptor.schema
				});
			};
			if( descriptor.intent ){
				args.push({
					category: 'intents'
					,name: descriptor.intent
				});
			};
			this._installDefinition.apply(this,args);
		};
	}
	
	,_parseDefinition: function(userDefinition){
		// Make a list of descriptors to return
		var descriptors = [];
		
		// Initial descriptor
		var initialDescriptor = {
			layer: null
			,schema: null
			,intent: null
			,priority: -1
			,styleSet: this._computeStyleSet(userDefinition)
		};
		descriptors.push(initialDescriptor);
		
		// Default layers, schemas, intents
		this._parseDefinition2(initialDescriptor, [], defaultDefinition, descriptors);
		
		// User layers, schemas, intents
		initialDescriptor = $n2.extend({},initialDescriptor,{priority:0});
		this._parseDefinition2(initialDescriptor, [userDefinition], userDefinition, descriptors);
		
		return descriptors;
	}
	
	/**
	 * @param descriptor {Object} Carries accumulated description for the definitions
	 *                   processed so far.
	 * @param accumulatedDefinitions {Array} Array of definitions to be merged into the next
	 *                               levels of styles.
	 * @param userDefinition {Object} Style definition currently processed
	 * @param descriptorArray {Array} Array of all generated style descriptor
	 */
	,_parseDefinition2: function(descriptor, accumulatedDefinitions, userDefinition, descriptorArray){
		// Creates styles for layers
		if( userDefinition && userDefinition.layers ){
			for(var layerName in userDefinition.layers){
				// Create a new descriptor. Set layer name and increase priority
				var layerDescriptor = $n2.extend({},descriptor,{
					layer: layerName
					,priority: (descriptor.priority + 1)
				});
				
				// Add definition for layer, after default for layer
				var layerDef = userDefinition.layers[layerName];
				var defs = accumulatedDefinitions.slice(0);
				
				if( defaultDefinition.layers && defaultDefinition.layers[layerName] ){
					defs.push(defaultDefinition.layers[layerName]);
				};
				
				defs.push(layerDef);
				
				// Compute style set based on all definitions
				layerDescriptor.styleSet = this._computeStyleSet.apply(this, defs);
				
				// Add descriptor to array of descriptors
				descriptorArray.push(layerDescriptor);
				
				// Recurse
				this._parseDefinition2(layerDescriptor, defs, layerDef, descriptorArray);
			};
		};
		
		// Create styles for schemas
		if( userDefinition && userDefinition.schemas ){
			for(var schemaName in userDefinition.schemas){
				var schemaDescriptor = $n2.extend({},descriptor,{
					schema: schemaName
					,priority: (descriptor.priority + 1)
				});
				
				var schemaDef = userDefinition.schemas[schemaName];
				var defs = accumulatedDefinitions.slice(0);
				
				if( defaultDefinition.schemas && defaultDefinition.schemas[schemaName] ){
					defs.push(defaultDefinition.schemas[schemaName]);
				};

				defs.push(schemaDef);
				
				schemaDescriptor.styleSet = this._computeStyleSet.apply(this, defs);
				
				descriptorArray.push(schemaDescriptor);
				
				// Recurse
				this._parseDefinition2(schemaDescriptor, defs, schemaDef, descriptorArray);
			};
		};
		
		// Create styles for intents
		if( userDefinition && userDefinition.intents ){
			for(var intentName in userDefinition.intents){
				var intentDescriptor = $n2.extend({},descriptor,{
					intent: intentName
					,priority: (descriptor.priority + 1)
				});
				
				var intentDef = userDefinition.intents[intentName];
				var defs = accumulatedDefinitions.slice(0);
				
				if( defaultDefinition.intents && defaultDefinition.intents[intentName] ){
					defs.push(defaultDefinition.intents[intentName]);
				};

				defs.push(intentDef);
				
				intentDescriptor.styleSet = this._computeStyleSet.apply(this, defs);
				
				descriptorArray.push(intentDescriptor);
				
				// Recurse
				this._parseDefinition2(intentDescriptor, defs, intentDef, descriptorArray);
			};
		};
	}
	
	/**
	 * Accepts a styleDescriptor and install within a tree for easy look up.
	 */
	,_installDefinition: function(styleDescriptor, currentNode, routingInfo){
		if( !routingInfo ){
			if( currentNode.descriptor 
			 && currentNode.descriptor.priority <= styleDescriptor.priority ){
				currentNode.descriptor = styleDescriptor;
				
			} else if( !currentNode.descriptor ){
				currentNode.descriptor = styleDescriptor;
			};
			
		} else {
			var nextRoute = arguments[arguments.length-1];
			var category = nextRoute.category;
			var name = nextRoute.name;
			if( !currentNode[category] ){
				currentNode[category] = {};
			};
			if( !currentNode[category][name] ){
				currentNode[category][name] = {};
			};
			
			// Next call, drop last route
			var nextLevelArgs = [styleDescriptor, currentNode[category][name]];
			for(var i=2,e=arguments.length-1;i<e;++i){
				nextLevelArgs.push(arguments[i]);
			};
			this._installDefinition.apply(this, nextLevelArgs);
		};
	}
	
	,_retrieveStyleSet: function(intent, schema, layer){
		var currentNode = this.activeStyles;
		var currentDescriptor = this.activeStyles.descriptor;

		if( intent 
		 && currentNode.intents 
		 && currentNode.intents[intent] ){
			currentNode = currentNode.intents[intent];
			if( currentNode.descriptor 
			 && currentDescriptor.priority < currentNode.descriptor.priority ) {
				currentDescriptor = currentNode.descriptor;
			};
		};

		if( schema 
		 && currentNode.schemas 
		 && currentNode.schemas[schema] ){
			currentNode = currentNode.schemas[schema];
			if( currentNode.descriptor 
			 && currentDescriptor.priority < currentNode.descriptor.priority ) {
				currentDescriptor = currentNode.descriptor;
			};
		};

		if( layer 
		 && currentNode.layers 
		 && currentNode.layers[layer] ){
			currentNode = currentNode.layers[layer];
			if( currentNode.descriptor 
			 && currentDescriptor.priority < currentNode.descriptor.priority ) {
				currentDescriptor = currentNode.descriptor;
			};
		};
		
		return currentDescriptor.styleSet;
	}

	/*
	 * Computes the three variants of a style: point, line, polygon. This is
	 * accomplished by computing a base style. Then, styles for points, lines
	 * and polygons are derived by adding deltas to the effective base style.
	 * 
	 * base = defaultDefinition(base) + userDefinition(base) + a0(base) + ... + an(base)
	 * point = base + defaultDefinition(point) + userDefinition(point) + a0(point) + ... + an(point)
	 * line = base + defaultDefinition(line) + userDefinition(line) + a0(line) + ... + an(line)
	 * polygon = base + defaultDefinition(polygon) + userDefinition(polygon) + a0(polygon) + ... + an(polygon)
	 */
	,_computeStyleSet: function(){
		
		var computedSet = {};
		
		// Start from default base and user base
		var pointArgs = [defaultDefinition.base];
		var lineArgs = [defaultDefinition.base];
		var polygonArgs = [defaultDefinition.base];
		
		// Add default style for geometry
		pointArgs.push(defaultDefinition.point);
		lineArgs.push(defaultDefinition.line);
		polygonArgs.push(defaultDefinition.polygon);
		
		// Add all base styles found in arguments
		for(var i=0,e=arguments.length;i<e;++i){
			var setDelta = arguments[i];
			
			if( setDelta ) {
				pointArgs.push(setDelta.base);
				lineArgs.push(setDelta.base);
				polygonArgs.push(setDelta.base);
			};
		};
		
		// Add all geometry styles found in argument
		for(var i=0,e=arguments.length;i<e;++i){
			var setDelta = arguments[i];
			
			if( setDelta ) {
				pointArgs.push(setDelta.point);
				lineArgs.push(setDelta.line);
				polygonArgs.push(setDelta.polygon);
			};
		};
		
		// Merge all the styles and save the geometries
		computedSet.point = this._computeStateStyles.apply(this, pointArgs);
		computedSet.line = this._computeStateStyles.apply(this, lineArgs);
		computedSet.polygon = this._computeStateStyles.apply(this, polygonArgs);

		return computedSet;
	}

	/*
	 * This function can be called with many arguments. The first style
	 * is cloned and then the clone is merged with all subsequent styles in
	 * arguments.
	 * 
	 * As arguments, this method expect a number of object containing a definition
	 * for each of the four states: normal, clicked, hovered, hoveredClicked.
	 * 
	 * The merging is accomplished by extending the first definiton for the normal 
	 * state with all of the subsequent definitions for the normal state. This results 
	 * into the effective definition for the normal state.
	 * 
	 * The merging process continues with the other three states: clicked, hovered and
	 * hoveredClicked. For each of those states, the process starts with the effective
	 * definition for the normal state and extending it with all the definitions for the 
	 * currently merged state.
	 * 
	 * normal = {} + normal(1) + normal(2) + ... + normal(n)
	 * clicked = normal + clicked(1) + clicked(2) + ... + clicked(n)
	 * hovered = normal + hovered(1) + hovered(2) + ... + hovered(n)
	 * hoveredClicked = normal + hoveredClicked(1) + hoveredClicked(2) + ... + hoveredClicked(n)
	 */
	,_mergeStateStyles: function(baseStyle){
		
		var mergedStyle = {};
		
		if( !baseStyle ){
			baseStyle = {};
		};

		// Compute normal state by applying all deltas
		mergedStyle.normal = $n2.extend({},baseStyle.normal);
		for(var i=1,e=arguments.length; i<e; ++i){
			var delta = arguments[i];
			if( delta && delta.normal ) {
				$n2.extend(mergedStyle.normal, delta.normal);
			};
		};
		
		// Derive the other states from the normal one
		mergedStyle.hovered = $n2.extend({},mergedStyle.normal,baseStyle.hovered);
		mergedStyle.clicked = $n2.extend({},mergedStyle.normal,baseStyle.clicked);
		mergedStyle.hoveredClicked = $n2.extend({},mergedStyle.normal,baseStyle.hoveredClicked);
		
		// Apply deltas to other states
		for(var i=1,e=arguments.length; i<e; ++i){
			var delta = arguments[i];
			if( delta && delta.hovered ) {
				$n2.extend(mergedStyle.hovered, delta.hovered);
			};
			if( delta && delta.clicked ) {
				$n2.extend(mergedStyle.clicked, delta.clicked);
			};
			if( delta && delta.hoveredClicked ) {
				$n2.extend(mergedStyle.hoveredClicked, delta.hoveredClicked);
			};
		};
		
		return mergedStyle;
	}

	/*
	 * This function can be called with many arguments. The first style
	 * is cloned and then the clone is extended by all subsequent styles in
	 * arguments.
	 */
	,_computeStateStyles: function(baseStyle){
		
		// Merge the styles
		var mergedStyle = this._mergeStateStyles.apply(this,arguments);
		
		// Wrap the styles into an OpenLayers Style instance
		var computedStyle = {
			normal: new OpenLayers.Style(mergedStyle.normal)
			,hovered: new OpenLayers.Style(mergedStyle.hovered)
			,clicked: new OpenLayers.Style(mergedStyle.clicked)
			,hoveredClicked: new OpenLayers.Style(mergedStyle.hoveredClicked)
			,_merged: mergedStyle // keep around for debugging
		};
		
		return computedStyle;
	}
	
	/*
	 * Returns a style map function for a given layer
	 */
	,getStyleMapForLayerInfo: function(layerInfo){
		
		var _this = this;
		
		var styleMap = new OpenLayers.StyleMapCallback(function(feature,intent){
			
			// Figure out intent
	        var effectiveIntent = null;
	        
	    	if( null == effectiveIntent && feature.isHovered ) {
		        if( feature.isClicked ) {
	        		effectiveIntent = 'hoveredClicked';
	        	} else {
	        		effectiveIntent = 'hovered';
		        };
	    	};
	    	
	    	if( null == effectiveIntent && feature.isClicked ) {
	    		effectiveIntent = 'clicked';
	    	};
	    	
	    	if( null == effectiveIntent ) {
	    		effectiveIntent = 'normal';
	    	};
	    	
	    	// Figure out type of geometry
	    	var geomType = feature.geometry._n2Type;
	    	if( !geomType ){
	    		if( feature.geometry.CLASS_NAME.indexOf('Line') >= 0 ) {
	    			geomType = feature.geometry._n2Type = 'line';
	    		} else if( feature.geometry.CLASS_NAME.indexOf('Polygon') >= 0 ) {
	    			geomType = feature.geometry._n2Type = 'polygon';
	    		} else {
	    			geomType = feature.geometry._n2Type = 'point';
	    		};
	    	};

			// Retrieve data. Handle clusters
	    	var data = feature.data;
			if( feature 
			 && feature.cluster 
			 && 1 === feature.cluster.length ){
				data = feature.cluster[0].data;
			};

			// Compute intent
	    	var n2Intent = feature.n2HoverIntent;
	    	if( !n2Intent ){
	    		n2Intent = feature.n2SelectIntent;
	    	};
	    	if( !n2Intent ){
	    		n2Intent = feature.n2Intent;
	    	};
	    	
	    	var layerId = layerInfo.id;
	    	var schemaName = null;
			if( data 
			 && data.nunaliit_schema ) {
				schemaName = data.nunaliit_schema;
			};
			if( feature 
			 && feature.cluster
			 && feature.cluster.length > 1 ){
				n2Intent = 'cluster';
			};

			var styleSet = _this._retrieveStyleSet(n2Intent, schemaName, layerId);
			var style = styleSet[geomType][effectiveIntent];
	        
	        return style.createSymbolizer(feature);
		});
		
		return styleMap;
	}
});

//=========================================================================
var olStyleNames = {
	"fill": "fillColor"
	,"fill-opacity": "fillOpacity"
	,"stroke": "strokeColor"
	,"stroke-opacity": "strokeOpacity"
	,"stroke-width": "strokeWidth"
	,"stroke-linecap": "strokeLinecap"
	,"stroke-dasharray": "strokeDashstyle"
	,"r": "pointRadius"
	,"pointer-events": "pointEvents"
	,"color": "fontColor"
	,"font-family": "fontFamily"
	,"font-size": "fontSize"
	,"font-weight": "fontWeight"
};

var stringStyles = {
	"label": true
};

var featureStyleFunctions = {
	getDocuments: function(){
		// this is the feature

		var documents = [];

		if( $n2.isArray(this.cluster) ) {
			this.cluster.forEach(function(f){
				documents.push(f.data);
			});
		} else {
			documents.push(this.data);
		};

		return documents;
	}
};

var MapStylesAdaptor = $n2.Class({
	
	styleRules: null,
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			ruleArray: null
			,dispatchService: null
		},opts_);
		
		var rules = [];

		// Base rule
		rules.push({
			condition: 'true'
			,normal:{
				fillColor: '#ffffff'
				,strokeColor: '#ee9999'
				,strokeWidth: 2
				,fillOpacity: 0.4
				,strokeOpacity: 1
				,strokeLinecap: "round"
				,strokeDashstyle: "solid"
				,pointRadius: 6
				,pointerEvents: "visiblePainted"
			}
			,selected:{
				strokeColor: "#ff2200"
			}
			,hovered:{
				fillColor: "#0000ff"
			}
			,found: {
				'strokeColor': '#00ffff'
				,'fillColor': '#00ffff'
			}
		});
		
		// Line
		rules.push({
			condition: 'isLine()'
			,normal: {
				'fillColor': 'none'
			}
			,selected: {
				'fillColor': 'none'
			}
			,hovered:{
				'strokeColor': '#0000ff'
				,'fillColor': 'none'
			}
			,found: {
				'strokeColor': '#00ffff'
				,'fillColor': 'none'
			}
		});

		if( $n2.isArray(opts.ruleArray) ){
			opts.ruleArray.forEach(function(rule){
				rules.push(rule);
			});
		};
		
		this.styleRules = $n2.styleRule.loadRulesFromObject(rules, {
			skipDefaults: true
		});
		this.dispatchService = opts.dispatchService;
		
	},

	getStyleMapForLayerInfo: function(layerInfo){
		
		var _this = this;
		
		var styleMap = new OpenLayers.StyleMapCallback(function(feature,intent){

			// Install functions on feature to support style system
			for(var fnName in featureStyleFunctions){
				feature[fnName] = featureStyleFunctions[fnName];
			};
			
	    	if( feature.isHovered ) {
		        feature.n2_hovered = true;
	    	} else {
		        feature.n2_hovered = false;
	    	};
	    	
	    	if( feature.isClicked ) {
	    		feature.n2_selected = true;
	    	} else {
	    		feature.n2_selected = false;
	    	};

	    	if( 'find' === feature.n2Intent ) {
	    		feature.n2_found = true;
	    	} else {
	    		feature.n2_found = false;
	    	};
	    	
	    	// Figure out type of geometry
	    	var geomType = feature.geometry._n2Type;
	    	if( !geomType ){
	    		if( feature.geometry.CLASS_NAME.indexOf('Line') >= 0 ) {
	    			geomType = feature.geometry._n2Type = 'line';
	    		} else if( feature.geometry.CLASS_NAME.indexOf('Polygon') >= 0 ) {
	    			geomType = feature.geometry._n2Type = 'polygon';
	    		} else {
	    			geomType = feature.geometry._n2Type = 'point';
	    		};
	    	};
	    	feature.n2_geometry = geomType;

			// Retrieve data. Handle clusters
	    	var data = feature.data;
			if( feature 
			 && feature.cluster 
			 && 1 === feature.cluster.length ){
				data = feature.cluster[0].data;
			};
			feature.n2_doc = data;

			var style = _this.styleRules.getStyle(feature);
			feature._n2Style = style;
			var symbolizer = style.getSymbolizer(feature);

			//TODO add a cache -- pending --
			var symbols = {};
			symbolizer.forEachSymbol(function(name,value){
				name = olStyleNames[name] ? olStyleNames[name] : name;
				
				if( stringStyles[name] ){
					if( null === value ){
						// Nothing
					} else if( typeof value === 'number' ) {
						value = '' + value;
					};
				};
				
				symbols[name] = value;
			},feature);

			return symbols;
		});
		
		return styleMap;
	}
});

//=========================================================================
$n2.mapStyles = {
	MapFeatureStyles: MapFeatureStyles
	,MapStylesAdaptor: MapStylesAdaptor
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.mapInitialBounds.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.instance'
 ;

// Requires OpenLayers
if( typeof OpenLayers === 'undefined' ) {
	return;
};

//--------------------------------------------------------------------------
// This instance attempts to compute the initial extent by looking up each
// couchDb overlay specified in the map options.
var MapAutoInitialBoundsCouchDbOverlays = $n2.Class({
	
	documentSource: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: null
		},opts_);
		
		this.documentSource = opts.documentSource;
	},
	
	computeInitialBounds: function(opts_){
		var opts = $n2.extend({
			mapOptions: null
			,mapInfo: null
			,initialBounds: null
			,coordinateProjection: null
			,onSuccess: function(bounds){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var mapOptions = opts.mapOptions;
		var initialBounds = opts.initialBounds;
		var documentSource = this.documentSource;
		var coordinateProjection = opts.coordinateProjection;
		
		// Loop over all layers, computing initial bounding box for
		// each
		var layerBoundingBox = null;
		var layersPending = 0;
		for(var i=0,e=mapOptions.overlays.length; i<e; ++i){
			var layerDef = mapOptions.overlays[i];
			if( layerDef.type === 'couchdb' ){
				++layersPending;
				var documentSource = layerDef.options.documentSource;
				var layerName = layerDef.options.layerName;
				documentSource.getGeographicBoundingBox({
					layerId: layerName
					,onSuccess: function(bbox){
						reportLayer(bbox);
					}
					,onError: function(errorMsg){ 
						$n2.log('Error computing bounds for layer '+layerName+': '+errorMsg); 
						reportLayer(null);
					}
				});
			};
		};
		testDone();
		
		function reportLayer(bounds){
			--layersPending;
			if( null == bounds ) {
				// ignore
			} else if( false == _this._isValidBounds(bounds) ) {
				// ignore
			} else {
				if( null == layerBoundingBox ) {
					layerBoundingBox = bounds;
				} else {
					if( layerBoundingBox[0] > bounds[0] ) layerBoundingBox[0] = bounds[0];
					if( layerBoundingBox[1] > bounds[1] ) layerBoundingBox[1] = bounds[1];
					if( layerBoundingBox[2] < bounds[2] ) layerBoundingBox[2] = bounds[2];
					if( layerBoundingBox[3] < bounds[3] ) layerBoundingBox[3] = bounds[3];
				};
			};
			testDone();
		};
		
		function testDone(){
			if( layersPending > 0 ){
				return;
			};
			
			// If nothing specified by layers, just use what the user specified
			if( null == layerBoundingBox ){
				// Nothing defined by the layers, use initial bounds
				opts.onSuccess(null);
				return;
			};
	
			// If computations from layers is invalid, use the initial bounds specified
			// by user
			if( false == _this._isValidBounds(layerBoundingBox) ) {
				$n2.log('Invalid bounding box reported for layer in database.',layerBoundingBox);
				opts.onSuccess(null);
				return;
			};
			
			// layerBoundingBox is in EPSG:4326
			// initialBounds is in the user coordinate projection
			var userInitialBounds = new OpenLayers.Bounds(
				initialBounds[0]
				,initialBounds[1]
				,initialBounds[2]
				,initialBounds[3]
			);
			var layerInitialBounds = new OpenLayers.Bounds(
				layerBoundingBox[0]
				,layerBoundingBox[1]
				,layerBoundingBox[2]
				,layerBoundingBox[3]
			);

			var dbProj = new OpenLayers.Projection('EPSG:4326');
			layerInitialBounds.transform(dbProj,coordinateProjection);
			
			if( userInitialBounds.containsBounds(layerInitialBounds) ){
				// Bounds defined by layers fit within the one specified by user.
				// Just use initial bounds (prevent too much zooming in)
				opts.onSuccess(initialBounds);
				
			} else if( layerInitialBounds.getWidth() < userInitialBounds.getWidth() 
			 || layerInitialBounds.getHeight() < userInitialBounds.getHeight() ){
				// The bounds defined by the layers are smaller than that of the bounds
				// specified by user. Adjust size of bounds so that zoom is not too high
				
				if( layerInitialBounds.getWidth() < userInitialBounds.getWidth() ){
					var l = userInitialBounds.getWidth()/2;
					var m = (layerInitialBounds.left+layerInitialBounds.right)/2;
					layerInitialBounds.left = m - l;
					layerInitialBounds.right = m + l;
				};
				
				if( layerInitialBounds.getHeight() < userInitialBounds.getHeight() ){
					var l = userInitialBounds.getHeight()/2;
					var m = (layerInitialBounds.bottom+layerInitialBounds.top)/2;
					layerInitialBounds.bottom = m - l;
					layerInitialBounds.top = m + l;
				};
				opts.onSuccess([
					layerInitialBounds.left
					,layerInitialBounds.bottom
					,layerInitialBounds.right
					,layerInitialBounds.top
				]);
				
			} else {
				// Use bounds computed by layers
				opts.onSuccess([
					layerInitialBounds.left
					,layerInitialBounds.bottom
					,layerInitialBounds.right
					,layerInitialBounds.top
				]);
			};
		};
	},
	
	_isValidBounds: function(bounds){
		if( !bounds.length ) return false;
		if( bounds.length < 4 ) return false;
		
		if( bounds[0] < -180 || bounds[0] > 180 ) return false;
		if( bounds[2] < -180 || bounds[2] > 180 ) return false;
		if( bounds[1] < -90 || bounds[1] > 90 ) return false;
		if( bounds[3] < -90 || bounds[3] > 90 ) return false;
		
		return true;
	}
});

//--------------------------------------------------------------------------
// This instance computes the initial extent by looking up a number of layers 
// in the CouchDb database. The layers can be specified as an array or an option
// 'allLayers' can be specified to look them all up.
var MapAutoInitialBoundsCouchDbLayers = $n2.Class({

	atlasDesign: null,

	layerIds: null,
	
	allLayers: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			atlasDesign: null
			,layers: null
			,allLayers: null
		},opts_);
		
		var _this = this;
		
		this.atlasDesign = opts.atlasDesign;
		
		this.layerIds = [];
		if( $n2.isArray(opts.layers) ){
			opts.layers.forEach(function(layerId){
				if( typeof layerId === 'string' ){
					_this.layerIds.push(layerId);
				};
			});
		};
		
		this.allLayers = false;
		if( typeof opts.allLayers === 'boolean' ){
			this.allLayers = opts.allLayers;
		};
	},
	
	computeInitialBounds: function(opts_){
		var opts = $n2.extend({
			mapOptions: null
			,mapInfo: null
			,initialBounds: null
			,coordinateProjection: null
			,onSuccess: function(bounds){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;

		var mapOptions = opts.mapOptions;
		var initialBounds = opts.initialBounds;
		var documentSource = this.documentSource;
		var coordinateProjection = opts.coordinateProjection;
		
		// Query view to get bounding box
		var queryOpt = {
			viewName: 'geom-layer-bbox'
			,reduce: true
			,onSuccess: bboxLoaded
			,onError: opts.onError
		};
		
		if( this.allLayers ){
			// Do not specify anything
		} else {
			queryOpt.keys = [];
			queryOpt.group = true;
			this.layerIds.forEach(function(layerId){
				queryOpt.keys.push(layerId);
			});
		};
		
		this.atlasDesign.queryView(queryOpt);
		
		// This is called as a result of the query
		function bboxLoaded(rows){
			var layerBoundingBox = undefined;
			
			rows.forEach(function(row){
				var bounds = row.value;
				
				if( !bounds ) {
					// ignore
				} else if( false == _this._isValidBounds(bounds) ) {
					// ignore
				} else {
					if( !layerBoundingBox ) {
						layerBoundingBox = bounds;
					} else {
						if( layerBoundingBox[0] > bounds[0] ) layerBoundingBox[0] = bounds[0];
						if( layerBoundingBox[1] > bounds[1] ) layerBoundingBox[1] = bounds[1];
						if( layerBoundingBox[2] < bounds[2] ) layerBoundingBox[2] = bounds[2];
						if( layerBoundingBox[3] < bounds[3] ) layerBoundingBox[3] = bounds[3];
					};
				};
			});
			
			// If nothing specified by layers, just use what the user specified
			if( !layerBoundingBox ){
				// Nothing defined by the layers, use initial bounds
				opts.onSuccess(null);
				return;
			};
	
			// If computations from layers is invalid, use the initial bounds specified
			// by user
			if( !_this._isValidBounds(layerBoundingBox) ) {
				$n2.log('Invalid bounding box reported for layer in database.',layerBoundingBox);
				opts.onSuccess(null);
				return;
			};
			
			// layerBoundingBox is in EPSG:4326
			// initialBounds is in the user coordinate projection
			var userInitialBounds = new OpenLayers.Bounds(
				initialBounds[0]
				,initialBounds[1]
				,initialBounds[2]
				,initialBounds[3]
			);
			var layerInitialBounds = new OpenLayers.Bounds(
				layerBoundingBox[0]
				,layerBoundingBox[1]
				,layerBoundingBox[2]
				,layerBoundingBox[3]
			);

			var dbProj = new OpenLayers.Projection('EPSG:4326');
			layerInitialBounds.transform(dbProj,coordinateProjection);
			
			if( userInitialBounds.containsBounds(layerInitialBounds) ){
				// Bounds defined by layers fit within the one specified by user.
				// Just use initial bounds (prevent too much zooming in)
				opts.onSuccess(initialBounds);
				
			} else if( layerInitialBounds.getWidth() < userInitialBounds.getWidth() 
			 || layerInitialBounds.getHeight() < userInitialBounds.getHeight() ){
				// The bounds defined by the layers are smaller than that of the bounds
				// specified by user. Adjust size of bounds so that zoom is not too high
				
				if( layerInitialBounds.getWidth() < userInitialBounds.getWidth() ){
					var l = userInitialBounds.getWidth()/2;
					var m = (layerInitialBounds.left+layerInitialBounds.right)/2;
					layerInitialBounds.left = m - l;
					layerInitialBounds.right = m + l;
				};
				
				if( layerInitialBounds.getHeight() < userInitialBounds.getHeight() ){
					var l = userInitialBounds.getHeight()/2;
					var m = (layerInitialBounds.bottom+layerInitialBounds.top)/2;
					layerInitialBounds.bottom = m - l;
					layerInitialBounds.top = m + l;
				};
				opts.onSuccess([
					layerInitialBounds.left
					,layerInitialBounds.bottom
					,layerInitialBounds.right
					,layerInitialBounds.top
				]);
				
			} else {
				// Use bounds computed by layers
				opts.onSuccess([
					layerInitialBounds.left
					,layerInitialBounds.bottom
					,layerInitialBounds.right
					,layerInitialBounds.top
				]);
			};
		};
	},
	
	_isValidBounds: function(bounds){
		if( !bounds.length ) return false;
		if( bounds.length < 4 ) return false;
		
		if( bounds[0] < -180 || bounds[0] > 180 ) return false;
		if( bounds[2] < -180 || bounds[2] > 180 ) return false;
		if( bounds[1] < -90 || bounds[1] > 90 ) return false;
		if( bounds[3] < -90 || bounds[3] > 90 ) return false;
		
		return true;
	}
});

//--------------------------------------------------------------------------
// This instance computes the initial extent by looking up the position of
// the user based on what the browser returns for geolocation. Adjust centre
// of defined 
var MapAutoInitialBoundsCentreOnUserPosition = $n2.Class({

	adjustLatitude: null,
	
	adjustLongitude: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			adjustLatitude: true
			,adjustLongitude: true
			,_mapInfo: null
		},opts_);
		
		var _this = this;
		
		this.adjustLatitude = opts.adjustLatitude;
		this.adjustLongitude = opts.adjustLongitude;
	},
	
	computeInitialBounds: function(opts_){
		var opts = $n2.extend({
			mapOptions: null
			,mapInfo: null
			,initialBounds: null
			,coordinateProjection: null
			,onSuccess: function(bounds){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		// Check initial bounds
		if( $n2.isArray(opts.initialBounds) && opts.initialBounds.length >=4 ){
			// OK
		} else {
			$n2.logError("MapAutoInitialBoundsCentreOnUserPosition: Do not understand initial bounds", opts.initialBounds);
			opts.onSuccess(opts.initialBounds);
		};
		
		// Get user location
		if( typeof navigator !== 'undefined' ){
			if( navigator.geolocation 
			 && typeof navigator.geolocation.getCurrentPosition === 'function' ){
				navigator.geolocation.getCurrentPosition(
					function(position){
						//$n2.log("getCurrentPosition()",position);
						var myCurrentLoc;
						if( position && position.coords ){
							var lat = position.coords.latitude;
							var lng = position.coords.longitude;
							
							if( typeof lat === 'number' 
							 && typeof lng === 'number' ){
								myCurrentLoc = new OpenLayers.Geometry.Point(lng, lat);
							};
						};
						
						if( myCurrentLoc ){
							receivedCoords(myCurrentLoc);
						} else {
							$n2.logError("MapAutoInitialBoundsCentreOnUserPosition: error during getCurrentPosition(): do not understand", position);
							opts.onSuccess(opts.initialBounds);
						};
						
					},function(err){
						$n2.logError("MapAutoInitialBoundsCentreOnUserPosition: error during getCurrentPosition()",err);
						opts.onSuccess(opts.initialBounds);
					},{ // options
						
					}
				);
			} else {
				// No geolocation.getCurrentPosition()
				opts.onSuccess(opts.initialBounds);
			};
		} else {
			// No Navigator
			opts.onSuccess(opts.initialBounds);
		};
		
		function receivedCoords(myCurrentLoc){
			// The coordinates received from browser are lat/long (EPSG:4326)
			var browserProj = new OpenLayers.Projection('EPSG:4326');
			if( browserProj.getCode() !== opts.coordinateProjection.getCode() ){
				myCurrentLoc.transform(browserProj, opts.coordinateProjection);
			};
			
			var initialBounds = [
				opts.initialBounds[0]
				,opts.initialBounds[1]
				,opts.initialBounds[2]
				,opts.initialBounds[3]
			];
			
			if( _this.adjustLatitude ){
				var halfHeight = (1 * opts.initialBounds[3] - 1 * opts.initialBounds[1]) / 2;
				initialBounds[1] = myCurrentLoc.y - halfHeight;
				initialBounds[3] = myCurrentLoc.y + halfHeight;
			};

			if( _this.adjustLongitude ){
				var halfWidth = (1 * opts.initialBounds[2] - 1 * opts.initialBounds[0]) / 2;
				initialBounds[0] = myCurrentLoc.x - halfWidth;
				initialBounds[2] = myCurrentLoc.x + halfWidth;
			};
			
			opts.onSuccess(initialBounds);
		};
	}
});

//--------------------------------------------------------------------------
function getCurrentConfiguration(dispatcher){
	var config = undefined;
	
	if( dispatcher ){
		var m = {
			type: 'configurationGetCurrentSettings'
		};
		dispatcher.synchronousCall(DH,m);
		config = m.configuration;
	};

	return config;
};

//--------------------------------------------------------------------------
function handleInstanceCreate(m, addr, dispatcher){
	if( 'mapAutoInitialBoundsCouchDbOverlays' === m.instanceConfiguration.type ){
		var config = getCurrentConfiguration(dispatcher);
		
		var opts = $n2.extend({},m.instanceConfiguration);
		
		if( config ){
			opts.documentSource = config.documentSource;
		};
		
		m.instance = new MapAutoInitialBoundsCouchDbOverlays(opts);

	} else if( 'mapAutoInitialBoundsCouchDbLayers' === m.instanceConfiguration.type ){
		var config = getCurrentConfiguration(dispatcher);
		
		var opts = $n2.extend({},m.instanceConfiguration);
		
		if( config ){
			opts.atlasDesign = config.atlasDesign;
		};
		
		m.instance = new MapAutoInitialBoundsCouchDbLayers(opts);

	} else if( 'mapAutoInitialBoundsCentreOnUserPosition' === m.instanceConfiguration.type ){
		var opts = $n2.extend({},m.instanceConfiguration);
		
		m.instance = new MapAutoInitialBoundsCentreOnUserPosition(opts);
	};
};

//--------------------------------------------------------------------------
$n2.mapInitialBounds = {
	handleInstanceCreate: handleInstanceCreate
	,MapAutoInitialBoundsCouchDbOverlays: MapAutoInitialBoundsCouchDbOverlays
	,MapAutoInitialBoundsCouchDbLayers: MapAutoInitialBoundsCouchDbLayers
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.mapUtilities.js

/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH='n2.mapUtilities';

//=========================================================================
var MapClusterClickToZoom = $n2.Class('MapClusterClickToZoom',{

	customService: undefined,

	initialize: function(opts_){
		var opts = $n2.extend({
			customService: undefined
		},opts_);
		
		var _this = this;
	
		this.customService = opts.customService;
		
		if( this.customService ){
			this.customService.setOption('mapClusterClickCallback',$n2.mapAndControls.ZoomInClusterClickCallback);
		};
		
		$n2.log(this._classname, this);
	}
});

//=========================================================================
var MapClusterClickToMultiSelect = $n2.Class('MapClusterClickToMultiSelect',{

	customService: undefined,

	initialize: function(opts_){
		var opts = $n2.extend({
			customService: undefined
		},opts_);
		
		var _this = this;
	
		this.customService = opts.customService;
		
		if( this.customService ){
			this.customService.setOption('mapClusterClickCallback',$n2.mapAndControls.MultiSelectClusterClickCallback);
		};
		
		$n2.log(this._classname, this);
	}
});

//=========================================================================
var MapClusterClickHandler = $n2.Class('MapClusterClickHandler',{

	customService: undefined,

	minimumCountToZoom: undefined,

	minimumResolutionToZoom: undefined,

	initialize: function(opts_){
		var opts = $n2.extend({
			customService: undefined
			,minimumCountToZoom: 0
			,minimumResolutionToZoom: -1
		},opts_);
		
		var _this = this;
	
		this.customService = opts.customService;
		if( typeof opts.minimumCountToZoom === 'number' ){
			this.minimumCountToZoom = opts.minimumCountToZoom;
		} else {
			$n2.logError('MapClusterClickHandler: minimumCountToZoom must be a number');
		};
		if( typeof opts.minimumResolutionToZoom === 'number' ){
			this.minimumResolutionToZoom = opts.minimumResolutionToZoom;
		} else {
			$n2.logError('MapClusterClickHandler: minimumResolutionToZoom must be a number');
		};
		
		if( this.customService ){
			var f = function(feature, mapAndControls){
				_this._clusterClickCallback(feature, mapAndControls);
			};

			this.customService.setOption('mapClusterClickCallback',f);
		};
		
		$n2.log(this._classname, this);
	},

	_clusterClickCallback: function(feature, mapAndControls){
		var zoom = false;
		if( feature.cluster 
		 && feature.cluster.length >= this.minimumCountToZoom ) {
			zoom = true;
		};
		if( this.minimumResolutionToZoom > 0 ){
			var resolution = mapAndControls.getResolution();
			if( resolution <= this.minimumResolutionToZoom ){
				zoom = false;
			};
		};
		
		if( zoom ){
			$n2.mapAndControls.ZoomInClusterClickCallback(feature, mapAndControls);
		} else {
			$n2.mapAndControls.MultiSelectClusterClickCallback(feature, mapAndControls);
		};
	}
});

//=========================================================================
function HandleUtilityCreateRequests(m, addr, dispatcher){
	if( 'mapClusterClickToZoom' === m.utilityType ){
		var options = {};
		
		if( typeof m.utilityOptions === 'object' ){
			for(var key in m.utilityOptions){
				var value = m.utilityOptions[key];
				options[key] = value;
			};
		};
		
		if( m.config ){
			if( m.config.directory ){
				options.customService = m.config.directory.customService;
			};
		};
		
		new MapClusterClickToZoom(options);

		m.created = true;

	} else if( 'mapClusterClickToMultiSelect' === m.utilityType ){
		var options = {};
		
		if( typeof m.utilityOptions === 'object' ){
			for(var key in m.utilityOptions){
				var value = m.utilityOptions[key];
				options[key] = value;
			};
		};
		
		if( m.config ){
			if( m.config.directory ){
				options.customService = m.config.directory.customService;
			};
		};
		
		new MapClusterClickToMultiSelect(options);

		m.created = true;

	} else if( 'mapClusterClickHandler' === m.utilityType ){
		var options = {};
		
		if( typeof m.utilityOptions === 'object' ){
			for(var key in m.utilityOptions){
				var value = m.utilityOptions[key];
				options[key] = value;
			};
		};
		
		if( m.config ){
			if( m.config.directory ){
				options.customService = m.config.directory.customService;
			};
		};
		
		new MapClusterClickHandler(options);

		m.created = true;
	};
};

//=========================================================================
$n2.mapUtilities = {
	HandleUtilityCreateRequests: HandleUtilityCreateRequests
	,MapClusterClickToZoom: MapClusterClickToZoom
	,MapClusterClickToMultiSelect: MapClusterClickToMultiSelect
	,MapClusterClickHandler: MapClusterClickHandler
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/patcher.js

//-------------------------------------------------------------
// Javascript/Node.js JSON diffing/patching utility
//
// Author: Mikola Lysenko
//
// "patcher.js"
//
// License: BSD
//-------------------------------------------------------------

//node.js interoperability
if(typeof(exports) === "undefined") {
  var patcher = {};
}

(function(){


//-------------------------------------------------------------
// Helper function, clones an object doing a deep copy
//-------------------------------------------------------------
function clone(obj) {
  if(obj === null) {
    return null;
    
  } else if(typeof(obj) != "object") {
    return obj;
    
  } else if(obj instanceof Array) {
    var result = new Array(obj.length);
    for(var i=0; i<result.length; ++i) {
      result[i] = clone(obj[i]);
    }
    return result;
    
  } else {  
    var result = {}
    for(var i in obj) {
      result[i] = clone(obj[i]);
    }
    return result;
  }
}

//-------------------------------------------------------------
// Computes a patch between a pair of json objects
// Note that this assumes both prev and next are simple, acyclic
// dictionaries.  This does not support serializing functions.
//
//  prev - Object we are patching from
//  next - Object we are patching to
//  update_in_place - A flag, which if set updates prev to next
//
//  Returns:
//    1. A patch object if there are any differences, or
//    2. null if the objects are equal.
//-------------------------------------------------------------
function computePatch(prev, next, update_in_place) {
  var updates = { }, has_updates = false;
  
  //Checks if an element common to prev and next 
  var processElement = function(id) {
  
    //Add _ to escape ids which start with _
    var target_id = (typeof(id) == "string" && id.charAt(0) == "_" ? "_" + id : id);
    if( typeof(target_id) === 'number' ){
    	target_id = '_'+target_id;
    };
    
    //First, check if the element exists and types match
    if(id in prev && typeof(prev[id]) == typeof(next[id])) {
    
      if(typeof(next[id]) == "object" && (prev[id] instanceof Array) == (next[id] instanceof Array) ) {
      
        //Object case
        var res = computePatch(prev[id], next[id], update_in_place);
        if(res !== null) {
          has_updates = true;
          updates[target_id] = res;
        }
        return;
      }
      else if(prev[id] === next[id]) {
      
        //P.O.D. case
        return;
      }
    }
    
    //Add to update list
    has_updates = true;
    updates[target_id] = clone(next[id]);
    
    if(update_in_place) {
      prev[id] = updates[target_id];
    }
  };
  
  //Two cases to deal with for plain old javascript objects:
  if(next instanceof Array) {
    //Case 1: Arrays
    if(prev.length != next.length) {
      if(update_in_place) {
        prev.length = next.length;
      }
      has_updates = true;
      updates["_r"] = next.length;
    }
    for(var i=next.length-1; i>=0; --i) {
      processElement(i);
    }
    
  } else {
    //Case 2: Objects
    var removals = [];
    for(var i in prev) {
      if(!(i in next)) {
        removals.push(i);
      }
    }
    if(removals.length > 0) {
      has_updates = true;
      updates["_r"] = (removals.length == 1 ? removals[0] : removals);
      
      if(update_in_place) {
        for(var i=removals.length-1; i>=0; --i) {
          delete prev[removals[i]];
        }
      }
    }
    for(var i in next) {
      processElement(i);
    }
  }
  
  if(has_updates) {
    return updates;
  }
  return null;
};


//-------------------------------------------------------------
// Applies a patch to an object
//-------------------------------------------------------------
function applyPatch(obj, patch) {
  var i;
  if("_r" in patch) {
    if(obj instanceof Array) {
      obj.length = patch["_r"];
    }
    else {
      var removals = patch["_r"];
      
      if(removals instanceof Array) {
        for(i=0; i<removals.length; ++i) {
          delete obj[removals[i]];
        }
      } else {
        delete obj[removals];
      }
    }
    delete patch["_r"];
  }
  
  for(i in patch) {
    //Unescape underscore
    //var t = (typeof(i) == "string" && i.charAt(0) == "_" ? i.substring(1) : i);
	if( typeof(i) === 'string' 
     && i.length > 1 
     && i.charAt(0) == '_' 
     && i.charAt(1) == '_'  ) {
      // string staring with _ which is escaped
      var t = i.substring(1);
      
    } else if( typeof(i) === 'string' 
        && i.length > 0
        && i.charAt(0) == '_'  ) {
      // escaped index
      t = 1 * i.substring(1);
      
    } else {
      t = i;
    };
    
    if(typeof(obj[t]) == typeof(patch[i]) &&
      typeof(patch[i]) == "object" &&
      patch[i] != null ) {
      if( (obj[t] instanceof Array) == (patch[i] instanceof Array) ) {
        applyPatch(obj[t], patch[i]);
        continue;
      } else if( (obj[t] instanceof Array) && false == (patch[i] instanceof Array) ) {
        applyPatch(obj[t], patch[i]);
        continue;
      };
    }
    obj[t] = patch[i]
  }
};


//Add methods to patcher
if(typeof(exports) === "undefined") {
  patcher.computePatch = computePatch;
  patcher.applyPatch   = applyPatch;
} else {
  exports.computePatch = computePatch;
  exports.applyPatch   = applyPatch;
}

})();


// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.GeoJsonGeometryCompressor.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

	var DEFAULT_PRECISION = 0.00001;
	var MIN_POSITIONS_LINEAR_RING = 4;
	var MIN_POSITIONS_LINE_STRING = 2;
	
	/**
	 * @param ca coordinate array.  Note this is not what is called 'coordinates' in GeoJSON
	 *           because that is a misnomer, except in the case of Point and Multipoint.
	 *           That is an array of positions (the GeoJSON spec explains
	 *           it correctly but the explanation is not consistent with the naming in the structures).
	 *           This IS the array of coordinates for a single position.
	 * @return recomputed array of position coordinates or null if ca is not an array
	 */
	function compressCoordinateArray(ca, precision, sigDecimals) {
		function compressCoordinate(c) {
			/*
			 * If you have negative values, floor() makes it absolutely larger.
			 * Reverse case for positives.  So I'm going to round.
			 */
			var temp = Math.round(c / precision) * precision;
			
			/*
			 * the above works and is pretty fast but leaves rounding errors in the
			 * binary representation that then need clean-up code.  
			 * 
			 * Note: the above computation is still needed because for precisions > 1.0,
			 * the sigDecimals are still no less than 0 (can't be...) and the above 
			 * ensures that the rounding is done properly according to precision.
			 */
			var str = temp.toFixed(sigDecimals); // toss rounding error digits
			return parseFloat(str);
		};
		
		/*
		 * Only need 2-d coordinates now but handle more for future
		 */
		var out = [];
		for (var i=0, len=ca.length; i < len; i++) {
			out[i] = compressCoordinate(ca[i]);
		};
		return out;
	};
	
	function computeSignificantDecimalDigits(precision) {
		/*
		 * precision is greater than 1 => no digits after the decimal needed
		 */
		var sigDecimals = 0;
		if (precision < 1.0) {
			for (var temp = precision; temp < 1.0; temp *= 10, sigDecimals++) {
				// do nothing
			};
		};
		return sigDecimals;
	};
	
	var defaultOptions_GJCC = {
		precision: DEFAULT_PRECISION, // difference comparison threshold; <> 0

		/*
		 * Default behaviour is to treat a coordinates array as representing the 
		 * positions in a linestring.  The following booleans adjust this 
		 * behaviour.
		 * ! isLinearRing && ! isPoint => linestring
		 * ! isLinearRing && isPoint   => point
		 * isLinearRing && ! isPoint   => linearring
		 */
		
		// if true, 1st and last point are identical and there must be at least four positions
		isLinearRing: false,
		
		// if true, coordinates are intended to represent a point
		isPoint: false,
		
		// if true, the inner rings are dropped from multipolygons and polygons.
		dropInnerRings: false
	};
	$n2.GeoJsonCoordinatesCompressor = $n2.Class({
		/*
		 * Object to scan the coordinates for a linear set of positions
		 * and simplify it to ensure that positions
		 * are distinct when compared using the configured precision.
		 * 
		 * Adjusting the precision of a point geometry is handled as a special case.
		 */
		options: null,	
				
		significantDigits: null,
			
		initialize: function(/* ... variable argument list ... */) { // duplicates? - rightmost take precedence
			this.options = $n2.extend({}, defaultOptions_GJCC);
			for (var i=0; i < arguments.length; i++) { // update o with properties from objects in variable arg list.
				var o = arguments[i];
				if ($n2.isDefined(o)) {
					this.options = $n2.extend(true, this.options, o);
				};
			};
			
			/*
			 * If precision makes no sense, revert to default.
			 */
			if (0.0 === this.options.precision) {
				this.options.precision = DEFAULT_PRECISION;
			};
			this.significantDigits = computeSignificantDecimalDigits(this.options.precision);
		},
		
		/**
		 * @param coordinates array of coordinate pairs, each an array, to be compressed
		 * @return compressed array of coordinates or null if precision-adjustment geometry
		 * is insignificant.
		 */
		compress: function(coordinates) {
			if (this.options.isPoint) {
				return compressCoordinateArray(coordinates, this.options.precision, this.significantDigits);
			};
			
			/*
			 * Except in the point case handled above, all coordinate arrays are misnamed position arrays.
			 * For all remaining cases, the elements of coordinates must be arrays.  Check only the first
			 * and simply return the input coordinates array if it is not an array.  Probably a Point being
			 * processed without configuring the options properly to deal with that.
			 * 
			 * Better to just keep the existing precision of the point than to mangle the coordinates in the
			 * following code that expects arrays.
			 * 
			 * Only check the first array element for efficiency.
			 */
			if (! $n2.isArray(coordinates[0])) {
				return coordinates;
			};
			
			var out = [];
			var last = compressCoordinateArray(coordinates[0], this.options.precision, this.significantDigits);
			out.push(last); // 1st position
			
			for (var i=1, len=coordinates.length - 1; i < len; i++) {
				var curr = compressCoordinateArray(coordinates[i], this.options.precision, this.significantDigits);
				if (last[0] !== curr[0] ||
					last[1] !== curr[1]) {
					out.push(curr);
					last = curr;
				};
			};
			out.push(compressCoordinateArray(coordinates[len], this.options.precision, this.significantDigits));
			
			// sanity check
			if (this.options.isLinearRing && MIN_POSITIONS_LINEAR_RING > out.length) {
				return null; // return null - zero area ring
			} else if (MIN_POSITIONS_LINE_STRING > out.length) {
				return null; // return null - zero length 
			};
			
			return out;
		}
	});

	/**
	 * class-level utility functions for $n2.GeoJsonFeatureCoordinatesProcessor
	 */
	function initialStatus() {
		return {
			original: { linestrings: 0, positions: 0 },
			processed: { linestrings: 0, positions: 0 }
		};
	};
	
	/**
	 * @param accumulate accumulating status structure
	 * @param update the result status
	 */
	function accumulateStatus(accumulate, update) {
		accumulate.original.positions += update.original.positions;
		accumulate.original.linestrings += update.original.linestrings;
		accumulate.processed.positions += update.processed.positions;
		accumulate.processed.linestrings += update.processed.linestrings;
	};

	/**
	 * @param accumulate accumulating status structure
	 * @param inData the original unprocessed data
	 * @param update the result of processing (data and status)
	 * The original unprocessed data and the processed data are passed in
	 * to allow comparisons of the results of processing (e.g., size of
	 * coordinates arrays) to be included in the status info.
	 */
	function computeStatus(accumulate, inData, update) {
		function isPointCase(coords) {
			/*
			 * for point and multipoint, processing occurs on 1-d arrays of
			 * coordinates.  For other cases, processing occurs on 2-d arrays
			 * of positions (n-dim coordinate vectors).
			 */
			if (! $n2.isArray(coords[0])) {
				return true;
			};
			return false;
		};
		
		/*
		 * compare length of in to out coordinate arrays.
		 */
		var inLength, outLength;
		if (isPointCase(inData)) {
			// point counts as 1 position, regardless length of coordinate array
			inLength = 1;
			if ($n2.isDefined(update)) {
				outLength = 1;
			} else {
				outLength = 0;
			};
		} else {
			inLength = inData.length;
			if ($n2.isDefined(update)) {
				outLength = update.length
			} else {
				outLength = 0;
			};					
		};

		accumulate.original.positions += inLength; // number positions
		accumulate.original.linestrings += 1; // one linestring
		accumulate.processed.positions += outLength; // number positions
		if (outLength > 0) {
			accumulate.processed.linestrings += 1; // one linestring
		};
	};
	
	var defaultOptions_GJGC = {
		precision: DEFAULT_PRECISION // difference comparison threshold; <> 0
	};
	$n2.GeoJsonGeometryCompressor = $n2.Class({
		/*
		 * Object to scan the coordinates for all linestrings and positions in 
		 * a GeoJSON feature representation and simplify them to ensure that
		 * positions within each are distinct when compared using the
		 * configured precision.
		 * 
		 * Adjusting the precision of point geometries is handled as a special case.
		 */
		options: null,
		
		/*
		 * compressors for linestring, point, and linearRings
		 */
		linestringCoordCompressor: null,
		pointCoordCompressor: null,
		linearRingCoordCompressor: null,
					
		/*
		 * utility functions for $n2.GeoJsonFeatureCoordinatesProcessor
		 */
		coordinateProcessors: null,

		/*
		 * the coordinate processor
		 */
		featureProcessor: null,

		initialize: function(/* ... variable argument list ... */) { // duplicates? - rightmost take precedence
			this.options = $n2.extend({}, defaultOptions_GJGC);
			for (var i=0; i < arguments.length; i++) { // update o with properties from objects in variable arg list.
				var o = arguments[i];
				if ($n2.isDefined(o)) {
					this.options = $n2.extend(true, this.options, o);
				};
			};

			/*
			 * If precision makes no sense, revert to default.
			 */
			if (0.0 === this.options.precision) {
				this.options.precision = DEFAULT_PRECISION;
			};

			/*
			 * create the coordinate array processors
			 */
			this.linestringCoordCompressor = new $n2.GeoJsonCoordinatesCompressor({
				precision: this.options.precision
			});
			this.pointCoordCompressor = new $n2.GeoJsonCoordinatesCompressor({
				precision: this.options.precision,
				isPoint: true
			});
			this.linearRingCoordCompressor = new $n2.GeoJsonCoordinatesCompressor({
				precision: this.options.precision,
				isLinearRing: true
			});

			/*
			 * encapsulate the processor functions to resolve 'this'.
			 */
			function createCoordinateProcessors(that) {
				that.coordinateProcessors = {
					'point': function(coordinates, context) { 
						return that.pointCoordCompressor.compress(coordinates);
					},
					'multipoint': function(coordinates, context) { 
						return that.pointCoordCompressor.compress(coordinates);
					},
					'linestring': function(coordinates, context) { 
						return that.linestringCoordCompressor.compress(coordinates);
					},
					'multilinestring': function(coordinates, context) { 
						return that.linestringCoordCompressor.compress(coordinates);
					},
					'polygon': function(coordinates, context) { 
						if (that.options.dropInnerRings && 
								0 !== context[context.length-1]) {
							return null;
						};
						return that.linearRingCoordCompressor.compress(coordinates);
					},
					'multipolygon': function(coordinates, context) { 
						if (that.options.dropInnerRings && 
								0 !== context[context.length-1]) {
							return null;
						};
						return that.linearRingCoordCompressor.compress(coordinates);
					}
				};
			};
			createCoordinateProcessors(this);
			
			/*
			 * create the feature coordinate processor
			 */
			this.featureProcessor = new $n2.GeoJsonFeatureCoordinatesProcessor({
				coordinateProcessors: this.coordinateProcessors,
				initialStatus: initialStatus,
				computeStatus: computeStatus,
				accumulateStatus: accumulateStatus
			});
		},
		
		/**
		 * @param feature object with structure corresponding to a GeoJSON
		 *		feature.
		 * @return an object encapsulating the object representing the 
		 * processed feature and the status of the operation performed.
		 */
		compressFeature: function(feature) {
			var out = this.featureProcessor.process.feature(feature);
			return out;
		}
	});

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.GeoJsonFeatureCoordinatesProcessor.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2){
"use strict";

	function wrapGeoOutput(type, data, status) {
		var d;
		if (null === data) {
			d = null;
		} else {
			d = {
				'type': type,
				'coordinates': data
			};
		};
		
		return {
			data: d,
			status: status 
		};
	};

	var defaultOptions = {
		coordinateProcessors: {
			/*
			 * Note that each of these returns only the processed coordinates
			 * for the geometry, or null if none to return.
			 * 
			 * default: just return the coordinates unchanged.
			 */
			'point': function(coordinates) { 
				return coordinates; 
			},
			'multipoint': function(coordinates) { 
				return coordinates; 
			},
			'linestring': function(coordinates) { 
				return coordinates; 
			},
			'multilinestring': function(coordinates) { 
				return coordinates; 
			},
			'polygon': function(coordinates) { 
				return coordinates; 
			},
			'multipolygon': function(coordinates) { 
				return coordinates; 
			}
		},
		
		/**
		 * Return the data structure needed for status tracking of the processing to 
		 * be performed.
		 */
		'initialStatus': function() {
			return null;
		},
		
		/**
		 * Compute the status for a processing step performed on a 'simple' geometry
		 * (i.e., those other than the feature itself and a geometrycollection).
		 * 
		 * @param accumulate accumulating status structure
		 * @param inData the original unprocessed data
		 * @param update the result of processing (data and status)
		 * The original unprocessed data and the processed data are passed in
		 * to allow comparisons of the results of processing (e.g., size of
		 * coordinates arrays) to be included in the status info.
		 */
		'computeStatus': function(accumulate, inData, update) {
			// do nothing
		},
		
		/**
		 * Accumulate the status for a set of processed geometries.  This is required 
		 * with geometrycollections and could be, but is not currently used with features
		 * (there a simple assignment is currently used since it would only be done once).
		 * 
		 * @param accumulate accumulating status structure
		 * @param update the result status
		 */
		'accumulateStatus': function(accumulate, update) {
			// do nothing
		},
		
		/**
		 * return an initial context structure.
		 */
		"initialContext": function() {
			return [ ];
		},
		
		/**
		 * @param context context information showing what IS being processed.  Context accumulates
		 * down (geometryCollection, coordinates) and laterally (geometries, across coordinate arrays).
		 * @param direction'down' or 'lateral'
		 * Note that 'down" adjustments are mutable (the original will be unchanged) but lateral
		 * adjustments update the input context.
		 */
		"adjustContext": function(context, direction) {
			var temp;
			if ('down' === direction) {
				// copy array add a new element
				temp = context.slice(0);
				temp.push( 0 );
			} else {
				context[context.length - 1] += 1; // increment last element
				temp = context;
			};
			return temp;
		}
	};
	$n2.GeoJsonFeatureCoordinatesProcessor = $n2.Class({
		/*
		 * Object to scan the coordinates for all linestrings and positions in 
		 * a GeoJSON feature representation and perform configured functions on
		 * each, accumulating status and data concerning the function performed
		 * at the level of the feature.
		 * 
		 * A replicate/modified feature and the stats computed are returned.
		 * 
		 * Handling point geometry is handled as a special case.
		 */
		options: null,	
					
		/*
		 * Object with properties corresponding to the GeoJSON types encapsulated 
		 * within a feature.  Each is a function that invokes processing on the 
		 * corresponding object type and returns data and status information
		 * specific to that processing.
		 * 
		 * Idea for general structuring approach borrowed from 
		 * OpenLayers.Format.GeoJSON.extract.
		 * 
		 * Contained functions are initialized below to get instance initialization correct.  
		 * See use of this.
		 */
		process: {},

		initialize: function(/* ... variable argument list ... */) { // duplicates? - rightmost take precedence
			this.options = $n2.extend({}, defaultOptions);
			for (var i=0; i < arguments.length; i++) { // update o with properties from objects in variable arg list.
				var o = arguments[i];
				if ($n2.isDefined(o)) {
					this.options = $n2.extend(true, this.options, o);
				};
			};
			
			/*
			 * NOW INITIALIZE ALL OF THE FUNCTIONS MAINTAINED IN this.process
			 */
			var that = this;
			
			/**
			 * @param feature object with structure corresponding to a GeoJSON
			 *		feature.
			 * @return an object encapsulating the object representing the 
			 * processed feature and the status of the operation performed.
			 */
			this.process.feature = function(feature) {
				if (null === feature) {
					return null;
				};
				
				var context = that.options.initialContext();
				
				var out = { data: {}, status: null };
				for (var p in feature) {
					if (feature.hasOwnProperty(p)) {
						if ('geometry' == p) {
							var geometryType = feature[p].type;
							var geo = that.process[geometryType.toLowerCase()].apply(
								that, [feature[p], that.options.adjustContext(context, 'down')]);
							if (! $n2.isDefined(geo) || ! $n2.isDefined(geo.data)) {
								// processing eliminated geometry - drop feature....
								out.data = null;
							} else {
								out.data[p] = geo.data;
							};
							out.status = geo.status; // don't accumulate here - just retain
						} else {
							if ($n2.isDefined(out.data)) {
								out.data[p] = feature[p];
							};
						};
					};
				};
				
				return out;
			};

			/**
			 * @param point object with structure corresponding to a GeoJSON
			 *		point.
			 * @return an object encapsulating the object representing the 
			 * processed point and the status of the operation performed.
			 */
			this.process.point = function(point, context) {
				if (null === point) {
					return null;
				};

				var out = { data: [], status: that.options.initialStatus() };
				var p = that.options.coordinateProcessors.point(point.coordinates, context);
				that.options.computeStatus(out.status, point.coordinates, p);

				return wrapGeoOutput(point.type, p, out.status);
			};

			/**
			 * @param multipoint object with structure corresponding to a GeoJSON
			 *		multipoint.
			 * @return an object encapsulating the object representing the 
			 * processed multipoint and the status of the operation performed.
			 */
			this.process.multipoint = function(multipoint, context) {
				if (null === multipoint) {
					return null;
				};
				
				var out = { data: [], status: that.options.initialStatus() };
				for (var i=0, len=multipoint.coordinates.length; i<len; ++i) {
					var p = that.options.coordinateProcessors.multipoint(multipoint.coordinates[i], context);
					if ($n2.isDefined(p)) {
						out.data.push(p);
					};
					that.options.computeStatus(
							out.status, multipoint.coordinates[i], p);
					that.options.adjustContext(context, 'lateral');
				};
				
				if (0 === out.data.length) {
					out.data = null;
				};
				
				return wrapGeoOutput(multipoint.type, out.data, out.status);
			};
			
			/**
			 * @param linestring object with structure corresponding to a GeoJSON
			 *		linestring.
			 * @return an object encapsulating the object representing the 
			 * processed linestring and the status of the operation performed.
			 */
			this.process.linestring = function(linestring, context) {
				if (null === linestring) {
					return null;
				};

				var out = { data: [], status: that.options.initialStatus() };
				var s = that.options.coordinateProcessors.linestring(linestring.coordinates, context);
				that.options.computeStatus(
						out.status, linestring.coordinates, s);

				return wrapGeoOutput(linestring.type, s, out.status);
			};

			/**
			 * @param multilinestring object with structure corresponding to a GeoJSON
			 *		multilinestring.
			 * @return an object encapsulating the object representing the 
			 * processed multilinestring and the status of the operation performed.
			 */
			this.process.multilinestring = function(multilinestring, context) {
				if (null === multilinestring) {
					return null;
				};

				var out = { data: [], status: that.options.initialStatus() };
				for (var i=0, len=multilinestring.coordinates.length; i<len; ++i) {
					var s = that.options.coordinateProcessors.multilinestring(multilinestring.coordinates[i], context);
					if ($n2.isDefined(s)) {
						out.data.push(s);
					};
					that.options.computeStatus(
							out.status, multilinestring.coordinates[i], s);
					that.options.adjustContext(context, 'lateral');
				};
				
				if (0 === out.data.length) {
					out.data = null;
				};
				
				return wrapGeoOutput(multilinestring.type, out.data, out.status);
			};
			
			/**
			 * @param polygon object with structure corresponding to a GeoJSON
			 *		polygon.
			 * @return an object encapsulating the object representing the 
			 * processed polygon and the status of the operation performed.
			 */
			this.process.polygon = function(polygon, context) {
				if (null === polygon) {
					return null;
				};

				var out = { data: [], status: that.options.initialStatus() };
				for (var i=0, len=polygon.coordinates.length; i<len; ++i) {
					var p = that.options.coordinateProcessors.polygon(polygon.coordinates[i], context);
					if ($n2.isDefined(p)) {
						out.data.push(p);
					};
					that.options.computeStatus(
							out.status, polygon.coordinates[i], p);
					that.options.adjustContext(context, 'lateral');
				};

				if (0 === out.data.length) {
					out.data = null;
				};
				
				return wrapGeoOutput(polygon.type, out.data, out.status);
			};

			/**
			 * @param multipolygon object with structure corresponding to a GeoJSON
			 *		multipolygon.
			 * @return an object encapsulating the object representing the 
			 * processed multipolygon and the status of the operation performed.
			 */
			this.process.multipolygon = function(multipolygon, context) {
				if (null === multipolygon) {
					return null;
				};

				var out = { data: [], status: that.options.initialStatus() };

				for (var i=0, len=multipolygon.coordinates.length; i<len; ++i) {
					var data2 = [];
					var ctxt = that.options.adjustContext(context, 'down');
					
					for (var j=0, len2=multipolygon.coordinates[i].length; j < len2; j++) {
						var p = that.options.coordinateProcessors.multipolygon(multipolygon.coordinates[i][j], ctxt);
						if ($n2.isDefined(p)) {
							data2.push(p);
						};
						that.options.computeStatus(
								out.status, multipolygon.coordinates[i][j], p);
						that.options.adjustContext(ctxt, 'lateral');
					};
					
					if (0 !== data2.length) {
						out.data.push(data2);
					};
					
					that.options.adjustContext(context, 'lateral');
				};
				
				if (0 === out.data.length) {
					out.data = null;
				};
				
				return wrapGeoOutput(multipolygon.type, out.data, out.status);
			};
			
			/**
			 * @param geometrycollection object with structure corresponding to a GeoJSON
			 *		geometrycollection.
			 * @return an object encapsulating the object representing the 
			 * processed geometrycollection and the status of the operation performed.
			 */
			this.process.geometrycollection = function(geometrycollection, context) {
				if (null === geometrycollection) {
					return null;
				};
				
				var out = { data: [], status: that.options.initialStatus() };

				for (var i=0, len=geometrycollection.geometries.length; i<len; i++) {
					var geometryType = geometrycollection.geometries[i].type;
					var geo = that.process[geometryType.toLowerCase()].apply(
						that, 
						[geometrycollection.geometries[i], that.options.adjustContext(context, 'down')]);
					if ($n2.isDefined(geo) && $n2.isDefined(geo.data)) {
						out.data.push(geo.data);
					};
					
					// note special case of null inData for this case
					that.options.accumulateStatus(out.status, geo.status);
					that.options.adjustContext(context, 'lateral');
				};
				
				/*
				 * wrapping this here allows for recursive geometrycollections which,
				 * the way I read the spec, are allowed.
				 */ 
				var d;
				if (0 === out.data.length) {
					d = null;
				} else {
					d = { 
						"type": geometrycollection.type,
						"geometries": out.data
					};
				};
				
				return {
					data: d,
					status: out.status
				};
			};
		}
	});

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.languageSupport.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

var DH = 'n2.languageSupport';

var DEFAULT_LANGUAGES = [
	 {
		 code: 'en'
		 ,name: 'English'
	 }
	 ,{
		 code: 'fr'
		 ,name: 'Français'
	 }
];

var g_LanguageService = undefined;

/*
 * ======================================================
 * HTML Language Switching Widget
 */
var LanguageSwitcher = $n2.Class({
	
	elemId: null,
	
	dispatcher: null,
	
	languages: null,
	
	languageService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,elemId: null
			,dispatcher: null
			,languages: null
			,languageService: null
		},opts_);

		// Get element id
		this.elemId = opts.elemId;
		if( opts.elem ){
			var $elem = $(opts.elem);
			var id = $elem.attr('id');
			if( !id ){
				id = $n2.getUniqueId();
				$elem.attr('id',id);
			};
			this.elemId = id;
		};
		
		this.dispatcher = opts.dispatcher;
		this.languages = opts.languages;
		this.languageService = opts.languageService;
		
		this._display();
	},

	_getLanguages: function(){
		if( this.languageService ){
			return this.languageService.getLanguages();
		};
		
		if( this.languages ){
			return this.languages;
		};
		
		return DEFAULT_LANGUAGES;
	},

	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_display: function(){
		var _this = this;
		
		var $elem = this._getElem();
		
		$elem.empty();
		
		$('<a>')
			.text( _loc('Language') )
			.attr('href','#')
			.appendTo($elem)
			.click(function(){
				_this._dialog();
				return false;
			});
	},
	
	_dialog: function(){
		var _this = this;
		
		var diagId = $n2.getUniqueId();
		var $langDialog = $('<div id="'+diagId+'" class="n2lang_langSelect_dialog"></div>');

		var $langList = $('<div class="n2lang_langSelect_list"></div>')
			.appendTo($langDialog);
		
		var onChange = function(e){
			var $input = $(this);
			if( $input.is(':checked') ){
				var code = $input.attr('n2Code');
				_this._selectLanguage(code);
				$('#'+diagId).dialog('close');
			};
			return false;
		};
		
		var languages = this._getLanguages();
		for(var i=0,e=languages.length;i<e;++i){
			var l = languages[i];
			addLanguage($langList, l.name, l.code);
		};

		addLanguage($langList, _loc('Default'), null);

		var dialogOptions = {
			autoOpen: true
			,title: _loc('Select Language')
			,modal: true
			,width: 740
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$langDialog.dialog(dialogOptions);
		
		function addLanguage($list, name, code){
			var $div = $('<div/>').appendTo($list);
			var id = $n2.getUniqueId();
			var $input = $('<input type="radio" name="languageSelect"/>')
				.attr('id',id)
				.appendTo($div)
				.change(onChange);
			
			if( code ){
				$input.attr('n2Code',code);
			};
			
			var locale = $n2.l10n.getLocale();
			if( locale.lang === code ){
				$input.attr('checked', 'checked');
			};
			
			$('<label/>')
				.attr('for',id)
				.text(name)
				.appendTo($div);
		};
	},
	
	_selectLanguage: function(code){
		if( this.dispatcher ){
			this.dispatcher.send(DH,{
				type: 'languageSelect'
				,lang: code
			});
		};
	}
});

/*
 * ======================================================
 * HTML Language Toggle Widget
 */
var LanguageToggler = $n2.Class({
	
	elemId: null,
	
	dispatcher: null,
	
	languages: null,
	
	languageService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,elemId: null
			,dispatcher: null
			,languages: null
			,languageService: null
		},opts_);

		// Get element id
		this.elemId = opts.elemId;
		if( opts.elem ){
			var $elem = $(opts.elem);
			var id = $elem.attr('id');
			if( !id ){
				id = $n2.getUniqueId();
				$elem.attr('id',id);
			};
			this.elemId = id;
		};
		
		this.dispatcher = opts.dispatcher;
		this.languages = opts.languages;
		this.languageService = opts.languageService;
		
		this._display();
	},

	_getLanguages: function(){
		if( this.languageService ){
			return this.languageService.getLanguages();
		};
		
		if( this.languages ){
			return this.languages;
		};
		
		return DEFAULT_LANGUAGES;
	},

	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_display: function(){
		var _this = this;
		
		var $elem = this._getElem();
		
		$elem.empty();
		
		var language = this._pickLanguageToDisplay();
		if( language ){
			$('<a>')
				.text( language.name )
				.attr('href','#')
				.appendTo($elem)
				.click(function(){
					_this._selectLanguage(language.code);
					return false;
				});
		};
	},
	
	_pickLanguageToDisplay: function(){
		var locale = $n2.l10n.getLocale();
		
		var lang = null;
		if( locale ){
			lang = locale.lang;
		};
		
		var languages = this._getLanguages();
		for(var i=0,e=languages.length;i<e;++i){
			var l = languages[i];
			if( l.code !== lang ){
				return l;
			};
		};
		
		return null;
	},
	
	_selectLanguage: function(code){
		if( this.dispatcher ){
			this.dispatcher.send(DH,{
				type: 'languageSelect'
				,lang: code
			});
		};
	}
});

/*
 * ======================================================
 * Language Service
 */
var LanguageService = $n2.Class({
	
	dispatcher: null,
	
	languages: null,
	
	useToggleWidget: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			directory: null
			,languages: null
		},opts_);

		var _this = this;
		
		// Save in global variable
		g_LanguageService = this;
		
		if( opts.directory ){
			this.dispatcher = opts.directory.dispatchService;
		};
		
		this.languages = opts.languages;
		if( !this.languages ){
			this.languages = DEFAULT_LANGUAGES.slice(0);
		};
		
		this.useToggleWidget = false;
		
		var d = this.dispatcher;
		if( d ){
			var f = function(m){
				_this._handle(m);
			};
			d.register(DH,'languageSelect',f);
		};
	},

	getLanguages: function(){
		return this.languages;
	},
	
	addLanguage: function(language){
		if( language.name && language.code ){
			this.languages.push(language);
		};
	},
	
	setUseToggleWidget: function(f){
		this.useToggleWidget = f;
	},

	drawWidget: function(opts_){
		var opts = $n2.extend({
				elem: null
				,elemId: null
			}
			,opts_
			,{
				dispatcher: this.dispatcher
				,languageService: this
			}
		);
		
		if( this.useToggleWidget ) {
			return new LanguageToggler(opts);
		} else {
			return new LanguageSwitcher(opts);
		};
	},
	
	_send: function(msg){
		var d = this.dispatcher;
		if( d ){
			d.send(DH,msg);
		};
	},
	
	_handle: function(msg){
		if( 'languageSelect' === msg.type ){
			if( msg.lang ) {
				this._selectLanguage(msg.lang);
			} else {
				this._resetLanguage();
			};
		};
	},
	
	_selectLanguage: function(lang){
		// Set cookie
		$n2.cookie.setCookie({
			name: 'nunaliit-l10n'
			,value: lang
			,path: '/'
			// session cookie ,end: (60 * 60 * 24 * 90) // 90 days in seconds
		});
		
		// Reload page
		location.reload();
	},
	
	_resetLanguage: function(){
		// Remove cookie
		$n2.cookie.deleteCookie('nunaliit-l10n');
		
		// Reload page
		location.reload();
	}
});

/*
 * ======================================================
 * Function to retrieve languages currently in use
 */
function getLanguages(){
	if( g_LanguageService ){
		return g_LanguageService.getLanguages();
	};
	
	return DEFAULT_LANGUAGES;
};

/*
 * ======================================================
 * Exports
 */
$n2.languageSupport = {
	LanguageService: LanguageService
	,LanguageSwitcher: LanguageSwitcher
	,LanguageToggler: LanguageToggler
	,getLanguages: getLanguages
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.GeoNames.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

// ===================================
	
var FeatureClass = {
	ADMIN: 'A' // countries and states
	,HYDRO: 'H' // stream, lake
	,LANDMARKS: 'L' // park, area
	,PLACES: 'P' // city, village
	,ROADS: 'R' // road, railroad
	,SPOT: 'S' // spot, building, farm
	,MOUNTAINS: 'T' // mountain, hill, rock
	,UNDERSEA: 'U' // undersea
};

//===================================
var AutoComplete = $n2.Class({
	service: null,
	
	inputId: null,
	
	options: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			service: null
			,input: null
			,autocomplete: null
		},opts_);
		
		var _this = this;
		
		this.service = opts.service;
		
		var $input = null;
		if( typeof(opts.input) === 'string' ) {
			$input = $('#'+opts.input);
			this.inputId = opts.input;
		} else {
			$input = $(opts.input);
			var inputId = $input.attr('id');
			if( !inputId ){
				inputId = $n2.getUniqueId();
				$input.attr('id', inputId);
			};
			this.inputId = inputId;
		};
		
		// Request options
		this.options = {
			featureClass: $n2.GeoNames.FeatureClass.PLACES
			,maxRows: 12
		};
		for(var key in opts){
			if( 'service' === key ){
			} else if( 'input' === key ){
			} else if( 'autocomplete' === key ){
			} else {
				this.options[key] = opts[key];
			};
		};

		// Install autocomplete
		var autocompleteOptions = $n2.extend(
			{
				minLength: 3
			}
			,opts.autocomplete
			,{
				open: function() {
					$(this).removeClass("ui-corner-all").addClass("ui-corner-top");
				}
				,close: function() {
					$(this).removeClass("ui-corner-top").addClass("ui-corner-all");
				}
				,source: function(request, response) {
					_this._autocompleteSource(request, response);
				}
			}
		);
		
		$input = this.getInput();
		$input.autocomplete(autocompleteOptions);
	},

	getInput: function(){
		return $('#'+this.inputId);
	},
	
	_autocompleteSource: function(request, response) {
		if( request && request.term && request.term.length > 2 ) {
			var opts = $n2.extend({},this.options);
			
			opts.name = request.term;
			opts.onSuccess = function(results){
				var suggestions = [];
				var names = {};
				for(var i=0,e=results.length; i<e; ++i){
					var res = results[i];
					var name = res.name;
					if( !names[name] ) { // eliminate duplicates
						var obj = {
							label: res.name
							,value: res.name
						};
						suggestions[suggestions.length] = obj;
						names[name] = true;
					};
				};
				response(suggestions);
			};
			opts.onError = function(err){
				$n2.log('Error encountered during GeoService lookup: '+err,err);
				response([]);
			};
			
			this.service.getNameStartsWith(opts);
		};
	}
});
	
// ===================================
var GeoNameService = $n2.Class({
	options: null,
	
	initialize: function(opts_){
		this.options = $n2.extend({
			geoNamesUrl: 'http://api.geonames.org/'
			,username: 'nunaliit'
		},opts_);
	},

	getName: function(opts_){
		var opts = $n2.extend({
			name: null // must be provided
			,featureClass: null
			,maxRows: null
			,country: null
			,countryBias: null
			,style: null
			,onSuccess: function(results){}
			,onError: function(err){}
		},opts_);
		
		var data = {
			name: opts.name	
		};
		
		this._processGeoNamesSearchOptions(data, opts);
		
		this._getGeoNames(
			'searchJSON'
			,data
			,function(r){
				if( r.geonames ) {
					opts.onSuccess(r.geonames);
				} else {
					$n2.log('Invalid result returned by GeoNames',r);
					opts.onError( _loc('Invalid result returned by GeoNames') );
				};
			}
			,opts.onError
		);
	},

	getNameStartsWith: function(opts_){
		var opts = $n2.extend({
			name: null // must be provided
			,featureClass: null
			,maxRows: null
			,country: null
			,countryBias: null
			,style: null
			,onSuccess: function(results){}
			,onError: function(err){}
		},opts_);
		
		var data = {
			name_startsWith: opts.name	
		};
		
		this._processGeoNamesSearchOptions(data, opts);
		
		this._getGeoNames(
			'searchJSON'
			,data
			,function(r){
				if( r.geonames ) {
					opts.onSuccess(r.geonames);
				} else {
					$n2.log('Invalid result returned by GeoNames',r);
					opts.onError( _loc('Invalid result returned by GeoNames') );
				};
			}
			,opts.onError
		);
	},
	
	findNearby: function(opts_){
		var opts = $n2.extend({
			lng: null // must be provided
			,lat: null // must be provided
			,featureClass: null
			,featureCode: null
			,lang: null
			,radius: null
			,maxRows: null
			,style: null
			,localCountry: null
			,cities: null
			,onSuccess: function(results){}
			,onError: function(err){}
		},opts_);
		
		var data = {
			lng: opts.lng
			,lat: opts.lat
		};
		
		if( opts.maxRows ){
			data.maxRows = opts.maxRows;
		};
		
		this._getGeoNames(
			'findNearbyJSON'
			,data
			,function(r){
				if( r.geonames ) {
					opts.onSuccess(r.geonames);
				} else {
					$n2.log('Invalid result returned by GeoNames',r);
					opts.onError( _loc('Invalid result returned by GeoNames') );
				};
			}
			,opts.onError
		);
	},
	
	installAutoComplete: function(opts_){
		var opts = $n2.extend({
			input: null // jquery element of input
		},opts_);
		
		opts.service = this;
		
		return new AutoComplete(opts);
	},
	
	_processGeoNamesSearchOptions: function(data, opts){
		if( opts.featureClass ){
			data.featureClass = opts.featureClass;
		};
		
		if( typeof(opts.maxRows) === 'number' ){
			data.maxRows = opts.maxRows;
		};

		if( opts.country ){
			data.country = opts.country;
		};

		if( opts.countryBias ){
			data.countryBias = opts.countryBias;
		};

		if( opts.style ){
			data.style = opts.style;
		};
	},
	
	_getGeoNames: function(method, data, success, error) {
		var nonNullData = {};
		for (var key in data) {
			if (key && data[key]) {
				nonNullData[key] = data[key];
			};
		};
		nonNullData.username = this.options.username;
		$.ajax({
			url: this.options.geoNamesUrl + method
			,dataType: 'json'
			,data: nonNullData
			,traditional: true
			,success: success
			,error: function(xhr, textStatus) {
				error(textStatus);
			}
		});
	}
});

//===================================

$n2.GeoNames = {
	Service: GeoNameService
	,FeatureClass: FeatureClass
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.document.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.document'
;

//*******************************************************
var dataSourceFromId = {};

function getDocumentSourceFromId(id){
	return dataSourceFromId[id];
};

// *******************************************************
var DocumentSource = $n2.Class('DocumentSource', {
	id: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			id: null
		},opts_);
		
		this.id = opts.id;
		if( !this.id ){
			this.id = $n2.getUniqueId();
		};
		if( this.id ){
			dataSourceFromId[this.id] = this;
		};
	},

	getId: function(){
		return this.id;
	},

	/**
	 * This method accepts a document and modifies it so that it reflects that
	 * the document belongs to this source. This is useful if a document is
	 * retrieved on behalf of the document source.
	 */
	adoptDocument: function(doc){
		throw new Error('Subclasses must implement adoptDocument(doc)');
	},

	createDocument: function(opts_){
		var opts = $n2.extend({
				doc: {}
				,onSuccess: function(doc){}
				,onError: function(errorMsg){}
			}
			,opts_
		);

		opts.onError('Data source does not support the "createDocument" call.');
	},

	getDocument: function(opts_){
		var opts = $n2.extend({
				docId: null
				,rev: null
				,revs_info: false
				,revisions: false
				,conflicts: false
				,deleted_conflicts: false
				,onSuccess: function(doc){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getDocument" call.');
	},

	getDocuments: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,onSuccess: function(docs){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getDocuments" call.');
	},

	getDocumentAttachments: function(doc){
		throw new Error('Subclasses must implement getDocumentAttachments(doc)');
	},

	getDocumentAttachment: function(doc, attachmentName){
		throw new Error('Subclasses must implement getDocumentAttachment(doc,attachmentName)');
	},

	getDocumentAttachmentUrl: function(doc, attachmentName){
		throw new Error('Subclasses must implement getDocumentAttachmentUrl(doc,attachmentName)');
	},

	verifyDocumentExistence: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,onSuccess: function(info){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "verifyDocumentExistence" call.');
	},

	updateDocument: function(opts_){
		var opts = $n2.extend({
				doc: null
				,onSuccess: function(doc){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "updateDocument" call.');
	},

	deleteDocument: function(opts_){
		var opts = $n2.extend({
				doc: null
				,onSuccess: function(){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "deleteDocument" call.');
	},

	getLayerDefinitions: function(opts_){
		var opts = $n2.extend({
				onSuccess: function(layerDefinitions){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getLayerDefinitions" call.');
	},

	getDocumentInfoFromIds: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,onSuccess: function(docInfos){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getDocumentInfoFromIds" call.');
	},

	getReferencesFromId: function(opts_){
		var opts = $n2.extend({
				docId: null
				,onSuccess: function(referenceIds){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getReferencesFromId" call.');
	},

	getProductFromId: function(opts_){
		var opts = $n2.extend({
				docId: null
				,onSuccess: function(referenceIds){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getProductFromId" call.');
	},

	getDocumentsFromGeographicFilter: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,layerId: null
				,bbox: null
				,projectionCode: null
				,onSuccess: function(docs){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getDocumentsFromGeographicFilter" call.');
	},

	getGeographicBoundingBox: function(opts_){
		var opts = $n2.extend({
				layerId: null
				,bbox: null
				,onSuccess: function(bbox){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		opts.onError('Data source does not support the "getGeographicBoundingBox" call.');
	}
});

//*******************************************************

var getDocumentSourceFromDocument = function(opts_) {
	var opts = $n2.extend({
		doc: null
		,dispatchService: null
		,dispatchHandle: DH
	},opts_);

	var doc = opts.doc;
	var dispatchService = opts.dispatchService;
	
	if( !doc ) return undefined;
	if( !dispatchService ) return undefined;
	
	var m = {
		type: 'documentSourceFromDocument'
		,doc: opts.doc
	};
	opts.dispatchService.synchronousCall(opts.dispatchHandle,m);

	return m.documentSource;
};

//*******************************************************

// Deep copy of document
var clone = function(doc){
	var copy = {};
	
	for(var key in doc){
		if( '__n2Source' === key ){
			copy[key] = doc[key];
		} else {
			copy[key] = $n2.deepCopy(doc[key]);
		};
	};
	
	return copy;
};

//*******************************************************
$n2.document = {
	DocumentSource: DocumentSource
	,getDocumentSourceFromDocument: getDocumentSourceFromDocument
	,getDocumentSourceFromId: getDocumentSourceFromId
	,clone: clone
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.objectSelector.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

// Localization
//var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

//=========================================================================
function escapeSelector(sel) {
	if( null === sel ) {
		return 'x';

	} else if( 'string' === typeof sel ) {
		var res = [];
		res.push('s');
		for(var i=0,e=sel.length; i<e; ++i) {
			var c = sel[i];
			if( c >= 'a' && c <= 'z' ) { res.push(c); }
			else if( c >= 'A' && c <= 'Z' ) { res.push(c); }
			else if( c >= '0' && c <= '9' ) { res.push(c); }
			else {
				var code = c.charCodeAt(0);
				var o0 = (code & 0x07) + 0x30;
				var o1 = ((code >> 3) & 0x07) + 0x30;
				var o2 = ((code >> 6) & 0x07) + 0x30;
				res.push('_');
				res.push( String.fromCharCode(o2) );
				res.push( String.fromCharCode(o1) );
				res.push( String.fromCharCode(o0) );
			};
		};
		return res.join('');

	} else if( 'number' === typeof sel ) {
		if( sel >= 0 ){
			return 'p'+sel;
		};
		return 'n'+(sel * -1);

	} else if( 'boolean' === typeof sel ) {
		if( sel ){
			return 't';
		} else {
			return 'f';
		};

	} else if( 'undefined' === typeof sel ) {
		return 'u';
	};

	return 'u';
};

function unescapeSelector(sel) {
	if( !sel ){
		return undefined;
	};
	if( sel.length < 1 ){
		return undefined;
	};
	
	if( 'u' === sel[0] ){
		return undefined;
	};
	
	if( 't' === sel[0] ){
		return true;
	};

	if( 'f' === sel[0] ){
		return false;
	};

	if( 'x' === sel[0] ){
		return null;
	};

	if( 'p' === sel[0] ){
		return 1 * sel.substr(1);
	};

	if( 'n' === sel[0] ){
		return -1 * sel.substr(1);
	};
	
	if( 's' === sel[0] ) {
		var res = [];
		for(var i=1,e=sel.length; i<e; ++i) {
			var c = sel[i];
			if( c === '_' ) { 
				++i;
				var o2 = sel.charCodeAt(i);
				++i;
				var o1 = sel.charCodeAt(i);
				++i;
				var o0 = sel.charCodeAt(i);
				
				var b = ((o2-0x30)<<6)+((o1-0x30)<<3)+(o0-0x30);
				res.push(String.fromCharCode(b));
				
			} else {
				res.push(c);
			};
		};
		return res.join('');
	};
	
	return undefined;
};

//=========================================================================
/**
 * Instances of this class represent a path selector, which can be used
 * to address a portion of an object. This class is instantiated by providing
 * an array of strings. Each string in the array represent one step in the
 * path selection.
 */
var ObjectSelector = $n2.Class({
	
	selectors: null,
	
	initialize: function(selectors){
		// Verify that this is an array of string or numbers
		if( !$n2.isArray(selectors) ){
			throw new Error('Instances of ObjectSelector must be created using an array');
		};
		
		this.selectors = selectors;
	},
	
	getChildSelector: function(key){
		var effectiveKey = null;
		if( typeof key === 'string' ){
			effectiveKey = key;
			
		} else if( typeof key === 'number' ) {
			effectiveKey = key;

		} else if( typeof key === 'object' 
		 && $n2.isArray(key) ) {
			var selectors = this.selectors.slice();
			selectors.push.apply(selectors, key);
			return new ObjectSelector(selectors);

		} else if( typeof key === 'object'
		 && typeof key.selectors === 'object'
		 && $n2.isArray(key.selectors) ) {
			var selectors = this.selectors.slice();
			selectors.push.apply(selectors, key.selectors);
			return new ObjectSelector(selectors);
			
		} else {
			throw new Error('A string or number must be provided when creating a child selector');
		};
		
		// Copy current selector
		var selectors = this.selectors.slice();
		selectors.push(effectiveKey);
		
		return new ObjectSelector(selectors);
	},
	
	getValue: function(obj){
		if(this.selectors.length < 1){
			return obj;
			
		} else if( typeof obj === 'undefined' ){
			return obj;
			
		} else if( obj === null ){
			return undefined;

		} else if( typeof obj === 'object' ){
			var effObj = obj;
			for(var i=0,e=this.selectors.length; i<e; ++i){
				var sel = this.selectors[i];
				if( null === effObj ){
					return undefined;
				} else if( typeof effObj[sel] === 'undefined' ){
					return undefined;
				};
				effObj = effObj[sel];
			};
			return effObj;
		
		} else {
			return undefined;
		};
	},
	
	setValue: function(obj, value, create){
		
		if( typeof value === 'undefined' ){
			return this.removeValue(obj);
		};
		
		var createFlag = (typeof create !== 'undefined') ? create : false;
		
		if( typeof obj !== 'object' ){
			return false;
		};
		if( this.selectors.length < 1 ){
			return false;
		};
		
		var effObj = obj;
		for(var i=0,e=this.selectors.length-1; i<e; ++i){
			var sel = this.selectors[i];
			if( typeof effObj[sel] === 'undefined' ){
				if( createFlag ){
					effObj[sel] = {};
				} else {
					return false;
				};
			} else if( typeof effObj[sel] !== 'object' ){
				return false;
			};
			effObj = effObj[sel];
		};
		var lastSel = this.selectors[this.selectors.length-1];
		effObj[lastSel] = value;
		
		return true;
	},
	
	removeValue: function(obj){
		if( typeof obj !== 'object' ){
			return false;
		};
		if( this.selectors.length < 1 ){
			return false;
		};
		
		var effObj = obj;
		for(var i=0,e=this.selectors.length-1; i<e; ++i){
			var sel = this.selectors[i];
			if( typeof effObj[sel] === 'undefined' ){
				return false;
			} else if( typeof effObj[sel] !== 'object' ){
				return false;
			};
			effObj = effObj[sel];
		};
		var lastSel = this.selectors[this.selectors.length-1];
		if( typeof effObj[lastSel] !== 'undefined' ){
			delete effObj[lastSel];
			return true;
		};

		return false;
	},
	
	/**
	 * Returns the selector to address the object containing the one pointed
	 * to by this path. If there are no parent selector, null is returned.
	 */
	getParentSelector: function(){
		if( this.selectors.length < 1 ){
			return null;
		};
		
		if( this.selectors.length === 1 ){
			return new ObjectSelector([]);
		};
		
		var parentSelectors = this.selectors.slice(0,this.selectors.length-1);
		return new ObjectSelector(parentSelectors);
	},
	
	/**
	 * Returns the key needed, from the perspective of the parent selector,
	 * to address the portion of the object that this path refers to. If there are no 
	 * parent selector, undefined is returned.
	 */
	getKey: function(){
		if( this.selectors.length < 1 ){
			return undefined;
		};
		
		return this.selectors[this.selectors.length-1];
	},
	
	getSelectorString: function(){
		return this.selectors.join('.');
	},
	
	encodeForDomAttribute: function(){
		var encodedPortions = [];
		for(var i=0,e=this.selectors.length; i<e; ++i){
			var sel = this.selectors[i];
			var encoded = escapeSelector(sel);
			encodedPortions.push(encoded);
		};
		return encodedPortions.join('-');
	},

	/*
	 * Traverses an object starting from the location of the selector and
	 * including all children. For each attribute, call the callback function
	 * which should have the following signature
	 *     callbackFn(value, childSelector)
	 * where
	 *    value is a descendant (or self) of the value selected by the selector
	 *    childSelector is a selector that matches the location of value
	 */
	traverse: function(obj, callbackFn){
		function traverseObj(obj, callbackFn, selector){
			for(var key in obj){
				var value = obj[key];
				var childSelector = selector.getChildSelector(key);
				callbackFn(value, childSelector);
				
				if( typeof value === 'object' && null !== value ){
					traverseObj(value, callbackFn, childSelector);
				};
			};
		};

		if( typeof obj !== 'object' ){
			throw new Error('objectSelector.traverse() needs an object');
		};
		if( typeof callbackFn !== 'function' ){
			throw new Error('objectSelector.traverse() needs a callback function');
		};
		
		var value = this.getValue(obj);
		if( typeof value !== 'undefined' ){
			// Perform self
			callbackFn(value, this);
			
			// Start traversal
			traverseObj(value, callbackFn, this);
		};
	}
});

//=========================================================================
function parseSelector(selectorString){
	var parts = selectorString.split('.');
	return new ObjectSelector(parts);
};

//=========================================================================
function decodeFromDomAttribute(domAttribute){
	var parts = [];
	if( domAttribute && domAttribute.length > 0 ) {
		var encodedParts = domAttribute.split('-');
		for(var i=0,e=encodedParts.length; i<e; ++i){
			var encoded = encodedParts[i];
			var part = unescapeSelector(encoded);
			parts.push(part);
		};
	};
	return new ObjectSelector(parts);
};

//=========================================================================
// Iterate over an object and find all possible selectors according to a
// a filter function
function findSelectors(obj, testFn){
	function traverse(obj, testFn, result, selector){
		for(var key in obj){
			var value = obj[key];
			if( testFn(value) ){
				var childSelector = selector.getChildSelector(key);
				result.push(childSelector);
			};
			
			if( typeof value === 'object' ){
				var childSelector = selector.getChildSelector(key);
				traverse(value, testFn, result, childSelector);
			};
		};
	};

	if( typeof obj !== 'object' ){
		throw new Error('objectSelector.findSelectors() needs an object');
	};
	if( typeof testFn !== 'function' ){
		throw new Error('objectSelector.findSelectors() needs a test function');
	};
	
	var result = [];
	var rootSelector = new ObjectSelector([]);
	
	if( testFn(obj) ){
		result.push(rootSelector);
	};
	
	traverse(obj, testFn, result, rootSelector);
	
	return result;
};

// =========================================================================

$n2.objectSelector = {
	ObjectSelector: ObjectSelector
	,parseSelector: parseSelector
	,decodeFromDomAttribute: decodeFromDomAttribute
	,findSelectors: findSelectors
};	
	
})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.userIntentView.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

//var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };
var DH = 'n2.userIntentView';

//--------------------------------------------------------------------------
/*
This class accepts nodes from a caller and manages the intent on those
nodes. Nodes should have the format:

{
	n2_id:              <string>         [input]
	,n2_selected:       <boolean>        [output]
	,n2_selectedIntent: <null or string> [output]
	,n2_hovered:        <boolean>        [output]
	,n2_hoveredIntent:  <null or string> [output]
	,n2_found:          <boolean>        [output]
	,n2_intent:         <null or string> [output]
}

*/
var IntentView = $n2.Class({
	dispatchService: null,
	
	listeners: null,

	hoverInfo: null,
	
	selectInfo: null,
	
	findInfo: null,
	
	nodesArrayById: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,suppressFindEvent: false
		}, opts_);

		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		this.listeners = [];
		this.nodesArrayById = {};
		this.hoverInfo = null;
		this.selectInfo = null;
		this.findInfo = null;
		
		if( this.dispatchService ){
			var f = function(m){
				_this._handleDispatch(m);
			};
			
			this.dispatchService.register(DH,'selected',f);
			this.dispatchService.register(DH,'selectedSupplement',f);
			this.dispatchService.register(DH,'unselected',f);
			this.dispatchService.register(DH,'focusOn',f);
			this.dispatchService.register(DH,'focusOnSupplement',f);
			this.dispatchService.register(DH,'focusOff',f);
			this.dispatchService.register(DH,'searchInitiate',f);
			
			if( !opts.suppressFindEvent ){
				this.dispatchService.register(DH,'find',f);
			};
		};
	},
	
	/**
	 * Adds a function that should be called every time a monitored node
	 * is updated with new user intentions. The function should have the
	 * following signature:
	 * function(nodes){ // nodes that have been changed
	 *  ...
	 * }
	 */
	addListener: function(listener){
		this.listeners.push(listener);
	},
	
	/**
	 * This function adds nodes to be monitored for changes in the user intention.
	 * When this function returns, each node is updated with the current intention
	 * flags (n2_selected, n2_hovered)
	 */
	addNodes: function(nodes){
		for(var i=0,e=nodes.length; i<e; ++i){
			var node = nodes[i];
			var id = node.n2_id;
			var nodesArray = this.nodesArrayById[id];
			if( !nodesArray ){
				nodesArray = [];
				this.nodesArrayById[id] = nodesArray;
			};
			if( nodesArray.indexOf(node) < 0 ){
				nodesArray.push(node);
			};
			
			this._adjustIntentOnNode(node);
		};
	},
	
	removeNodes: function(nodes){
		for(var i=0,e=nodes.length; i<e; ++i){
			var node = nodes[i];
			var id = node.n2_id;
			var nodesArray = this.nodesArrayById[id];
			if( nodesArray ){
				var index = nodesArray.indexOf(node);
				if( index >= 0 ){
					if( nodesArray.length < 2 ){
						delete this.nodesArrayById[id];
					} else {
						this.nodesArrayById[id].splice(index, 1);
					};
				};
			};
		};
	},
	
	_adjustIntentOnNode: function(node){
		var changed = false;
		
		var docId = node.n2_id;
		
		// Selection
		var selected = false;
		var selectedIntent = null;
		if( this.selectInfo && this.selectInfo.docIds ){
			var intent = this.selectInfo.docIds[docId];
			if( intent ){
				selected = true;
				if( typeof intent === 'string' ){
					selectedIntent = intent;
				};
			};
		};
		if( node.n2_selected !== selected ){
			node.n2_selected = selected;
			changed = true;
		};
		if( node.n2_selectedIntent !== selectedIntent ){
			node.n2_selectedIntent = selectedIntent;
			changed = true;
		};

		// Focus
		var focus = false;
		var hoveredIntent = null;
		if( this.hoverInfo && this.hoverInfo.docIds ){
			var intent = this.hoverInfo.docIds[docId];
			if( intent ){
				focus = true;
				if( typeof intent === 'string' ){
					hoveredIntent = intent;
				};
			};
		};
		if( node.n2_hovered !== focus ){
			node.n2_hovered = focus;
			changed = true;
		};
		if( node.n2_hoveredIntent !== hoveredIntent ){
			node.n2_hoveredIntent = hoveredIntent;
			changed = true;
		};
		
		// Find on map
		var find = false;
		if( this.findInfo ){
			var intent = this.findInfo[docId];
			if( intent ){
				find = true;
			};
		};
		if( node.n2_found !== find ){
			node.n2_found = find;
			changed = true;
		};
		
		// Compute intent
		var effectiveIntent = hoveredIntent;
		if( !effectiveIntent ){
			effectiveIntent = selectedIntent;
		};
		if( node.n2_intent !== effectiveIntent ){
			node.n2_intent = effectiveIntent;
			changed = true;
		};
		
		return changed;
	},
	
	_performUnselect: function(changedArray){
		var docIds = {};

		if( this.selectInfo 
		 && this.selectInfo.docIds ) {
			for(var selectedDocId in this.selectInfo.docIds){
				docIds[selectedDocId] = true;
			};
		};

		if( this.findInfo ) {
			for(var selectedDocId in this.findInfo){
				docIds[selectedDocId] = true;
			};
		};

		// needed for _adjustIntentOnNode()
		this.selectInfo = null;
		this.findInfo = null;
		
		for(var selectedDocId in docIds){
			var nodesArray = this.nodesArrayById[selectedDocId];
			if( nodesArray ){
				for(var j=0,k=nodesArray.length; j<k; ++j){
					var n = nodesArray[j];
					if( this._adjustIntentOnNode(n) ){
						changedArray.push(n);
					};
				};
			};
		};
	},

	_performFocusOff: function(changedArray){
		if( this.hoverInfo 
		 && this.hoverInfo.docIds ) {
			var docIds = this.hoverInfo.docIds;
			this.hoverInfo = null; // needed for _adjustIntentOnNode()
			
			for(var focusDocId in docIds){
				var nodesArray = this.nodesArrayById[focusDocId];
				if( nodesArray ){
					for(var j=0,k=nodesArray.length; j<k; ++j){
						var n = nodesArray[j];
						if( this._adjustIntentOnNode(n) ){
							changedArray.push(n);
						};
					};
				};
			};
		};
		
		this.hoverInfo = null;
	},

	_handleSelect: function(docIds){
		var changed = [];

		// New selection, unselect previous
		this._performUnselect(changed);

		// Create new selection
		this.selectInfo = {
			docIds: {}
		};
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			this.selectInfo.docIds[docId] = true;

			// Adjust selected nodes
			var nodesArray = this.nodesArrayById[docId];
			if( nodesArray ){
				for(var j=0,k=nodesArray.length; j<k; ++j){
					var n = nodesArray[j];
					if( this._adjustIntentOnNode(n) ){
						changed.push(n);
					};
				};
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleSelectSupplement: function(docId, intent){
		var changed = [];

		// Update current selection
		if( this.selectInfo && this.selectInfo.docIds ){
			if( intent ){
				this.selectInfo.docIds[docId] = intent;
			} else {
				this.selectInfo.docIds[docId] = true;
			};

			// Adjust selected nodes
			var nodesArray = this.nodesArrayById[docId];
			if( nodesArray ){
				for(var j=0,k=nodesArray.length; j<k; ++j){
					var n = nodesArray[j];
					if( this._adjustIntentOnNode(n) ){
						changed.push(n);
					};
				};
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleUnselect: function(){
		var changed = [];

		this._performUnselect(changed);

		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFind: function(docId){
		var changed = [];

		var previousNodes = [];
		if( this.findInfo ){
			for(var foundDocId in this.findInfo){
				var nodesArray = this.nodesArrayById[foundDocId];
				
				// Append all to previous nodes
				previousNodes.push.apply(previousNodes, nodesArray);
			};
		};
		
		// Create new find on map
		this.findInfo = {};
		this.findInfo[docId] = true;

		// Adjust previous nodes
		for(var i=0,e=previousNodes.length; i<e; ++i){
			var n = previousNodes[i];
			if( this._adjustIntentOnNode(n) ){
				changed.push(n);
			};
		};
		
		// Adjust selected nodes
		var nodesArray = this.nodesArrayById[docId];
		if( nodesArray ){
			for(var j=0,k=nodesArray.length; j<k; ++j){
				var n = nodesArray[j];
				if( this._adjustIntentOnNode(n) ){
					changed.push(n);
				};
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFocusOn: function(docIds){
		var changed = [];

		// New selection, unselect previous
		this._performFocusOff(changed);

		// Create new focus
		this.hoverInfo = {
			originMap: {}
			,docIds: {}
		};

		if( docIds ){
			for(var i=0,e=docIds.length; i<e; ++i){
				var docId = docIds[i];

				this.hoverInfo.originMap[docId] = true;
				this.hoverInfo.docIds[docId] = true;
				
				// Adjust associated nodes
				var nodesArray = this.nodesArrayById[docId];
				if( nodesArray ){
					for(var j=0,k=nodesArray.length; j<k; ++j){
						var n = nodesArray[j];
						if( this._adjustIntentOnNode(n) ){
							changed.push(n);
						};
					};
				};
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFocusOnSupplement: function(docId, intent){
		var changed = [];

		// Update current focus
		if( this.hoverInfo && this.hoverInfo.docIds ){
			if( intent ){
				this.hoverInfo.docIds[docId] = intent;
			} else {
				this.hoverInfo.docIds[docId] = true;
			};

			// Adjust selected nodes
			var nodesArray = this.nodesArrayById[docId];
			if( nodesArray ){
				for(var j=0,k=nodesArray.length; j<k; ++j){
					var n = nodesArray[j];
					if( this._adjustIntentOnNode(n) ){
						changed.push(n);
					};
				};
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFocusOff: function(){
		var changed = [];

		this._performFocusOff(changed);

		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleDispatch: function(m){
		if( 'selected' === m.type ){
			if( m.docId ){
				var docId = m.docId;
				this._handleSelect([docId]);
			} else if( m.docIds ) {
				this._handleSelect(m.docIds);
			} else if( m.doc ){
				var docId = m.doc._id;
				this._handleSelect([docId]);
			} else if( m.docs ) {
				var docIds = [];
				for(var i=0,e=m.docs.length; i<e; ++i){
					var doc = m.docs[i];
					docIds.push(doc._id);
				};
				this._handleSelect(docIds);
			} else {
				$n2.log('UserIntentView unable to handle "selected" event',m);
			};

		} else if( 'selectedSupplement' === m.type ) {
			var docId = m.docId;
			var intent = m.intent;
			this._handleSelectSupplement(docId, intent);
			
		} else if( 'unselected' === m.type ){
			this._handleUnselect();
			
		} else if( 'focusOn' === m.type ){
			if( m.docId ){
				this._handleFocusOn([m.docId]);
			} else if( m.docIds ){
				this._handleFocusOn(m.docIds);
			};

		} else if( 'focusOnSupplement' === m.type ) {
			var docId = m.docId;
			var intent = m.intent;
			
			var valid = true;
			if( m.origin ){
				valid = false;
				if( this.hoverInfo 
				 && this.hoverInfo.originMap 
				 && this.hoverInfo.originMap[m.origin] ){
					valid = true;
				};
			};
			
			if( docId && valid ){
				this._handleFocusOnSupplement(docId, intent);
			};
			
		} else if( 'focusOff' === m.type ){
			this._handleFocusOff();
			
		} else if( 'searchInitiate' === m.type ){
			this._handleUnselect();

		} else if( 'find' === m.type ){
			var docId = m.docId;
			this._handleFind(docId);
		};
	},
	
	_reportChangedNodes: function(changedNodes){
		for(var i=0,e=this.listeners.length; i<e; ++i){
			var l = this.listeners[i];
			l(changedNodes);
		};
	}
});

//--------------------------------------------------------------------------
/*
	Service used to track the user intent. It keeps an internal set of nodes that
	expands and shrinks according to the current selection.
	
	Internally, the nodes employed to track intent have the following format:
{
	n2_id:              <string>         [input]
	,n2_selected:       <boolean>        [output]
	,n2_selectedIntent: <null or string> [output]
	,n2_hovered:        <boolean>        [output]
	,n2_hoveredIntent:  <null or string> [output]
	,n2_found:          <boolean>        [output]
	,n2_intent:         <null or string> [output]
	,n2_stale:          <boolean>
}

	Note that when n2_stale is set, this node will no longer be reported and will be
	removed from the internal set.
*/
var IntentService = $n2.Class({
	dispatchService: null,
	
	hoverInfo: null,
	
	selectInfo: null,
	
	findInfo: null,
	
	nodesById: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,suppressFindEvent: false
		}, opts_);

		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		this.nodesById = {};
		this.hoverInfo = null;
		this.selectInfo = null;
		this.findInfo = null;
		
		if( this.dispatchService ){
			var f = function(m){
				_this._handleDispatch(m);
			};
			
			this.dispatchService.register(DH,'selected',f);
			this.dispatchService.register(DH,'selectedSupplement',f);
			this.dispatchService.register(DH,'unselected',f);
			this.dispatchService.register(DH,'focusOn',f);
			this.dispatchService.register(DH,'focusOnSupplement',f);
			this.dispatchService.register(DH,'focusOff',f);
			this.dispatchService.register(DH,'searchInitiate',f);
			
			if( !opts.suppressFindEvent ){
				this.dispatchService.register(DH,'find',f);
			};

			this.dispatchService.register(DH,'userIntentGetCurrent',f);
		};
	},
	
	_getNode: function(docId){
		var node = this.nodesById[docId];
		if( !node ){
			node = {
				n2_id: docId
			};
			this.nodesById[docId] = node;
		};
		return node;
	},
	
	_adjustIntentOnNode: function(node){
		var changed = false;
		
		var docId = node.n2_id;
		
		// Stale. Initially, assume that it is stale
		var stale = true;
		
		// Selection
		var selected = false;
		var selectedIntent = null;
		if( this.selectInfo && this.selectInfo.docIds ){
			var intent = this.selectInfo.docIds[docId];
			if( intent ){
				selected = true;
				stale = false;
				if( typeof intent === 'string' ){
					selectedIntent = intent;
				};
			};
		};
		if( node.n2_selected !== selected ){
			node.n2_selected = selected;
			changed = true;
		};
		if( node.n2_selectedIntent !== selectedIntent ){
			node.n2_selectedIntent = selectedIntent;
			changed = true;
		};

		// Focus
		var focus = false;
		var hoveredIntent = null;
		if( this.hoverInfo && this.hoverInfo.docIds ){
			var intent = this.hoverInfo.docIds[docId];
			if( intent ){
				focus = true;
				stale = false;
				if( typeof intent === 'string' ){
					hoveredIntent = intent;
				};
			};
		};
		if( node.n2_hovered !== focus ){
			node.n2_hovered = focus;
			changed = true;
		};
		if( node.n2_hoveredIntent !== hoveredIntent ){
			node.n2_hoveredIntent = hoveredIntent;
			changed = true;
		};
		
		// Find on map
		var find = false;
		if( this.findInfo ){
			var intent = this.findInfo[docId];
			if( intent ){
				find = true;
				stale = false;
			};
		};
		if( node.n2_found !== find ){
			node.n2_found = find;
			changed = true;
		};
		
		// Compute intent
		var effectiveIntent = hoveredIntent;
		if( !effectiveIntent ){
			effectiveIntent = selectedIntent;
		};
		if( node.n2_intent !== effectiveIntent ){
			node.n2_intent = effectiveIntent;
			changed = true;
		};

		// This node is no longer interesting. It has become stale
		// and should be removed from tracked nodes.
		if( stale ){
			node.n2_stale = stale;
			changed = true;
		};
		
		return changed;
	},
	
	_performUnselect: function(changedArray){
		var docIds = {};

		if( this.selectInfo 
		 && this.selectInfo.docIds ) {
			for(var selectedDocId in this.selectInfo.docIds){
				docIds[selectedDocId] = true;
			};
		};

		if( this.findInfo ) {
			for(var selectedDocId in this.findInfo){
				docIds[selectedDocId] = true;
			};
		};

		// needed for _adjustIntentOnNode()
		this.selectInfo = null;
		this.findInfo = null;
		
		for(var selectedDocId in docIds){
			var n = this._getNode(selectedDocId);
			if( this._adjustIntentOnNode(n) ){
				changedArray.push(n);
			};
		};
	},

	_performFocusOff: function(changedArray){
		if( this.hoverInfo 
		 && this.hoverInfo.docIds ) {
			var docIds = this.hoverInfo.docIds;
			this.hoverInfo = null; // needed for _adjustIntentOnNode()
			
			for(var focusDocId in docIds){
				var n = this._getNode(focusDocId);
				if( this._adjustIntentOnNode(n) ){
					changedArray.push(n);
				};
			};
		};
		
		this.hoverInfo = null;
	},

	_handleSelect: function(docIds){
		var changed = [];

		// New selection, unselect previous
		this._performUnselect(changed);

		// Create new selection
		this.selectInfo = {
			docIds: {}
		};
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			this.selectInfo.docIds[docId] = true;

			// Adjust selected nodes
			var n = this._getNode(docId);
			if( this._adjustIntentOnNode(n) ){
				changed.push(n);
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleSelectSupplement: function(docId, intent){
		var changed = [];

		// Update current selection
		if( this.selectInfo && this.selectInfo.docIds ){
			if( intent ){
				this.selectInfo.docIds[docId] = intent;
			} else {
				this.selectInfo.docIds[docId] = true;
			};

			// Adjust selected nodes
			var n = this._getNode(docId);
			if( this._adjustIntentOnNode(n) ){
				changed.push(n);
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleUnselect: function(){
		var changed = [];

		this._performUnselect(changed);

		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFind: function(docId){
		var changed = [];

		var previousNodes = [];
		if( this.findInfo ){
			for(var foundDocId in this.findInfo){
				var n = this._getNode(foundDocId);
				
				previousNodes.push(n);
			};
		};
		
		// Create new find on map
		this.findInfo = {};
		this.findInfo[docId] = true;

		// Adjust previous nodes
		for(var i=0,e=previousNodes.length; i<e; ++i){
			var n = previousNodes[i];
			if( this._adjustIntentOnNode(n) ){
				changed.push(n);
			};
		};
		
		// Adjust current node
		var n = this._getNode(docId);
		if( this._adjustIntentOnNode(n) ){
			changed.push(n);
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFocusOn: function(docIds){
		var changed = [];

		// New selection, unselect previous
		this._performFocusOff(changed);

		// Create new focus
		this.hoverInfo = {
			originMap: {}
			,docIds: {}
		};
		if( docIds ){
			for(var i=0,e=docIds.length; i<e; ++i){
				var docId = docIds[i];

				this.hoverInfo.originMap[docId] = true;
				this.hoverInfo.docIds[docId] = true;
				
				// Adjust current node
				var n = this._getNode(docId);
				if( this._adjustIntentOnNode(n) ){
					changed.push(n);
				};
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFocusOnSupplement: function(docId, intent){
		var changed = [];

		// Update current focus
		if( this.hoverInfo && this.hoverInfo.docIds ){
			if( intent ){
				this.hoverInfo.docIds[docId] = intent;
			} else {
				this.hoverInfo.docIds[docId] = true;
			};

			// Adjust current node
			var n = this._getNode(docId);
			if( this._adjustIntentOnNode(n) ){
				changed.push(n);
			};
		};
		
		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleFocusOff: function(){
		var changed = [];

		this._performFocusOff(changed);

		// Report to listener the nodes that were changed
		if( changed.length > 0 ){
			this._reportChangedNodes(changed);
		};
	},

	_handleDispatch: function(m){
		if( 'selected' === m.type ){
			if( m.docId ){
				var docId = m.docId;
				this._handleSelect([docId]);
			} else if( m.docIds ) {
				this._handleSelect(m.docIds);
			} else if( m.doc ){
				var docId = m.doc._id;
				this._handleSelect([docId]);
			} else if( m.docs ) {
				var docIds = [];
				for(var i=0,e=m.docs.length; i<e; ++i){
					var doc = m.docs[i];
					docIds.push(doc._id);
				};
				this._handleSelect(docIds);
			} else {
				$n2.log('UserIntentService unable to handle "selected" event',m);
			};

		} else if( 'selectedSupplement' === m.type ) {
			var docId = m.docId;
			var intent = m.intent;
			this._handleSelectSupplement(docId, intent);
			
		} else if( 'unselected' === m.type ){
			this._handleUnselect();
			
		} else if( 'focusOn' === m.type ){
			if( m.docId ){
				this._handleFocusOn([m.docId]);
			} else if( m.docIds ){
				this._handleFocusOn(m.docIds);
			};

		} else if( 'focusOnSupplement' === m.type ) {
			var docId = m.docId;
			var intent = m.intent;
			
			var valid = true;
			if( m.origin ){
				valid = false;
				if( this.hoverInfo 
				 && this.hoverInfo.originMap 
				 && this.hoverInfo.originMap[m.origin] ){
					valid = true;
				};
			};

			if( docId && valid ){
				this._handleFocusOnSupplement(docId, intent);
			};
			
		} else if( 'focusOff' === m.type ){
			this._handleFocusOff();
			
		} else if( 'searchInitiate' === m.type ){
			this._handleUnselect();

		} else if( 'find' === m.type ){
			var docId = m.docId;
			this._handleFind(docId);
			
		} else if( 'userIntentGetCurrent' === m.type ){
			// Asynchronous call
			m.intentMap = this.nodesById;
		};
	},
	
	_reportChangedNodes: function(changedNodes){
		this.dispatchService.send(DH,{
			type: 'userIntentChanged'
			,intentMap: this.nodesById
			,changes: changedNodes
		});
		
		// Remove nodes that have become stale
		for(var i=0,e=changedNodes.length; i<e; ++i){
			var n = changedNodes[i];
			if( n.n2_stale ){
				var docId = n.n2_id;
				delete this.nodesById[docId];
			};
		};
	}
});

//--------------------------------------------------------------------------
$n2.userIntentView = {
	IntentView: IntentView
	,IntentService: IntentService
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.styleRuleParser.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var styleRule = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,3],$V1=[1,4],$V2=[1,6],$V3=[1,7],$V4=[1,8],$V5=[1,9],$V6=[1,10],$V7=[1,12],$V8=[1,13],$V9=[1,14],$Va=[1,15],$Vb=[1,16],$Vc=[1,17],$Vd=[1,18],$Ve=[1,19],$Vf=[1,20],$Vg=[1,21],$Vh=[1,22],$Vi=[1,23],$Vj=[1,24],$Vk=[5,6,7,10,11,12,13,14,15,16,23,24,25,26,27,28,32],$Vl=[5,6,7,9,10,11,12,13,14,15,16,23,24,25,26,27,28,29,31,32],$Vm=[5,6,7,10,28,32],$Vn=[5,6,7,10,11,12,13,14,15,16,28,32],$Vo=[5,6,7,10,11,12,13,14,15,16,23,24,28,32];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"program":3,"value":4,"EOF":5,"&&":6,"||":7,"!":8,"(":9,")":10,"==":11,"!=":12,">=":13,"<=":14,">":15,"<":16,"identifier":17,"arguments":18,"true":19,"false":20,"NUMBER":21,"STRING":22,"+":23,"-":24,"*":25,"/":26,"%":27,",":28,".":29,"VAR_NAME":30,"[":31,"]":32,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"&&",7:"||",8:"!",9:"(",10:")",11:"==",12:"!=",13:">=",14:"<=",15:">",16:"<",19:"true",20:"false",21:"NUMBER",22:"STRING",23:"+",24:"-",25:"*",26:"/",27:"%",28:",",29:".",30:"VAR_NAME",31:"[",32:"]"},
productions_: [0,[3,2],[4,3],[4,3],[4,2],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,4],[4,1],[4,1],[4,1],[4,1],[4,1],[4,3],[4,3],[4,3],[4,3],[4,3],[18,3],[18,1],[17,3],[17,4],[17,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2:

        	this.$ = new Expression($$[$0-2],'&&',$$[$0]);
        
break;
case 3:

        	this.$ = new Expression($$[$0-2],'||',$$[$0]);
        
break;
case 4:

        	this.$ = new Expression($$[$0],'!');
        
break;
case 5:

    		this.$ = $$[$0-1];
    	
break;
case 6:

        	this.$ = new Comparison($$[$0-2],$$[$0],'==');
        
break;
case 7:

        	this.$ = new Comparison($$[$0-2],$$[$0],'!=');
        
break;
case 8:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>=');
        
break;
case 9:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<=');
        
break;
case 10:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>');
        
break;
case 11:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<');
        
break;
case 12:

        	this.$ = new FunctionCall($$[$0-2],null);
        
break;
case 13:

        	this.$ = new FunctionCall($$[$0-3],$$[$0-1]);
        
break;
case 14:

        	this.$ = $$[$0];
        
break;
case 15:

    		this.$ = new Literal(true);
    	
break;
case 16:

    		this.$ = new Literal(false);
    	
break;
case 17:

    		this.$ = new Literal(1 * $$[$0]);
    	
break;
case 18:

    		this.$ = new Literal($$[$0]);
    	
break;
case 19:

    		this.$ = new MathOp($$[$0-2],$$[$0],'+');
    	
break;
case 20:

    		this.$ = new MathOp($$[$0-2],$$[$0],'-');
    	
break;
case 21:

    		this.$ = new MathOp($$[$0-2],$$[$0],'*');
    	
break;
case 22:

    		this.$ = new MathOp($$[$0-2],$$[$0],'/');
    	
break;
case 23:

    		this.$ = new MathOp($$[$0-2],$$[$0],'%');
    	
break;
case 24:

        	this.$ = new Argument($$[$0-2],$$[$0]);
        
break;
case 25:

        	this.$ = new Argument($$[$0]);
        
break;
case 26:

        	var id = new Literal($$[$0]);
        	this.$ = new ObjectSelector(id,$$[$0-2]);
        
break;
case 27:

        	this.$ = new ObjectSelector($$[$0-1],$$[$0-3]);
        
break;
case 28:

        	this.$ = new Variable($$[$0]);
        
break;
}
},
table: [{3:1,4:2,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{1:[3]},{5:[1,11],6:$V7,7:$V8,11:$V9,12:$Va,13:$Vb,14:$Vc,15:$Vd,16:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj},{4:25,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:26,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},o($Vk,[2,14],{9:[1,27],29:[1,28],31:[1,29]}),o($Vk,[2,15]),o($Vk,[2,16]),o($Vk,[2,17]),o($Vk,[2,18]),o($Vl,[2,28]),{1:[2,1]},{4:30,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:31,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:32,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:33,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:34,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:35,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:36,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:37,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:38,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:39,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:40,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:41,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{4:42,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},o($Vk,[2,4]),{6:$V7,7:$V8,10:[1,43],11:$V9,12:$Va,13:$Vb,14:$Vc,15:$Vd,16:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj},{4:46,8:$V0,9:$V1,10:[1,44],17:5,18:45,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},{30:[1,47]},{4:48,8:$V0,9:$V1,17:5,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},o($Vm,[2,2],{11:$V9,12:$Va,13:$Vb,14:$Vc,15:$Vd,16:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vm,[2,3],{11:$V9,12:$Va,13:$Vb,14:$Vc,15:$Vd,16:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vn,[2,6],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vn,[2,7],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vn,[2,8],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vn,[2,9],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vn,[2,10],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vn,[2,11],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj}),o($Vo,[2,19],{25:$Vh,26:$Vi,27:$Vj}),o($Vo,[2,20],{25:$Vh,26:$Vi,27:$Vj}),o($Vk,[2,21]),o($Vk,[2,22]),o($Vk,[2,23]),o($Vk,[2,5]),o($Vk,[2,12]),{10:[1,49]},{6:$V7,7:$V8,10:[2,25],11:$V9,12:$Va,13:$Vb,14:$Vc,15:$Vd,16:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,28:[1,50]},o($Vl,[2,26]),{6:$V7,7:$V8,11:$V9,12:$Va,13:$Vb,14:$Vc,15:$Vd,16:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,32:[1,51]},o($Vk,[2,13]),{4:46,8:$V0,9:$V1,17:5,18:52,19:$V2,20:$V3,21:$V4,22:$V5,30:$V6},o($Vl,[2,27]),{10:[2,24]}],
defaultActions: {11:[2,1],52:[2,24]},
parseError: function parseError(str, hash) {
    function _parseError (msg, hash) {
        this.message = msg;
        this.hash = hash;
    }
    _parseError.prototype = Error;

    if (hash.recoverable) {
        this.trace(str);
    } else {

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    // return true;
}};

// Utilities
function classNamesFromElement(elem){
	var names = undefined;
	
	var classAttr = elem.getAttribute('class');
	if( classAttr ){
		names = classAttr.split(' ').filter(function(name){
			return (name.length > 0);
		});
	};
	
	return names;
};

// Functions in the global space receives the context object
// as 'this'.
var global = {
	isSelected: function(){
		return this.n2_selected;
	}
	,isHovered: function(){
		return this.n2_hovered;
	}
	,isFound: function(){
		return this.n2_found;
	}
	,isPoint: function(){
		return 'point' === this.n2_geometry;
	}
	,isLine: function(){
		return 'line' === this.n2_geometry;
	}
	,isPolygon: function(){
		return 'polygon' === this.n2_geometry;
	}
	,isSchema: function(schemaName){
		if( schemaName && this.n2_doc ){
			return (schemaName === this.n2_doc.nunaliit_schema);
		};
		return false;
	}
	,onLayer: function(layerId){
		if( layerId
		 && this.n2_doc 
		 && this.n2_doc.nunaliit_layers ){
		 	var index = this.n2_doc.nunaliit_layers.indexOf(layerId);
			return (index >= 0);
		};
		return false;
	}
	,hasClass: function(className){
		if( className
		 && this.n2_elem ){
			var classNames = classNamesFromElement(this.n2_elem);
		 	var index = -1;
		 	if( classNames ){
			 	index = classNames.indexOf(className);
		 	};
			return (index >= 0);
		};
		return false;
	}
	,Math: Math
};
parser.global = global;

// -----------------------------------------------------------
var FunctionCall = function(value, args){
	this.value = value;
	this.args = args;
};
FunctionCall.prototype.getValue = function(ctxt){
	var value = this.value.getValue(ctxt);
	if( typeof value === 'function' ){
		var args = [];
		if( this.args ){
			this.args.pushOnArray(ctxt, args);
		};
		return value.apply(ctxt, args);
	};
	return false;
};

// -----------------------------------------------------------
// Argument
var Argument = function(a1, a2){
	this.valueNode = a1;
	if( a2 ){
		this.nextArgument = a2;
	} else {
		this.nextArgument = null;
	};
};
Argument.prototype.getCount = function(){
	if( this.nextArgument ){
		return 1 + this.nextArgument.getCount();
	};
	
	return 1;
};
Argument.prototype.getArgument = function(ctxt, position){
	if( position < 1 ){
		return this.valueNode.getValue(ctxt);
	};
	
	if( this.nextArgument ){
		this.nextArgument.getArgument(ctxt, position-1);
	};
	
	return undefined;
};
Argument.prototype.pushOnArray = function(ctxt, array){
	var value = this.valueNode.getValue(ctxt);
	array.push(value);
	
	if( this.nextArgument ){
		this.nextArgument.pushOnArray(ctxt, array);
	};
};

// -----------------------------------------------------------
var Expression = function(n1, op, n2){
	this.n1 = n1;
	this.n2 = n2;
	this.op = op;
};
Expression.prototype.getValue = function(ctxt){
	var r1 = this.n1.getValue(ctxt);
	var r2 = undefined;
	if( this.n2 ){
		r2 = this.n2.getValue(ctxt);
	};
	if( '!' === this.op ){
		return !r1;
		
	} else if( '&&' === this.op ){
		return (r1 && r2);
		
	} else if( '||' === this.op ){
		return (r1 || r2);
	};
	return false;
};

// -----------------------------------------------------------
var Literal = function(value){
	this.value = value;
};
Literal.prototype.getValue = function(ctxt){
	return this.value;
};

// -----------------------------------------------------------
var Comparison = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
Comparison.prototype.getValue = function(ctxt){
	var left = this.leftNode.getValue(ctxt);
	var right = this.rightNode.getValue(ctxt);

	if( '==' === this.op ){
		return (left == right);

	} else if( '!=' === this.op ){
		return (left != right);

	} else if( '>=' === this.op ){
		return (left >= right);

	} else if( '<=' === this.op ){
		return (left <= right);

	} else if( '>' === this.op ){
		return (left > right);

	} else if( '<' === this.op ){
		return (left < right);
	};
	
	return false;
};

// -----------------------------------------------------------
var MathOp = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
MathOp.prototype.getValue = function(ctxt){
	var left = this.leftNode.getValue(ctxt);
	var right = this.rightNode.getValue(ctxt);

	if( '+' === this.op ){
		return (left + right);

	} else if( '-' === this.op ){
		return (left - right);

	} else if( '*' === this.op ){
		return (left * right);

	} else if( '/' === this.op ){
		return (left / right);

	} else if( '%' === this.op ){
		return (left % right);
	};
	
	return 0;
};

// -----------------------------------------------------------
var ObjectSelector = function(id, previousSelector){
	this.idNode = id;
	this.previousSelector = previousSelector;
};
ObjectSelector.prototype.getValue = function(ctxt){
	var obj = this.previousSelector.getValue(ctxt);
	if( typeof obj === 'object' ){
		var id = this.idNode.getValue(ctxt);
		if( typeof id === 'undefined' ){
			return undefined;
		};
		
		return obj[id];
	};

	return undefined;
};

// -----------------------------------------------------------
var Variable = function(variableName){
	this.variableName = variableName;
};
Variable.prototype.getValue = function(ctxt){
	var obj = undefined;
	
	if( ctxt && 'doc' === this.variableName ) {
		obj = ctxt.n2_doc;
		
	} else if( ctxt && ctxt[this.variableName] ) {
		obj = ctxt[this.variableName];
		
	} else if( global && global[this.variableName] ) {
		obj = global[this.variableName];
	};
	
	return obj;
};




/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: /* skip whitespace */ 
break;
case 1: return 19; 
break;
case 2: return 20; 
break;
case 3: return 21; 
break;
case 4: return 30; 
break;
case 5: yy_.yytext = yy_.yytext.substr(1,yy_.yytext.length-2); return 22; 
break;
case 6: return 11; 
break;
case 7: return 12; 
break;
case 8: return 13; 
break;
case 9: return 14; 
break;
case 10: return 15; 
break;
case 11: return 16; 
break;
case 12: return 9; 
break;
case 13: return 10; 
break;
case 14: return '{'; 
break;
case 15: return '}'; 
break;
case 16: return 31; 
break;
case 17: return 32; 
break;
case 18: return 28; 
break;
case 19: return 29; 
break;
case 20: return 8; 
break;
case 21: return 23; 
break;
case 22: return 24; 
break;
case 23: return 25; 
break;
case 24: return 26; 
break;
case 25: return 27; 
break;
case 26: return 6; 
break;
case 27: return 7; 
break;
case 28: return 5; 
break;
case 29: return 'INVALID'; 
break;
}
},
rules: [/^(?:\s+)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:[_a-zA-Z][_a-zA-Z0-9]*)/,/^(?:'(\\'|[^'])*')/,/^(?:==)/,/^(?:!=)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:\()/,/^(?:\))/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?:\.)/,/^(?:!)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = styleRule;
exports.Parser = styleRule.Parser;
exports.parse = function () { return styleRule.parse.apply(styleRule, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}	
//--------------------------------------------------------------------------
function parse(){
	return styleRule.parse.apply(styleRule, arguments);
};

//--------------------------------------------------------------------------
function getGlobalContext(){
	return styleRule.global;
};
	
//--------------------------------------------------------------------------
$n2.styleRuleParser = {
	parse: parse
	,getGlobalContext: getGlobalContext
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.styleRule.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };
var DH = 'n2.styleRule';

//--------------------------------------------------------------------------
var TrueNode = $n2.Class({
	initialize: function(){},
	getValue: function(ctxt){
		return true;
	}
});
var g_TrueNode = new TrueNode();

//--------------------------------------------------------------------------
var svgSymbolNames = {
	'fill': {
		applies: {
			circle: true
			,line: false
			,path: true
			,text: true
			,g: true
		}
	}
	,'fill-opacity': {
		applies: {
			circle: true
			,line: false
			,path: true
			,text: true
			,g: true
		}
	}
	,'stroke': {
		applies: {
			circle: true
			,line: true
			,path: true
			,text: true
			,g: true
		}
	}
	,'stroke-width': {
		applies: {
			circle: true
			,line: true
			,path: true
			,text: true
			,g: true
		}
	}
	,'stroke-opacity': {
		applies: {
			circle: true
			,line: true
			,path: true
			,text: true
			,g: true
		}
	}
	,'stroke-linecap': {
		applies: {
			circle: true
			,line: true
			,path: true
			,text: false
			,g: true
		}
	}
	,'stroke-dasharray': {
		applies: {
			circle: true
			,line: true
			,path: true
			,text: false
			,g: true
		}
	}
	,'r': {
		applies: {
			circle: true
			,line: false
			,path: false
			,text: false
			,g: true
		}
	}
	,'pointer-events': {
		applies: {
			circle: true
			,line: true
			,path: true
			,text: true
			,g: true
		}
	}
	,'cursor': {
		applies: {
			circle: true
			,line: true
			,path: true
			,text: true
			,g: true
		}
	}
	,'label': {
		applies: {
			circle: false
			,line: false
			,path: false
			,text: true
			,g: true
		}
	}
	,'font-family': {
		applies: {
			circle: false
			,line: false
			,path: false
			,text: true
			,g: true
		}
	}
	,'font-size': {
		applies: {
			circle: false
			,line: false
			,path: false
			,text: true
			,g: true
		}
	}
	,'font-style': {
		applies: {
			circle: false
			,line: false
			,path: false
			,text: true
			,g: true
		}
	}
	,'font-weight': {
		applies: {
			circle: false
			,line: false
			,path: false
			,text: true
			,g: true
		}
	}
	,'text-anchor': {
		applies: {
			circle: false
			,line: false
			,path: false
			,text: true
			,g: true
		}
	}
	,'marker-start': {
		applies: {
			circle: false
			,line: false
			,path: true
			,text: false
			,g: true
		}
	}
	,'marker-end': {
		applies: {
			circle: false
			,line: false
			,path: true
			,text: false
			,g: true
		}
	}
	,'marker-mid': {
		applies: {
			circle: false
			,line: false
			,path: true
			,text: false
			,g: true
		}
	}
};

//--------------------------------------------------------------------------
var SymbolTranslationMap = {
	'fillColor': 'fill'	
	,'fillOpacity': 'fill-opacity'
	,'strokeColor': 'stroke'
	,'strokeWidth': 'stroke-width'
	,'strokeOpacity': 'stroke-opacity'
	,'strokeLinecap': 'stroke-linecap'
	,'strokeDashstyle': 'stroke-dasharray'
	,'pointRadius': 'r'
	,'pointEvents': 'pointer-events'
	,'fontColor': 'color'
	,'font-color': 'color'
	,'fontFamily': 'font-family'
	,'fontSize': 'font-size'
	,'fontWeight': 'font-weight'
};


//--------------------------------------------------------------------------
var Symbolizer = $n2.Class({
	
	symbols: null,
	
	initialize: function(){
		
		this.symbols = {};
		this.id = null;
		this._n2Symbolizer = true;
		
		for(var i=0,e=arguments.length; i<e; ++i){
			var otherSymbolizer = arguments[i];
			this.extendWith(otherSymbolizer);
		};
	},
	
	extendWith: function(symbolizer){
		if( symbolizer ){
			if( symbolizer._n2Symbolizer ){
				// From another instance of Symbolizer
				var att = symbolizer.symbols;
				for(var key in att){
					var value = att[key];
					this.symbols[key] = value;
				};
			} else {
				// From a user supplied dictionary. Must translate
				for(var key in symbolizer){
					var symbolValue = symbolizer[key];

					// Translate key, if needed
					if( SymbolTranslationMap[key] ){
						key = SymbolTranslationMap[key];
					};

					// Parse value if it starts with a '='
					if( symbolValue 
					 && symbolValue.length > 0 
					 && symbolValue[0] === '=' ){
						try {
							// This should return an object with a function getValue(ctxt)
							symbolValue = $n2.styleRuleParser.parse(symbolValue.substr(1));
						} catch(e) {
							symbolValue = e;
						};
					};

					if( 'opacity' === key ){
						this.symbols['fill-opacity'] = symbolValue;
						this.symbols['stroke-opacity'] = symbolValue;
					} else {
						this.symbols[key] = symbolValue;
					};
				};
			};
		};
	},
	
	getSymbolValue: function(symbolName, ctxt){
		var value = this.symbols[symbolName];
		
		if( typeof value === 'object'
		 && typeof value.getValue === 'function' ){
			value = value.getValue(ctxt);
		} else if( typeof value === 'object'
		 && 'localized' === value.nunaliit_type){
			value = _loc(value);
		};
		
		return value;
	},
	
	forEachSymbol: function(fn, ctxt){
		if( typeof fn === 'function' ){
			for(var name in this.symbols){
				var value = this.getSymbolValue(name, ctxt);
				fn(name,value);
			};
		};
	},
	
	adjustSvgElement: function(svgDomElem,ctxt){

		var nodeName = svgDomElem.nodeName.toLowerCase();

		for(var name in svgSymbolNames){
			var info = svgSymbolNames[name];
			if( info.applies[nodeName] ){
				var value = this.getSymbolValue(name,ctxt);
				
				if( 'label' === name ){
					if( value === null ){
						// ignore
					} else if( typeof value === 'object' 
					 && 'localized' === value.nunaliit_type ){
						value = _loc( value );
					} else if( typeof value === 'undefined' ){
						// ignore
					} else if( typeof value !== 'string' ){
						value = '' + value;
					};
					
					// empty()
					while ( svgDomElem.firstChild ) {
						svgDomElem.removeChild( svgDomElem.firstChild );
					};

					if( value ){
						// text(value)
						var textNode = svgDomElem.ownerDocument.createTextNode(value);
						svgDomElem.appendChild(textNode);
					};
					
				} else if( typeof value !== 'undefined' ){
					svgDomElem.setAttributeNS(null, name, value);
				};
			};
		};

		var value = this.getSymbolValue('display',ctxt);
		if( 'none' === value ){
			svgDomElem.setAttributeNS(null, 'display', 'none');
		} else {
			svgDomElem.setAttributeNS(null, 'display', 'inherit');
		};
	},
	
	adjustHtmlElement: function(htmlDomElement,ctxt){

		var cssArr = [];
		
		this.forEachSymbol(function(name,value){
			if( 'display' === name ){
				if( 'none' === value ){
					cssArr.push('display:none');
				};
				
			} else {
				cssArr.push(name+':'+value);
			};
		},ctxt);

		var cssString = cssArr.join(';');
		htmlDomElement.setAttribute("style", cssString);
	}
});

//--------------------------------------------------------------------------
var Style = $n2.Class({
	
	symbolizersByLabel: null,
	
	id: null,
	
	label: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			id: undefined
			,basicStyle: undefined
			,extendWithRule: undefined
		},opts_);
		
		this.symbolizersByLabel = {};
		this.id = opts.id;
		this.label = null;
		
		if( opts.extendWithRule ){
			this.label = opts.extendWithRule.label;
		};
		
		if( opts.basicStyle && opts.extendWithRule ){
			this.symbolizersByLabel.normal = new Symbolizer(
				opts.basicStyle.symbolizersByLabel.normal, 
				opts.extendWithRule.normal
			);
			this.symbolizersByLabel.selected = new Symbolizer(
				opts.basicStyle.symbolizersByLabel.selected, 
				opts.extendWithRule.selected
			);
			this.symbolizersByLabel.hovered = new Symbolizer(
				opts.basicStyle.symbolizersByLabel.hovered, 
				opts.extendWithRule.hovered
			);
			this.symbolizersByLabel.found = new Symbolizer(
				opts.basicStyle.symbolizersByLabel.found, 
				opts.extendWithRule.found
			);

		} else if( opts.basicStyle ){
			this.symbolizersByLabel.normal = opts.basicStyle.symbolizersByLabel.normal;
			this.symbolizersByLabel.selected = opts.basicStyle.symbolizersByLabel.selected;
			this.symbolizersByLabel.hovered = opts.basicStyle.symbolizersByLabel.hovered;
			this.symbolizersByLabel.found = opts.basicStyle.symbolizersByLabel.found;

		} else if( opts.extendWithRule ){
			this.symbolizersByLabel.normal = opts.extendWithRule.normal;
			this.symbolizersByLabel.selected = opts.extendWithRule.selected;
			this.symbolizersByLabel.hovered = opts.extendWithRule.hovered;
			this.symbolizersByLabel.found = opts.extendWithRule.found;

		} else {
			this.symbolizersByLabel.normal = new Symbolizer();
			this.symbolizersByLabel.selected = new Symbolizer();
			this.symbolizersByLabel.hovered = new Symbolizer();
			this.symbolizersByLabel.found = new Symbolizer();
		};
	},

	getSymbolizer: function(ctxt){
		var label = 'normal';
		if( ctxt.n2_selected || ctxt.n2_derived_selected ){
			label = '$selected';
			if( ctxt.n2_found ){
				label = '$selectedFound';
				if( ctxt.n2_hovered || ctxt.n2_derived_hovered ){
					label = '$selectedFoundHovered';
				};
			} else if( ctxt.n2_hovered || ctxt.n2_derived_hovered ){
				label = '$selectedHovered';
			};
		} else if( ctxt.n2_found ){
			label = '$found';
			if( ctxt.n2_hovered || ctxt.n2_derived_hovered ){
				label = '$foundHovered';
			};
		} else if( ctxt.n2_hovered || ctxt.n2_derived_hovered ){
			label = '$hovered';
		};
		
		return this._getSymbolizerFromLabel(label);
	},

	_getSymbolizerFromLabel: function(label){
		var symbolizer = this.symbolizersByLabel[label];
		
		if( !symbolizer ){
			// Need to compute it
			if( 'normal' === label ){
				symbolizer = new Symbolizer();
				
			} else if( '$hovered' === label ){
				// $hovered = normal + hovered
				var s1 = this._getSymbolizerFromLabel('normal');
				symbolizer = new Symbolizer(s1, this.symbolizersByLabel.hovered);
				
			} else if( '$found' === label ){
				// $found = normal + found
				var s1 = this._getSymbolizerFromLabel('normal');
				symbolizer = new Symbolizer(s1, this.symbolizersByLabel.found);
				
			} else if( '$selected' === label ){
				// $selected = normal + selected
				var s1 = this._getSymbolizerFromLabel('normal');
				symbolizer = new Symbolizer(s1, this.symbolizersByLabel.selected);
				
			} else if( '$selectedFound' === label ){
				// $selectedFound = $selected + found
				var s1 = this._getSymbolizerFromLabel('$selected');
				symbolizer = new Symbolizer(s1, this.symbolizersByLabel.found);
				
			} else if( '$selectedHovered' === label ){
				// $selectedHovered = $selected + hovered
				var s1 = this._getSymbolizerFromLabel('$selected');
				symbolizer = new Symbolizer(s1, this.symbolizersByLabel.hovered);
				
			} else if( '$foundHovered' === label ){
				// $foundHovered = $found + hovered
				var s1 = this._getSymbolizerFromLabel('$found');
				symbolizer = new Symbolizer(s1, this.symbolizersByLabel.hovered);
				
			} else if( '$selectedFoundHovered' === label ){
				// $selectedFoundHovered = $selectedFound + hovered
				var s1 = this._getSymbolizerFromLabel('$selectedFound');
				symbolizer = new Symbolizer(s1, this.symbolizersByLabel.hovered);
			};
			
			// Save computed symbolizer for next call
			if( symbolizer ){
				this.symbolizersByLabel[label] = symbolizer;
			};
		};
		
		return symbolizer;
	}
});

//--------------------------------------------------------------------------
var StyleRule = $n2.Class({
	
	condition: null,
	
	label: null,

	source: null,
	
	normal: null,
	
	selected: null,

	found: null,
	
	hovered: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			condition: null
			,label: null
			,source: null
			,normal: null
			,selected: null
			,found: null
			,hovered: null
		},opts_);
		
		this.condition = opts.condition;
		this.label = opts.label;
		this.source = opts.source;
		this.normal = new Symbolizer(opts.normal);
		this.selected = new Symbolizer(opts.selected);
		this.found = new Symbolizer(opts.found);
		this.hovered = new Symbolizer(opts.hovered);
	},
	
	isValidForContext: function(ctxt){
		if( !this.condition ){
			return false;
		};
		try {
			var result = this.condition.getValue(ctxt);
			return result;
		} catch(e) {
			return false;
		};
	}
});

//--------------------------------------------------------------------------
var StyleRules = $n2.Class({
	
	rules: null,
	
	cache: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			skipDefaults: false
		},opts_);
		
		this.rules = [];
		this.cache = {
			style: new Style({
				id: ''
			})
		};

		if( !opts.skipDefaults ) {
			var rule = loadRuleFromObject({
				condition: 'true'
				,normal: {
					'fillColor': '#ffffff'
					,'strokeColor': '#ee9999'
					,'strokeWidth': 2
					,'fillOpacity': 1
					,'strokeOpacity': 1
					,'strokeLinecap': 'round'
					,pointRadius: 6
					,pointerEvents: 'visiblePainted'
				}
				,selected: {
					'strokeColor': '#ff2200'
				}
				,found: {
					'strokeColor': '#00ffff'
					,'fillColor': '#00ffff'
				}
				,hovered: {
					'fillColor': '#0000ff'
				}
			});
			this.addRule(rule);

			var rule = loadRuleFromObject({
				condition: 'isLine()'
				,normal: {
					'fillColor': 'none'
				}
				,selected: {
					'fillColor': 'none'
				}
				,hovered:{
					'strokeColor': '#0000ff'
					,'fillColor': 'none'
				}
				,found: {
					'strokeColor': '#00ffff'
					,'fillColor': 'none'
				}
			});
			this.addRule(rule);
		};
	},
	
	addRule: function(rule){
		rule.id = $n2.getUniqueId();
		this.rules.push(rule);
	},
	
	/**
	 * ctxt: {
	 *    n2_selected: <boolean>
	 *    ,n2_hovered: <boolean>
	 *    ,n2_found: <boolean>
	 *    ,n2_intent: <null or string>
	 *    ,n2_doc: <object>
	 *    ,n2_elem: HTML element, SVG element, undefined
	 * }
	 */
	getSymbolizer: function(ctxt){
		var style = this.getStyle(ctxt);
		var symbolizer = style.getSymbolizer(ctxt);
		return symbolizer;
	},

	getStyle: function(ctxt){
		var stylePath = [];
		var current = this.cache;
		for(var i=0,e=this.rules.length; i<e; ++i){
			var rule = this.rules[i];
			if( rule.isValidForContext(ctxt) ){
				stylePath.push(''+i);
				if( !current[i] ){
					var style = new Style({
						id: stylePath.join('+')
						,basicStyle: current.style
						,extendWithRule: rule
					});
					current[i] = {};
					current[i].style = style;
				};
				current = current[i];
			};
		};
		return current.style;
	}
});

//--------------------------------------------------------------------------
function loadRuleFromObject(ruleObj){
	var condition = g_TrueNode;
	if( ruleObj.condition ){
		condition = $n2.styleRuleParser.parse(ruleObj.condition);
	};
	
	var rule = new StyleRule({
		condition: condition
		,label: ruleObj.label
		,source: ruleObj.condition
		,normal: ruleObj.normal ? ruleObj.normal : {}
		,selected: ruleObj.selected ? ruleObj.selected : {}
		,found: ruleObj.found ? ruleObj.found : {}
		,hovered: ruleObj.hovered ? ruleObj.hovered : {}
	});
	
	return rule;
};

//--------------------------------------------------------------------------
function loadRulesFromObject(arr, opts_){
	var rules = [];
	if( arr ){
		for(var i=0,e=arr.length; i<e; ++i){
			var ruleObj = arr[i];
			try {
				var rule = loadRuleFromObject(ruleObj);
				rules.push(rule);
			} catch(e) {
				$n2.log('Error trying to load style rule: '+e);
			};
		};
	};
	
	var styleRules = new StyleRules(opts_);
	for(var i=0,e=rules.length; i<e; ++i){
		var rule = rules[i];
		styleRules.addRule(rule);
	};
	
	return styleRules;
};

//--------------------------------------------------------------------------
$n2.styleRule = {
	loadRulesFromObject: loadRulesFromObject
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.svg.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.svg'
 ,XMLNS = "http://www.w3.org/2000/svg"
 ;
 
//--------------------------------------------------------------------------
// Thanks to OpenLayers 2
var PredefinedGraphicsByName = {
     "star": [350,75, 379,161, 469,161, 397,215, 423,301, 350,250, 277,301,
             303,215, 231,161, 321,161, 350,75],
     "cross": [4,0, 6,0, 6,4, 10,4, 10,6, 6,6, 6,10, 4,10, 4,6, 0,6, 0,4, 4,4,
             4,0],
     "x": [0,0, 25,0, 50,35, 75,0, 100,0, 65,50, 100,100, 75,100, 50,65, 25,100, 0,100, 35,50, 0,0],
     "square": [0,0, 0,1, 1,1, 1,0, 0,0],
     "triangle": [0,10, 10,10, 5,0, 0,10]
 };

//--------------------------------------------------------------------------
var PredefinedMarkersByName = {
	'endArrow': {
		attributes: {
			viewBox: '0 0 10 10'
			,refX: '1'
			,refY: '5'
			,markerWidth: '6' 
			,markerHeight: '6'
			,orient: 'auto'
		}
		,path: 'M 0 0 L 10 5 L 0 10 z'
	}
};

//--------------------------------------------------------------------------
// List of SVG presentation attributes served in a map for fast access
var presentationAttributeMap = {
	'alignment-baseline': true
	,'baseline-shift': true
	,'clip': true
	,'clip-path': true
	,'clip-rule': true
	,'color': true
	,'color-interpolation': true
	,'color-interpolation-filters': true
	,'color-profile': true
	,'color-rendering': true
	,'cursor': true
	,'direction': true
	,'display': true
	,'dominant-baseline': true
	,'enable-background': true
	,'fill': true
	,'fill-opacity': true
	,'fill-rule': true
	,'filter': true
	,'flood-color': true
	,'flood-opacity': true
	,'font-family': true
	,'font-size': true
	,'font-size-adjust': true
	,'font-stretch': true
	,'font-style': true
	,'font-variant': true
	,'font-weight': true
	,'glyph-orientation-horizontal': true
	,'glyph-orientation-vertical': true
	,'image-rendering': true
	,'kerning': true
	,'letter-spacing': true
	,'lighting-color': true
	,'marker-end': true
	,'marker-mid': true
	,'marker-start': true
	,'mask': true
	,'opacity': true
	,'overflow': true
	,'pointer-events': true
	,'shape-rendering': true
	,'stop-color': true
	,'stop-opacity': true
	,'stroke': true
	,'stroke-dasharray': true
	,'stroke-dashoffset': true
	,'stroke-linecap': true
	,'stroke-linejoin': true
	,'stroke-miterlimit': true
	,'stroke-opacity': true
	,'stroke-width': true
	,'text-anchor': true
	,'text-decoration': true
	,'text-rendering': true
	,'unicode-bidi': true
	,'visibility': true
	,'word-spacing': true
	,'writing-mode': true
};

//--------------------------------------------------------------------------
var Renderer = $n2.Class({
	
	svgElemId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			svgElem: null
			,svgElemId: null
		},opts_);
		
		this.svgElemId = opts.svgElemId;
		if( !this.svgElemId && opts.svgElem ){
			this.svgElemId = $n2.utils.getElementIdentifier(opts.svgElem);
		};
		if( !this.svgElemId ){
			throw 'SVG element must be provided';
		};
	},
	
	_getSvgElem: function(){
		return document.getElementById(this.svgElemId);
	},
	
	_getDefsElem: function(){
		var defsElem = null;
		
		var svgElem = this._getSvgElem();
		var childNodeList = svgElem.childNodes;
		for(var i=0,e=childNodeList.length; i<e; ++i){
			var child = childNodeList.item(i);
			if( 'defs' === child.localName.toLowerCase() ){
				defsElem = child;
			};
		};
		
		if( null === defsElem ){
			defsElem = this._createNode('defs');
			svgElem.appendChild(defsElem);
		};
		
		return defsElem;
	},
	
    _importGraphic: function (graphicName)  {
    	var defsElem = this._getDefsElem();

        var graphicId = this.svgElemId + "-graphic-" + graphicName;
        
        // Try to get by id
        var graphicNode = document.getElementById(graphicId);
        if( !graphicNode ) {
            var graphic = PredefinedGraphicsByName[graphicName];
            if (!graphic) {
                throw ('' + graphicName + ' is not a valid graphic name');
            }

            var graphicNode = this._createNode('symbol',graphicId);
            var node = this._createNode('polygon');
            graphicNode.appendChild(node);
            var maxx = null
             ,minx = null
             ,maxy = null
             ,miny = null
             ,points = []
             ,x,y;

            for (var i=0; i<graphic.length; i=i+2) {
                x = graphic[i];
                y = graphic[i+1];
                
                minx = (minx == null) ? x : Math.min(minx, x);
                maxx = (maxx == null) ? x : Math.max(maxx, x);
                miny = (miny == null) ? y : Math.min(miny, y);
                maxy = (maxy == null) ? y : Math.max(maxy, y);
            }
            
            var width = maxx - minx;
            var height = maxy - miny;
            var longestDim = width > height ? width : height;
            var factor = 2 / longestDim;
            var midX = (minx + maxx) / 2;
            var midY = (miny + maxy) / 2;

            for (var i=0; i<graphic.length; i=i+2) {
                x = (graphic[i] - midX) * factor;
                y = (graphic[i+1] - midY) * factor;
                
                if( i != 0 ){
                	points.push(' ');
                };
                points.push(x, ',', y);
            }
            
            node.setAttributeNS(null, 'points', points.join(''));
            
            graphicNode.setAttributeNS(null, 'viewBox', '-3 -3 6 6');
            
            defsElem.appendChild(graphicNode);
        };
        
        return graphicNode;
    },
	
    _importMarker: function (markerName)  {
    	var defsElem = this._getDefsElem();

        var markerId = this.svgElemId + "-marker-" + markerName;
        
        // Try to get by id
        var markerNode = document.getElementById(markerId);
        if( !markerNode ) {
            var marker = PredefinedMarkersByName[markerName];
            if (!marker) {
                throw ('' + markerName + ' is not a valid marker name');
            }

            var markerNode = this._createNode('marker',markerId);
			if( marker.attributes ){
				for(var markerAttributeName in marker.attributes){
					var markerAttributeValue = marker.attributes[markerAttributeName];
					markerNode.setAttributeNS(null, markerAttributeName, markerAttributeValue);
				};
			};

            if( marker.path ){
                var path = this._createNode('path');
    			path.setAttributeNS(null, 'd', marker.path);
                markerNode.appendChild(path);
            };

            defsElem.appendChild(markerNode);
        };
        
        return markerNode;
    },
	
	_createNode: function(name, id){
        var node = document.createElementNS(XMLNS, name);
        if (id) {
            node.setAttributeNS(null, "id", id);
        }
        return node;    
	}
});

var svgNs = 'http://www.w3.org/2000/svg';
var xlinkNs = 'http://www.w3.org/1999/xlink';

function createSVGNode(type, id) {
    var node = null;
    if( document.createElementNS ) {
        node = document.createElementNS(svgNs, type);
        if (id) {
            node.setAttributeNS(null, 'id', id);
        };
    };
    return node;    
};

function setAttr(node, name, value) {
	node.setAttributeNS(null, name, value);
};

function setAttrNS(node, ns, name, value) {
	node.setAttributeNS(ns, name, value);
};

function addClass(elem, className) {
	var classNames = [];
	
	if( elem.className ){
		var currentClasses = '' + elem.className;
		classNames = currentClasses.split(' ');
	};
	
	classNames.push(className);
	
	elem.className = classNames.join(' ');
};

//--------------------------------------------------------------------------
$n2.svg = {
	Renderer: Renderer
	,svgNs: svgNs
	,xlinkNs: xlinkNs
	,createSVGNode: createSVGNode
	,setAttr: setAttr
	,setAttrNS: setAttrNS
	,addClass: addClass
	,presentationAttributeMap: presentationAttributeMap
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.mail.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.mail'
 ;

var MailService = $n2.Class({
	
	url: null,
	
	dispatchService: null,
	
	customService: null,
	
	welcome: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			url: null
			,dispatchService: null
			,customService: null
		},opts_);
		
		var _this = this;
		
		this.url = opts.url;
		this.dispatchService = opts.dispatchService;
		this.customService = opts.customService;
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH,'mailShowMailForm',f);
			this.dispatchService.register(DH,'showPreprocessElement',f);
		};

		this.getWelcome({
			onSuccess: function(welcome){
				$n2.log('mail service',welcome);
			}
		});
	},
	
	getWelcome: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(welcome){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		if( this.welcome ){
			opts.onSuccess( this.welcome );
		} else {
			$.ajax({
				url: this.url
				,type: 'get'
				,async: true
				,dataType: 'json'
				,success: function(res) {
					if( res.ok ) {
						_this.welcome = res;
						opts.onSuccess(res);
					} else {
						opts.onError('Malformed welcome reported');
					};
				}
				,error: function(XMLHttpRequest, textStatus, errorThrown) {
					var errStr = $n2.utils.parseHttpJsonError(XMLHttpRequest, textStatus);
					opts.onError('Error obtaining welcome: '+errStr);
				}
			});
		};
	},
	
	formEmailAvailable: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(available){}
			,onError: function(err){}
		},opts_);
		
		this.getWelcome({
			onSuccess: function(welcome){
				var available = false;
				
				if( welcome.ok 
				 && welcome.configured 
				 && welcome.defaultRecipientCount > 0 ){
					available = true;
				};
				
				opts.onSuccess(available);
			}
			,onError: opts.onError
		});
	},
	
	sendFormEmail: function(opts_){
		var opts = $n2.extend({
			destination: null
			,subject: null
			,contact: null
			,message: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var request = {};
		if( opts.destination ){
			request.destination = opts.destination;
		};
		if( opts.contact ){
			request.contact = opts.contact;
		};
		if( opts.message ){
			request.body = opts.message;
		};
		if( opts.subject ){
			request.subject = opts.subject;
		};
		
		if( !request.contact 
		 || (typeof request.contact === 'string' && request.contact.length < 1) ){
			opts.onError( _loc('You must provide contact information') );
			return;
		};
		
		if( !request.body 
		 || (typeof request.body === 'string' && request.body.length < 1) ){
			opts.onError( _loc('You must provide a message') );
			return;
		};
		
		if( request.subject 
		 && typeof request.subject !== 'string' ){
			opts.onError( _loc('The mail subject, if specified, must be a string') );
			return;
		};
		
		$.ajax({
			url: this.url + 'sendFormMail'
			,type: 'post'
			,async: true
			,dataType: 'json'
			,data: request
			,success: function(res) {
				if( res.ok ) {
					opts.onSuccess(res);
				} else {
					opts.onError('Problem: '+res.error);
				};
			}
			,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = $n2.utils.parseHttpJsonError(XMLHttpRequest, textStatus);
				if( typeof errStr === 'object' && errStr.error ){
					errStr = errStr.error;
				};
				opts.onError('Error sending form e-mail: '+errStr);
			}
		});
	},
	
	_getMailFormContactFields: function(){
		var formContactFields = null;
		
		if( this.customService ){
			formContactFields = this.customService.getOption('mailFormContactFields');
		};
		
		// Default
		if( !$n2.isArray(formContactFields) ){
			formContactFields = [{
				"name": "contact_info"
				,"label": _loc('Contact Information')
				,"placeholder": _loc('Information to contact you')
				,"required": true
				,"textarea": true
			}];
		};
		
		return formContactFields;
	},
	
	showMailForm: function(){
		var _this = this;

		var subject = undefined;
		if( this.customService ){
			subject = this.customService.getOption('mailFormSubject',undefined);
		};
		
		var formContactFields = this._getMailFormContactFields();
		
		var diagId = $n2.getUniqueId();
		var $diag = $('<div>')
			.addClass('n2mailForm_dialog')
			.attr('id',diagId)
			.appendTo( $('body') );

		var $content = $('<div>')
			.addClass('n2mailForm_content')
			.appendTo( $diag );

		if( formContactFields ){
			for(var i=0,e=formContactFields.length; i<e; ++i){
				var contactField = formContactFields[i];
				if( !contactField.name ){
					continue;
				};
				var label = contactField.label;
				if( !label ){
					label = contactField.name;
				};
				
				var labelClassName = 'n2mailForm_label_' + $n2.utils.stringToHtmlId(contactField.name);
				var inputClassName = 'n2mailForm_input_' + $n2.utils.stringToHtmlId(contactField.name);

				$('<div>')
					.addClass('n2mailForm_label '+labelClassName)
					.text( label )
					.appendTo($content);
				
				var $input = null;
				if( contactField.textarea ){
					$input = $('<textarea>')
						.attr('placeholder', _loc('Information to contact you'))
						.appendTo($content);
				} else {
					$input = $('<input>')
						.attr('type', 'text')
						.appendTo($content);
				};
				
				$input
					.addClass('n2mailForm_input n2mailForm_processing_element '+inputClassName)
					.attr('name',contactField.name);
				
				if( contactField.placeholder ){
					$input.attr('placeholder', contactField.placeholder);
				};
			};
		};
		
		$('<div>')
			.addClass('n2mailForm_label')
			.text( _loc('Message') )
			.appendTo($content);
		
		$('<textarea>')
			.addClass('n2mailForm_input n2mailForm_processing_element n2mailForm_input_message')
			.appendTo($content);
		
		var $buttons = $('<div>')
			.addClass('n2mailForm_buttons')
			.appendTo($diag);
		
		$('<a>')
			.addClass('n2mailForm_button n2mailForm_button_cancel')
			.text( _loc('Cancel') )
			.attr('href','#')
			.appendTo($buttons)
			.click(function(){
				var $diag = $('#'+diagId);
				$diag.dialog('close');
				return false;
			});
		
		$('<a>')
			.addClass('n2mailForm_button n2mailForm_button_send')
			.text( _loc('Send') )
			.attr('href','#')
			.appendTo($buttons)
			.click(function(){
				var $diag = $('#'+diagId);
				$diag.find('.n2mailForm_processing_element').attr('disabled','disabled');
				$diag.find('.n2mailForm_button').addClass('n2mailForm_button_disabled');
				
				var contact = [];
				if( formContactFields ){
					for(var i=0,e=formContactFields.length; i<e; ++i){
						var contactField = formContactFields[i];
						if( !contactField.name ){
							continue;
						};
						var label = contactField.label;
						if( !label ){
							label = contactField.name;
						};
						
						var inputClassName = 'n2mailForm_input_' + $n2.utils.stringToHtmlId(contactField.name);
						var value = $diag.find('.'+inputClassName).val();
						
						if( contactField.required ){
							if( !value || value === '' ){
								alert( _loc('You must provide field: {label}',{
									label: label
								}) );
								$diag.find('.n2mailForm_processing_element').removeAttr('disabled');
								$diag.find('.n2mailForm_button').removeClass('n2mailForm_button_disabled');
								return;
							};
						};
						
						contact.push({
							"name": contactField.name
							,"value": value
						});
					};
				};
				var message = $diag.find('.n2mailForm_input_message').val();
				
				_this.sendFormEmail({
					destination: null
					,subject: subject
					,contact: JSON.stringify(contact)
					,message: message
					,onSuccess: function(){
						var $diag = $('#'+diagId);
						$diag.find('.n2mailForm_content')
							.empty()
							.text(_loc('Your message was sent'));
						var $buttons = $diag.find('.n2mailForm_buttons')
							.empty();

						$('<a>')
							.addClass('n2mailForm_button n2mailForm_button_close')
							.text( _loc('Close') )
							.attr('href','#')
							.appendTo($buttons)
							.click(function(){
								var $diag = $('#'+diagId);
								$diag.dialog('close');
							});
					}
					,onError: function(err){
						alert( _loc('Unable to send e-mail: {err}',{
							err: err
						}) );
						var $diag = $('#'+diagId);
						$diag.find('.n2mailForm_processing_element').removeAttr('disabled');
						$diag.find('.n2mailForm_button').removeClass('n2mailForm_button_disabled');
					}
				});
				
				return false;
			});

		var title = null;
		if( this.customService ){
			title = this.customService.getOption('mailFormTitle',null);
		};
		if( typeof title !== 'string' ){
			title = _loc('E-mail Form');
		};
		
		$diag.dialog({
			autoOpen: true
			,title: title
			,modal: true
			,width: 'auto'
			,close: function(event, ui){
				var $diag = $('#'+diagId);
				$diag.remove();
			}
		});
	},
	
	_insertMailFormButton: function($elem){
		var _this = this;
		
		$elem.empty();
		var elemId = $n2.utils.getElementIdentifier($elem);
		
		var label = $elem.attr('nunaliit-label');
		if( !label ){
			label = _loc('Send us information');
		};
		
		this.formEmailAvailable({
			onSuccess: function(available){
				if( available && _this.dispatchService ){
					var $elem = $('#'+elemId);
					
					$('<a>')
						.addClass('n2mailFormButton')
						.attr('href','#')
						.text( label )
						.appendTo($elem)
						.click(function(){
							_this.dispatchService.send(DH,{
								type: 'mailShowMailForm'
							});
							return false;
						});
				};
			}
			,onError: function(err){}
		});
	},
	
	_showPreprocessElement: function($elem){
		var _this = this;
		
		var $set = $elem.find('*').addBack();
		
		$set.filter('.n2s_insertMailFormButton').each(function(){
			var $jq = $(this);
			_this._insertMailFormButton($jq);
			$jq.removeClass('n2s_insertMailFormButton').addClass('n2s_insertedMailFormButton');
		});
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'mailShowMailForm' === m.type ){
			this.showMailForm();

		} else if( 'showPreprocessElement' === m.type ){
			var $elem = m.elem;
			this._showPreprocessElement($elem);
		};
	}
});
 
//--------------------------------------------------------------------------
$n2.mail = {
	MailService: MailService
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.instance.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.instance'
 ;

//--------------------------------------------------------------------------
var Service = $n2.Class({
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;

		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'instanceCreate',f);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'instanceCreate' === m.type ){
			if( typeof m.instanceConfiguration !== 'object' ){
				$n2.log('instanceConfiguration must be provided when creating an instance');
				return;
			};

			if( typeof m.instanceConfiguration.type !== 'string' ){
				$n2.log('instanceConfiguration.type must be a string when creating an instance');
				return;
			};
			
			if( $n2.mapInitialBounds 
			 && typeof $n2.mapInitialBounds.handleInstanceCreate === 'function' ){
				$n2.mapInitialBounds.handleInstanceCreate(m, addr, dispatcher);
			};
			
			if( $n2.utilitiesModel 
			 && typeof $n2.utilitiesModel.handleInstanceCreate === 'function' ){
				$n2.utilitiesModel.handleInstanceCreate(m, addr, dispatcher);
			};
		};
	}
});

//--------------------------------------------------------------------------
$n2.instance = {
	Service: Service
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.model.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.model'
 ;

//--------------------------------------------------------------------------
 /**
  * This class manages a parameter based on a model. A parameter supports
  * 3 events:
  * - get
  * - change
  * - set
  * 
  * The "get" event returns the current value of a parameter.
  * The "change" event is sent to the parameter, indicating the new value desired
  * by the user.
  * The "set" event is sent went the parameter value is modified.
  */
var ModelParameter = $n2.Class({

	model: null,
	
	parameterId: null,
	
	type: null,
	
	name: null,
	
	label: null,
	
	setFn: null,
	
	getFn: null,
	
	dispatchService: null,
	
	eventNameSet: null,
	
	eventNameGet: null,
	
	eventNameChange: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			model: null
			,modelId: null // optional
			,type: null
			,name: null
			,label: null
			,setFn: null
			,getFn: null
			,dispatchService: null
		},opts_);
	
		var _this = this;
		
		this.model = opts.model;
		this.type = opts.type;
		this.name = opts.name;
		this.label = opts.label;
		this.setFn = opts.setFn;
		this.getFn = opts.getFn;
		this.dispatchService = opts.dispatchService;
		
		var modelId = opts.modelId;
		if( !modelId ){
			modelId = $n2.getUniqueId('parameter_');
		};
		
		if( !this.label ){
			this.label = this.name;
		};
		
		this.parameterId = modelId + '_' + this.name;
		this.eventNameSet = this.parameterId + '_set';
		this.eventNameGet = this.parameterId + '_get';
		this.eventNameChange = this.parameterId + '_change';
		
		if( this.dispatchService ){
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, this.eventNameSet, fn);
			this.dispatchService.register(DH, this.eventNameGet, fn);
		};
	},

	getInfo: function(){
		var info = {
			parameterId: this.parameterId
			,type: this.type
			,name: this.name
			,label: this.label
			,setEvent: this.eventNameSet
			,getEvent: this.eventNameGet
			,changeEvent: this.eventNameChange
		};
		
		var effectiveValue = this._getValue();
		info.value = effectiveValue;
		
		return info;
	},

	sendUpdate: function(){
		var effectiveValue = this._getValue();
		this.dispatchService.send(DH, {
			type: this.eventNameChange
			,parameterId: this.parameterId
			,value: effectiveValue
		});
	},

	_getValue: function(){
		var value = null;
		
		if( this.getFn ){
			value = this.getFn.call(this.model);
		} else {
			value = this.model[this.name];
		};
		
		return value;
	},

	_setValue: function(value){
		if( this.setFn ){
			this.setFn.call(this.model, value);
		} else {
			this.model[this.name] = value;
			this.sendUpdate();
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( m.type === this.eventNameSet ){
			var value = m.value;
				
			this._setValue(value);
	 			
		} else if( m.type === this.eventNameGet ){
			var effectiveValue = this._getValue();
			m.value = effectiveValue;
		};
	}
});

//--------------------------------------------------------------------------
/**
 * This class implements a generic Observer to monitor a ParameterModel.
 * Build an instance of observer by providing the info structure obtained
 * by a model.
 */
var ModelParameterObserver = $n2.Class({

	dispatchService: null,
	
	onChangeFn: null,

	// Variables obtained from info
	
	parameterId: null,

	type: null,

	name: null,

	label: null,

	setEvent: null,
	
	getEvent: null,
	
	changeEvent: null,
	
	// Cached value that was observed last
	
	lastValue: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			parameterInfo: null
			,dispatchService: null
			,onChangeFn: null
		},opts_);
	
		var _this = this;
		
		this.onChangeFn = opts.onChangeFn;
		this.dispatchService = opts.dispatchService;
		this.lastValue = undefined;

		if( opts.parameterInfo 
		 && typeof opts.parameterInfo === 'object' ){
			this.parameterId = opts.parameterInfo.parameterId;
			this.type = opts.parameterInfo.type;
			this.name = opts.parameterInfo.name;
			this.label = opts.parameterInfo.label;
			this.setEvent = opts.parameterInfo.setEvent;
			this.getEvent = opts.parameterInfo.getEvent;
			this.changeEvent = opts.parameterInfo.changeEvent;
			this.lastValue = opts.parameterInfo.value;
		} else {
			throw new Error('parameterInfo must be provided');
		};

		if( this.dispatchService ){
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, this.changeEvent, fn);
		};
	},
	
	getValue: function(){
		return this.lastValue;
	},
	
	setValue: function(value){
		this.lastValue = value;

		this.dispatchService.send(DH, {
			type: this.setEvent
			,value: value
		});
	},

	_handle: function(m, addr, dispatcher){
		if( m.type === this.changeEvent  
		 && m.parameterId === this.parameterId ){
			var value = m.value;
			
			if( this.lastValue !== value ){
				var previousValue = this.lastValue;
				this.lastValue = value;
				if( typeof this.onChangeFn === 'function' ){
					this.onChangeFn(this.lastValue, previousValue);
				};
			};
		};
	}
});

//--------------------------------------------------------------------------
function getModelInfo(opts_){
	var opts = $n2.extend({
		dispatchService: null
		,modelId: null
	},opts_);
	
	var dispatchService = opts.dispatchService;
	var modelId = opts.modelId;
	
	if( !dispatchService ){
		throw new Error('dispatchService must be specified');
	};
	if( typeof modelId !== 'string' ){
		throw new Error('modelId must be specified');
	};

	var m = {
		type: 'modelGetInfo'
		,modelId: modelId
	};
	dispatchService.synchronousCall(DH,m);
	
	return m.modelInfo;
};

//--------------------------------------------------------------------------
function getModelState(opts_){
	var opts = $n2.extend({
		dispatchService: null
		,modelId: null
	},opts_);
	
	var dispatchService = opts.dispatchService;
	var modelId = opts.modelId;
	
	if( !dispatchService ){
		throw new Error('dispatchService must be specified');
	};
	if( typeof modelId !== 'string' ){
		throw new Error('modelId must be specified');
	};

	var m = {
		type: 'modelGetState'
		,modelId: modelId
	};
	dispatchService.synchronousCall(DH,m);
	
	return m.state;
};

//--------------------------------------------------------------------------
/*
 * This is an abstract class for a document model.
 */
var DocumentModel = $n2.Class('DocumentModel', {

	dispatchService: null,
	
	modelId: null,

	modelType: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,modelId: null
			,modelType: null
		},opts_);
	
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.modelType = opts.modelType;

		if( typeof this.modelId !== 'string' ){
			throw new Error('modelId must be specified and it must be a string');
		};

		if( this.dispatchService ){
			this.dispatchService.register(DH, 'modelGetInfo', function(m, addr, dispatcher){
				if( m.modelId === _this.modelId ){
					m.modelInfo = _this._getModelInfo();
				}
			});
			this.dispatchService.register(DH, 'modelGetState', function(m, addr, dispatcher){
				if( m.modelId === _this.modelId ){
					var currentDocs = _this._getCurrentDocuments();
					m.state = {
						added: currentDocs
						,updated: []
						,removed: []
						,loading: _this._isLoading()
					};
				}
			});
		};
	},

	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: this.modelType
			,parameters: {}
		};
		
		this._addModelInfoParameters(info);
		
		return info;
	},
	
	_addModelInfoParameters: function(info){
	},

	/**
	 * This method should be used by sub-classes to report the changes
	 * in the current state.
	 * @param added Array of documents that were added
	 * @param updated Array of documents that were modified since last state report
	 * @param removed Array of documents that were removed from the state
	 */
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this._isLoading()
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	/*
	 * Return an array of documents that represent the current state of the model
	 */
	_getCurrentDocuments: function(){
		throw new Error('Subclasses must implement the method _getCurrentDocuments()');
	},
	
	/*
	 * Returns true if the model is currently loading
	 */
	_isLoading: function(){
		throw new Error('Subclasses must implement the method _isLoading()');
	}
});

//--------------------------------------------------------------------------
/*
 * This is an observer for a document model. It registers to a document model
 * identified by the sourceModelId. The observer can be queried for the currently
 * observed documents. 
 */
var DocumentModelObserver = $n2.Class('DocumentModelObserver', {

	dispatchService: null,
	
	sourceModelId: null,
	
	modelIsLoading: null,
	
	docsById: null,
	
	updatedCallback: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,sourceModelId: null
			,updatedCallback: null
		},opts_);
	
		var _this = this;
		
		this.docsById = {};
		this.modelIsLoading = false;
		
		this.dispatchService = opts.dispatchService;
		this.sourceModelId = opts.sourceModelId;
		this.updatedCallback = opts.updatedCallback;

		if( typeof this.sourceModelId !== 'string' ){
			throw new Error('sourceModelId must be specified and it must be a string');
		};

		if( this.dispatchService ){
			this.dispatchService.register(DH, 'modelStateUpdated', function(m, addr, dispatcher){
				if( _this.sourceModelId === m.modelId ){
					_this._sourceModelUpdated(m.state);
				};
			});
			
			// Get current state
			var state = $n2.model.getModelState({
				dispatchService: this.dispatchService
				,modelId: this.sourceModelId
			});
			if( state ){
				this._sourceModelUpdated(state);
			};
		};
	},
	
	getDocuments: function(){
		var docs = [];
		for(var docId in this.docsById){
			var doc = this.docsById[docId];
			docs[docs.length] = doc;
		};
		return docs;
	},
	
	_sourceModelUpdated: function(sourceState){
		
		var _this = this;
		
		if( typeof sourceState.loading === 'boolean'
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};
		
		// Loop through all added documents
		if( $n2.isArray(sourceState.added) ){
			sourceState.added.forEach(function(doc){
				var docId = doc._id;
				
				_this.docsById[docId] = doc;
			});
		};
		
		// Loop through all updated documents
		if( $n2.isArray(sourceState.updated) ){
			sourceState.updated.forEach(function(doc){
				var docId = doc._id;
				
				_this.docsById[docId] = doc;
			});
		};
		
		// Loop through all removed documents
		if( $n2.isArray(sourceState.removed) ){
			sourceState.removed.forEach(function(doc){
				var docId = doc._id;
				
				delete _this.docsById[docId];
			});
		};
		
		this._documentUpdated(sourceState);
	},
	
	isLoading: function(){
		return this.modelIsLoading;
	},
	
	/*
	 * Called when there is a change in the document set
	 */
	_documentUpdated: function(sourceState){
		if( typeof this.updatedCallback === 'function' ){
			this.updatedCallback(sourceState, this.sourceModelId);
		};
	}
});

//--------------------------------------------------------------------------
var MODEL_CONFIRMED = '__confirmed__';
var MODEL_SUSPECTED = '__suspected__';
var Service = $n2.Class({
	
	dispatchService: null,
	
	modelIdMap: null,
	
	modelIds: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;

		this.modelIdMap = {};
		this.modelIds = [];
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelCreate',f);
			this.dispatchService.register(DH,'modelStateUpdated',f);
			this.dispatchService.register(DH,'modelGetList',f);
			this.dispatchService.register(DH,'modelGetState',f);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelCreate' === m.type ){
			if( ! m.modelType ){
				$n2.log('modelType must be provided when creating a model');
				return;
			};
			
			if( ! m.modelId ){
				$n2.log('modelId must be provided when creating a model: '+m.modelType);
				return;
			};
			
			// Suspect this model id
			if( !this.modelIdMap[m.modelId] ){
				this.modelIdMap[m.modelId] = MODEL_SUSPECTED;
			};

			if( $n2.modelFilter && typeof $n2.modelFilter.handleModelCreate === 'function' ){
				$n2.modelFilter.handleModelCreate(m, addr, dispatcher);
			};
			
			if( $n2.modelUtils && typeof $n2.modelUtils.handleModelCreate === 'function' ){
				$n2.modelUtils.handleModelCreate(m, addr, dispatcher);
			};

			if( $n2.modelTime && typeof $n2.modelTime.handleModelCreate === 'function' ){
				$n2.modelTime.handleModelCreate(m, addr, dispatcher);
			};

			if( $n2.modelLayer && typeof $n2.modelLayer.handleModelCreate === 'function' ){
				$n2.modelLayer.handleModelCreate(m, addr, dispatcher);
			};

			if( $n2.couchDbPerspective && typeof $n2.couchDbPerspective.handleModelCreate === 'function' ){
				$n2.couchDbPerspective.handleModelCreate(m, addr, dispatcher);
			};

			if( $n2.modelFilterSimultaneous && typeof $n2.modelFilterSimultaneous.handleModelCreate === 'function' ){
				$n2.modelFilterSimultaneous.handleModelCreate(m, addr, dispatcher);
			};

		} else if( 'modelGetState' === m.type ){
			var modelId = m.modelId;

			// Suspect this model id
			if( !this.modelIdMap[m.modelId] ){
				this.modelIdMap[m.modelId] = MODEL_SUSPECTED;
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Keep track of model identifiers
			var modelId = m.modelId;
			if( modelId ){
				if( this.modelIdMap[modelId] !== MODEL_CONFIRMED ){
					this.modelIdMap[modelId] = MODEL_CONFIRMED;
					this.modelIds.push(modelId);
				};
			};

		} else if( 'modelGetList' === m.type ){
			// This is a synchronous request to find all model identifiers
			if( !m.modelIds ){
				m.modelIds = [];
			};
			
			// Attempt to confirm suspected models
			for(var modelId in this.modelIdMap){
				var state = this.modelIdMap[modelId];
				if( MODEL_SUSPECTED === state ){
					var msg = {
						type: 'modelGetInfo'
						,modelId: modelId
					};
					this.dispatchService.synchronousCall(DH,msg);
					
					if( msg.modelInfo ){
						this.modelIdMap[modelId] = MODEL_CONFIRMED;
						this.modelIds.push(modelId);
					};
				};
			};
			
			this.modelIds.forEach(function(modelId){
				m.modelIds.push(modelId);
			});
		};
	}
});

//--------------------------------------------------------------------------
$n2.model = {
	Service: Service
	,DocumentModel: DocumentModel
	,DocumentModelObserver: DocumentModelObserver
	,ModelParameter: ModelParameter
	,ModelParameterObserver: ModelParameterObserver
	,getModelInfo: getModelInfo
	,getModelState: getModelState
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.modelFilter.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.modelFilter'
 ;

//--------------------------------------------------------------------------
function FilterFunctionFromModelConfiguration(modelConf){
	if( 'filter' === modelConf.modelType ){
		if( modelConf.condition ) {
			var condition = $n2.styleRuleParser.parse(modelConf.condition);
			var ctxt = {
				n2_doc: null
				,n2_selected: false
				,n2_hovered: false
				,n2_found: false
				,n2_intent: null
			};
			var filterOnCondition = function(doc){
				// Re-use same context to avoid generating
				// temporary objects
				ctxt.n2_doc = doc;
				
				var value = condition.getValue(ctxt);

				ctxt.n2_doc = null;
				
				return value;
			};
			filterOnCondition.NAME = "filterOnCondition("+modelConf.condition+")";
			
			return filterOnCondition;
			
		} else if( 'all' === modelConf.useBuiltInFunction ){
			var allDocuments = function(doc){
				return true;
			};
			allDocuments.NAME = "allDocuments";
			
			return allDocuments;
			
		} else if( 'none' === modelConf.useBuiltInFunction ){
			var noDocument = function(doc){
				return false;
			};
			noDocument.NAME = "noDocument";
			
			return noDocument;
			
		} else if( 'withDates' === modelConf.useBuiltInFunction ){
			var withDates = function(doc){
				var dates = [];
				$n2.couchUtils.extractSpecificType(doc,'date',dates);
				return (dates.length > 0);
			};
			withDates.NAME = "withDates";
			
			return withDates;
			
		} else if( 'withoutDates' === modelConf.useBuiltInFunction ){
			var withoutDates = function(doc){
				var dates = [];
				$n2.couchUtils.extractSpecificType(doc,'date',dates);
				return (dates.length < 1);
			};
			withoutDates.NAME = "withoutDates";
			
			return withoutDates;

		} else if( 'withoutGeometry' === modelConf.useBuiltInFunction ){
			var withoutGeometry = function(doc){
				if( doc ){
					if( !doc.nunaliit_geom ){
						return true;
					};
				};
				return false;
			};
			withoutGeometry.NAME = "withoutGeometry";
			
			return withoutGeometry;
		};
	};
	
	return null;
};

//--------------------------------------------------------------------------
var ModelFilter = $n2.Class('ModelFilter',{
		
	dispatchService: null,

	modelId: null,
	
	sourceModelId: null,
	
	docInfosByDocId: null,
	
	modelIsLoading: null,
	
	filterFn: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,filterName: null
			,filterFn: null

			// From configuration
			,modelId: null
			,sourceModelId: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.sourceModelId = opts.sourceModelId;
		this.filterFn = opts.filterFn;
		this.filterName = opts.filterName;
		if( !this.filterName ){
			this.filterName = this._classname;
		};
		
		this.docInfosByDocId = {};
		this.modelIsLoading = false;

		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handleModelFilterEvents(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelGetInfo',f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			if( this.sourceModelId ){
				// Initialize state
				var state = $n2.model.getModelState({
					dispatchService: this.dispatchService
					,modelId: this.sourceModelId
				});
				if( state ){
					this._sourceModelUpdated(state);
				};
			};
		};
		
		$n2.log(this.filterName,this);
	},
	
	_handleModelFilterEvents: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
				m.modelInstance = this;
			};
			
		} else if( 'modelGetState' === m.type ){
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					if( docInfo.visible ){
						var doc = docInfo.doc;
						added.push(doc);
					};
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.modelIsLoading
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from one of our sources?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},
	
	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'filter'
			,parameters: {}
		};
		
		this._addModelInfoParameters(info);
		
		return info;
	},
	
	_addModelInfoParameters: function(info){
		// Used by sub-classes to add parameters
	},
	
	_sourceModelUpdated: function(sourceState){
		
		var added = []
			,updated = []
			,removed = []
			;

		if( typeof sourceState.loading === 'boolean' 
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};

		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;
	
				var docInfo = this.docInfosByDocId[docId];
				if( !docInfo ){
					docInfo = {
						id: docId
						,doc: doc
						,visible: false
					};
					this.docInfosByDocId[docId] = docInfo;
				};
				
				var visible = this._computeVisibility(doc);
				
				if( visible ){
					docInfo.visible = visible;
					added.push(doc);
				};
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
	
				var docInfo = this.docInfosByDocId[docId];
				if( !docInfo ){
					docInfo = {
						id: docId
						,doc: doc
						,visible: false
					};
					this.docInfosByDocId[docId] = docInfo;
				};
				
				// Update document
				docInfo.doc = doc;
				
				// Compute new visibility
				var visible = this._computeVisibility(doc);
				
				if( visible ){
					if( docInfo.visible ){
						// Is visible and used to be visible: update
						updated.push(doc);
					} else {
						// Is visible and did not used to be visible: added
						added.push(doc);
					};
				} else {
					if( docInfo.visible ){
						// Is not visible and used to be visible: remove
						removed.push(doc);
					} else {
						// Is not visible and did not used to be visible: nothing
					};
				};
				
				// Update visibility
				docInfo.visible = visible;
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					delete this.docInfosByDocId[docId];
					
					if( docInfo.visible ){
						// Has been removed, but used to be visible: remove
						removed.push(doc);
					};
				};
			};
		};

		this._reportStateUpdate(added, updated, removed);
	},
	
	/*
	 * This function should be called if the conditions of the underlying filter
	 * have changed. Recompute visibility on all documents and report a state update
	 */
	_filterChanged: function(){
		
		var added = []
			,updated = []
			,removed = []
			;

		// Loop through all documents
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;
			
			// Compute new visibility
			var visible = this._computeVisibility(doc);
			
			if( visible ){
				if( docInfo.visible ){
					// Is visible and used to be visible: nothing
				} else {
					// Is visible and did not used to be visible: added
					added.push(doc);
				};
			} else {
				if( docInfo.visible ){
					// Is not visible and used to be visible: remove
					removed.push(doc);
				} else {
					// Is not visible and did not used to be visible: nothing
				};
			};
			
			// Update visibility
			docInfo.visible = visible;
		};

		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.modelIsLoading
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_computeVisibility: function(doc){
		var visible = false;
		
		if( this.filterFn ){
			if( this.filterFn(doc) ){
				visible = true;
			};
		};
		
		return visible;
	}
});

//--------------------------------------------------------------------------
/*
 * Filter: a Document Model that filters out certain document
 * SchemaFilter: Allows documents that are identified by schema names
 */
var SchemaFilterLegacy = $n2.Class('SchemaFilterLegacy', ModelFilter, {
		
	schemaNameMap: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null

			// From configuration
			,modelId: null
			,sourceModelId: null
			,schemaName: null
			,schemaNames: null
		},opts_);
		
		var _this = this;
		
		this.schemaNameMap = {};
		if( typeof opts.schemaName === 'string' ){
			this.schemaNameMap[opts.schemaName] = true;
		};
		if( $n2.isArray(opts.schemaNames) ){
			for(var i=0,e=opts.schemaNames.length; i<e; ++i){
				var schemaName = opts.schemaNames[i];
				if( typeof schemaName === 'string' ){
					this.schemaNameMap[schemaName] = true;
				};
			};
		};
		
		opts.filterFn = function(doc){
			return _this._isDocVisible(doc);
		};
		opts.filterName = 'SchemaFilterLegacy';
		
		ModelFilter.prototype.initialize.call(this,opts);
	},
	
	_isDocVisible: function(doc){
		if( doc && doc.nunaliit_schema ){
			if( this.schemaNameMap[doc.nunaliit_schema] ){
				return true;
			};
		};
		return false;
	}
});

//--------------------------------------------------------------------------
/*
* Filter: a Document Model that filters out certain documents
* ReferenceFilter: Allows documents that are identified by references
*/
var ReferenceFilter = $n2.Class(ModelFilter, {
		
	referenceMap: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null

			// From configuration
			,modelId: null
			,sourceModelId: null
			,reference: null
			,references: null
		},opts_);
		
		var _this = this;
		
		this.referenceMap = {};
		if( typeof opts.reference === 'string' ){
			this.referenceMap[opts.reference] = true;
		};
		if( $n2.isArray(opts.references) ){
			for(var i=0,e=opts.references.length; i<e; ++i){
				var reference = opts.references[i];
				if( typeof reference === 'string' ){
					this.referenceMap[reference] = true;
				};
			};
		};
		
		opts.filterFn = function(doc){
			return _this._isDocVisible(doc);
		};
		opts.filterName = 'ReferenceFilter';
		
		ModelFilter.prototype.initialize.call(this,opts);
	},

	getReferences: function(){
		var references = [];
		for(var ref in this.referenceMap){
			references.push(ref);
		};
		return references;
	},

	setReferences: function(references){
		this.referenceMap = {};
		for(var i=0,e=references.length; i<e; ++i){
			var ref = references[i];
			this.referenceMap[ref] = true;
		};

		this._filterChanged();
	},
	
	_isDocVisible: function(doc){
		if( doc ){
			var links = [];
			$n2.couchUtils.extractLinks(doc, links);
			for(var i=0,e=links.length; i<e; ++i){
				var refId = links[i].doc;
				if( this.referenceMap[refId] ){
					return true;
				};
			};
		};
		return false;
	}
});

//--------------------------------------------------------------------------
/*
* Filter: a Document Model that filters out certain documents
* SingleDocumentFilter: Allows only one specified document
*/
var SingleDocumentFilter = $n2.Class(ModelFilter, {

	selectedDocParameter: null,

	selectedDocId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null

			// From configuration
			,modelId: null
			,sourceModelId: null
			,selectedDocId: null
		},opts_);
		
		var _this = this;
		
		this.selectedDocId = opts.selectedDocId;
		
		this.selectedDocParameter = new $n2.model.ModelParameter({
			model: this
			,type: 'string'
			,name: 'selectedDocumentId'
			,label: 'Selected Document Id'
			,setFn: function(docId){
				_this._setSelectedDocId(docId);
			}
			,getFn: function(){
				return _this._getSelectedDocId();
			}
			,dispatchService: opts.dispatchService
		});
		
		opts.filterFn = function(doc){
			return _this._isDocVisible(doc);
		};
		opts.filterName = 'SingleDocumentFilter';
		
		ModelFilter.prototype.initialize.call(this,opts);
	},
	
	_getSelectedDocId: function(){
		return this.selectedDocId;
	},
	
	_setSelectedDocId: function(docId){
		this.selectedDocId = docId;
		
		this._filterChanged();
	},
	
	_addModelInfoParameters: function(info){
		info.parameters.selectedDocumentId = this.selectedDocParameter.getInfo();
	},
	
	_isDocVisible: function(doc){
		if( doc && doc._id === this.selectedDocId ){
			return true;
		};
		return false;
	}
});

//--------------------------------------------------------------------------
/*
* Filter: a Document Model that filters out certain documents
* 
* SelectableDocumentFilter: Allows a user to choose which document to
* allow through using a set of choices. These choices can be changed
* using a widget.
* 
* Abstract Class. Subclasses must implement the following methods:
* - _computeAvailableChoicesFromDocs
* - _isDocVisible
* 
* Sublcasses may implement the following methods (optional):
* - _selectionChanged : Called when a change in selection is detected
* 
* Options:
* - modelId: String. Identifier for this model
* - sourceModelId: String. Identifier for the model where documents are obtained
* - initialSelection: Optional array of strings. If specified, the choices specified in the
*                     array are initially selected. The strings in the array are choice identifiers.
* - saveSelection: Optional object { enabled: <boolean>, name: <string> }. If specified, the 
*                  last selection is saved to local storage. When the model is reloaded, the saved
*                  selection is restored. If this option is enabled and a selection is restored,
*                  then the option "initialSelection" is ignored.
*/
var SelectableDocumentFilter = $n2.Class('SelectableDocumentFilter', {

	dispatchService: undefined,

	modelId: undefined,
	
	sourceModelId: undefined,
	
	saveSelection: undefined,
	
	saveSelectionName: undefined,

	docInfosByDocId: undefined,
	
	selectedChoicesParameter: undefined,

	allSelectedParameter: undefined,
	
	availableChoicesParameter: undefined,
	
	selectedChoiceIdMap: undefined,
	
	allSelected: undefined,

	availableChoices: undefined,
	
	modelIsLoading: undefined,

	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null

			// From configuration
			,modelId: null
			,sourceModelId: null
			,initialSelection: null
			,saveSelection: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.sourceModelId = opts.sourceModelId;
		
		this.saveSelection = false;
		this.saveSelectionName = this.modelId;
		if( typeof opts.saveSelection === 'string' ){
			this.saveSelection = true;
			this.saveSelectionName = opts.saveSelection;

		} else if( typeof opts.saveSelection === 'boolean' ){
			if( opts.saveSelection ){
				this.saveSelection = true;
			};

		} else if( opts.saveSelection === null ){

		} else if( typeof opts.saveSelection === 'object' ){
			if( opts.saveSelection.enabled ){
				this.saveSelection = true;
				if( typeof opts.saveSelection.name === 'string' ){
					this.saveSelectionName = opts.saveSelection.name;
				};
			};
		};
		
		this.docInfosByDocId = {};
		this.selectedChoiceIdMap = {};
		this.allSelected = true;
		this.availableChoices = [];
		this.modelIsLoading = false;

		// Compute initial selection
		var initialSelectionComputed = false;
		var initialSelection;
		if( this.saveSelection ){
			var localStorage = $n2.storage.getLocalStorage();
			var jsonSelection = localStorage.getItem(this.saveSelectionName);
			if( '__ALL__' === jsonSelection ){
				// All was selected.
				initialSelectionComputed = true;
				this.allSelected = true;
				initialSelection = [];
			} else if( jsonSelection ){
				try {
					var loadedSelection = JSON.parse(jsonSelection);
					if( $n2.isArray(loadedSelection) ) {
						initialSelectionComputed = true;
						this.allSelected = false;
						initialSelection = loadedSelection;
					} else {
						$n2.logError('Unexpected initial selection loaded',loadedSelection);
					};
				} catch(e) {
					$n2.logError('Error while parsing JSON selection '+this.saveSelectionName,e);
				};
			};
		};
		if( !initialSelectionComputed && $n2.isArray(opts.initialSelection) ){
			initialSelectionComputed = true;
			this.allSelected = false;
			initialSelection = [];
			opts.initialSelection.forEach(function(choiceId){
				if( typeof choiceId === 'string' ){
					initialSelection.push(choiceId);
				} else {
					$n2.log('Error: SelectableDocumentFilter initialized with initial selection: '+choiceId);
				};
			});
		};
		if( !initialSelectionComputed ){
			// Default behaviour
			initialSelectionComputed = true;
			this.allSelected = true;
			initialSelection = [];
		};
		// Update selection objects
		initialSelection.forEach(function(choiceId){
			if( typeof choiceId === 'string' ){

				if( choiceId === "__ALL_CHOICES__" ){
					_this.allSelected = true;
				} else {
					_this.selectedChoiceIdMap[choiceId] = true;
					_this.availableChoices.push({
						id: choiceId
						,label: choiceId
					});
				};
			};
		});
		
		this.selectedChoicesParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.modelId
			,type: 'strings'
			,name: 'selectedChoices'
			,label: _loc('Choices')
			,setFn: this._setSelectedChoices
			,getFn: this.getSelectedChoices
			,dispatchService: this.dispatchService
		});
		
		this.allSelectedParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.modelId
			,type: 'boolean'
			,name: 'allSelected'
			,label: _loc('All Selected')
			,setFn: this._setAllSelected
			,getFn: this.getAllSelected
			,dispatchService: this.dispatchService
		});
		
		this.availableChoicesParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.modelId
			,type: 'objects'
			,name: 'availableChoices'
			,label: _loc('Available Choices')
			,setFn: this._setAvailableChoices
			,getFn: this.getAvailableChoices
			,dispatchService: this.dispatchService
		});
		

		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handleSelectableDocumentFilterEvents(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelGetInfo',f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			if( this.sourceModelId ){
				// Initialize state
				var state = $n2.model.getModelState({
					dispatchService: this.dispatchService
					,modelId: this.sourceModelId
				});
				if( state ){
					this._sourceModelUpdated(state);
				};
			};
		};
		
		$n2.log(this._classname,this);
	},
	
	getSelectedChoices: function(){
		var selectedChoices = [];
		for(var choiceId in this.selectedChoiceIdMap){
			selectedChoices.push(choiceId);
		};
		selectedChoices.sort();
		return selectedChoices;
	},

	_setSelectedChoices: function(choiceIdArray){
		var _this = this;
		
		if( !$n2.isArray(choiceIdArray) ){
			throw new Error('SelectableDocumentFilter._setSelectedChoices() should be an array of strings');
		};
		
		this.allSelected = false;
		this.selectedChoiceIdMap = {};
		choiceIdArray.forEach(function(choiceId){
			if( typeof choiceId !== 'string' ){
				throw new Error('SelectableDocumentFilter._setSelectedChoices() should be an array of strings');
			};
			_this.selectedChoiceIdMap[choiceId] = true;
		});

		// Save to local storage
		if( this.saveSelection ){
			var jsonSelection = JSON.stringify(choiceIdArray);
			var localStorage = $n2.storage.getLocalStorage();
			localStorage.setItem(this.saveSelectionName,jsonSelection);
		};

		this._selectionChanged(this.selectedChoiceIdMap, this.allSelected);
		this._filterChanged();
		
		this.allSelectedParameter.sendUpdate();
		this.selectedChoicesParameter.sendUpdate();
	},

	getAllSelected: function(){
		return this.allSelected;
	},

	_setAllSelected: function(flag){
		var _this = this;
		
		if( typeof flag !== 'boolean' ){
			throw new Error('SelectableDocumentFilter._setAllSelected() should be a boolean');
		};
		
		this.allSelected = flag;
		
		if( this.allSelected ){
			this.availableChoices.forEach(function(choice){
				_this.selectedChoiceIdMap[choice.id] = true;
			});
		};
		
		// Save to local storage
		if( this.saveSelection ){
			var jsonSelection = null;
			if( this.allSelected ){
				jsonSelection = '__ALL__';
			};
			if( jsonSelection ){
				var localStorage = $n2.storage.getLocalStorage();
				localStorage.setItem(this.saveSelectionName,jsonSelection);
			};
		};

		this._selectionChanged(this.selectedChoiceIdMap, this.allSelected);
		this._filterChanged();
		
		this.allSelectedParameter.sendUpdate();
		this.selectedChoicesParameter.sendUpdate();
	},

	getAvailableChoices: function(){
		return this.availableChoices;
	},

	_setAvailableChoices: function(){
		// Choices are generated by the set of documents, not externally
		throw new Error('SelectableDocumentFilter._setAvailableChoices() should never be called');
	},
	
	_updateAvailableChoices: function(availableChoices){
		var _this = this;

		if( !$n2.isArray(availableChoices) ){
			throw new Error('SelectableDocumentFilter._updateAvailableChoices() should be an array of choices');
		};
		availableChoices.forEach(function(choice){
			if( typeof choice !== 'object' ){
				throw new Error('SelectableDocumentFilter._updateAvailableChoices(): choice must be an object');
			};
			if( typeof choice.id !== 'string' ){
				throw new Error('SelectableDocumentFilter._updateAvailableChoices(): choice.id must be a string');
			};
		});
		this.availableChoices = availableChoices;
		
		this.availableChoicesParameter.sendUpdate();
		
		// If selecting all, then as new available choices arrive,
		// select them as well
		if( this.allSelected ){
			this.selectedChoiceIdMap = {};
			this.availableChoices.forEach(function(choice){
				_this.selectedChoiceIdMap[choice.id] = true;
			});

			this._selectionChanged(this.selectedChoiceIdMap, this.allSelected);
			this._filterChanged();

			this.selectedChoicesParameter.sendUpdate();
		};
	},
	
	_handleSelectableDocumentFilterEvents: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
				m.modelInstance = this;
			};
			
		} else if( 'modelGetState' === m.type ){
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					if( docInfo.visible ){
						var doc = docInfo.doc;
						added.push(doc);
					};
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.modelIsLoading
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from one of our sources?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},
	
	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'filter'
			,parameters: {}
		};
		
		this._addModelInfoParameters(info);
		
		return info;
	},
	
	_addModelInfoParameters: function(info){
		info.parameters.selectedChoices = this.selectedChoicesParameter.getInfo();
		info.parameters.allSelected = this.allSelectedParameter.getInfo();
		info.parameters.availableChoices = this.availableChoicesParameter.getInfo();
	},
	
	_sourceModelUpdated: function(sourceState){
		
		var _this = this;
		
		var added = []
			,updated = []
			,removed = []
			;

		if( typeof sourceState.loading === 'boolean' 
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};

		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;
	
				var docInfo = this.docInfosByDocId[docId];
				if( !docInfo ){
					docInfo = {
						id: docId
						,doc: doc
						,visible: false
					};
					this.docInfosByDocId[docId] = docInfo;
				};
				
				var visible = this._computeVisibility(doc);
				
				if( visible ){
					docInfo.visible = visible;
					added.push(doc);
				};
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
	
				var docInfo = this.docInfosByDocId[docId];
				if( !docInfo ){
					docInfo = {
						id: docId
						,doc: doc
						,visible: false
					};
					this.docInfosByDocId[docId] = docInfo;
				};
				
				// Update document
				docInfo.doc = doc;
				
				// Compute new visibility
				var visible = this._computeVisibility(doc);
				
				if( visible ){
					if( docInfo.visible ){
						// Is visible and used to be visible: update
						updated.push(doc);
					} else {
						// Is visible and did not used to be visible: added
						added.push(doc);
					};
				} else {
					if( docInfo.visible ){
						// Is not visible and used to be visible: remove
						removed.push(doc);
					} else {
						// Is not visible and did not used to be visible: nothing
					};
				};
				
				// Update visibility
				docInfo.visible = visible;
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					delete this.docInfosByDocId[docId];
					
					if( docInfo.visible ){
						// Has been removed, but used to be visible: remove
						removed.push(doc);
					};
				};
			};
		};

		// Report state update
		this._reportStateUpdate(added, updated, removed);
		
		// Recompute available choices from all documents
		var docs = [];
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;
			docs.push(doc);
		};
		var currentChoiceGeneration = $n2.getUniqueId();
		this.currentChoiceGeneration = currentChoiceGeneration;
		var availableChoices = this._computeAvailableChoicesFromDocs(docs, receiveChoices);
		if( availableChoices ){
			receiveChoices(availableChoices);
		};
		
		function receiveChoices(choices){
			if( _this.currentChoiceGeneration === currentChoiceGeneration ){
				_this._updateAvailableChoices(choices);
			};
		};
	},
	
	/*
	 * Subclasses must re-implement this function
	 * It must return an array of choice objects
	 * {
	 *    id: <string>
	 *    ,label: <string> optional
	 * }
	 * 
	 * There is two ways of implmenting this function:
	 * 1. Return an array of choices
	 * 2. Return null and call the callback function with the computed choices.
	 * 
	 * The second method allows an asynchronous approach
	 */
	_computeAvailableChoicesFromDocs: function(docs, callbackFn){
		throw new Error('Subclasses to SelectableDocumentFilter must implement _computeAvailableChoicesFromDocs()');
	},
	
	/*
	 * This function should be called if the conditions of the underlying filter
	 * have changed. Recompute visibility on all documents and report a state update
	 */
	_filterChanged: function(){
		
		var added = []
			,updated = []
			,removed = []
			;

		// Loop through all documents
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;
			
			// Compute new visibility
			var visible = this._computeVisibility(doc);
			
			if( visible ){
				if( docInfo.visible ){
					// Is visible and used to be visible: nothing
				} else {
					// Is visible and did not used to be visible: added
					added.push(doc);
				};
			} else {
				if( docInfo.visible ){
					// Is not visible and used to be visible: remove
					removed.push(doc);
				} else {
					// Is not visible and did not used to be visible: nothing
				};
			};
			
			// Update visibility
			docInfo.visible = visible;
		};

		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.modelIsLoading
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_computeVisibility: function(doc){
		return this._isDocVisible(doc, this.selectedChoiceIdMap, this.allSelected);
	},

	_isDocVisible: function(doc, selectedChoiceIdMap, allSelected){
		throw new Error('Subclasses to SelectableDocumentFilter must implement _isDocVisible()');
	},

	_selectionChanged: function(selectedChoiceIdMap, allSelected){
		// This can be implemented by a subclass to detect the changes in selection
	}
});

//--------------------------------------------------------------------------
var DocumentFilterByCreator = $n2.Class('DocumentFilterByCreator', SelectableDocumentFilter, {

	userInfoByName: null,
	
	currentChoices: null,

	currentCallback: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			modelId: null
			,sourceModelId: null
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		$n2.modelFilter.SelectableDocumentFilter.prototype.initialize.call(this,opts);
		
		this.userInfoByName = {};
		this.currentChoices = [];
		this.currentCallback = null;
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handleFilterByCreatorEvents(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH, 'userInfo', f);
		};
	},
	
	_handleFilterByCreatorEvents: function(m, addr, dispatcher){
		if( 'userInfo' === m.type ){
			var userInfo = m.userInfo;
			var userName = userInfo.name;
			
			this.userInfoByName[userName] = userInfo;
			
			this._recomuteAvailableChoices();
		};
	},
	
	_recomuteAvailableChoices: function(){
		var _this = this;

		if( this.currentChoices ){
			var choiceWasChanged = false;
			this.currentChoices.forEach(function(choice){
				var userInfo = _this.userInfoByName[choice.id];
				
				var label;
				if( userInfo ){
					label = userInfo.display;
				};
				if( !label ){
					label = choice.id;
				};
				
				if( label !== choice.label ){
					choice.label = label;
					choiceWasChanged = true;
				};
			});
			
			if( choiceWasChanged ){
				this.currentChoices.sort(function(a,b){
					if( a.label < b.label ){
						return -1;
					};
					if( a.label > b.label ){
						return 1;
					};
					return 0;
				});

				if( typeof this.currentCallback === 'function' ){
					this.currentCallback(this.currentChoices);
				};
			};
		};
	},

	_computeAvailableChoicesFromDocs: function(docs, callbackFn){
		var _this = this;

		var choiceLabelsById = {};
		var userNamesToFetch = [];
		docs.forEach(function(doc){
			if( doc && doc.nunaliit_created ){
				var userName = doc.nunaliit_created.name;
				var userInfo = _this.userInfoByName[userName];
				
				if( userInfo ){
					// OK
				} else {
					userNamesToFetch.push(userName);
				};

				if( userName && !choiceLabelsById[userName] ){
					choiceLabelsById[userName] = userName;
				};
			};
		});

		var availableChoices = [];
		for(var id in choiceLabelsById){
			var label = choiceLabelsById[id];
			availableChoices.push({
				id: id
				,label: label
			});
		};
		availableChoices.sort(function(a,b){
			if( a.label < b.label ){
				return -1;
			};
			if( a.label > b.label ){
				return 1;
			};
			return 0;
		});
		
		this.currentChoices = availableChoices;
		this.currentCallback = callbackFn;
		
		callbackFn(availableChoices);
		
		if( userNamesToFetch.length > 0 ){
			userNamesToFetch.forEach(function(userName){
				_this.dispatchService.send(DH,{
					type: 'requestUserDocument'
					,userId: userName
				});
			});
		};
		
		return null;
	},
	
	_isDocVisible: function(doc, selectedChoiceIdMap){
		if( doc 
		 && doc.nunaliit_created
		 && selectedChoiceIdMap[doc.nunaliit_created.name] ){
			return true;
		};
		
		return false;
	}
});

//--------------------------------------------------------------------------
var LayerFilter2 = $n2.Class('LayerFilter2', SelectableDocumentFilter, {

	layerDefinitionByLayerId: null,

	layerIdByDocId: null,

	currentChoices: null,

	currentCallback: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			modelId: null
			,sourceModelId: null
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		$n2.modelFilter.SelectableDocumentFilter.prototype.initialize.call(this,opts);
		
		this.layerDefinitionByLayerId = {};
		this.layerIdByDocId = {};
		this.currentChoices = [];
		this.currentCallback = null;
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handleLayerFilterEvents(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH,'documentContent',f);
			this.dispatchService.register(DH,'documentContentCreated',f);
			this.dispatchService.register(DH,'documentContentUpdated',f);
			this.dispatchService.register(DH,'documentDeleted',f);
		};
	},
	
	_handleLayerFilterEvents: function(m, addr, dispatcher){
		if( 'documentContent' === m.type 
		 || 'documentContentCreated' === m.type
		 || 'documentContentUpdated' === m.type ){
			if( m.doc ){
				if( m.doc.nunaliit_layer_definition ){
					var layerId = m.doc.nunaliit_layer_definition.id;
					if( !layerId ){
						layerId = m.doc._id;
					};
					this.layerIdByDocId[m.doc._id] = layerId;
					this.layerDefinitionByLayerId[layerId] = m.doc;
					this._recomuteAvailableChoices();

				} else if( this.layerIdByDocId[m.doc._id] ){
					var layerId = this.layerIdByDocId[m.doc._id];
					delete this.layerIdByDocId[m.doc._id];
					delete this.layerDefinitionByLayerId[layerId];
					this._recomuteAvailableChoices();
				};
			};

		} else if( 'documentDeleted' === m.type ){
			if( this.layerIdByDocId[m.docId] ){
				var layerId = this.layerIdByDocId[m.docId];
				delete this.layerIdByDocId[m.docId];
				delete this.layerDefinitionByLayerId[layerId];
				this._recomuteAvailableChoices();
			};
		};
	},
	
	_recomuteAvailableChoices: function(){
		var _this = this;

		if( this.currentChoices ){
			var choiceWasChanged = false;
			this.currentChoices.forEach(function(choice){
				var layerDefinition = _this.layerDefinitionByLayerId[choice.id];
				
				var label;
				if( layerDefinition 
				 && layerDefinition.nunaliit_layer_definition 
				 && layerDefinition.nunaliit_layer_definition.name ){
					label = _loc(layerDefinition.nunaliit_layer_definition.name);
				};
				if( !label ){
					label = choice.id;
				};
				
				if( label !== choice.label ){
					choice.label = label;
					choiceWasChanged = true;
				};
			});
			
			if( choiceWasChanged ){
				this.currentChoices.sort(function(a,b){
					if( a.label < b.label ){
						return -1;
					};
					if( a.label > b.label ){
						return 1;
					};
					return 0;
				});

				if( typeof this.currentCallback === 'function' ){
					this.currentCallback(this.currentChoices);
				};
			};
		};
	},

	_computeAvailableChoicesFromDocs: function(docs, callbackFn){
		var _this = this;

		var choiceLabelsById = {};
		var layerIdsToFetch = [];
		docs.forEach(function(doc){
			if( doc && $n2.isArray(doc.nunaliit_layers) ){
				doc.nunaliit_layers.forEach(function(layerId){
					var layerDefinition = _this.layerDefinitionByLayerId[layerId];

					if( layerDefinition ){
						// OK
					} else {
						layerIdsToFetch.push(layerId);
					};

					if( layerId && !choiceLabelsById[layerId] ){
						if( layerDefinition 
						 && layerDefinition.nunaliit_layer_definition
						 && layerDefinition.nunaliit_layer_definition.name ){
							choiceLabelsById[layerId] = _loc(layerDefinition.nunaliit_layer_definition.name);
						} else {
							choiceLabelsById[layerId] = layerId;
						};
					};
				});
			};
		});

		var availableChoices = [];
		for(var id in choiceLabelsById){
			var label = choiceLabelsById[id];
			availableChoices.push({
				id: id
				,label: label
			});
		};
		availableChoices.sort(function(a,b){
			if( a.label < b.label ){
				return -1;
			};
			if( a.label > b.label ){
				return 1;
			};
			return 0;
		});
		
		this.currentChoices = availableChoices;
		this.currentCallback = callbackFn;
		
		callbackFn(availableChoices);
		
		if( layerIdsToFetch.length > 0 ){
			this.dispatchService.send(DH,{
				type: 'requestLayerDefinitions'
				,layerIds: layerIdsToFetch
			});
		};
		
		return null;
	},
	
	_isDocVisible: function(doc, selectedChoiceIdMap){
		if( doc 
		 && $n2.isArray(doc.nunaliit_layers) ){
			for(var i in doc.nunaliit_layers){
				var layerId = doc.nunaliit_layers[i];
				if( selectedChoiceIdMap[layerId] ){
					return true;
				};
			};
		};
		
		return false;
	}
});

//--------------------------------------------------------------------------
var SchemaFilter = $n2.Class('SchemaFilter', SelectableDocumentFilter, {

	schemaRepository: null,

	schemasByName: null,

	currentChoices: null,

	currentCallback: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			modelId: undefined
			,sourceModelId: undefined
			,dispatchService: undefined
			,schemaRepository: undefined
			
			// From options
			,initialSelection: undefined
			,schemaName: undefined
			,schemaNames: undefined
		},opts_);
		
		var _this = this;
		
		// For compatibility with older version of SchemaFilter, schemaName and schemaNames are mapped on
		// initialSelection
		if( typeof opts.schemaName === 'string' ){
			if( !opts.initialSelection ){
				opts.initialSelection = [];
			};
			opts.initialSelection.push(opts.schemaName);
		};
		if( $n2.isArray(opts.schemaNames) ){
			if( !opts.initialSelection ){
				opts.initialSelection = [];
			};
			opts.schemaNames.forEach(function(schemaName){
				if( typeof schemaName === 'string' ){
					opts.initialSelection.push(schemaName);
				};
			});
		};
		
		$n2.modelFilter.SelectableDocumentFilter.prototype.initialize.call(this,opts);
		
		this.schemaRepository = opts.schemaRepository;
		this.schemasByName = {};
		this.currentChoices = [];
		this.currentCallback = null;
	},
	
	_recomuteAvailableChoices: function(){
		var _this = this;

		if( this.currentChoices ){
			var choiceWasChanged = false;
			this.currentChoices.forEach(function(choice){
				var schema = _this.schemasByName[choice.id];
				
				var label;
				if( schema ){
					label = schema.getLabel();
				};
				if( !label ){
					label = choice.id;
				};
				
				if( label !== choice.label ){
					choice.label = label;
					choiceWasChanged = true;
				};
			});
			
			if( choiceWasChanged ){
				this.currentChoices.sort(function(a,b){
					if( a.label < b.label ){
						return -1;
					};
					if( a.label > b.label ){
						return 1;
					};
					return 0;
				});

				if( typeof this.currentCallback === 'function' ){
					this.currentCallback(this.currentChoices);
				};
			};
		};
	},

	_computeAvailableChoicesFromDocs: function(docs, callbackFn){
		var _this = this;

		var choiceLabelByName = {};
		var fetchSchemaNamesMap = {};
		docs.forEach(function(doc){
			if( doc 
			 && typeof doc.nunaliit_schema === 'string' ){
				var name = doc.nunaliit_schema;
				var schema = _this.schemasByName[name];

				if( schema ){
					// OK
				} else {
					fetchSchemaNamesMap[name] = true;
				};

				if( name && !choiceLabelByName[name] ){
					if( schema ){
						choiceLabelByName[name] = schema.getLabel();
					} else {
						choiceLabelByName[name] = name;
					};
				};
			};
		});

		var availableChoices = [];
		for(var id in choiceLabelByName){
			var label = choiceLabelByName[id];
			availableChoices.push({
				id: id
				,label: label
			});
		};
		availableChoices.sort(function(a,b){
			if( a.label < b.label ){
				return -1;
			};
			if( a.label > b.label ){
				return 1;
			};
			return 0;
		});
		
		this.currentChoices = availableChoices;
		this.currentCallback = callbackFn;
		
		callbackFn(availableChoices);
		
		var fetchSchemaNames = $n2.utils.keys(fetchSchemaNamesMap);
		if( fetchSchemaNames.length > 0 
		 && this.schemaRepository ){
			this.schemaRepository.getSchemas({
				names: fetchSchemaNames
				,onSuccess: function(schemas){
					schemas.forEach(function(schema){
						var name = schema.name;
						_this.schemasByName[name] = schema;
					});
					
					_this._recomuteAvailableChoices();
				}
				,onError: function(err){
					// ignore
				}
			});
		};
		
		return null;
	},
	
	_isDocVisible: function(doc, selectedChoiceIdMap){
		if( doc 
		 && typeof doc.nunaliit_schema === 'string' ){
			if( selectedChoiceIdMap[doc.nunaliit_schema] ){
				return true;
			};
			
			return false;
		};
		
		return true;
	}
});

//--------------------------------------------------------------------------
function handleModelCreate(m, addr, dispatcher){
	if( m.modelType === 'filter' ){
		var options = {};
		
		if( m && m.modelOptions ){
			if( m.modelOptions.sourceModelId ){
				options.sourceModelId = m.modelOptions.sourceModelId;
			};
		};

		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		var filterFn = null;
		if( $n2.modelUtils.FilterFunctionFromModelConfiguration ){
			filterFn = $n2.modelUtils.FilterFunctionFromModelConfiguration(m.modelOptions);
			if( filterFn.NAME ){
				options.filterName = 'FilterModel - ' + filterFn.NAME;
			};
		};
		if( filterFn ){
			options.filterFn = filterFn;
		} else {
			throw 'Unable to find function for filter model';
		};
		
		m.model = new ModelFilter(options);
		
		m.created = true;

	} else if( m.modelType === 'schemaFilterLegacy' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;

		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new SchemaFilterLegacy(options);
		
		m.created = true;

	} else if( m.modelType === 'referenceFilter' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;

		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new ReferenceFilter(options);
		
		m.created = true;

	} else if( m.modelType === 'singleDocumentFilter' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;

		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new SingleDocumentFilter(options);
		
		m.created = true;

	} else if( m.modelType === 'documentFilterByCreator' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;

		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new DocumentFilterByCreator(options);
		
		m.created = true;

	} else if( m.modelType === 'layerFilter2' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;

		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new LayerFilter2(options);
		
		m.created = true;

	} else if( m.modelType === 'schemaFilter' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;

		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
				options.schemaRepository = m.config.directory.schemaRepository;
			};
		};
		
		m.model = new SchemaFilter(options);
		
		m.created = true;
	};
};

//--------------------------------------------------------------------------
$n2.modelFilter = {
	ModelFilter: ModelFilter
	,FilterFunctionFromModelConfiguration: FilterFunctionFromModelConfiguration
	,SchemaFilterLegacy: SchemaFilterLegacy
	,ReferenceFilter: ReferenceFilter
	,SelectableDocumentFilter: SelectableDocumentFilter
	,LayerFilter2: LayerFilter2
	,SchemaFilter: SchemaFilter
	,handleModelCreate: handleModelCreate 
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.modelFilterSimultaneous.js

/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.modelFilterSimultaneous'
 ;

//--------------------------------------------------------------------------
// Wraps a ModelParameter for the purpose of re-writing the available
// choices for a filter within the SimultaneousFilters construct.
// This wrapper is dependent on two models:
// 1. the filter model, used to call the _computeAvailableChoicesFromDocs()
// 2. the doc model, to get all currently displayed document
// It is important to note that this parameter does not support "setting the
// value" by the client. This parameter only updates value for clients.
var AvailableChoicesWrapper = $n2.Class({

	dispatchService: null,

	wrappingModelId: null,

	docModelId: null,

	filterModel: null,
	
	modelParameter: null,
	
	currentChoices: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: undefined
			,wrappingModelId: undefined
			,docModelId: undefined
			,filterModel: undefined
		},opts_);
		
		this.dispatchService = opts.dispatchService;
		this.wrappingModelId = opts.wrappingModelId;
		this.docModelId = opts.docModelId;
		this.filterModel = opts.filterModel;
		
		var _this = this;

		if( !this.dispatchService ){
			throw new Error('AvailableChoicesWrapper requires dispatchService');
		};
		
		// Check that filter model supports what we need
		if( !this.filterModel ){
			throw new Error('Option "filterModel" must be provided');
		};
		if( typeof this.filterModel._computeAvailableChoicesFromDocs != 'function' ){
			throw new Error('The instance of "filterModel" must support _computeAvailableChoicesFromDocs(): '+this.filterModel._classname);
		};
		
		this.currentChoices = [];
		
		// Create supporting model parameter
		this.modelParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.wrappingModelId
			,type: 'objects'
			,name: 'availableChoices'
			,label: _loc('Available Choices')
			,setFn: this._setAvailableChoices
			,getFn: this._getAvailableChoices
			,dispatchService: this.dispatchService
		});

		// Listen to source model
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			// Initialize state
			this._sourceModelUpdated();
		};
	},
	
	getInfo: function(){
		return this.modelParameter.getInfo();
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelStateUpdated' === m.type ){
			// Does it come from from our source?
			if( this.sourceModelId === m.docModelId ){
				this._sourceModelUpdated();
			};
		};
	},
	
	_sourceModelUpdated: function(){
		var _this = this;

		var state = $n2.model.getModelState({
			dispatchService: this.dispatchService
			,modelId: this.docModelId
		});
		if( state && state.added ){
			this.filterModel._computeAvailableChoicesFromDocs(state.added, function(choices){
				_this._choicesUpdated(choices);
			});
		};
	},
	
	_choicesUpdated: function(choices){
		this.currentChoices = choices;
		this.modelParameter.sendUpdate();
	},

	_setAvailableChoices: function(){
		throw new Error('This function should never be called');
	},

	_getAvailableChoices: function(){
		return this.currentChoices;
	}
});

//--------------------------------------------------------------------------
// The point of this filter is to accept a number of filters and let
// them operate in parallel.
// All the contained filters should work on the same input (sourceModelId).
// The output of all filters should be combined in an intersection. This
// intersection is the end result of the instance of SimultaneousFilters.
var SimultaneousFilters = $n2.Class('SimultaneousFilters',{
		
	config: null,

	dispatchService: null,

	modelId: null,
	
	sourceModelId: null,
	
	filterInfosByModelId: null,
	
	intersectionModel: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			config: undefined
			,dispatchService: undefined

			// From configuration
			,modelId: undefined
			,sourceModelId: undefined
			,filters: undefined
		},opts_);
		
		var _this = this;
		
		this.config = opts.config;
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.sourceModelId = opts.sourceModelId;
		
		if( !this.dispatchService ){
			throw new Error('Dispatch Service required for SimultaneousFilters');
		};
		
		// Create filters from filter definitions
		this.filterInfosByModelId = {};
		var filterCount = 0;
		if( opts.filters && $n2.isArray(opts.filters) ){
			opts.filters.forEach(function(filterDefinition, defIndex){
				if( typeof filterDefinition === 'object' ){
					var declaredModelId = undefined;
					var modelType = undefined;

					// Create an alternate definition for the purpose of
					// this construct
					var altDefinition = {};
					
					// Copy most attributes
					for(var key in filterDefinition){
						var value = filterDefinition[key];
						if( 'sourceModelId' === key ){
							$n2.log('Attribute "sourceModelId" should not be specified in a filter definition within "simultaneousFilters"');
						} else if( 'modelId' === key ) {
							declaredModelId = value;
						} else if( 'modelType' === key ) {
							modelType = value;
							altDefinition[key] = value;
						} else {
							altDefinition[key] = value;
						};
					};
					
					// Check that all needed attributes are provided
					if( !declaredModelId ){
						throw new Error('Attribute "modelId" must be provided for filter definitions within "simultaneousFilters"');
					};
					if( !modelType ){
						throw new Error('Attribute "modelType" must be provided for filter definitions within "simultaneousFilters"');
					};

					var effectiveModelId = _this.modelId+'_filter_'+declaredModelId;
					altDefinition.sourceModelId = _this.sourceModelId;
					altDefinition.modelId = effectiveModelId;
					
					// Create filter
					var msg = {
						type: 'modelCreate'
						,modelId: effectiveModelId
						,modelType: modelType
						,modelOptions: altDefinition
						,config: _this.config
					};
					_this.dispatchService.synchronousCall(DH, msg);
					
					if( !msg.created ){
						throw new Error('Unknown modelType: '+modelType);
					};
					if( !msg.model ){
						throw new Error('Invalid modelType: '+modelType);
					};
					
					// Save filter info
					var filterInfo = {
						declaredModelId: declaredModelId
						,effectiveModelId: effectiveModelId
						,modelType: modelType
						,model: msg.model
					};
					_this.filterInfosByModelId[declaredModelId] = filterInfo;
					
					// Count this filter
					++filterCount;

				} else {
					throw new Error('Filter definitions must be objects');
				};
			});
		};
		
		// Check that enough filters are defined
		if( filterCount <= 1 ){
			throw new Error('Requires at least two filters');
		};
		
		// Make a list of all effective filter ids
		var allFilterIds = [];
		for(var key in this.filterInfosByModelId){
			var filterInfo = this.filterInfosByModelId[key];
			allFilterIds.push(filterInfo.effectiveModelId);
		};

		// Create an intersection model based on all filter models
		this.intersectionModel = new $n2.modelUtils.ModelIntersect({
			dispatchService: this.dispatchService
			,modelId: this.modelId
			,sourceModelIds: allFilterIds
		});

		// For each filter, create an intersection of the other filters combined, and 
		// an available parameter to represent it
		for(var filterId in this.filterInfosByModelId){
			var filterInfo = this.filterInfosByModelId[filterId];
			
			var otherSourceIds = [];
			for(var otherSourceId in this.filterInfosByModelId){
				if( otherSourceId !== filterId ){
					var otherSourceInfo = this.filterInfosByModelId[otherSourceId];
					otherSourceIds.push(otherSourceInfo.effectiveModelId);
				};
			};
			
			var docModelId = this.modelId + '_inter_' + filterInfo.declaredModelId;
			filterInfo.availableChoicesModel = new $n2.modelUtils.ModelIntersect({
				dispatchService: this.dispatchService
				,modelId: docModelId
				,sourceModelIds: otherSourceIds
			});

			var availableChoicesParameter = new AvailableChoicesWrapper({
				dispatchService: this.dispatchService
				,wrappingModelId: filterId
				,docModelId: docModelId
				,filterModel: filterInfo.model
			});
			
			filterInfo.availableChoicesParameter = availableChoicesParameter;
		};
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelGetInfo',f);
			this.dispatchService.register(DH, 'modelGetState', f);
		};
		
		$n2.log(this._classname,this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			// Answer on behalf of our filters
			var filterInfo = this.filterInfosByModelId[m.modelId];
			if( filterInfo ){
				var modelInfo = $n2.model.getModelInfo({
					dispatchService: this.dispatchService
					,modelId: filterInfo.effectiveModelId
				});
				if( modelInfo ){
					// Replace available choices parameter
					if( modelInfo.parameters 
					 && modelInfo.parameters.availableChoices ){
						modelInfo.parameters.availableChoices = 
							filterInfo.availableChoicesParameter.getInfo();
					} else {
						$n2.logError('Underlying filter model is supposed to report "availableChoices" parameter: '+m.modelId);
					};

					m.modelInfo = modelInfo;
				};
			};
			
		} else if( 'modelGetState' === m.type ){
			// Answer on behalf of our filters
			var filterInfo = this.filterInfosByModelId[m.modelId];
			if( filterInfo ){
				var modelState = $n2.model.getModelState({
					dispatchService: this.dispatchService
					,modelId: filterInfo.effectiveModelId
				});
				if( modelState ){
					m.state = modelState;
				};
			};
		};
	}
});

//--------------------------------------------------------------------------
function handleModelCreate(m, addr, dispatcher){
	if( m.modelType === 'simultaneousFilters' ){
		try {
			var options = {};
			
			if( m && m.modelOptions ){
				for(var key in m.modelOptions){
					var value = m.modelOptions[key];
					options[key] = value;
				};
			};
	
			options.modelId = m.modelId;
			options.modelType = m.modelType;
			
			if( m && m.config ){
				options.config = m.config;

				if( m.config.directory ){
					options.dispatchService = m.config.directory.dispatchService;
				};
			};
		
			m.model = new SimultaneousFilters(options);
			
			m.created = true;

		} catch(err) {
			$n2.logError('Error while creating SimultaneousFilters',err);
		};
	};
};


//--------------------------------------------------------------------------
$n2.modelFilterSimultaneous = {
	SimultaneousFilters: SimultaneousFilters
	,handleModelCreate: handleModelCreate 
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.modelUtils.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.modelUtils'
 ;

//--------------------------------------------------------------------------
var ModelUnion = $n2.Class({
	
	dispatchService: null,

	modelId: null,
	
	sourceModelIds: null,
	
	docInfosByDocId: null,
	
	loadingMap: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			
			// From configuration
			,modelId: null
			,sourceModelIds: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;

		// Source models
		this.sourceModelIds = {};
		if( opts.sourceModelIds ){
			for(var i=0,e=opts.sourceModelIds.length; i<e; ++i){
				var sourceModelId = opts.sourceModelIds[i];
				this.sourceModelIds[sourceModelId] = {};
			};
		};
		
		this.docInfosByDocId = {};
		this.loadingMap = {};

		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelGetInfo',f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			for(var sourceModelId in this.sourceModelIds){
				// Initialize state
				var state = $n2.model.getModelState({
					dispatchService: this.dispatchService
					,modelId: sourceModelId
				});
				if( state ){
					this._sourceModelUpdated(sourceModelId, state);
				};
			};
		};
		
		$n2.log('UnionModel',this);
	},
	
	isLoading: function(){
		for(var modelId in this.loadingMap){
			var loading = this.loadingMap[modelId];
			if( loading ){
				return true;
			};
		};
		return false;
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( 'modelGetState' === m.type ){
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					var doc = docInfo.doc;
					added.push(doc);
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.isLoading()
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from one of our sources?
			if( this.sourceModelIds[m.modelId] ){
				this._sourceModelUpdated(m.modelId, m.state);
			};
		};
	},
	
	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'union'
			,parameters: {}
		};
		
		return info;
	},
	
	_sourceModelUpdated: function(sourceModelId, sourceState){
		
		if( !this.sourceModelIds[sourceModelId] ){
			// Not one of our source models
			return;
		};
		
		var added = []
			,updated = []
			,removed = []
			;
		
		if( typeof sourceState.loading === 'boolean' ){
			this.loadingMap[sourceModelId] = sourceState.loading;
		};
		
		// Loop through all added and modified documents
		var addedAndModifiedDocs = sourceState.added ? sourceState.added.slice(0) : [];
		if( sourceState.updated ){
			addedAndModifiedDocs.push.apply(addedAndModifiedDocs, sourceState.updated);
		};
		for(var i=0,e=addedAndModifiedDocs.length; i<e; ++i){
			var doc = addedAndModifiedDocs[i];
			var docId = doc._id;

			var docInfo = this.docInfosByDocId[docId];
			if( !docInfo ){
				docInfo = {
					id: docId
					,doc: doc
					,rev: doc._rev
					,sources: {}
				};
				this.docInfosByDocId[docId] = docInfo;
				
				added.push(doc);
			};
			
			docInfo.sources[sourceModelId] = true;
			
			// Check if new revision
			if( docInfo.rev !== doc._rev ){
				// Modified
				docInfo.doc = doc;
				docInfo.rev = doc._rev;
				
				updated.push(doc);
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					docInfo.sources[sourceModelId] = false;
					
					var removedFlag = true;
					for(var modelId in docInfo.sources){
						if( docInfo.sources[modelId] ){
							removedFlag = false;
						};
					};
					
					if( removedFlag ){
						delete this.docInfosByDocId[docId];
						removed.push(doc);
					};
				};
			};
		};

		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.isLoading()
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	}
});

//--------------------------------------------------------------------------
var ModelIntersect = $n2.Class({
	
	dispatchService: null,

	modelId: null,
	
	sourceModelIds: null,
	
	docInfosByDocId: null,
	
	loadingMap: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			
			// From configuration
			,modelId: null
			,sourceModelIds: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;

		// Source models
		this.sourceModelIds = {};
		if( opts.sourceModelIds ){
			for(var i=0,e=opts.sourceModelIds.length; i<e; ++i){
				var sourceModelId = opts.sourceModelIds[i];
				this.sourceModelIds[sourceModelId] = {};
			};
		};
		
		this.docInfosByDocId = {};
		this.loadingMap = {};

		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelGetInfo',f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			for(var sourceModelId in this.sourceModelIds){
				// Initialize state
				var state = $n2.model.getModelState({
					dispatchService: this.dispatchService
					,modelId: sourceModelId
				});
				if( state ){
					this._sourceModelUpdated(sourceModelId, state);
				};
			};
		};
		
		$n2.log('IntersectModel',this);
	},
	
	isLoading: function(){
		for(var modelId in this.loadingMap){
			var loading = this.loadingMap[modelId];
			if( loading ){
				return true;
			};
		};
		return false;
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( 'modelGetState' === m.type ){
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];

					if( docInfo.visible ){
						var doc = docInfo.doc;
						added.push(doc);
					};
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.isLoading()
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from one of our sources?
			if( this.sourceModelIds[m.modelId] ){
				this._sourceModelUpdated(m.modelId, m.state);
			};
		};
	},
	
	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'intersect'
			,parameters: {}
		};
		
		return info;
	},
	
	_sourceModelUpdated: function(sourceModelId, sourceState){
		
		if( !this.sourceModelIds[sourceModelId] ){
			// Not one of our source models
			return;
		};
		
		var added = []
			,updated = []
			,removed = []
			;
		
		if( typeof sourceState.loading === 'boolean' ){
			this.loadingMap[sourceModelId] = sourceState.loading;
		};
		
		// Loop through all added and modified documents
		var addedAndModifiedDocs = sourceState.added ? sourceState.added.slice(0) : [];
		if( sourceState.updated ){
			addedAndModifiedDocs.push.apply(addedAndModifiedDocs, sourceState.updated);
		};
		for(var i=0,e=addedAndModifiedDocs.length; i<e; ++i){
			var doc = addedAndModifiedDocs[i];
			var docId = doc._id;
			
			
			// Flag docs to be removed if not in they currently exist in the docsInfoByDocId exist and the model 
			
			
			var docInfo = this.docInfosByDocId[docId];
			if( !docInfo ){
				docInfo = {
					id: docId
					,visible: false
					,doc: doc
					,rev: doc._rev
					,sources: {}
				};
				this.docInfosByDocId[docId] = docInfo;
			};
			docInfo.sources[sourceModelId] = true;

			// Check if new revision
			var revUpdated = false;
			if( docInfo.rev !== doc._rev ){
				// Modified
				docInfo.doc = doc;
				docInfo.rev = doc._rev;
				
				revUpdated = true;
			};

			// Check change in visibility
			var visible = this._isDocVisible(doc);
			if( visible && !docInfo.visible ){
				added.push(doc);
			} else if( !visible && docInfo.visible ){
				removed.push(doc);
			} else if( visible && docInfo.visible ) {
				if( revUpdated ){
					updated.push(doc);
				};
			} else {
				// Do not worry about it
			};
			docInfo.visible = visible;
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					// Mark that this source no longer reports it
					docInfo.sources[sourceModelId] = false;

					// Check change in visibility
					if( docInfo.visible ){
						docInfo.visible = false;
						removed.push(doc);
					};
					
					// Check if we keep it
					var removedFlag = true;
					for(var modelId in docInfo.sources){
						if( docInfo.sources[modelId] ){
							removedFlag = false;
						};
					};
					
					if( removedFlag ){
						delete this.docInfosByDocId[docId];
					};
				};
			};
		};

		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.isLoading()
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_isDocVisible: function(doc){
		var docId = doc._id;
		var docInfo = this.docInfosByDocId[docId];
		
		for(var sourceModelId in this.sourceModelIds){
			if( !docInfo.sources[sourceModelId] ) {
				return false;
			};
		};
		
		return true;
	}
});



//--------------------------------------------------------------------------
/*
* This class is a document source model. This means that it is a document model
* (a model that makes documents available to other entities), but it does not
* connect to a source model. Instead, being a source, it generates a stream of
* documents for other entities.
* 
* This document model is static, meaning that it does not change over time. It
* has a set of documents that it manages in memory and makes it available.
*/
var StaticDocumentSource = $n2.Class('StaticDocumentSource', $n2.model.DocumentModel, {

	docsById: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null

			// From configuration
			,modelId: null
			,modelType: null
			,docs: null
		},opts_);
		
		$n2.model.DocumentModel.prototype.initialize.call(this,opts);

		this.docsById = {};
		
		$n2.log('StaticDocumentSource', this);

		if( $n2.isArray(opts.docs) ){
			this.setDocuments(opts.docs);
		};
	},
	
	setDocuments: function(docs){
		var _this = this;
		
		var added = [];
		var updated = [];
		var removed = [];
		
		var newDocsById = {};
		docs.forEach(function(doc){
			if( doc && doc._id ){
				var docId = doc._id;

				newDocsById[docId] = doc;
				
				if( _this.docsById ){
					updated.push(doc);
				} else {
					added.push(doc);
				};
			};
		});
		
		// Figure out removed document
		for(var docId in this.docsById){
			var doc = this.docsById[docId];
			if( !newDocsById[docId] ){
				removed.push(doc);
			};
		};
		
		// Install new document map
		this.docsById = newDocsById;
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_getCurrentDocuments: function(){
		var docs = [];
		
		for(var docId in this.docsById){
			var doc = this.docsById[docId];
			docs[docs.length] = doc;
		};
		
		return docs;
	},

	_isLoading: function(){
		return false;
	}
});

//--------------------------------------------------------------------------
function handleModelCreate(m, addr, dispatcher){
	if( m.modelType === 'union' ){
		var options = {};
		
		if( m && m.modelOptions ){
			if( m.modelOptions.sourceModelIds 
			 && m.modelOptions.sourceModelIds.length ){
				options.sourceModelIds = m.modelOptions.sourceModelIds;
			};
		};

		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new ModelUnion(options);
		
		m.created = true;

	} else if( m.modelType === 'intersect' ){
		var options = {};
		
		if( m && m.modelOptions ){
			if( m.modelOptions.sourceModelIds 
			 && m.modelOptions.sourceModelIds.length ){
				options.sourceModelIds = m.modelOptions.sourceModelIds;
			};
		};

		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new ModelIntersect(options);
		
		m.created = true;

	} else if( m.modelType === 'staticDocumentSource' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;

		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new StaticDocumentSource(options);
		
		m.created = true;
	};
};

//--------------------------------------------------------------------------
$n2.modelUtils = {
	ModelUnion: ModelUnion
	,ModelIntersect: ModelIntersect
	,StaticDocumentSource: StaticDocumentSource
	,handleModelCreate: handleModelCreate 
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.modelTime.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.modelTime'
 ;
 
//--------------------------------------------------------------------------
// This is a generic model that manages a time interval.
// It provides a time range and an interval.
//
// Subclasses should implement the method _intervalUpdated() to detect
// when the time interval is modified.
//
// Subclasses should call _addModelInfoParameters() to augment the model info
// message.
//
// Subclasses should call the method _setRange() to report the range reported by the
// documents.
var TimeIntervalModel = $n2.Class({
	
	dispatchService: null,
	
	modelId: null,
	
	autoRange: null,
	
	range: null,
	
	rangeParameter: null,
	
	interval: null,
	
	intervalParameter: null,
	
	now: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,modelId: null
			,range: null
		},opts_);
		
		var _this = this;

		this.docInfosByDocId = {};
		this.now = Date.now();
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		
		this.autoRange = true;
		if( opts.range ){
			this.range = $n2.date.parseUserDate(opts.range);
			if( this.range && this.range.ongoing ){
				this.range.ongoing = false;
				this.range.max = this.now;
			};
			this.interval = this.range;
			this.autoRange = false;
		};
		
		this.rangeParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.modelId
			,type: 'dateInterval'
			,name: 'range'
			,label: _loc('Range')
			,setFn: this._setRange
			,getFn: this.getRange
			,dispatchService: this.dispatchService
		});
		
		this.intervalParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.modelId
			,type: 'dateInterval'
			,name: 'interval'
			,label: _loc('Interval')
			,setFn: this._setInterval
			,getFn: this.getInterval
			,dispatchService: this.dispatchService
		});
	},
	
	getRange: function(){
		return this.range;
	},
	
	_setRange: function(updatedRange){
		var previous = this.getRange();
		
		this.range = updatedRange;
		if( this.range && this.range.ongoing ){
			this.range.max = this.now;
			this.range.ongoing = false;
		};
		
		var current = this.getRange();
		
		if( current === previous ){
			// Nothing to do. This takes care
			// of previous and current being null
		
		} else if( previous && previous.equals(current) ){
			// Nothing to do
		
		} else {
			// Range has changed
			this.rangeParameter.sendUpdate();
			
			// Verify if changes are required in interval
			// since interval should always be contained within
			// range.
			if( this.interval ){
				if( this.range ) {
					if( this.interval.min < this.range.min 
					 || this.interval.max > this.range.max ){
						// Need to fix interval
						var updatedInterval = this.range.intersection(this.interval);
						this._setInterval(updatedInterval);
					};
				} else {
					// Range is now null. Erase interval
					this._setInterval(null);
				};
			} else {
				// Range has changed. Since interval is null, then the interval
				// has also changed.
				this.intervalParameter.sendUpdate();
				
				// Check all documents to see if visibility has changed
				this._intervalUpdated();
			};
		};
	},
	
	getInterval: function(){
		if( this.interval ){
			return this.interval;
		};
		
		return this.range;
	},
	
	_setInterval: function(updatedInterval){
		var previous = this.getInterval();
		
		this.interval = updatedInterval;
		if( this.interval && this.interval.ongoing ){
			this.interval.max = this.now;
		};
		
		var current = this.getInterval();
		
		if( previous === current ) {
			// Nothing to do. This takes care of
			// previous and current being null
			
		} else if( previous && previous.equals(current) ){
			// Nothing to do
			
		} else {
			this.intervalParameter.sendUpdate();
			
			// Check all documents to see if visibility has changed
			this._intervalUpdated();
		};
	},
	
	_addModelInfoParameters: function(modelInfo){
		if( !modelInfo.parameters ){
			modelInfo.parameters = {};
		};
		
		modelInfo.parameters.range = this.rangeParameter.getInfo();
		modelInfo.parameters.interval = this.intervalParameter.getInfo();
	},
	
	_intervalUpdated: function(){
		throw new Error('Subclasses to TimeIntervalModel must implement _intervalUpdated()');
	}
});

//--------------------------------------------------------------------------
// This is a document filter model. In other words, it accepts documents from
// a source model and makes those documents available to listeners. Since it 
// is a filter, the documents are sent or not to downstream listeners based on
// a boolean function.
//
// This time filter retrieves all date structures in a document and create a set
// of intervals from them. The documents sent downstream are the one with intervals 
// that intersects the one reported by the model.
//
// If the option 'selectors' is specified, then only the portions of the document
// that correspond to the selectors are searched for date structure.
//
// If the option 'allowNoDate', if set, will not filter documents where no date structure
// are found. In other word, when 'allowNoDate' is set, documents that do not provide a date
// structure will not be filtered out and pass on to downstream listeners.
var TimeFilter = $n2.Class('TimeFilter',TimeIntervalModel,{
	
	sourceModelId: null,

	selectors: null,
	
	allowNoDate: null,
	
	docInfosByDocId: null,
	
	modelIsLoading: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			sourceModelId: null
			,selectors: null
			,allowNoDate: false
		},opts_);
		
		TimeIntervalModel.prototype.initialize.apply(this,arguments);
		
		var _this = this;
		
		this.sourceModelId = opts.sourceModelId;
		this.allowNoDate = opts.allowNoDate;
		
		if( $n2.isArray(opts.selectors) ) {
			this.selectors = [];
			for(var i=0,e=opts.selectors.length; i<e; ++i){
				var sel = opts.selectors[i];
				if( typeof sel === 'string' ){
					sel = $n2.objectSelector.parseSelector(sel);
				};
				if( sel ){
					this.selectors.push(sel);
				};
			};
		} else {
			this.selectors = [
				new $n2.objectSelector.ObjectSelector([]) // root
			];
		};
		
		this.docInfosByDocId = {};
		this.modelIsLoading = false;
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'modelGetInfo', f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			// Initialize state
			var m = {
				type:'modelGetState'
				,modelId: this.sourceModelId
			};
			this.dispatchService.synchronousCall(DH, m);
			if( m.state ){
				this._sourceModelUpdated(m.state);
			};
		};
		
		$n2.log('TimeFilter',this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( 'modelGetState' === m.type ){
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					var doc = docInfo.doc;
					if( docInfo.visible ){
						added.push(doc);
					};
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.modelIsLoading
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from our source?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},

	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'timeFilter'
			,parameters: {}
		};
		
		this._addModelInfoParameters(info);
		
		return info;
	},
	
	_sourceModelUpdated: function(sourceState){
		var added = []
			,updated = []
			,removed = []
			;
		
		var now = Date.now();
		
		if( typeof sourceState.loading === 'boolean' 
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};
		
		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;
				var intervals = this._getTimeIntervalsFromDoc(doc);
				var docInfo = {
					id: docId
					,doc: doc
					,intervals: intervals
					,visible: false
				};
				
				// Compute new visibility
				var visibility = this._computeVisibility(docInfo, now);
				
				docInfo.visible = visibility;

				// Save info
				this.docInfosByDocId[docId] = docInfo;
				
				if( docInfo.visible ){
					added.push(doc);
				};
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				var intervals = this._getTimeIntervalsFromDoc(doc);
				if( !docInfo ) {
					docInfo = {
						id: docId
						,doc: doc
						,visible: false
					};
					this.docInfosByDocId[docId] = docInfo;
				};

				// Update
				docInfo.doc = doc;
				docInfo.intervals = intervals;
				
				// Compute new visibility
				var visibility = this._computeVisibility(docInfo, now);
				var changeInVisibility = ( visibility !== docInfo.visible );
				docInfo.visible = visibility;

				// Report change in visibility
				if( changeInVisibility ){
					
					if( docInfo.visible ){
						// It used to be hidden. Now, it is visible. Add
						added.push(doc);
					} else {
						// It used to be visible. Now, it is hidden. Remove
						removed.push(doc);
					};
					
				} else if( docInfo.visible ) {
					// In this case, there was an update and it used to
					// be visible and it is still visible. Report update
					updated.push(doc);
				};
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					delete this.docInfosByDocId[docId];
					
					// If previously visible, add to removal list
					if( docInfo.visible ){
						removed.push(doc);
					};
				};
			};
		};

		// Report changes in visibility
		this._reportStateUpdate(added, updated, removed);

		// Recompute range, if necessary
		if( this.autoRange ){
			var updatedRange = null;
			for(var docId in this.docInfosByDocId){
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo 
				 && docInfo.intervals  ){
					
					for(var i=0,e=docInfo.intervals.length; i<e; ++i){
						var interval = docInfo.intervals[i];
						
						if( !updatedRange ){
							updatedRange = interval;
						} else {
							updatedRange = updatedRange.extendTo(interval, now);
						};
					};
				};
			};
			
			if( updatedRange ){
				var updatedMin = updatedRange.getMin();
				var updatedMax = updatedRange.getMax(now);

				if( this.range ) {
					if( updatedMin != this.range.getMin() 
					 || updatedMax != this.range.getMax(now) ){
						updatedRange = new $n2.date.DateInterval({
							min: updatedMin
							,max: updatedMax
							,ongoing: false
						});
						this._setRange(updatedRange);
					};
				} else {
					updatedRange = new $n2.date.DateInterval({
						min: updatedMin
						,max: updatedMax
						,ongoing: false
					});
					this._setRange(updatedRange);
				};
			} else {
				// No longer any document with a date
				this._setRange(null);
			};
		};
	},
	
	_intervalUpdated: function(){
		var added = []
			,updated = []
			,removed = []
			;
		
		var now = Date.now();
		
		// Loop through all documents
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;

			// Compute new visibility
			var visibility = this._computeVisibility(docInfo, now);
			var changeInVisibility = ( visibility !== docInfo.visible );
			docInfo.visible = visibility;

			// Report change in visibility
			if( changeInVisibility ){
				
				if( docInfo.visible ){
					// It used to be hidden. Now, it is visible. Add
					added.push(doc);
				} else {
					// It used to be visible. Now, it is hidden. Remove
					removed.push(doc);
				};
			};
		};
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.modelIsLoading
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_computeVisibility: function(docInfo, now){
		var filterInterval = this.getInterval();
		
		if( docInfo 
		 && docInfo.intervals ) {
			 if( docInfo.intervals.length > 0 
			  && filterInterval ){
				
				for(var i=0,e=docInfo.intervals.length; i<e; ++i){
					var interval = docInfo.intervals[i];
					
					if( interval.intersectsWith(filterInterval, now) ){
						return true;
					};
				};

			 } else if( docInfo.intervals.length < 1 
					 && this.allowNoDate ){
				 return true;
			};
		};
		
		return false;
	},
	
	_getTimeIntervalsFromDoc: function(doc){
		var intervals = [];
		
		for(var i=0,e=this.selectors.length; i<e; ++i){
			var selector = this.selectors[i];
			selector.traverse(doc,function(value, sel){
				if( typeof value === 'object' 
				 && null !== value 
				 && value.nunaliit_type === 'date'
				 && typeof value.date === 'string' ){
					// is a date
					var interval = $n2.date.parseDateStructure(value);
					if( interval ){
						intervals.push( interval );
					};
				};
			});
		};
		
		return intervals;
	}
});

// --------------------------------------------------------------------------
// This is a document transform model. In other words, it accepts documents from
// another model and makes those documents available to listeners. Since it is a
// transform, it modifies the document contents before passing them on.
//
// This time transform retrieves all date structures in a document and create a set
// of intervals from them. The documents sent downstream are updated with an attribute
// reporting how well the intervals match the time interval reported by the model.
//
// The attribute added by this transform has the following format:
// {
//    _n2TimeTransform: {
//       intersects: <boolean> Set if the document intersects with the model interval
//       ,intervalSize: <number> Size of the time interval reported by the document
//        ,filterIntervalSize: <number> Size of the time interval reported by the model
//       ,intersectionSize: <number> Size of the intersection between the time interval 
//                                   reported by the document and the one reported by the
//                                   model
//    }
// }
var TimeTransform = $n2.Class('TimeTransform',TimeIntervalModel,{
	
	sourceModelId: null,
	
	docInfosByDocId: null,
	
	modelIsLoading: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			sourceModelId: null
		},opts_);
		
		TimeIntervalModel.prototype.initialize.apply(this,arguments);
		
		var _this = this;
		
		this.sourceModelId = opts.sourceModelId;
		this.docInfosByDocId = {};
		this.modelIsLoading = false;
		this.now = Date.now();
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'modelGetInfo', f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			// Initialize state
			var m = {
				type:'modelGetState'
				,modelId: this.sourceModelId
			};
			this.dispatchService.synchronousCall(DH, m);
			if( m.state ){
				this._sourceModelUpdated(m.state);
			};
		};
		
		$n2.log('TimeTransform',this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( 'modelGetState' === m.type ){
			// Is this request intended for this time transform?
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					var doc = docInfo.doc;
					added.push(doc);
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.modelIsLoading
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from our source?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},

	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'timeTransform'
			,parameters: {}
		};
		
		this._addModelInfoParameters(info);
		
		return info;
	},
	
	_sourceModelUpdated: function(sourceState){
		var added = []
			,updated = []
			,removed = []
			;
		
		var _this = this;
		
		if( typeof sourceState.loading === 'boolean' 
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};
		
		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;

				var docInfo = createDocInfo(doc);

				// Save info
				this.docInfosByDocId[docId] = docInfo;
				
				added.push(docInfo.doc);
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( !docInfo ) {
					// Added
					var docInfo = createDocInfo(doc);

					// Save info
					this.docInfosByDocId[docId] = docInfo;
					
					added.push(docInfo.doc);

				} else {
					// Updated
					var intervals = this._getTimeIntervalsFromDoc(doc);
					var transform = this._computeTransform(intervals, this.now);
					
					var myDoc = {
						_n2TimeTransform: transform
					};
					for(var key in doc){
						myDoc[key] = doc[key];
					};

					// Update
					docInfo.doc = myDoc;
					docInfo.intervals = intervals;
					
					updated.push(docInfo.doc);
				};
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					delete this.docInfosByDocId[docId];
					
					removed.push(doc);
				};
			};
		};

		// Report changes in visibility
		this._reportStateUpdate(added, updated, removed);

		// Recompute range, if necessary
		if( this.autoRange ){
			var updatedRange = null;
			for(var docId in this.docInfosByDocId){
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo 
				 && docInfo.intervals  ){
					
					for(var i=0,e=docInfo.intervals.length; i<e; ++i){
						var interval = docInfo.intervals[i];
						
						if( !updatedRange ){
							updatedRange = interval;
						} else {
							updatedRange = updatedRange.extendTo(interval, this.now);
						};
					};
				};
			};
			
			if( updatedRange ){
				var updatedMin = updatedRange.getMin();
				var updatedMax = updatedRange.getMax(this.now);

				if( this.range ) {
					if( updatedMin != this.range.getMin() 
					 || updatedMax != this.range.getMax(this.now) ){
						updatedRange = new $n2.date.DateInterval({
							min: updatedMin
							,max: updatedMax
							,ongoing: false
						});
						this._setRange(updatedRange);
					};
				} else {
					updatedRange = new $n2.date.DateInterval({
						min: updatedMin
						,max: updatedMax
						,ongoing: false
					});
					this._setRange(updatedRange);
				};
			} else {
				// No longer any document with a date
				this._setRange(null);
			};
		};
		
		function createDocInfo(doc){
			var docId = doc._id;
			var intervals = _this._getTimeIntervalsFromDoc(doc);
			var transform = _this._computeTransform(intervals, _this.now);
			
			var myDoc = {
				_n2TimeTransform: transform
			};
			for(var key in doc){
				myDoc[key] = doc[key];
			};
			
			var docInfo = {
				id: docId
				,doc: myDoc
				,intervals: intervals
			};
			
			return docInfo;
		};
	},
	
	_intervalUpdated: function(){
		var added = []
			,updated = []
			,removed = []
			;
		
		// Loop through all documents
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;

			// Compute new visibility
			var intervals = docInfo.intervals;
			var updatedTransform = this._computeTransform(intervals, this.now);
			var transformsEqual = this._areTransformsEqual(updatedTransform, doc._n2TimeTransform);
			if( !transformsEqual ){
				doc._n2TimeTransform = updatedTransform;
				updated.push(doc);
			};
		};
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.modelIsLoading
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_computeTransform: function(intervals, now){
		var filterInterval = this.getInterval();
		
		var intersects = false;
		var intervalSize = 0;
		var intersectionSize = 0;
		var filterIntervalSize = 0;
		
		if( filterInterval ){
			filterIntervalSize = filterInterval.size(now);
			
			if( intervals ){
				for(var i=0,e=intervals.length; i<e; ++i){
					var interval = intervals[i];
					
					intervalSize += interval.size(now);
					
					var intersection = interval.intersection(filterInterval, now);
					if( intersection ){
						intersects = true;
						
						intersectionSize += intersection.size(now);
					};
				};
			};
		};
		
		if( !intersects ){
			filterIntervalSize = 0;
		};
		
		var transform = {
			intersects: intersects
			,intervalSize: intervalSize
			,intersectionSize: intersectionSize
			,filterIntervalSize: filterIntervalSize
		};
		
		return transform;
	},
	
	_areTransformsEqual: function(t1,t2){
		if( t1 === t2 ){
			return true;
			
		} else if( !t1 ) {
			return false;
			
		} else if( !t2 ) {
			return false;
		};

		if( t1.intersects !== t2.intersects ) return false;
		if( t1.intervalSize !== t2.intervalSize ) return false;
		if( t1.intersectionSize !== t2.intersectionSize ) return false;
		if( t1.filterIntervalSize !== t2.filterIntervalSize ) return false;
		
		return true;
	},
	
	_getTimeIntervalsFromDoc: function(doc){
		var dates = [];
		$n2.couchUtils.extractSpecificType(doc,'date',dates);
		
		var intervals = [];
		for(var i=0,e=dates.length; i<e; ++i){
			var date = dates[i];
			var interval = $n2.date.parseDateStructure(date);
			if( interval ){
				intervals.push( interval );
			};
		};
		
		return intervals;
	}
});

// --------------------------------------------------------------------------
// This is a document transform model. In other words, it accepts documents from
// another model and makes those documents available to listeners. Since it is a
// transform, it modifies the document contents before passing them on.
//
// A dated reference is a reference object that contains a dated. The reference is
// valid only for the specified time interval. A dated reference has the following
// format:
// {
//     nunaliit_type: "reference"
//     ,doc: <string, identifier of referenced document>
//     ,date: {
//        nunaliit_type: "date"
//        ,date: <string>
//        ,min: <number>
//        ,max: <number>
//        ,ongoing: <boolean>
//     }
// }
//
// This time transform removes the references from documents when they do not match
// the selected time interval.
//
// This class uses a dictionay to track all documents received from the source model
// docInfosByDocId = {
//    <docId>: {
//       id: <string> identifier for document
//       ,doc: <object> transformed document
//       ,originalDoc: <object> document received from source model
//    }
// }
var DatedReferenceTransform = $n2.Class('DatedReferenceTransform',TimeIntervalModel,{
	
	sourceModelId: null,
	
	docInfosByDocId: null,
	
	modelIsLoading: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			sourceModelId: null
		},opts_);
		
		TimeIntervalModel.prototype.initialize.apply(this,arguments);
		
		var _this = this;

		this.docInfosByDocId = {};
		this.modelIsLoading = false;
		
		this.sourceModelId = opts.sourceModelId;
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelGetInfo',f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			// Initialize state
			var m = {
				type:'modelGetState'
				,modelId: this.sourceModelId
			};
			this.dispatchService.synchronousCall(DH, m);
			if( m.state ){
				this._sourceModelUpdated(m.state);
			};
		};
		
		$n2.log('DatedReferenceTransform',this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( 'modelGetState' === m.type ){
			// Is this request intended for this time transform?
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					var doc = docInfo.doc;
					added.push(doc);
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.modelIsLoading
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from our source?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},

	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'datedReferenceTransform'
			,parameters: {}
		};
		
		this._addModelInfoParameters(info);
		
		return info;
	},
	
	_sourceModelUpdated: function(sourceState){
		var added = []
			,updated = []
			,removed = []
			;
		
		var _this = this;
		
		if( typeof sourceState.loading === 'boolean'
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};
		
		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;

				var docInfo = createDocInfo(doc);

				// Save info
				this.docInfosByDocId[docId] = docInfo;
				
				added.push(docInfo.doc);
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( !docInfo ) {
					// Added
					var docInfo = createDocInfo(doc);

					// Save info
					this.docInfosByDocId[docId] = docInfo;
					
					added.push(docInfo.doc);

				} else {
					// Updated
					var intervalInfos = this._getIntervalInfosFromDoc(doc);
					var myDoc = this._computeTransform(doc, intervalInfos);
					
					docInfo.sourceDoc = doc;
					docInfo.doc = myDoc;
					docInfo.intervalInfos = intervalInfos;
					
					updated.push(docInfo.doc);
				};
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					delete this.docInfosByDocId[docId];
					
					removed.push(doc);
				};
			};
		};

		// Report changes in visibility
		this._reportStateUpdate(added, updated, removed);

		// Recompute range, if necessary
		if( this.autoRange ){
			var updatedRange = null;
			for(var docId in this.docInfosByDocId){
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo 
				 && docInfo.intervalInfos  ){
					
					for(var i=0,e=docInfo.intervalInfos.length; i<e; ++i){
						var intervalInfo = docInfo.intervalInfos[i];
						var interval = intervalInfo.interval;
						
						if( !updatedRange ){
							updatedRange = interval;
						} else {
							updatedRange = updatedRange.extendTo(interval, this.now);
						};
					};
				};
			};
			
			if( updatedRange ){
				var updatedMin = updatedRange.getMin();
				var updatedMax = updatedRange.getMax(this.now);

				if( this.range ) {
					if( updatedMin != this.range.getMin() 
					 || updatedMax != this.range.getMax(this.now) ){
						updatedRange = new $n2.date.DateInterval({
							min: updatedMin
							,max: updatedMax
							,ongoing: false
						});
						this._setRange(updatedRange);
					};
				} else {
					updatedRange = new $n2.date.DateInterval({
						min: updatedMin
						,max: updatedMax
						,ongoing: false
					});
					this._setRange(updatedRange);
				};
			} else {
				// No longer any document with a date
				this._setRange(null);
			};
		};
		
		function createDocInfo(sourceDoc){
			var docId = doc._id;
			var intervalInfos = _this._getIntervalInfosFromDoc(sourceDoc);

			var myDoc = _this._computeTransform(sourceDoc, intervalInfos);
			
			var docInfo = {
				id: docId
				,doc: myDoc
				,sourceDoc: sourceDoc
				,intervalInfos: intervalInfos
			};
			
			return docInfo;
		};
	},
	
	_intervalUpdated: function(){
		var added = []
			,updated = []
			,removed = []
			;
		
		var filterInterval = this.getInterval();
		
		// Loop through all documents
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;

			// Compute changes in transforms
			var transformChanged = false;
			var intervalInfos = docInfo.intervalInfos;
			for(var i=0,e=intervalInfos.length; i<e; ++i){
				var intervalInfo = intervalInfos[i];
				var interval = intervalInfo.interval;
				
				var visible = false;
				if( filterInterval && filterInterval.intersectsWith(interval, this.now) ){
					visible = true;
				};
				
				if( intervalInfo.visible !== visible ){
					transformChanged = true;
					intervalInfo.visible = visible;
				};
			};

			// Recompute transform document, if needed
			if( transformChanged ){
				var myDoc = this._computeTransform(docInfo.sourceDoc, intervalInfos);
				docInfo.doc = myDoc;
				updated.push(myDoc);
			};
		};
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.modelIsLoading
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_computeTransform: function(sourceDoc, intervalInfos){
		var myDoc = $n2.extend(true, {}, sourceDoc);
		
		for(var i=0,e=intervalInfos.length; i<e; ++i){
			var intervalInfo = intervalInfos[i];
			if( intervalInfo.visible ){
				// OK
			} else {
				// Remove this reference. Replace it with null
				intervalInfo.selector.setValue(myDoc, null);
			};
		};

		return myDoc;
	},
	
	_getIntervalInfosFromDoc: function(doc){
		var currentInterval = this.getInterval();

		// Find selectors for all dated reference
		var selectors = $n2.objectSelector.findSelectors(doc, function(v){
			if( null !== v 
			 && typeof v === 'object' ){
				if( v.nunaliit_type === 'reference' 
				 && v.date 
				 && v.date.nunaliit_type === 'date' ){
					return true;
				};
			};
			return false;
		});
		
		// Compute interval infos
		var intervalInfos = [];
		for(var i=0,e=selectors.length; i<e; ++i){
			var selector = selectors[i];
			var ref = selector.getValue(doc);
			var dateStr = ref.date;
			var interval = $n2.date.parseDateStructure(dateStr);
			if( interval ){
				var intervalInfo = {
					interval: interval
					,selector: selector
					,visible: false
				};
				
				if( currentInterval ){
					if( currentInterval.intersectsWith(interval, this.now) ){
						intervalInfo.visible = true;
					};
				};
				
				intervalInfos.push( intervalInfo );
			};
		};

		return intervalInfos;
	}
});

//--------------------------------------------------------------------------
// No time filter.
// This is a document filter that allows through documents that do not contain
// any time intervals.
var NoTimeFilter = $n2.Class({
	
	dispatchService: null,
	
	modelId: null,
	
	sourceModelId: null,
	
	docInfosByDocId: null,
	
	modelIsLoading: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,modelId: null
			,sourceModelId: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.sourceModelId = opts.sourceModelId;
		
		this.docInfosByDocId = {};
		this.modelIsLoading = false;
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'modelGetInfo',f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			// Initialize state
			var m = {
				type:'modelGetState'
				,modelId: this.sourceModelId
			};
			this.dispatchService.synchronousCall(DH, m);
			if( m.state ){
				this._sourceModelUpdated(m.state);
			};
		};
		
		$n2.log('NoTimeFilter',this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( 'modelGetState' === m.type ){
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					var doc = docInfo.doc;
					if( docInfo.visible ){
						added.push(doc);
					};
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.modelIsLoading
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from our source?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},
	
	_getModelInfo: function(){
		var info = {
			modelId: this.modelId
			,modelType: 'noTimeFilter'
			,parameters: {}
		};
		
		return info;
	},
	
	_sourceModelUpdated: function(sourceState){
		var added = []
			,updated = []
			,removed = []
			;
		
		if( typeof sourceState.loading === 'boolean' 
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};
		
		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;
				var intervals = this._getTimeIntervalsFromDoc(doc);
				var docInfo = {
					id: docId
					,doc: doc
					,intervals: intervals
					,visible: false
				};
				
				// Compute new visibility
				var visibility = this._computeVisibility(docInfo);
				
				docInfo.visible = visibility;

				// Save info
				this.docInfosByDocId[docId] = docInfo;
				
				if( docInfo.visible ){
					added.push(doc);
				};
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				var intervals = this._getTimeIntervalsFromDoc(doc);
				if( !docInfo ) {
					docInfo = {
						id: docId
						,doc: doc
						,visible: false
					};
					this.docInfosByDocId[docId] = docInfo;
				};

				// Update
				docInfo.doc = doc;
				docInfo.intervals = intervals;
				
				// Compute new visibility
				var visibility = this._computeVisibility(docInfo);
				var changeInVisibility = ( visibility !== docInfo.visible );
				docInfo.visible = visibility;

				// Report change in visibility
				if( changeInVisibility ){
					
					if( docInfo.visible ){
						// It used to be hidden. Now, it is visible. Add
						added.push(doc);
					} else {
						// It used to be visible. Now, it is hidden. Remove
						removed.push(doc);
					};
					
				} else if( docInfo.visible ) {
					// In this case, there was an update and it used to
					// be visible and it is still visible. Report update
					updated.push(doc);
				};
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					delete this.docInfosByDocId[docId];
					
					// If previously visible, add to removal list
					if( docInfo.visible ){
						removed.push(doc);
					};
				};
			};
		};

		// Report changes in visibility
		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.modelIsLoading
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_computeVisibility: function(docInfo){

		if( docInfo 
		 && docInfo.intervals
		 && docInfo.intervals.length > 0 ){
			// Any time interval makes the document invisible
			return false;
		};
		
		return true;
	},
	
	_getTimeIntervalsFromDoc: function(doc){
		var dates = [];
		$n2.couchUtils.extractSpecificType(doc,'date',dates);
		
		var intervals = [];
		for(var i=0,e=dates.length; i<e; ++i){
			var date = dates[i];
			var interval = $n2.date.parseDateStructure(date);
			if( interval ){
				intervals.push( interval );
			};
		};
		
		return intervals;
	}
});

//--------------------------------------------------------------------------
// This is a not a document model. This model does not provide any document to
// listeners.
//
// Instead, this model monitors other time models and unifies the range/intervals
// reported by them.
//
// This model monitors the range intervals reported by all source models, merges
// those intervals and report the result to the listeners. It ignores requests to change
// the range.
// 
var TimeSynchronize = $n2.Class('TimeSynchronize',{
	
	dispatchService: null,
	
	modelId: null,

	rangeChangeEvent: null,

	rangeSetEvent: null,
	
	rangeGetEvent: null,
	
	currentRange: null,

	intervalChangeEvent: null,

	intervalSetEvent: null,
	
	intervalGetEvent: null,
	
	currentInterval: null,
	
	sourceModelsById: null,
	
	now: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,modelId: null
			,sourceModelIds: null
		},opts_);
		
		var _this = this;
		
		this.sourceModelsById = {};

		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.now = Date.now();
		
		this.rangeChangeEvent = this.modelId + '_range_change_event';
		this.rangeSetEvent = this.modelId + '_range_set_event';
		this.rangeGetEvent = this.modelId + '_range_get_event';

		this.intervalChangeEvent = this.modelId + '_interval_change_event';
		this.intervalSetEvent = this.modelId + '_interval_set_event';
		this.intervalGetEvent = this.modelId + '_interval_get_event';
		
		if( this.dispatchService ){
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH, 'modelGetInfo', fn);
			this.dispatchService.register(DH, this.rangeGetEvent, fn);
			this.dispatchService.register(DH, this.intervalSetEvent, fn);
			this.dispatchService.register(DH, this.intervalGetEvent, fn);

			if( $n2.isArray(opts.sourceModelIds)  ){
				// Register change events with source models
				for(var i=0,e=opts.sourceModelIds.length; i<e; ++i){
					var sourceModelId = opts.sourceModelIds[i];
					if( sourceModelId && typeof sourceModelId === 'string' ){
						var sourceModelInfo = {
							id: sourceModelId
						};
						this.sourceModelsById[sourceModelId] = sourceModelInfo;
						
						// Get model info
						var modelInfoRequest = {
							type: 'modelGetInfo'
							,modelId: sourceModelId
							,modelInfo: null
						};
						this.dispatchService.synchronousCall(DH, modelInfoRequest);
						var modelInfo = modelInfoRequest.modelInfo;
						
						if( modelInfo 
						 && modelInfo.parameters 
						 && modelInfo.parameters.range ){
							var paramInfo = modelInfo.parameters.range;
							sourceModelInfo.rangeChangeEventName = paramInfo.changeEvent;
							sourceModelInfo.rangeGetEventName = paramInfo.getEvent;
							sourceModelInfo.rangeSetEventName = paramInfo.setEvent;
							
							var parameterId = paramInfo.parameterId;
							if( parameterId ){
								this.sourceModelsById[parameterId] = sourceModelInfo;
							};
	
							if( paramInfo.value ){
								sourceModelInfo.range = paramInfo.value;
							};
						};
						
						if( modelInfo 
						 && modelInfo.parameters 
						 && modelInfo.parameters.interval ){
							var paramInfo = modelInfo.parameters.interval;
							sourceModelInfo.intervalChangeEventName = paramInfo.changeEvent;
							sourceModelInfo.intervalGetEventName = paramInfo.getEvent;
							sourceModelInfo.intervalSetEventName = paramInfo.setEvent;
	
							var parameterId = paramInfo.parameterId;
							if( parameterId ){
								this.sourceModelsById[parameterId] = sourceModelInfo;
							};
	
							if( paramInfo.value ){
								sourceModelInfo.interval = paramInfo.value;
							};
						};
						
						if( sourceModelInfo.rangeChangeEventName ){
							this.dispatchService.register(DH, sourceModelInfo.rangeChangeEventName, fn);
						};
						
						if( sourceModelInfo.intervalChangeEventName ){
							this.dispatchService.register(DH, sourceModelInfo.intervalChangeEventName, fn);
						};
					};
				};
			};
		};
		
		// Report current values
		this._recomputeRange();
		
		$n2.log('TimeSynchronize',this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( this.rangeGetEvent === m.type ){
			m.value = this.currentRange;

		} else if( this.intervalGetEvent === m.type ){
			m.value = this.currentInterval;

		} else if( this.intervalSetEvent === m.type ){
			var value = m.value;
			this._setInterval(value);

		} else if( m.parameterId 
		 && this.sourceModelsById[m.parameterId] ){
			var sourceModelInfo = this.sourceModelsById[m.parameterId];
			if( m.type === sourceModelInfo.intervalChangeEventName ){
				// Interval from a source model was changed
			} else if( m.type === sourceModelInfo.rangeChangeEventName ){
				// Range from a source model was changed
				sourceModelInfo.range = m.value;
				this._recomputeRange();
			};
		};
	},
	
	_getModelInfo: function(){
		var modelInfo = {
			modelId: this.modelId
			,modelType: 'timeSynchronize'
			,parameters: {}
		};
		
		// Add range parameter
		modelInfo.parameters.range = {
			parameterId: this.modelId + '_range'
			,type: 'dateInterval'
			,name: 'range'
			,label: _loc('Range')
			,setEvent: this.rangeSetEvent
			,getEvent: this.rangeGetEvent
			,changeEvent: this.rangeChangeEvent
			,value: this.currentRange
		};
		
		// Add interval parameter
		modelInfo.parameters.interval = {
			parameterId: this.modelId + '_interval'
			,type: 'dateInterval'
			,name: 'interval'
			,label: _loc('Interval')
			,setEvent: this.intervalSetEvent
			,getEvent: this.intervalGetEvent
			,changeEvent: this.intervalChangeEvent
			,value: this.getInterval()
		};
		
		return modelInfo;
	},

	_recomputeRange: function(){
		var newRange = undefined;
		var previousInterval = this.getInterval();
		
		for(var sourceModelId in this.sourceModelsById){
			var sourceModelInfo = this.sourceModelsById[sourceModelId];
			if( sourceModelInfo.range ){
				if( !newRange ){
					newRange = sourceModelInfo.range;
				} else {
					newRange.extendTo(sourceModelInfo.range, this.now);
				};
			};
		};
		
		var rangeChanged = false;
		if( this.currentRange && !newRange ){
			this.currentRange = newRange;
			rangeChanged = true;

		} else if( !this.currentRange && newRange ) {
			this.currentRange = newRange;
			rangeChanged = true;

		} else if( this.currentRange && newRange ){
			if( this.currentRange.equals(newRange) ){
				// Nothing to do
			} else {
				this.currentRange = newRange;
				rangeChanged = true;
			};

		} else {
			// !this.currentRange && !newRange: do nothing
		};
		
		if( rangeChanged ){
			this._contrainIntervalToRange();
			
			var currentInterval = this.getInterval();
			
			if( currentInterval === previousInterval ){
				// Nothing to do. Takes care of null === null
			} else if( currentInterval && currentInterval.equals(previousInterval) ){
				// Nothing to do
			} else {
				this._reportChangedInterval();
			};
			
			this._reportChangedRange();
		};
	},
	
	_reportChangedRange: function(){
		this.dispatchService.send(DH, {
			type: this.rangeChangeEvent
			,parameterId: this.modelId + '_range'
			,value: this.currentRange
		});
	},
	
	getInterval: function(){
		if( this.currentInterval ){
			return this.currentInterval;
		};
		
		return this.currentRange;
		
	},
	
	_contrainIntervalToRange: function(){
		if( this.currentInterval && this.currentRange ){
			// Interval should not fall outside range
			this.currentInterval = this.currentInterval.intersection(this.currentRange, this.now);
		} else if( !this.currentRange ) {
			// No range, then no interval
			this.currentInterval = null;
		};

		if( this.currentInterval && this.currentInterval.ongoing ){
			this.currentInterval.max = this.now;
		};
	},
	
	_setInterval: function(updatedInterval){
		var previous = this.getInterval();
		
		this.currentInterval = updatedInterval;

		this._contrainIntervalToRange();
		
		var current = this.getInterval();
		
		if( previous === current ) {
			// Nothing to do. This takes care of
			// previous and current being null
			
		} else if( previous && previous.equals(current) ){
			// Nothing to do
			
		} else {
			this._reportChangedInterval();
		};
	},
	
	_reportChangedInterval: function(){
		var current = this.getInterval();
		
		// Notify all source models
		for(var sourceModelId in this.sourceModelsById){
			var sourceModelInfo = this.sourceModelsById[sourceModelId];
			if( sourceModelInfo.intervalSetEventName ){
				this.dispatchService.send(DH, {
					type: sourceModelInfo.intervalSetEventName
					,parameterId: sourceModelInfo.parameterId
					,value: current
				});
			};
		};

		this.dispatchService.send(DH, {
			type: this.intervalChangeEvent
			,parameterId: this.modelId + '_interval'
			,value: current
		});
	}
});

//--------------------------------------------------------------------------
function handleModelCreate(m, addr, dispatcher){
	if( m.modelType === 'timeFilter' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				var value = m.modelOptions[key];
				options[key] = value;
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new TimeFilter(options);
		
		m.created = true;
	    
	} else if( m.modelType === 'noTimeFilter' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				var value = m.modelOptions[key];
				options[key] = value;
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new NoTimeFilter(options);
		
		m.created = true;
	    
	} else if( m.modelType === 'timeTransform' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				var value = m.modelOptions[key];
				options[key] = value;
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new TimeTransform(options);
		
		m.created = true;
	    
	} else if( m.modelType === 'datedReferenceTransform' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				var value = m.modelOptions[key];
				options[key] = value;
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new DatedReferenceTransform(options);
		
		m.created = true;
	    
	} else if( m.modelType === 'timeSynchronize' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				var value = m.modelOptions[key];
				options[key] = value;
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new TimeSynchronize(options);
		
		m.created = true;
    };
};

//--------------------------------------------------------------------------
$n2.modelTime = {
	TimeFilter: TimeFilter
	,TimeTransform: TimeTransform
	,DatedReferenceTransform: DatedReferenceTransform
	,NoTimeFilter: NoTimeFilter
	,TimeSynchronize: TimeSynchronize
	,handleModelCreate: handleModelCreate
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.modelLayer.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.modelLayer'
 ;
 
//--------------------------------------------------------------------------
// This is a document filter model. In other words, it accepts documents from
// a source model and makes those documents available to listeners. Since it 
// is a filter, the documents are sent or not to downstream listeners based on
// a boolean function.
//
// This layer filter selects documents based on the set of layerIds found in
// nunaliit_layers attribute
var LayerFilter = $n2.Class({
	
	dispatchService: null,
	
	modelId: null,
	
	sourceModelId: null,
	
	selectedLayers: null,
	
	selectedLayersParameter: null,

	availableLayers: null,

	availableLayersParameter: null,
	
	docInfosByDocId: null,
	
	modelIsLoading: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,modelId: null
			,sourceModelId: null
		},opts_);
		
		var _this = this;

		this.docInfosByDocId = {};
		this.selectedLayers = {};
		this.availableLayers = {};
		this.modelIsLoading = false;
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.sourceModelId = opts.sourceModelId;
		
		this.selectedLayersParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.modelId
			,type: 'layerIds'
			,name: 'selectedLayers'
			,label: _loc('Layers')
			,setFn: this._setLayers
			,getFn: this.getLayers
			,dispatchService: this.dispatchService
		});
		
		this.availableLayersParameter = new $n2.model.ModelParameter({
			model: this
			,modelId: this.modelId
			,type: 'layerIds'
			,name: 'availableLayers'
			,label: _loc('Available Layers')
			,setFn: this._setAvailableLayers
			,getFn: this.getAvailableLayers
			,dispatchService: this.dispatchService
		});
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'modelGetInfo', f);
			this.dispatchService.register(DH, 'modelGetState', f);
			this.dispatchService.register(DH, 'modelStateUpdated', f);
			
			// Initialize state
			var m = {
				type:'modelGetState'
				,modelId: this.sourceModelId
			};
			this.dispatchService.synchronousCall(DH, m);
			if( m.state ){
				this._sourceModelUpdated(m.state);
			};
		};
		
		$n2.log('LayerFilter',this);
	},
	
	getLayers: function(){
		var layerIds = [];
		for(var layerId in this.selectedLayers){
			layerIds[layerIds.length] = layerId;
		};
		return layerIds;
	},
	
	_setLayers: function(layerIds){
		var newSelectedLayers = {};
		if( layerIds ){
			layerIds.forEach(function(layerId){
				newSelectedLayers[layerId] = true;
			});
		};
		
		// Check if selection is changed
		var changed = false;
		for(var layerId in newSelectedLayers){
			if( !this.selectedLayers[layerId] ){
				changed = true;
			};
		};
		if( !changed ){
			for(var layerId in this.selectedLayers){
				if( !newSelectedLayers[layerId] ){
					changed = true;
				};
			};
		};
		
		if( !changed ){
			// Nothing to do
		
		} else {
			// Set of selected layer ids has changed
			this.selectedLayers = newSelectedLayers;
			
			this.selectedLayersParameter.sendUpdate();
			
			this._selectedLayersUpdated();
		};
	},
	
	getAvailableLayers: function(){
		var layerIds = [];
		for(var layerId in this.availableLayers){
			layerIds[layerIds.length] = layerId;
		};
		return layerIds;
	},
	
	_setAvailableLayers: function(layerIds){
		var newAvailableLayerMap = {};
		if( layerIds ){
			layerIds.forEach(function(layerId){
				newAvailableLayerMap[layerId] = true;
			});
		};
		
		this._setAvailableLayersMap(newAvailableLayerMap);
	},
	
	_setAvailableLayersMap: function(newAvailableLayerMap){
		// Check if selection is changed
		var changed = false;
		for(var layerId in newAvailableLayerMap){
			if( !this.availableLayers[layerId] ){
				changed = true;
			};
		};
		if( !changed ){
			for(var layerId in this.availableLayers){
				if( !newAvailableLayerMap[layerId] ){
					changed = true;
				};
			};
		};
		
		if( !changed ){
			// Nothing to do
		
		} else {
			// Set of selected layer ids has changed
			this.availableLayers = newAvailableLayerMap;
			
			this.availableLayersParameter.sendUpdate();
		};
	},

	_handle: function(m, addr, dispatcher){
		if( 'modelGetInfo' === m.type ){
			if( this.modelId === m.modelId ){
				m.modelInfo = this._getModelInfo();
			};
			
		} else if( 'modelGetState' === m.type ){
			if( this.modelId === m.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					var doc = docInfo.doc;
					if( docInfo.visible ){
						added.push(doc);
					};
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.modelIsLoading
				};
			};
			
		} else if( 'modelStateUpdated' === m.type ){
			// Does it come from our source?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},

	_getModelInfo: function(){
		var modelInfo = {
			modelId: this.modelId
			,modelType: 'layerFilter'
			,parameters: {}
		};
		
		modelInfo.parameters.selectedLayers = this.selectedLayersParameter.getInfo();
		modelInfo.parameters.availableLayers = this.availableLayersParameter.getInfo();
		
		return modelInfo;
	},
	
	_sourceModelUpdated: function(sourceState){
		var added = []
			,updated = []
			,removed = []
			;
		
		if( typeof sourceState.loading === 'boolean' 
		 && this.modelIsLoading !== sourceState.loading ){
			this.modelIsLoading = sourceState.loading;
		};
		
		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;
				var layerMap = this._getLayerMapFromDoc(doc);
				var docInfo = {
					id: docId
					,doc: doc
					,layerMap: layerMap
					,visible: false
				};
				
				// Compute new visibility
				var visibility = this._computeVisibility(docInfo);
				
				docInfo.visible = visibility;

				// Save info
				this.docInfosByDocId[docId] = docInfo;
				
				if( docInfo.visible ){
					added.push(doc);
				};
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				var layerMap = this._getLayerMapFromDoc(doc);
				if( !docInfo ) {
					docInfo = {
						id: docId
						,doc: doc
						,visible: false
					};
					this.docInfosByDocId[docId] = docInfo;
				};

				// Update
				docInfo.doc = doc;
				docInfo.layerMap = layerMap;
				
				// Compute new visibility
				var visibility = this._computeVisibility(docInfo);
				var changeInVisibility = ( visibility !== docInfo.visible );
				docInfo.visible = visibility;

				// Report change in visibility
				if( changeInVisibility ){
					
					if( docInfo.visible ){
						// It used to be hidden. Now, it is visible. Add
						added.push(doc);
					} else {
						// It used to be visible. Now, it is hidden. Remove
						removed.push(doc);
					};
					
				} else if( docInfo.visible ) {
					// In this case, there was an update and it used to
					// be visible and it is still visible. Report update
					updated.push(doc);
				};
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				var docInfo = this.docInfosByDocId[docId];
				if( docInfo ){
					delete this.docInfosByDocId[docId];
					
					// If previously visible, add to removal list
					if( docInfo.visible ){
						removed.push(doc);
					};
				};
			};
		};

		// Report changes in visibility
		this._reportStateUpdate(added, updated, removed);
		
		// Recompute available layers
		var newAvailableLayerMap = {};
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			for(var layerId in docInfo.layerMap){
				newAvailableLayerMap[layerId] = true;
			};
		};
		this._setAvailableLayersMap(newAvailableLayerMap);
	},
	
	_selectedLayersUpdated: function(){
		var added = []
			,updated = []
			,removed = []
			;
		
		// Loop through all documents
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;

			// Compute new visibility
			var visibility = this._computeVisibility(docInfo);
			var changeInVisibility = ( visibility !== docInfo.visible );
			docInfo.visible = visibility;

			// Report change in visibility
			if( changeInVisibility ){
				
				if( docInfo.visible ){
					// It used to be hidden. Now, it is visible. Add
					added.push(doc);
				} else {
					// It used to be visible. Now, it is hidden. Remove
					removed.push(doc);
				};
			};
		};
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.modelIsLoading
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	},
	
	_computeVisibility: function(docInfo){
		if( docInfo 
		 && docInfo.layerMap ) {
			for(var layerId in docInfo.layerMap){
				if( this.selectedLayers[layerId] ){
					return true;
				};
			};
		};
		
		return false;
	},
	
	_getLayerMapFromDoc: function(doc){
		var layerMap = {};
		
		if( doc.nunaliit_layers ){
			doc.nunaliit_layers.forEach(function(layerId){
				layerMap[layerId] = true;
			});
		};
		
		return layerMap;
	}
});

//--------------------------------------------------------------------------
function handleModelCreate(m, addr, dispatcher){
	if( m.modelType === 'layerFilter' ){
		var options = {};
		
		if( m && m.modelOptions ){
			for(var key in m.modelOptions){
				var value = m.modelOptions[key];
				options[key] = value;
			};
		};
		
		options.modelId = m.modelId;
		options.modelType = m.modelType;
		
		if( m && m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new LayerFilter(options);
		
		m.created = true;
    };
};

//--------------------------------------------------------------------------
$n2.modelLayer = {
	LayerFilter: LayerFilter
	,handleModelCreate: handleModelCreate
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetBasic.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetService'
 ;

//--------------------------------------------------------------------------
function createActionFromDefinition(dispatchService, definition){
	 	
	if( typeof definition != 'object' ){
		throw new Error('Unable to create an instance of Action since definition is not provided');
	};
	
	// Create instance from definition
	var m = {
		type: 'instanceCreate'
		,instanceConfiguration: definition
		,instance: undefined
	};
	dispatchService.synchronousCall(DH,m);
	var instance = m.instance;
	
	if( !instance ){
		throw new Error('Unable to create an instance of type: '+definition.type);
	};
	
	if( typeof instance != 'object' ){
		throw new Error('Instance of type: '+definition.type+' is not an object');
	};
	
	if( typeof instance.execute != 'function' ){
		throw new Error('Instance of type: '+definition.type+' must implement execute() method');
	};
	 	
	return instance;
};

//--------------------------------------------------------------------------
var CreateDocumentWidget = $n2.Class({
	
	contentId: null,
	
	dispatchService: null,
	
	authService: null,
	
	showAsLink: null,
	
	containerId: null,
	
	elemId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			contentId: null
			,containerId: null
			,dispatchService: null
			,authService: null
			,showAsLink: false
		},opts_);
		
		this.contentId = opts.contentId;
		this.containerId = opts.containerId;
		this.dispatchService = opts.dispatchService;
		this.authService = opts.authService;
		this.showAsLink = opts.showAsLink;

		if( !this.containerId ){
			throw new Error('containerId must be specified');
		};
		
		this._display();
	},
	
	_display: function(){
		var _this = this;
		
		if (window.cordova) {
			// Remove the header since the Create Document is in the native nav bar on Cordova
			var headers = document.getElementsByClassName("nunaliit_header");
			if (headers.length) {
				$(headers[0]).hide();
				// Let the content start at the top since there is no header on Cordova
				$("<style type='text/css'> .nunaliit_content { top: 0 } </style>").appendTo("head");
			}

			// Listen to the Create Document callback from native
			document.addEventListener("deviceready", function() {
				window.nunaliit2.cordovaPlugin.registerCallback('onCreateDocument', 
					function() {
						window.onCreateDocument = function() {
							_this._startEdit();
						};
					}, function(error) {
						console.error('Error on cordova callback invocation: ', error);
					});
			});
		} else {
			this.elemId = $n2.getUniqueId();
			
			var containerId = this.containerId;
			
			var $div = $('<div>')
				.attr('id',this.elemId)
				.addClass('n2widget_createDocument')
				.appendTo( $('#'+containerId) );
	
			if( this.showAsLink ) {
				$div.addClass('n2widget_createDocument_asLink');
	
				$('<a>')
					.attr('href','#')
					.text( _loc('Create Document') )
					.appendTo($div)
					.click(function(){
						_this._startEdit();
						return false;
					});
			} else {
				$('<button>')
					.text( _loc('Create Document') )
					.appendTo($div)
					.click(function(){
						_this._startEdit();
						return false;
					});
			};
		}
	},
	
	_startEdit: function(){
		var _this = this;
		
		if( this.authService ){
			if( false == this.authService.isLoggedIn() ){
				this.authService.showLoginForm({
					prompt: _loc('You must first log in to create a new document.')
					,anonymousLoginAllowed: false
					,onSuccess: function(){ _this._startEdit(); }
				});
				
				return;
			};
		};

		this.dispatchService.send(DH, {
			type: 'editInitiate'
			,doc: {}
		});
	}
});

//--------------------------------------------------------------------------
function BuildCreateDocumentWidgetFromRequest(m){
	var widgetOptions = m.widgetOptions;
	var contentId = m.contentId;
	var containerId = m.containerId;
	var config = m.config;
	// var moduleDisplay = m.moduleDisplay;
	
	var options = {};

	if( widgetOptions ){
		for(var key in widgetOptions){
			var value = widgetOptions[key];
			options[key] = value;
		};
	};

	options.contentId = contentId;
	options.containerId = containerId;

	if( config && config.directory ){
		options.dispatchService = config.directory.dispatchService;
		options.authService = config.directory.authService;
	};
	
	new CreateDocumentWidget(options);
};

//--------------------------------------------------------------------------
var CreateDocumentFromSchemaWidget = $n2.Class({
	
	elemId: null,
	
	dispatchService: null,

	authService: null,

	schemaRepository: null,
	
	schemaName: null,
	
	label: null,
	
	showAsLink: null,

	schema: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,authService: null
			,schemaRepository: null

			// From configuration
			,schemaName: null
			,label: null
			,showAsLink: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.authService = opts.authService;
		this.schemaRepository = opts.schemaRepository;
		this.atlasDesign = opts.atlasDesign;
		this.schemaName = opts.schemaName;
		this.label = opts.label;
		this.showAsLink = opts.showAsLink;

		this.schema = null;
		
		var $parent = $('#'+opts.containerId);
		var $elem = $('<div>')
			.addClass('n2widget_createDocumentFromSchema')
			.appendTo($parent);
		this.elemId = $n2.utils.getElementIdentifier($elem);
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
		};
		
		if( this.schemaRepository && this.schemaName ){
			this.schemaRepository.getSchema({
				name: this.schemaName
				,onSuccess: function(schema){
					_this.schema = schema;
					_this._refresh();
				}
				,onError: function(){
					$n2.log('Schema not found: '+this.schemaName);
				}
			});
		} else {
			$n2.log('Schema repository or schema name not specified');
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_refresh: function(){
		var _this = this;
		
		var $div = this._getElem();
		
		var schemaLabel = this.schema.name;
		if( this.schema.label ){
			schemaLabel = _loc(this.schema.label);
		};
		
		var controlLabel = _loc('Create {label}',{
			label: schemaLabel
		});
		if( this.label ){
			controlLabel = _loc(this.label);
		};
		
		if( this.showAsLink ) {
			$('<a>')
				.attr('href','#')
				.text(controlLabel)
				.appendTo($div)
				.click(function(){
					_this._startEdit();
					return false;
				});
		} else {
			$('<button>')
				.text(controlLabel)
				.appendTo($div)
				.click(function(){
					_this._startEdit();
					return false;
				});
		};
	},
	
	_startEdit: function(){
		var _this = this;
		
		if( this.authService ){
			if( false == this.authService.isLoggedIn() ){
				this.authService.showLoginForm({
					prompt: _loc('You must first log in to create a new document.')
					,anonymousLoginAllowed: false
					,onSuccess: function(){ _this._startEdit(); }
				});
				
				return;
			};
		};

		this.dispatchService.send(DH, {
			type: 'editInitiate'
			,doc: {
				nunaliit_schema: this.schema.name
			}
		});
	},
	
	_handle: function(m, addr, dispatcher){
	}
});

//--------------------------------------------------------------------------
function BuildCreateDocumentFromSchemaWidget(m){
	var widgetOptions = m.widgetOptions;
	var contentId = m.contentId;
	var containerId = m.containerId;
	var config = m.config;
	// var moduleDisplay = m.moduleDisplay;
	
	var options = {};

	if( widgetOptions ){
		for(var key in widgetOptions){
			options[key] = widgetOptions[key];
		};
	};
	
	options.containerId = containerId;
	
	if( config ){
		if( config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.authService = config.directory.authService;
			options.schemaRepository = config.directory.schemaRepository;
		};
	};
	
	new CreateDocumentFromSchemaWidget(options);
};

//--------------------------------------------------------------------------
var DocumentSelectorWidget = $n2.Class({
	
	elemId: null,
	
	dispatchService: null,

	showService: null,

	filterModelId: null,
	
	filterParameterId: null,

	listModelId: null,
	
	listLabelSelectors: null,
	
	selectedDocumentIdObserver: null,
	
	listDocumentMap: null,
	
	label: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,showService: null

			// From configuration
			,filterModelId: null
			,filterParameterId: 'selectedDocumentId'
			,listModelId: null
			,listLabelSelectors: null
			,label: null
		},opts_);
		
		var _this = this;

		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.filterModelId = opts.filterModelId;
		this.filterParameterId = opts.filterParameterId;
		this.listModelId = opts.listModelId;
		this.label = opts.label;
		this.listDocumentMap = {};
		
		this.listLabelSelectors = [];
		if( $n2.isArray(opts.listLabelSelectors) ){
			opts.listLabelSelectors.forEach(function(labelSelectorStr){
				if( typeof labelSelectorStr === 'string' ){
					var selector = $n2.objectSelector.parseSelector(labelSelectorStr);
					_this.listLabelSelectors.push(selector);
				};
			});
		};

		var $parent = $('#'+opts.containerId);
		var $elem = $('<div>')
			.addClass('n2widget_documentSelector')
			.appendTo($parent);
		this.elemId = $n2.utils.getElementIdentifier($elem);
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH,'modelStateUpdated',f);

			// Filter
			if( this.filterModelId ){
				var modelInfo = $n2.model.getModelInfo({
					dispatchService: this.dispatchService
					,modelId: this.filterModelId
				});
				if( modelInfo
				 && modelInfo.parameters 
				 && modelInfo.parameters[this.filterParameterId] ){
					var parameterInfo = modelInfo.parameters[this.filterParameterId];

					this.selectedDocumentIdObserver = new $n2.model.ModelParameterObserver({
						parameterInfo: parameterInfo
						,dispatchService: this.dispatchService
						,onChangeFn: function(selectedDocId){
							_this._selectedDocIdChanged(selectedDocId);
						}
					});
				};
			};
			
			// Get document list
			if( this.listModelId ){
				var state = $n2.model.getModelState({
					dispatchService: this.dispatchService
					,modelId: this.listModelId
				});
				if( state ){
					this._listModelStateUpdated(state);
				};
			};
		};
		
		$n2.log('DocumentSelectorWidget',this);
		
		this._refresh();
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_listModelStateUpdated: function(state){
		// Loop through all added documents
		if( state.added ){
			for(var i=0,e=state.added.length; i<e; ++i){
				var doc = state.added[i];
				var docId = doc._id;
				
				this.listDocumentMap[docId] = doc;
			};
		};
		
		// Loop through all updated documents
		if( state.updated ){
			for(var i=0,e=state.updated.length; i<e; ++i){
				var doc = state.updated[i];
				var docId = doc._id;
	
				this.listDocumentMap[docId] = doc;
			};
		};
		
		// Loop through all removed documents
		if( state.removed ){
			for(var i=0,e=state.removed.length; i<e; ++i){
				var doc = state.removed[i];
				var docId = doc._id;

				delete this.listDocumentMap[docId];
			};
		};
	},
	
	/**
	 * This is called when the document filter is modified
	 */
	_selectedDocIdChanged: function(selectedDocId){
		this._refresh();
	},
	
	_getDisplayValueFromDoc: function(doc){
		var value = undefined;
		
		this.listLabelSelectors.forEach(function(selector){
			if( value === undefined ){
				value = selector.getValue(doc);
				if( value && value.nunaliit_type === 'localized' ){
					value = _loc( value );
				};
			};
		});
		
		if( value === undefined && this.showService ){
			var $div = $('<div>');
			this.showService.displayBriefDescription($div, {}, doc);
			value = $div.text();
		};
		
		if( value === undefined ){
			value = doc._id;
		};
		
		return value;
	},
	
	_refresh: function(){
		var _this = this;
		
		// Create array of information object
		var selections = [];
		for(var docId in this.listDocumentMap){
			var doc = this.listDocumentMap[docId];
			var sel = {
				docId: docId
				,doc: doc
				,display: this._getDisplayValueFromDoc(doc)
			};
			selections.push(sel);
		};
		selections.sort(function(a,b){
			if( a.display < b.display ) return -1;
			if( a.display > b.display ) return 1;
			return 0;
		});
		
		var $div = this._getElem()
			.empty();
		
		var $select = $('<select>')
			.appendTo($div)
			.change(function(){
				var $selection = $(this);
				_this._selectionChanged($selection);
			});

		var emptyLabel = '--';
		if( this.label ){
			emptyLabel = _loc(this.label);
		};
		var $opt = $('<option>')
			.val('__NO_SELECTION__')
			.text(emptyLabel)
			.appendTo($select);

		var optionFound = false;
		var currentSelection = undefined;
		if( this.selectedDocumentIdObserver ){
			currentSelection = this.selectedDocumentIdObserver.getValue();
		};

		selections.forEach(function(sel){
			var docId = sel.docId;
			var doc = sel.doc;
			
			if( docId === currentSelection ){
				optionFound = true;
			};
			
			var $opt = $('<option>')
				.val(docId)
				.text(sel.display)
				.appendTo($select);
		});
		
		if( optionFound ){
			$select.val(currentSelection);
		} else {
			$select.val('__NO_SELECTION__');
		};
	},
	
	_selectionChanged: function($select){
		var value = $select.val();
		if( this.selectedDocumentIdObserver ){
			if( !value ) {
				this.selectedDocumentIdObserver.setValue(null);
			} else if( '__NO_SELECTION__' === value ){
				this.selectedDocumentIdObserver.setValue(null);
			} else {
				this.selectedDocumentIdObserver.setValue(value);
			};
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( m.type === 'modelStateUpdated'
		 && m.modelId === this.listModelId
		 && m.state ){
			this._listModelStateUpdated(m.state);
			this._refresh();
		};
	}
});

//--------------------------------------------------------------------------
function BuildDocumentSelectorWidget(m){
	var widgetOptions = m.widgetOptions;
	var config = m.config;
	
	var options = {};

	if( widgetOptions ){
		for(var key in widgetOptions){
			options[key] = widgetOptions[key];
		};
	};
	
	options.containerId = m.containerId;
	
	if( config ){
		if( config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.showService = config.directory.showService;
		};
	};
	
	new DocumentSelectorWidget(options);
};

//--------------------------------------------------------------------------
var ButtonWidget = $n2.Class('ButtonWidget',{
	
	dispatchService: null,
	containerId: null,
	elemId: null,
	buttonLabel: null,
	actions: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,buttonLabel: null
			,action: undefined
			,actions: undefined
		},opts_);
		
		var _this = this;

		this.containerId = opts.containerId;
		this.dispatchService = opts.dispatchService;
		this.buttonLabel = opts.buttonLabel;
		
		this.actions = [];

		if( !this.containerId ){
			throw new Error('containerId must be specified');
		};

		if ( !this.buttonLabel ){
			this.buttonLabel = "Button";
		};
		
		if( typeof opts.action === 'object' ){
			var action = createActionFromDefinition(this.dispatchService, opts.action);
			this.actions.push(action);
		};

		if( typeof opts.actions === 'undefined' ){
			// OK
		} else if( $n2.isArray(opts.actions) ) {
			opts.actions.forEach(function(actionDef){
				if( typeof actionDef === 'object' ){
					var action = createActionFromDefinition(_this.dispatchService, actionDef);
					_this.actions.push(action);
				} else {
					throw new Error('If parameter "actions" is specified, it must be an array of action definitions.');
				};
			});
		} else {
			throw new Error('If parameter "actions" is specified, it must be an array of action definitions.');
		};

		this._display();
		
		$n2.log(this._classname,this);
	},
	
	_display: function(){
		var _this = this;

		this.elemId = $n2.getUniqueId();

		var containerId = this.containerId;

		var $button = $('<a>')
			.attr('id',this.elemId)
			.attr('href', '#')
			.addClass('n2widget_button')
			.appendTo( $('#'+containerId) )
			.click(function(){
				_this._buttonClicked();
				return false;
			});

		$('<span>')
			.text( _loc(this.buttonLabel) )
			.appendTo($button);
	},
	
	_buttonClicked: function(){
		this.actions.forEach(function(action){
			action.execute();
		});
	}
});

//--------------------------------------------------------------------------
function BuildButtonWidget(m){
	var widgetOptions = m.widgetOptions;
	var containerId = m.containerId;
	var config = m.config;
	
	var options = {};

	if( widgetOptions ){
		for(var key in widgetOptions){
			var value = widgetOptions[key];
			options[key] = value;
		};
	};

	options.containerId = containerId;

	if( config && config.directory ){
		options.dispatchService = config.directory.dispatchService;
	};
	
	new ButtonWidget(options);
};

//--------------------------------------------------------------------------
var Service = $n2.Class({
	
	config: null,
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			config: null
		},opts_);
		
		var _this = this;
		
		this.config = opts.config;
		
		if( this.config && this.config.directory ){
			this.dispatchService = this.config.directory.dispatchService;
		};
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'widgetIsTypeAvailable',f);
			this.dispatchService.register(DH,'widgetDisplay',f);
			this.dispatchService.register(DH,'showPreprocessElement',f);
		};
	},
	
	_showServicePreprocess: function($elem){
		var _this = this;
		
		var $set = $elem.find('*').addBack();
		
		// Localization
		$set.filter('.n2s_insertWidget').each(function(){
			var $jq = $(this);
			_this._insertWidget($jq);
			$jq.removeClass('n2s_insertWidget').addClass('n2s_insertedWidget');
		});
	},
	
	_insertWidget: function($jq){
		var widgetType = $jq.attr('nunaliit-widget');
		var containerId = $n2.utils.getElementIdentifier($jq);
		
		var widgetConfig = undefined;
		try {
			var configText = $jq.text();
			widgetConfig = JSON.parse(configText);
		} catch(e) {
			// Ignore
		};
		if( !widgetConfig ){
			widgetConfig = {};
		};
		$jq.empty();
		
		// Check if it is available
		var m = {
			type: 'widgetIsTypeAvailable'
			,widgetType: widgetType
			,widgetOptions: widgetConfig
			,isAvailable: false
		};
		
		var d = this.dispatchService;
		if( d ){
			d.synchronousCall(DH,m);
		};
		
		if( !m.isAvailable ){
			$jq.attr('nunaliit-error','widget type not available');
			return;
		};
		
		// Insert widget
		if( d ){
			d.send(DH,{
				type: 'widgetDisplay'
				,widgetType: widgetType
				,widgetOptions: widgetConfig
				,containerId: containerId
				,config: this.config
			});
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'widgetIsTypeAvailable' === m.type ){
			if( m.widgetType === 'createDocument' ){
		        m.isAvailable = true;

			} else if( m.widgetType === 'createDocumentFromSchema' ){
				m.isAvailable = true;

			} else if( m.widgetType === 'documentSelector' ){
				m.isAvailable = true;

			} else if( m.widgetType === 'button' ){
				m.isAvailable = true;

			} else {
				if( $n2.couchDbPerspective 
				 && $n2.couchDbPerspective.HandleWidgetAvailableRequests ){
					$n2.couchDbPerspective.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetTime 
				 && $n2.widgetTime.HandleWidgetAvailableRequests ){
					$n2.widgetTime.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetPolarStereographicProjectionSelector 
				 && $n2.widgetPolarStereographicProjectionSelector.HandleWidgetAvailableRequests ){
					$n2.widgetPolarStereographicProjectionSelector.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetWait 
				 && $n2.widgetWait.HandleWidgetAvailableRequests ){
					$n2.widgetWait.HandleWidgetAvailableRequests(m);
				};

				if( $n2.mapAndControls 
				 && $n2.mapAndControls.HandleWidgetAvailableRequests ){
					$n2.mapAndControls.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetBookBrowser 
				 && $n2.widgetBookBrowser.HandleWidgetAvailableRequests ){
					$n2.widgetBookBrowser.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetNavigation 
				 && $n2.widgetNavigation.HandleWidgetAvailableRequests ){
					$n2.widgetNavigation.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetSplash 
				 && $n2.widgetSplash.HandleWidgetAvailableRequests ){
					$n2.widgetSplash.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetLayer 
				 && $n2.widgetLayer.HandleWidgetAvailableRequests ){
					$n2.widgetLayer.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetExport 
				 && $n2.widgetExport.HandleWidgetAvailableRequests ){
					$n2.widgetExport.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetModelBrowser 
				 && $n2.widgetModelBrowser.HandleWidgetAvailableRequests ){
					$n2.widgetModelBrowser.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetSelectableFilter 
				 && $n2.widgetSelectableFilter.HandleWidgetAvailableRequests ){
					$n2.widgetSelectableFilter.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetLegend 
				 && $n2.widgetLegend.HandleWidgetAvailableRequests ){
					$n2.widgetLegend.HandleWidgetAvailableRequests(m);
				};

				if( $n2.widgetCollapsibleContainer 
				 && $n2.widgetCollapsibleContainer.HandleWidgetAvailableRequests ){
					$n2.widgetCollapsibleContainer.HandleWidgetAvailableRequests(m);
				};
				
				if( $n2.widgetResizingContainer 
				 && $n2.widgetResizingContainer.HandleWidgetAvailableRequests ){
					$n2.widgetResizingContainer.HandleWidgetAvailableRequests(m);
				};
				
				if( $n2.widgetDuplicate 
				 && $n2.widgetDuplicate.HandleWidgetAvailableRequests ){
					$n2.widgetDuplicate.HandleWidgetAvailableRequests(m);
				};
				
				if( $n2.widgetTranscript 
				 && $n2.widgetTranscript.HandleWidgetAvailableRequests ){
					$n2.widgetTranscript.HandleWidgetAvailableRequests(m);
				};
			};

		} else if( 'widgetDisplay' === m.type ){
			if( m.widgetType === 'createDocument' ){
				BuildCreateDocumentWidgetFromRequest(m);

			} else if( m.widgetType === 'createDocumentFromSchema' ){
				BuildCreateDocumentFromSchemaWidget(m);

			} else if( m.widgetType === 'documentSelector' ){
				BuildDocumentSelectorWidget(m);

			} else if( m.widgetType === 'button' ){
				BuildButtonWidget(m);

			} else {
				if( $n2.couchDbPerspective 
				 && $n2.couchDbPerspective.HandleWidgetDisplayRequests ){
					$n2.couchDbPerspective.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetTime 
				 && $n2.widgetTime.HandleWidgetDisplayRequests ){
					$n2.widgetTime.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetPolarStereographicProjectionSelector 
				 && $n2.widgetPolarStereographicProjectionSelector.HandleWidgetDisplayRequests ){
					$n2.widgetPolarStereographicProjectionSelector.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetWait 
				 && $n2.widgetWait.HandleWidgetDisplayRequests ){
					$n2.widgetWait.HandleWidgetDisplayRequests(m);
				};

				if( $n2.mapAndControls 
				 && $n2.mapAndControls.HandleWidgetDisplayRequests ){
					$n2.mapAndControls.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetBookBrowser 
				 && $n2.widgetBookBrowser.HandleWidgetDisplayRequests ){
					$n2.widgetBookBrowser.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetNavigation 
				 && $n2.widgetNavigation.HandleWidgetDisplayRequests ){
					$n2.widgetNavigation.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetSplash 
				 && $n2.widgetSplash.HandleWidgetDisplayRequests ){
					$n2.widgetSplash.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetLayer 
				 && $n2.widgetLayer.HandleWidgetDisplayRequests ){
					$n2.widgetLayer.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetExport 
				 && $n2.widgetExport.HandleWidgetDisplayRequests ){
					$n2.widgetExport.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetModelBrowser 
				 && $n2.widgetModelBrowser.HandleWidgetDisplayRequests ){
					$n2.widgetModelBrowser.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetSelectableFilter 
				 && $n2.widgetSelectableFilter.HandleWidgetDisplayRequests ){
					$n2.widgetSelectableFilter.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetLegend 
				 && $n2.widgetLegend.HandleWidgetDisplayRequests ){
					$n2.widgetLegend.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetCollapsibleContainer 
				 && $n2.widgetCollapsibleContainer.HandleWidgetDisplayRequests ){
					$n2.widgetCollapsibleContainer.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetResizingContainer 
				 && $n2.widgetResizingContainer.HandleWidgetDisplayRequests ){
					$n2.widgetResizingContainer.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetDuplicate 
				 && $n2.widgetDuplicate.HandleWidgetDisplayRequests ){
					$n2.widgetDuplicate.HandleWidgetDisplayRequests(m);
				};

				if( $n2.widgetTranscript 
				 && $n2.widgetTranscript.HandleWidgetDisplayRequests ){
					$n2.widgetTranscript.HandleWidgetDisplayRequests(m);
				};
			};

		} else if( 'showPreprocessElement' === m.type ){
			var $elem = m.elem;
			this._showServicePreprocess($elem);
		};
	}
});

//--------------------------------------------------------------------------
$n2.widgetBasic = {
	Service: Service
	,CreateDocumentWidget: CreateDocumentWidget
	,CreateDocumentFromSchemaWidget: CreateDocumentFromSchemaWidget
	,ButtonWidget: ButtonWidget
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetWait.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetMapWait'
 ;

//--------------------------------------------------------------------------
var WaitWidget = $n2.Class({
	
	dispatchService: null,
	
	elemId: null,
	
	/*
	   Dictionary, by requester identifier, of waiting objects (dictionary). Each dictionary
	   is based on the 'name' of what is waited on. Finally, each
	   waiting object has the following structure
	   {
	      count: <integer, total number of items we are waiting for>
	      ,name: <string, represents what is waited on>
	      ,label: <string or localized string, name of what we are waiting for>
	   }
	 */
	waitingByRequesterId: null,
	
	showNames: null,
	
	refreshIntervalInMs: null,

	logging: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			
			// From configuration
			,showNames: null
			,refreshIntervalInMs: null
			,logging: false
		},opts_);
		
		var _this = this;
		
		this.waitingByRequesterId = {};
		this.showNames = false;

		if( typeof opts.showNames === 'boolean' ){
			this.showNames = opts.showNames;
		};

		if( typeof opts.refreshIntervalInMs === 'number' ){
			this.refreshIntervalInMs = opts.refreshIntervalInMs;
		} else {
			this.refreshIntervalInMs = 300;
		};

		if( typeof opts.logging === 'boolean' ){
			this.logging = opts.logging;
		};
		
		this.dispatchService = opts.dispatchService;
		if( this.dispatchService ){
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};

			this.dispatchService.register(DH, 'waitReport', fn);
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2wait')
			.appendTo($container);
		
		this._display();
		
		$n2.log('WaitWidget', this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	getCount: function(){
		var count = 0;
		
		for(var requesterId in this.waitingByRequesterId){
			var waitObjects = this.waitingByRequesterId[requesterId];
			for(var name in waitObjects){
				var waitObject = waitObjects[name];
				count += waitObject.count;
			};
		};
		
		return count;
	},
	
	_displayNames: function($names){
		var infoByName = {};
		
		// Organize by name
		for(var requesterId in this.waitingByRequesterId){
			var waitObjects = this.waitingByRequesterId[requesterId];
			for(var name in waitObjects){
				var waitObject = waitObjects[name];
				if( waitObject.count > 0 ){
					var info = infoByName[name];
					if( !info ){
						info = {
							name: name
							,label: waitObject.label
							,count: 0
						};
						infoByName[name] = info;
					};
					info.count += waitObject.count;
				};
			};
		};
		
		// Sort by label
		var infos = [];
		for(var name in infoByName){
			infos.push( infoByName[name] );
		};
		infos.sort(function(a,b){
			if( a.label === b.label ) return 0;
			if( a.label < b.label ) return -1;
			if( a.label > b.label ) return 1;
			return 0;
		});
		
		// Display
		for(var i=0,e=infos.length; i<e; ++i){
			var info = infos[i];
			var $name = $('<div>')
				.addClass('n2_wait_name')
				.appendTo($names);
			$('<span>')
				.addClass('n2_wait_name_label')
				.text( _loc(info.label) )
				.appendTo($name);
			$('<span>')
				.addClass('n2_wait_name_count')
				.text( '' + info.count )
				.appendTo($name);
		};
	},
	
	_display: function(){
		var _this = this;
		
		var $elem = this._getElem();
		if( $elem.hasClass('n2wait_showing') ){
			// Already showing
		} else {
			displayTask();
		};
		
		function displayTask(){
			var $elem = _this._getElem()
				.empty();

			var count = _this.getCount();
			if( count > 0 ){
				$elem
					.show()
					.addClass('n2wait_showing');
				
				if( _this.showNames ){
					var $names = $('<div>')
						.addClass('n2wait_names')
						.appendTo($elem);
					
					_this._displayNames($names);
				};
				
				$('<div>')
					.addClass('olkit_wait')
					.appendTo($elem);
				
				setTimeout(displayTask, _this.refreshIntervalInMs); // Reschedule
				
			} else {
				$elem
					.hide()
					.removeClass('n2wait_showing');
			};
		};
	},

	_handle: function(m, addr, dispatcher){
		if( 'waitReport' === m.type ){
			var requesterId = m.requester;
			var name = m.name;
			var count = m.count;
			var label = m.label;
			if( !label ){
				label = name;
			};
			
			if( typeof requesterId === 'string'
			 && typeof name === 'string' 
			 && typeof count === 'number' ){
				// Insert information
				var waitObjects = this.waitingByRequesterId[requesterId];
				if( !waitObjects ){
					waitObjects = {};
					this.waitingByRequesterId[requesterId] = waitObjects;
				};
				
				var waitObject = waitObjects[name];
				if( !waitObject ){
					waitObject = {
						name: name
						,label: label
						,count: 0
					};
					waitObjects[name] = waitObject;
				};

				// Report
				if( this.logging ){
					if( waitObject.count < 1 && count > 0 ){
						// Report start
						waitObject.start = Date.now();
						$n2.log('wait '+requesterId+'/'+name+' start '+waitObject.start)
					} else if( waitObject.count > 0 && count < 1 ){
						// Report end
						var end = Date.now();
						var elapsed = end - waitObject.start;
						$n2.log('wait '+requesterId+'/'+name+' end '+end+' elapsed '+elapsed)
					};
				};
				
				waitObject.count = count;
				
				// Refresh
				this._display();
			};
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'wait' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'wait' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var opName in widgetOptions){
				options[opName] = widgetOptions[opName];
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
		};
		
		new WaitWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetWait = {
	WaitWidget: WaitWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetSplash.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetSplash'
 ;

//--------------------------------------------------------------------------
var SplashPageWidget = $n2.Class({
	
	dispatchService: null,

	showService: null,
	
	interactionSeen: null,
	
	dialogId: null,
	
	pages: null,
	
	title: null,
	
	dialogWidth: null,
	
	pageIndex: null,
	
	showSplashPage: null,
	
	version: null,
	
	cookieName: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,showService: null
			,pages: null
			,title: null
			,dialogWidth: 800
			,version: 1
			,cookieName: 'NunaliitSplashDontShow'
		},opts_);
		
		var _this = this;

		this.interactionSeen = false;
		this.showSplashPage = false;
		this.dialogId = undefined;
		this.pages = undefined;
		this.pageIndex = 0;
		
		this.title = opts.title;
		this.dialogWidth = opts.dialogWidth;
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.version = opts.version;
		this.cookieName = opts.cookieName;
		
		if( opts.pages && $n2.isArray(opts.pages) ){
			this.pages = opts.pages;
		};
		
		// Set up model listener
		if( this.dispatchService ){
			// The following code has to do with displaying the initial
			// introduction page. It can not be done when the module is
			// first loaded since it relies on the event system and that
			// the events are not translated until the 'start' is sent.
			// However, on 'start', the HashTracker may elect to send
			// a 'select' or 'searchInitiate' event to repeat what is
			// specified in the URL. Therefore, we must wait after the
			// start to see if a selection was done before we can override
			// with our own event.

			// Do not show splash page before the start event is sent
			this.dispatchService.register(DH,'start',function(){
				// Wait to see if reloading page, the hash will load something
				window.setTimeout(function(){
					if( !_this.interactionSeen ){
						_this.showSplashPage = true;
						_this._showInitialSplash();
					};
				},0);
			});

			var f = function(m, addr, dispatcher){ 
				_this._handle(m, addr, dispatcher); 
			};

			this.dispatchService.register(DH,'searchInitiate',f);
			this.dispatchService.register(DH,'selected',f);
			this.dispatchService.register(DH,'splashWidgetSetPages',f);
			this.dispatchService.register(DH,'showPreprocessElement',f);
			this.dispatchService.register(DH,'splashShowSplashPage',f);
		};
		
		this._showInitialSplash();
		
		this._handleShowPreprocessElement( $('body') );

		$n2.log('SplashPageWidget', this);
	},
	
	_showInitialSplash: function(){
		// If a selection is performed from the initial URL,
		// do not show splash page
		if( !this.showSplashPage ) return;

		// We are about to show splash. Check if a cookie is
		// set to prevent us from showing splash
		if( $n2.cookie && $n2.cookie.getCookie ){
			var cookie = $n2.cookie.getCookie(this.cookieName);
			var cookieVersion = 1 * cookie;
			if( cookieVersion >= this.version ){
				return;
			};
		};

		this._showSplash(true);
	},
	
	_showSplash: function(isInitialPage){
		var _this = this;

		if( !this.pages ) return;
		
		var $dialog = $('<div>')
			.addClass('n2Splash_dialog')
			.appendTo( $('body') );
		this.dialogId = $n2.utils.getElementIdentifier($dialog);
		
		var $content = $('<div>')
			.addClass('n2Splash_container n2Splash_updatePageIndex')
			.appendTo( $dialog );

		var $buttons = $('<div>')
			.addClass('n2Splash_buttons n2Splash_updatePageIndex')
			.appendTo( $dialog );

		$('<span>')
			.addClass('n2Splash_insertPreviousButton')
			.appendTo($buttons);
		
		$('<span>')
			.addClass('n2Splash_insertIndex')
			.appendTo($buttons);
		
		$('<span>')
			.addClass('n2Splash_insertRibbon')
			.appendTo($buttons);

		$('<span>')
			.addClass('n2Splash_insertNextButton')
			.appendTo($buttons);
	

		if( isInitialPage ){
			$('<span>')
				.addClass('n2Splash_insertDontShow')
				.appendTo($buttons);
		};
		
		$('<span>')
			.addClass('n2Splash_insertCloseButton')
			.appendTo($buttons);

		// Print HTML
		this._showCurrentPage();
		
		var title = undefined;
		if( this.title ){
			title = _loc(this.title);
		};
		if( !title ){
			title = _loc('Welcome');
		};
		var diagOptions = {
			autoOpen: true
			,title: title
			,modal: true
			,width: this.dialogWidth
			,dialogClass: 'n2Splash_dialog_container'
			,close: function(event, ui){
				var $diag = $(event.target);
				$diag.dialog('destroy');
				$diag.remove();
			}
		};
		
		$dialog.dialog(diagOptions);
	},

	_showCurrentPage: function(){
		var _this = this;
		
		var page = this.pages[this.pageIndex];

		var $dialog = $('#'+this.dialogId);
		
		var $container = $dialog.find('.n2Splash_container')
			.empty();
		
		if( page.html ){
			var html = page.html;
			if( typeof html === 'object' 
			 && 'localized' === html.nunaliit_type ){
				html = _loc(html);
			};
			
			$container.html(html);

		} else if( page.text ){
			$container.text(page.text);
		};
		
		this._fixElements($dialog);
		if( this.showService ){
			this.showService.fixElementAndChildren($dialog, {}, page.doc);
		};
	},
	
	_fixElements: function($dialog){
		var _this = this;

		// Insert Previous Button
		$dialog.find('.n2Splash_insertPreviousButton').each(function(){
			var $elem = $(this);

			var label = $elem.attr('nunaliit-label');
			if( !label ){
				label = _loc('Previous');
			};

			$('<a>')
				.addClass('n2Splash_button n2Splash_button_previous n2Splash_button_disabled')
				.text( label )
				.attr('href','#')
				.appendTo($elem)
				.click(function(){
					var index = _this.pageIndex;
					_this._goToPage(index-1);
					return false;
				});
			
			$elem
				.removeClass('n2Splash_insertPreviousButton')
				.addClass('n2Splash_insertedPreviousButton');
		});

		// Insert Next Button
		$dialog.find('.n2Splash_insertNextButton').each(function(){
			var $elem = $(this);

			var label = $elem.attr('nunaliit-label');
			if( !label ){
				label = _loc('Next');
			};

			$('<a>')
				.addClass('n2Splash_button n2Splash_button_next n2Splash_button_disabled')
				.text( label )
				.attr('href','#')
				.appendTo($elem)
				.click(function(){
					var index = _this.pageIndex;
					_this._goToPage(index+1);
					return false;
				});
			
			$elem
				.removeClass('n2Splash_insertNextButton')
				.addClass('n2Splash_insertedNextButton');
		});

		// Insert Close Button
		$dialog.find('.n2Splash_insertCloseButton').each(function(){
			var $elem = $(this);

			var label = $elem.attr('nunaliit-label');
			if( !label ){
				label = _loc('Close');
			};

			$('<a>')
				.addClass('n2Splash_button n2Splash_button_close n2Splash_button_enabled')
				.text( label )
				.attr('href','#')
				.appendTo($elem)
				.click(function(){
					var $diag = $('#'+_this.dialogId);
					$diag.dialog('close');
					return false;
				});
			
			$elem
				.removeClass('n2Splash_insertCloseButton')
				.addClass('n2Splash_insertedCloseButton');
		});

		// Insert Index
		$dialog.find('.n2Splash_insertIndex').each(function(){
			var $elem = $(this);

			// Just add a class. Recomputed every time
			$elem.addClass('n2Splash_index');
			
			$elem
				.removeClass('n2Splash_insertIndex')
				.addClass('n2Splash_insertedIndex');
		});

		// Insert Ribbon
		$dialog.find('.n2Splash_insertRibbon').each(function(){
			var $elem = $(this);

			$elem
				.empty()
				.attr('nunaliit-page-count',_this.pages.length);

			for(var i=0,e=_this.pages.length; i<e; ++i){
				var pageNumber = i + 1;

				var $pageDiv = $('<span>')
					.addClass('n2Splash_ribbon_page')
					.attr('nunaliit-page-index',i)
					.appendTo($elem);
				
				$('<a>')
					.attr('href','#')
					.text(pageNumber)
					.appendTo($pageDiv)
					.click(function(){
						var $pageDiv = $(this).parent();
						var pageIndex = 1 * $pageDiv.attr('nunaliit-page-index')
						_this._goToPage(pageIndex);
						return false;
					});
			};
			
			$elem
				.removeClass('n2Splash_insertRibbon')
				.addClass('n2Splash_insertedRibbon');
		});
		
		// Insert don't show again
		$dialog.find('.n2Splash_insertDontShow').each(function(){
			var $elem = $(this);

			var label = $elem.attr('nunaliit-label');
			if( !label ){
				label = _loc('Do not show again');
			};

			var cbId = $n2.getUniqueId();
			$('<label>')
				.addClass('n2Splash_label n2Splash_label_dontshow')
				.attr('for',cbId)
				.text( label )
				.appendTo($elem);

			$('<input>')
				.addClass('n2Splash_button n2Splash_button_dontshow')
				.attr('type','checkbox')
				.attr('id',cbId)
				.appendTo($elem)
				.click(function(){
					var $cb = $(this);
					var isChecked = $cb.is(':checked');
					_this._doNotShowAgain(isChecked);
					return true;
				});
			
			$elem
				.removeClass('n2Splash_insertDontShow')
				.addClass('n2Splash_insertedDontShow');
		});
		
		// Update element attributes that state page index
		$dialog.find('.n2Splash_updatePageIndex').each(function(){
			var $elem = $(this);
			var currentIndex = _this.pageIndex;
			
			$elem.attr('nunaliit-page-index',currentIndex);
			
			if( 0 === currentIndex ){
				$elem.addClass('n2Splash_currentIsFirstPage');
			} else {
				$elem.removeClass('n2Splash_currentIsFirstPage');
			};
			
			if( currentIndex >= (_this.pages.length - 1) ){
				$elem.addClass('n2Splash_currentIsLastPage');
			} else {
				$elem.removeClass('n2Splash_currentIsLastPage');
			};
		});
		
		// Update index
		var $index = $dialog.find('.n2Splash_index').empty();
		if( this.pages.length > 1 ){
			var indexStr = '('+(this.pageIndex+1)+'/'+this.pages.length+')';
			$index.text( indexStr );
		};
		
		// Update ribbon
		$dialog.find('.n2Splash_ribbon_page').each(function(){
			var $pageDiv = $(this);
			var pageIndex = 1 * $pageDiv.attr('nunaliit-page-index')
			if( pageIndex === _this.pageIndex ){
				$pageDiv.addClass('n2Splash_ribbon_page_current');
			} else {
				$pageDiv.removeClass('n2Splash_ribbon_page_current');
			};
		});
		
		// Update previous buttons
		var $prevButton = $dialog.find('.n2Splash_button_previous');
		if( 0 == this.pageIndex ){
			$prevButton.removeClass('n2Splash_button_enabled');
			$prevButton.addClass('n2Splash_button_disabled');
		} else {
			$prevButton.addClass('n2Splash_button_enabled');
			$prevButton.removeClass('n2Splash_button_disabled');
		};

		// Update next buttons
		var $nextButton = $dialog.find('.n2Splash_button_next');
		if( this.pageIndex >= (this.pages.length-1) ){
			$nextButton.removeClass('n2Splash_button_enabled');
			$nextButton.addClass('n2Splash_button_disabled');
		} else {
			$nextButton.addClass('n2Splash_button_enabled');
			$nextButton.removeClass('n2Splash_button_disabled');
		};
	},

	_changeCurrentPage: function(pageDelta){
		if( pageDelta < 0 ){
			--this.pageIndex;
			if( this.pageIndex < 0 ){
				this.pageIndex = 0;
			};

		} else if( pageDelta > 0 ){
			++this.pageIndex;
			if( this.pageIndex >= this.pages.length ){
				this.pageIndex = this.pages.length - 1;
			};
		};
		
		this._showCurrentPage();
	},

	_goToPage: function(pageIndex){
		if( pageIndex < 0 ){
			pageIndex = 0;

		} else if( pageIndex >= this.pages.length ){
			pageIndex = this.pages.length - 1;
		};
		
		if( this.pageIndex !== pageIndex ){
			this.pageIndex = pageIndex;
			this._showCurrentPage();
		};
	},

	_doNotShowAgain: function(dontShow){
		if( dontShow ){
			var now = new Date();
			var expiry = new Date(now.getTime() + (1000 * 60 * 60 * 24 * 400)); // 440 days
			$n2.cookie.setCookie({
				name: this.cookieName
				,value: ''+this.version
				,end: '' + expiry
				,path: '/'
			});
		} else {
			$n2.cookie.deleteCookie(this.cookieName);
		};
	},
	
	_insertShowSplashPageButton: function($elem){
		var _this = this;
		
		$elem.empty();
		var elemId = $n2.utils.getElementIdentifier($elem);
		
		var label = $elem.attr('nunaliit-label');
		if( !label ){
			label = _loc('Help');
		};
		
		if( this.dispatchService ){
			var $elem = $('#'+elemId);
			
			$('<a>')
				.addClass('n2splash_showSplashButton')
				.attr('href','#')
				.text( label )
				.appendTo($elem)
				.click(function(){
					_this.dispatchService.send(DH,{
						type: 'splashShowSplashPage'
					});
					return false;
				});
		};
	},
	
	_handleShowPreprocessElement: function($elem){
		var _this = this;

		var $set = $elem.find('*').addBack();
		
		// Localization
		$set.filter('.n2s_insertShowSplashPageButton').each(function(){
			var $jq = $(this);
			_this._insertShowSplashPageButton($jq);
			$jq
				.removeClass('n2s_insertShowSplashPageButton')
				.addClass('n2s_insertedShowSplashPageButton');
		});
	}, 
	
	_handle: function(m, addr, dispatcher){
		// If a 'selected' or 'searchInitiate' event is seen, then the page
		// has been reloaded
		if( 'searchInitiate' === m.type 
		 || 'selected' === m.type ){
			this.interactionSeen = true;

		} else if( 'splashWidgetSetPages' === m.type ){
			if( $n2.isArray(m.pages) ){
				this.pages = m.pages;
				
				if( typeof m.version === 'number' ){
					this.version = m.version;
				};
				
				if( typeof m.cookieName === 'string' ){
					this.cookieName = m.cookieName;
				};
				
				this.pageIndex = 0;
				this._showInitialSplash();
			};

		} else if( 'showPreprocessElement' === m.type ){
			var $elem = m.elem;
			this._handleShowPreprocessElement($elem);

		} else if( 'splashShowSplashPage' === m.type ){
			this._showSplash(false);
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'splashPage' ){
		m.isAvailable = true;
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'splashPage' ){
		var widgetOptions = m.widgetOptions;
		var config = m.config;
		
		var options = {};

		if( widgetOptions ){
			for(var key in widgetOptions){
				options[key] = widgetOptions[key];
			};
		};
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.showService = config.directory.showService;
		};
		
		new SplashPageWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetSplash = {
	SplashPageWidget: SplashPageWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetTime.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetTime'
 ;

//--------------------------------------------------------------------------
function numberToPaddedString(d){
	if (d < 10) {
        return '0' + d;
      }
      return '' + d;
};

//--------------------------------------------------------------------------
function formatDate(date, format){
	var acc = [];

	// Is year requested?
	if( format.indexOf('Y') >= 0 ){
		acc.push( date.getUTCFullYear() );
	};
	
	// Is month requested?
	if( format.indexOf('M') >= 0 ){
		if( acc.length > 0 ){
			acc.push( '-' );
		};
		acc.push( numberToPaddedString(date.getUTCMonth() + 1) );
	};
	
	// Is day of month requested?
	if( format.indexOf('D') >= 0 ){
		if( acc.length > 0 ){
			acc.push( '-' );
		};
		acc.push( numberToPaddedString(date.getUTCDate()) );
	};
	
	// Is time requested?
	if( format.indexOf('T') >= 0 ){
		if( acc.length > 0 ){
			acc.push( ' ' );
		};
		acc.push( numberToPaddedString(date.getUTCHours()) );
		acc.push( ':' );
		acc.push( numberToPaddedString(date.getUTCMinutes()) );
	};
	
	return acc.join('');
};
 
//--------------------------------------------------------------------------
var TimelineWidget = $n2.Class({
	
	dispatchService: null,
	
	sourceModelId: null,
	
	elemId: null,

	rangeChangeEventName: null,

	rangeGetEventName: null,

	rangeSetEventName: null,

	intervalChangeEventName: null,

	intervalGetEventName: null,

	intervalSetEventName: null,
	
	rangeMin: null,
	
	rangeMax: null,
	
	intervalMin: null,
	
	intervalMax: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,sourceModelId: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.sourceModelId = opts.sourceModelId;
		
		this.rangeMin = null;
		this.rangeMax = null;
		this.intervalMin = null;
		this.intervalMax = null;
		
		// Set up model listener
		if( this.dispatchService ){
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.range ){
				var paramInfo = sourceModelInfo.parameters.range;
				this.rangeChangeEventName = paramInfo.changeEvent;
				this.rangeGetEventName = paramInfo.getEvent;
				this.rangeSetEventName = paramInfo.setEvent;

				if( paramInfo.value ){
					this.rangeMin = paramInfo.value.min;
					this.rangeMax = paramInfo.value.max;
				};
			};
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.interval ){
				var paramInfo = sourceModelInfo.parameters.interval;
				this.intervalChangeEventName = paramInfo.changeEvent;
				this.intervalGetEventName = paramInfo.getEvent;
				this.intervalSetEventName = paramInfo.setEvent;

				if( paramInfo.value ){
					this.intervalMin = paramInfo.value.min;
					this.intervalMax = paramInfo.value.max;
				};
			};
			
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			if( this.rangeChangeEventName ){
				this.dispatchService.register(DH, this.rangeChangeEventName, fn);
			};
			
			if( this.intervalChangeEventName ){
				this.dispatchService.register(DH, this.intervalChangeEventName, fn);
			};
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2timeline')
			.appendTo($container);
		
		this._display();
		
		$n2.log('TimelineWidget', this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_getSlider: function(){
		var _this = this;
		
		var $slider = $('#'+this.elemId).find('.n2timeline_slider');
		if( $slider.length < 1 ){
			// Must recreate
			if( typeof this.rangeMin === 'number' 
			 && typeof this.rangeMax === 'number' 
			 && typeof this.intervalMin === 'number' 
			 && typeof this.intervalMax === 'number' ){
				var $sliderWrapper = $('#'+this.elemId).find('.n2timeline_slider_wrapper');

				$slider = $('<div>')
					.addClass('n2timeline_slider')
					.appendTo($sliderWrapper);

				$slider.slider({
					range: true
					,min: this.rangeMin
					,max: this.rangeMax
					,values: [this.intervalMin, this.intervalMax]
					,slide: function(event, ui){
						_this._barUpdated(ui);
					}
				});
			};
		};
		return $slider;
	},
	
	_removeSlider: function(){
		$('#'+this.elemId).find('.n2timeline_slider_wrapper').empty();
	},
	
	_display: function(){
		var $elem = this._getElem()
			.empty();
		
		var $container = $('<div>')
			.addClass('n2timeline_container')
			.appendTo($elem);

		$('<div>')
			.addClass('n2timeline_range')
			.appendTo($container);
		
		var $sliderWrapper = $('<div>')
			.addClass('n2timeline_slider_wrapper')
			.appendTo($container);

		$('<div>')
			.addClass('n2timeline_interval')
			.appendTo($container);

		// Create slider
		this._getSlider();

		this._displayRange();
		this._displayInterval();
	},

	_displayRange: function(){
		var $elem = this._getElem();

		var $topLine = $elem.find('.n2timeline_range')
			.empty();

		if( typeof this.rangeMin === 'number' 
		 && typeof this.rangeMax === 'number' ){
			// Compute range
			var minDate = new Date(this.rangeMin);
			var maxDate = new Date(this.rangeMax);
			
			var minDateStr = formatDate(minDate, 'YMD');
			var maxDateStr = formatDate(maxDate, 'YMD');
	
			// Display
			var textRange = '' + minDateStr + ' / ' + maxDateStr;
			$topLine.text(textRange);
		};
	},

	_displayInterval: function(){
		var $elem = this._getElem();

		var $intervalLine = $elem.find('.n2timeline_interval')
			.empty();

		if( typeof this.intervalMin === 'number' 
		 && typeof this.intervalMax === 'number' ){
			// Compute range
			var minDate = new Date(this.intervalMin);
			var maxDate = new Date(this.intervalMax);
			
			var minDateStr = formatDate(minDate, 'YMD');
			var maxDateStr = formatDate(maxDate, 'YMD');
	
			// Display
			var textRange = '' + minDateStr + ' / ' + maxDateStr;
			$intervalLine.text(textRange);
		};
	},

	_barUpdated: function(ui){
		var min = ui.values[0];
		var max = ui.values[1];
		
		//$n2.log('timeline min:'+min+' max:'+max);
		
		if( this.dispatchService ){
			var value = new $n2.date.DateInterval({
				min: min
				,max: max
				,ongoing: false
			});
			
			this.dispatchService.send(DH,{
				type: this.intervalSetEventName
				,value: value
			});
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( this.rangeChangeEventName === m.type ){
			if( m.value ){
				this.rangeMin = m.value.min;
				this.rangeMax = m.value.max;
				
				var $slider = this._getSlider();
				$slider.slider({
					min:this.rangeMin
					,max:this.rangeMax
				});

				if( typeof this.intervalMin === 'number' 
				 && typeof this.intervalMax === 'number' ){
					$slider.slider({
						values: [this.intervalMin,this.intervalMax]
					});
				};
				
			} else {
				this.rangeMin = null;
				this.rangeMax = null;
				this._removeSlider();
			};
			
			this._displayRange();
			
		} else if( this.intervalChangeEventName === m.type ){
			if( m.value ){
				this.intervalMin = m.value.min;
				this.intervalMax = m.value.max;

				var $slider = this._getSlider();
				$slider.slider({
					values: [this.intervalMin,this.intervalMax]
				});
				
			} else {
				this.intervalMin = null;
				this.intervalMax = null;
				this._removeSlider();
			};
			
			this._displayInterval();
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'timeline' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'timeline' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
		};
		
		new TimelineWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetTime = {
	TimelineWidget: TimelineWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetPolarStereographicProjectionSelector.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetPolarStereographicProjectionSelector'
 ;

// Required library: d3
var $d = null;
if( window ){ $d = window.d3; };

var DEFAULT_IMAGE_LOCATION = 'nunaliit2/images/arctic.png';

//--------------------------------------------------------------------------
var ProjectionSelector = $n2.Class({
	
	dispatchService: null,
	
	elemId: null,
	
	mapControl: null,
	
	width: null,
	
	height: null,
	
	imageLocation: null,
	
	imageRotation: null,
	
	selectionMap: null,
	
	currentLng: null,
	
	svgCTM: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,rootPath: './'
			,moduleDisplay: null
			,width: 100
			,height: 100
			,imageLocation: null
			,imageRotation: 0
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.rootPath = opts.rootPath;
		this.width = 1 * opts.width;
		this.height = 1 * opts.height;
		
		// Retrieve map controls if provided
		if( opts.moduleDisplay ){
			this._setMapControl(opts.moduleDisplay.mapControl);
		};
		
		if( opts.imageLocation ){
			this.imageLocation = this.rootPath + opts.imageLocation;
			this.imageRotation = opts.imageRotation;
		} else {
			this.imageLocation = this.rootPath + DEFAULT_IMAGE_LOCATION;
			this.imageRotation = 0;
		};
		
		// Wait for map control, if not yet available
		if( this.dispatchService && !this.mapControl ){
			this.dispatchService.register(DH,'reportModuleDisplay',function(m){
				if( m.moduleDisplay 
				 && m.moduleDisplay.mapControl ){
					_this._setMapControl(m.moduleDisplay.mapControl);
					_this._display();
				};
			});
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2polarStereographicProjectionSelector')
			.appendTo($container);
		
		this._display();
		
		$n2.log('ProjectionSelector', this);
	},
	
	_setMapControl: function(mapControl){
		var _this = this;
		
		this.mapControl = mapControl;
		
		if( this.mapControl 
		 && this.mapControl.map
		 && this.mapControl.map.events ){
			this.mapControl.map.events.register('changebaselayer',null,function(evt){
	        	_this._updateFromMap();
	        });
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_getBaseLayers: function(mapControl){
		var result = [];
		
		if( mapControl && mapControl.map && mapControl.map.layers ){
			for(var i=0,e=mapControl.map.layers.length; i<e; ++i){
				var layer = mapControl.map.layers[i];
				if( layer.isBaseLayer ){
					result.push(layer);
				};
			};
		};
		
		return result;
	},
	
	_selectPolarStereographicLayers: function(layers){
		var result = [];
		
		for(var i=0,e=layers.length; i<e; ++i){
			var layer = layers[i];
			var projection = layer.projection;
			if( projection 
			 && projection.proj ){
				if( 'laea' === projection.proj.projName 
				 && typeof projection.proj.long0 === 'number'){
					result.push(layer);
				};
			};
		};
		
		return result;
	},
	
	_createSelectionMap: function(layers){
		var result = {};
		
		for(var i=0,e=layers.length; i<e; ++i){
			var layer = layers[i];
			var proj = layer.projection.proj;
			var lng = proj.long0 * 180 / Math.PI;
			var id = layer.id;

			var angle = 360 - lng;
			if( angle > 180 ){
				angle -= 360;
			};
			
			result[id] = {
				id: id
				,angle: angle
				,lng: lng
				,srsCode: proj.srsCode
			};
		};
		
		return result;
	},
	
	_display: function(){
		var _this = this;
		
		this._getElem().empty();
		
		// No map, no widget
		if( !this.mapControl ) return;
		
		// Extract all base layers
		var baseLayers = this._getBaseLayers(this.mapControl);
		var polarLayers = this._selectPolarStereographicLayers(baseLayers);
		
		if( baseLayers.length < 1 ){
			$n2.log('ProjectionSelector: no base layer');
			return;
		} else if( baseLayers.length != polarLayers.length ){
			$n2.log('ProjectionSelector: not all base layers are polar stereographic');
			return;
		};
		
		this.selectionMap = this._createSelectionMap(polarLayers);
		
		var imagePadding = 10;
		var imageRadius = null;
		var overlayRadius = null;
		if( this.width > this.height ){
			imageRadius = Math.floor( (this.height/2) - imagePadding );
			overlayRadius = Math.floor(this.height/2);
		} else {
			imageRadius = Math.floor( (this.width/2) - imagePadding );
			overlayRadius = Math.floor(this.width/2);
		};
		
 		var $svg = $d.select('#' + this.elemId)
 			.append('svg')
 			.attr('width', this.width)
 			.attr('height', this.height)
 			//.attr('viewbox', '0 0 100 100')
 			;
 		
 		$svg.each(function(){
 			var svgNode = this;

 			try {
	 			var svgCTM = svgNode.getScreenCTM();
	 			var inverseScreenCTM = svgCTM.inverse();
	 			_this.svgCTM = inverseScreenCTM;
 			} catch(e) {
 				// ignore
 				$n2.log('Unable to obtain SVG CTM: '+ e);
 			};
 		});

 		var $center = $svg.append('g')
			.attr('class','centerGroup')
			.attr('transform','translate('+Math.floor(this.width/2)+','+Math.floor(this.height/2)+')')
			;
 		
 		$center.append('circle')
 			.attr('r',Math.floor(this.width/2)-Math.floor(imagePadding/2))
 			.attr('fill','none')
 			.attr('stroke','#aaaaaa')
 			.attr('stroke-width',Math.floor(imagePadding/2))
 			;

 		$center.append('path')
			.attr('d','M 0 0 L -4 -8 L 4 -8 Z')
			.attr('transform','translate(0,' + imageRadius + ') rotate(180)')
			.attr('fill','#ff0000')
			.attr('stroke','#ffffff')
			.attr('stroke-width',1)
			;
 		
 		var $rotateGroup = $center.append('g')
 			.attr('class','rotateGroup')
 			.attr('transform','rotate(0)')
 			;
 		
 		$center.append('circle')
 			.attr('r',overlayRadius)
 			.attr('fill','#000000')
 			.attr('fill-opacity',0.0)
 			.attr('stroke','none')
 			.on('mouseover', function(n){
 				var e = $d.event;
 				_this._initiateMouseOver(n,e);
 			})
 			.on('mousemove', function(n){
 				var e = $d.event;
 				_this._initiateMouseMove(n,e);
 			})
 			.on('mouseout', function(n){
 				var e = $d.event;
 				_this._initiateMouseOut(n,e);
 			})
 			.on('click', function(n){
 				var e = $d.event;
 				_this._initiateMouseClick(n,e);
 			})
 			;
		
 		$rotateGroup.append('image')
 			.attr('transform','rotate('+this.imageRotation+')')
 			.attr('x',0 - imageRadius)
 			.attr('y',0 - imageRadius)
 			.attr('width',imageRadius*2)
 			.attr('height',imageRadius*2)
 			.attr('xlink:href',this.imageLocation)
 			;

 		var $arrowsGroup = $rotateGroup
 			.append('g')
 			.attr('class', 'projArrows')
 			;
 		
 		var baseLayerData = [];
 		for(var baseLayerId in this.selectionMap){
 			var info = this.selectionMap[baseLayerId];
 			baseLayerData.push(info);
 		};
 		
 		var $arrows = $arrowsGroup.selectAll('.projArrow')
 			.data(baseLayerData, function(d){ return d.id; })
 			;
 		
 		$arrows.enter()
 			.append('path')
			.attr('class','projArrow')
			.attr('transform',function(d){ return 'rotate('+d.angle+') translate(0,'+imageRadius+')'; })
			.attr('d','M 0 0 L -4 -8 L 4 -8 Z')
			.attr('fill','#000000')
			.attr('stroke','#ffffff')
			.attr('stroke-width',1)
			;
 		
 		this._updateFromMap();
	},
	
	_rotateTo: function(lng){
		this.currentLng = lng;
		
		$d.select('#' + this.elemId)
			.select('g.rotateGroup')
			.transition()
			.attr('transform', 'rotate(' + lng + ')')
			;
	},
	
	_updateFromMap: function(){
		if( this.mapControl 
		 && this.mapControl.map 
		 && this.mapControl.map.baseLayer ){
			var id = this.mapControl.map.baseLayer.id;
			
			var lng = null;
			if( this.selectionMap ){
				for(var layerId in this.selectionMap){
					var layerInfo = this.selectionMap[layerId];
					layerInfo.selected = false;
					
					if( layerId === id ){
						layerInfo.selected = true;
						lng = layerInfo.lng;
					};
				};
			};
			
			if( typeof lng === 'number' ){
				this._rotateTo(lng);
			};
		};
		
		this._updateArrowStyles();
	},
	
	_updateArrowStyles: function(){
		if( this.selectionMap ){
	 		var $arrowsGroup = $d.select('#' + this.elemId).select('g.projArrows');
	 		
	 		var baseLayerData = [];
	 		for(var baseLayerId in this.selectionMap){
	 			var info = this.selectionMap[baseLayerId];
	 			baseLayerData.push(info);
	 		};
	 		
	 		$arrowsGroup.selectAll('.projArrow')
	 			.data(baseLayerData, function(d){ return d.id; })
	 			.attr('fill', function(d){
	 				if( d.hovered ){
	 					return '#0000ff';
	 				} else if( d.selected ){
	 					return '#ff0000';
	 				} else {
	 					return '#000000';
	 				};
	 			})
	 			;
		};
	},
	
	_angleFromMouseHover: function(x,y){
		var angle = null;
		
		var effX = x - Math.floor(this.width/2);
		var effY = y - Math.floor(this.height/2);
		if( 0 == effX && 0 == effY){
			return null;
			
		} else if( 0 == effY ){
			if( effX < 0 ){
				angle = -90;
			} else {
				angle = 90;
			}
		} else {
			angle = Math.atan(effX / effY) * 180 / Math.PI;
			if( effY < 0 ){
				angle += 180;
			};
			if( angle > 180 ){
				angle = angle - 360;
			};
		};

		return angle;
	},
	
	_getSelectionFromAngle: function(lng){
		var selected = null;
		var delta = null;
		for(var id in this.selectionMap){
			var selection = this.selectionMap[id];
			
			var d = selection.lng - lng;
			d = Math.abs(d);
			if( d > 180 ){
				d = 360 - d;
			};
			
			if( !selected ){
				selected = selection;
				delta = d;
			} else if( d < delta ){
				selected = selection;
				delta = d;
			};
		};
		
		return selected;
	},
	
	_userMouseHover: function(x,y){
		var angle = this._angleFromMouseHover(x, y);
		//$n2.log('angle: '+angle);

		if( typeof angle === 'number' 
		 && typeof this.currentLng === 'number' ){
			var effLng = angle + this.currentLng;
			if( effLng > 180 ){
				effLng -= 360;
			};
			if( effLng < -180 ){
				effLng += 360;
			};
			//$n2.log('effLng: '+effLng);
			
			// Select closest info
			var selection = this._getSelectionFromAngle(effLng);
			for(var id in this.selectionMap){
				var s = this.selectionMap[id];

				if( selection === s ){
					s.hovered = true;
				} else {
					s.hovered = false;
				};
			};
			
			this._updateArrowStyles();
		};
	},
	
	_getLocationFromEvent: function(e){
		var loc = null;
		
		if( typeof e.offsetX === 'number' ){
			loc = {
				x: e.offsetX
				,y: e.offsetY
			};
		} else {
			if( this.svgCTM ){
				var m = this.svgCTM;
				var x = (e.clientX * m.a) + (e.clientY * m.c) + m.e;
				var y = (e.clientX * m.b) + (e.clientY * m.d) + m.f;

				loc = {
					x: x
					,y: y
				};
			};
		};

		//$n2.log('loc x:'+(loc ? loc.x : null)+' y:'+(loc ? loc.y : null));
		
		return loc;
	},
	
	_initiateMouseOver: function(n,e){
		var loc = this._getLocationFromEvent(e);
		if( loc ){
			//$n2.log('over x:'+loc.x+' y:'+loc.y);
			this._userMouseHover(loc.x, loc.y);
		};
	},
	
	_initiateMouseMove: function(n,e){
		var loc = this._getLocationFromEvent(e);
		if( loc ){
			//$n2.log('move x:'+loc.x+' y:'+loc.y);
			this._userMouseHover(loc.x, loc.y);
		};
	},
	
	_initiateMouseOut: function(n,e){
		// Turn off all
		for(var id in this.selectionMap){
			var s = this.selectionMap[id];
			s.hovered = false;
		};
		
		this._updateArrowStyles();
	},
	
	_initiateMouseClick: function(n,e){
		var loc = this._getLocationFromEvent(e);
		if( loc ){
			//$n2.log('click x:'+loc.x+' y:'+loc.y);
			
			var angle = this._angleFromMouseHover(loc.x, loc.y);
			//$n2.log('angle: '+angle);
	
			if( typeof angle === 'number' 
			 && typeof this.currentLng === 'number' ){
				var effLng = angle + this.currentLng;
				if( effLng > 180 ){
					effLng -= 360;
				};
				if( effLng < -180 ){
					effLng += 360;
				};
				//$n2.log('effLng: '+effLng);
				
				// Select closest info
				var selection = this._getSelectionFromAngle(effLng);
				for(var id in this.selectionMap){
					var s = this.selectionMap[id];
	
					if( selection === s ){
						if( this.mapControl 
						 && this.mapControl.setBaseLayer ){
							this.mapControl.setBaseLayer(s.id);
						};
					};
				};
			};
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	// Required library: d3
	if( !$d && window ) $d = window.d3;

	if( m.widgetType === 'polarStereographicProjectionSelector' ){
		if( $d ) {
			m.isAvailable = true;
		} else {
			$n2.log('Widget polarStereographicProjectionSelector requires d3 library');
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'polarStereographicProjectionSelector' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var moduleDisplay = m.moduleDisplay;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		options.moduleDisplay = moduleDisplay;
		
		if( config && config.directory ){
			options.rootPath = config.rootPath;
			
			if( config.directory ){
				options.dispatchService = config.directory.dispatchService;
			};
		};
		
		new ProjectionSelector(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetPolarStereographicProjectionSelector = {
	ProjectionSelector: ProjectionSelector
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetBookBrowser.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetBookBrowser'
 ;

//--------------------------------------------------------------------------
// Abstract class representing a Page in a Book. 
// A page is made up of:
// - a URL for an image
// - a document id (to select document associated with page)
// - an index value (to sort pages in a Book)
var Page = $n2.Class({

	imageUrl: null,
	
	docId: null,
	
	index: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			imageUrl: null
			,docId: null
			,index: null
		},opts_);

		this.imageUrl = opts.imageUrl;
		this.docId = opts.docId;
		this.index = opts.index;
	},
	
	/**
	 * Returns the URL associated with this page
	 */
	getImageUrl: function(){
		return this.imageUrl;
	},
	
	/**
	 * Returns the identifier of the document associated with this
	 * page. Returns null or undefined if the page is not associated with
	 * a document.
	 */
	getDocId: function(){
		return this.docId;
	},
	
	/**
	 * Returns an index representing the position of the page in the book.
	 */
	getIndex: function(){
		return this.index;
	}
});

//--------------------------------------------------------------------------
// Abstract class for the representation of a Book, which can be displayed in
// the BookBrowser. This is mainly a collection of ordered pages.
var Book = $n2.Class({
	
	pages: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
		},opts_);
		
		this.pages = null;
	},
	
	/**
	 * Returns an array of Page instances. Returns null or
	 * undefined if the pages are not yet loaded
	 */
	getPages: function(){
		return this.pages;
	},
	
	/**
	 * Load the pages associated with the book and calls one of
	 * the callbacks when it is done.
	 */
	loadPages: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(pages, book){}
			,onError: function(err){}
		},opts_);
		
		throw 'Subclasses of book must implement loadPages()';
	}
});
 
//--------------------------------------------------------------------------
// The book browser widget creates a vertical scrolling that displays individual
// pages from a book. Each page from the book is an image that is loaded only when
// in comes into view.
//
// When the book browser is scrolled, the currently seen page is used to generate a selection
// event through the dispatcher. The document selected is the one associated with the current
// page. The current page is determined as the one crossing the horizontal line dividing
// the book browser in halves.
//
// The book browser also listens to dispatcher events. When a selected doc id corresponds to
// one of the pages, then the book is scrolled to show that page.
// 
// The widget creates HTML elements in the following format:
// <div class="n2BookBrowser_container">
//    <div class="n2BookBrowser_content">
//       <div class="n2BookBrowser_pagesOuter" scrollTop="x"> <!-- this is where the scrolling happens -->
//          <div class="n2BookBrowser_pagesInner">
//             <!-- There is a div.n2BookBrowser_page for each page of the book -->
//             <div class="n2BookBrowser_page" style="position:relative;height:x">
//                <div class="n2BookBrowser_pageTitleContainer"> <!-- only if a title is specified -->
//                   <div class="n2BookBrowser_pageTitleContent">
//                      text (title)
//                   </div>
//                </div>
//                <div class="n2BookBrowser_pageImageContainer">
//                </div>
//             </div>
//             ...
//             <div class="n2BookBrowser_preview"> <!-- to display overlay of page title, momentarily -->
//                <div class="n2BookBrowser_previewContent">
//                   text (title)
//                </div>
//             </div>
//          </div>
//       </div>
//    </div>
// </div>
var BookBrowser = $n2.Class({
	
	dispatchService: null,
	
	pagePadding: null,
	
	pageResizing: null,
	
	book: null,
	
	elemId: null,
	
	focusDocId: null,

	lastScrollTop: null,

	lastPreviewTitle: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,pagePadding: 2
			,pageResizing: true
			,book: null
		},opts_);
		
		var _this = this;

		this.pagePadding = opts.pagePadding;
		this.pageResizing = opts.pageResizing;
		this.book = opts.book;
		this.focusDocId = undefined;
		this.lastScrollTop = undefined;
		this.lastPreviewTitle = undefined;
		
		this.dispatchService = opts.dispatchService;
		if( this.dispatchService ){
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};

			this.dispatchService.register(DH, 'selected', fn);
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2BookBrowser_container')
			.appendTo($container);
		
		this._display();
		
		$n2.log('BookBrowser', this);
		
		if( this.book ){
			this.book.loadPages({
				onSuccess: function(pages, book){
					_this._pagesChanged();
				}
				,onError: function(err){
					// ?
				}
			});
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_display: function(){
		var _this = this;
		
		var pagePadding = this.pagePadding;
		
		var $elem = this._getElem()
			.empty();
		
		var $content = $('<div>')
			.addClass('n2BookBrowser_content')
			.appendTo($elem);

		var $pagesOuter = $('<div>')
			.addClass('n2BookBrowser_pagesOuter')
			.appendTo($content)
			.scroll(function(){
				_this._scrollChanged( $(this) );
				return false;
			});
		
		var $pagesInner = $('<div>')
			.addClass('n2BookBrowser_pagesInner')
			.appendTo($pagesOuter);

		var pages = this.book.getPages();
		if( pages ){
			var offset = pagePadding;
			for(var i=0,e=pages.length; i<e; ++i){
				var page = pages[i];
				
				if( !page._bookBrowser ){
					page._bookBrowser = {};
				};
				
				var $page = $('<div>')
					.addClass('n2BookBrowser_page')
					.css('position','relative')
					.appendTo($pagesInner);
				
				var pageId = $n2.utils.getElementIdentifier($page);
				
				page._bookBrowser.offset = offset;
				page._bookBrowser.pageId = pageId;
				
				if( page.imageHeight ){
					$page.css('height',page.imageHeight);
					var h = $page.height();
					//$n2.log('h:'+h+' imageHeight:'+page.imageHeight);
					offset += page.imageHeight;
				};
				
				offset += (2 * pagePadding);
				
				if( page.title ){
					var $pageTitleContainer = $('<div>')
						.addClass('n2BookBrowser_pageTitleContainer')
						.appendTo($page);
					var $pageTitleContent = $('<div>')
						.addClass('n2BookBrowser_pageTitleContent')
						.text( page.title )
						.appendTo($pageTitleContainer);
				};

				$('<div>')
					.addClass('n2BookBrowser_pageImageContainer')
					.appendTo($page);
			};
		};
		
		var $preview = $('<div>')
			.addClass('n2BookBrowser_preview')
			.appendTo($content);
		
		this._loadImages();
	},
	
	_pagesChanged: function(){
		//var pages = this.book.getPages();
		this._display();
		if( this.focusDocId ){
			this._selectDocId(this.focusDocId);
		};
	},
	
	_scrollChanged: function( $pagesOuter ){
		var _this = this;
		
		var scrollTop = $pagesOuter.scrollTop();

		var $elem = this._getElem();
		
		var middleOffset = 0;
		var $outer = $elem.find('.n2BookBrowser_pagesOuter');
		if( $outer.length > 0 ){
			middleOffset = $outer.height() / 2;
		};
		
		var bookOffset = scrollTop + middleOffset;
		var page = this._getPageFromOffset(bookOffset);

		var $preview = $elem.find('.n2BookBrowser_preview');
		if( page ){
			if( page.title 
			 && this.lastPreviewTitle !== page.title ){
				this.lastPreviewTitle = page.title;

				$preview.empty();
				
				$('<div>')
					.addClass('n2BookBrowser_previewContent')
					.text(page.title)
					.appendTo($preview)
					.delay(500)
					.fadeOut(300,function(){
						_this._getElem().find('.n2BookBrowser_preview').empty();
					})
					;
			};
			
			this._pageInFocus(page);
		};
		
		// Wait a bit before loading images
		this.lastScrollTop = scrollTop;
		window.setTimeout(function(){
			if( _this.lastScrollTop === scrollTop ){
				_this._loadImages();
			};
		},500);
	},
	
	_pageInFocus: function(page){
		var _this = this;
		var docId = page.docId;
		
		if( this.focusDocId !== docId ){
			this.focusDocId = docId;
			window.setTimeout(function(){
				if( _this.focusDocId === docId ){
					if( _this.dispatchService ){
						_this.dispatchService.send(DH,{
							type: 'userSelect'
							,docId: docId
						});
					};
				};
			},800);
		};
	},
	
	_getPageFromOffset: function(bookOffset){
		var page = undefined;

		var pages = this.book.getPages();
		if( pages ){
			for(var i=0,e=pages.length; i<e; ++i){
				var page = pages[i];

				if( page._bookBrowser ){
					var startOffset = page._bookBrowser.offset;
					var endOffset = startOffset + page.imageHeight;
					
					if( startOffset <= bookOffset 
					 && bookOffset <= endOffset ){
						return page;
					};
				};
			};
		};
		
		return page;
	},
	
	_getPageFromPageId: function(pageId_){
		var pages = this.book.getPages();
		if( pages ){
			for(var i=0,e=pages.length; i<e; ++i){
				var page = pages[i];

				if( page._bookBrowser ){
					var pageId = page._bookBrowser.pageId;
					
					if( pageId_ === pageId ){
						return page;
					};
				};
			};
		};
		
		return undefined;
	},
	
	_getViewportMiddleOffset: function(){
		var $elem = this._getElem();
		var $pagesOuter = $elem.find('.n2BookBrowser_pagesOuter');
		var scrollTop = $pagesOuter.scrollTop();
		var middleOffset = 0;
		var $outer = $elem.find('.n2BookBrowser_pagesOuter');
		if( $outer.length > 0 ){
			middleOffset = $outer.height() / 2;
		};
		var computedOffset = scrollTop + middleOffset;
		return computedOffset;
	},

	_selectDocId: function(docId){
		var bookOffset = this._getViewportMiddleOffset();

		var currentPage = this._getPageFromOffset(bookOffset);
		if( currentPage ){
			var currentDocId = currentPage.getDocId();
			if( currentDocId === docId ){
				// No need to move the scroll
				return;
			};
		};
		
		var pages = this.book.getPages();
		if( pages ){
			for(var i=0,e=pages.length; i<e; ++i){
				var page = pages[i];

				if( page.docId === docId ){
					if( page._bookBrowser 
					 && typeof page._bookBrowser.offset === 'number' ){
						var $elem = this._getElem();
						var $pagesOuter = $elem.find('.n2BookBrowser_pagesOuter');
						$pagesOuter.scrollTop( page._bookBrowser.offset );
					};
				};
			};
		};
	},
	
	_loadImages: function(){
		var _this = this;
		var pages = this.book.getPages();
		if( pages ){
			var $elem = this._getElem();
			var $pagesOuter = $elem.find('.n2BookBrowser_pagesOuter');
			var bookOffsetTop = $pagesOuter.scrollTop();
			var bookOffsetBottom = bookOffsetTop + $pagesOuter.height();
			
			var unloadByPageId = {};
			var loadByPageId = {};

			for(var i=0,e=pages.length; i<e; ++i){
				var page = pages[i];

				if( page._bookBrowser 
				 && typeof page._bookBrowser.offset === 'number' ){
					var pageId = page._bookBrowser.pageId;
					var pageOffsetTop = page._bookBrowser.offset;
					var pageOffsetBottom = pageOffsetTop + page.imageHeight;
					
					if( pageOffsetTop > bookOffsetBottom 
					 || pageOffsetBottom < bookOffsetTop ){
						// Not currently visible
						unloadByPageId[pageId] = page;
						
					} else {
						// Currently visible, or partly visible
						loadByPageId[pageId] = page;

						// Load page after
						var nextIndex = i + 1;
						if( nextIndex < pages.length ){
							var nextPage = pages[nextIndex];
							if( nextPage._bookBrowser 
							 && nextPage._bookBrowser.pageId ){
								var nextPageId = nextPage._bookBrowser.pageId;
								loadByPageId[nextPageId] = nextPage;
							};
						};

						// Load previous
						var previousIndex = i - 1;
						if( previousIndex >= 0 ){
							var previousPage = pages[previousIndex];
							if( previousPage._bookBrowser 
							 && previousPage._bookBrowser.pageId ){
								var previousPageId = previousPage._bookBrowser.pageId;
								loadByPageId[previousPageId] = previousPage;
							};
						};
					};
				};
			};

			// Load pages
			for(var pageId in loadByPageId){
				var page = loadByPageId[pageId];
				var $page = $('#'+pageId);

				// Do not unload loaded pages
				if( unloadByPageId[pageId] ){
					delete unloadByPageId[pageId];
				};
				
				var imageUrl = page.getImageUrl();
				if( imageUrl ){
					var $imageContainer = $page.find('.n2BookBrowser_pageImageContainer');
					var $image = $imageContainer.find('img');
					if( $image.length < 1 ){
						// Must load
						$('<img>')
							.addClass('n2BookBrowser_pageImage')
							.attr('n2PageId',pageId)
							.load(function(){
								var $img = $(this);
								var height = $img.height();
								var pageId = $img.attr('n2PageId');
								_this._setPageHeight(pageId,height);
								return true;
							}) // must come before setting src attribute
							.attr('src',imageUrl)
							.appendTo($imageContainer);
					};
				};
			};

			// Unload pages
			for(var pageId in unloadByPageId){
				var page = loadByPageId[pageId];
				var $page = $('#'+pageId);

				var $imageContainer = $page.find('.n2BookBrowser_pageImageContainer');
				$imageContainer.find('img').remove();
			};
		};
	},
	
	_setPageHeight: function(pageId,height){
		if( this.pageResizing ){
			var page = this._getPageFromPageId(pageId);
			if( page 
			 && page.imageHeight !== height ){
				// About to resize a page. Get offset of current page. Resize the page.
				// Recompute all page offsets. Re-adjust the the scrollTop so that the
				// same offset in the current page is preserved.
				
				// ... compute offset into current page
				var bookOffset = this._getViewportMiddleOffset();
				var currentPage = this._getPageFromOffset(bookOffset);
				var currentPageRatio = undefined;
				if( currentPage 
				 && currentPage._bookBrowser 
				 && typeof currentPage._bookBrowser.offset === 'number' 
				 && typeof currentPage.imageHeight === 'number' 
				 && currentPage.imageHeight > 0 ){
					currentPageRatio = (bookOffset - currentPage._bookBrowser.offset) / currentPage.imageHeight;
					if( currentPageRatio < 0 ){
						currentPageRatio = 0;
					};
					if( currentPageRatio > 1 ){
						currentPageRatio = 1;
					};
				};
				
				// ... resize page
				page.imageHeight = height;
				var $page = $('#'+pageId);
				$page.css('height',page.imageHeight);

				// ... recompute page offsets for all pages
				var pagePadding = this.pagePadding;
				var pages = this.book.getPages();
				if( pages ){
					var offset = pagePadding;
					for(var i=0,e=pages.length; i<e; ++i){
						var page = pages[i];
						
						if( !page._bookBrowser ){
							page._bookBrowser = {};
						};
						
						page._bookBrowser.offset = offset;
						
						if( page.imageHeight ){
							offset += page.imageHeight;
						};
						
						offset += (2 * pagePadding);
					};
				};
				
				// ... reposition book so that same offset in the current
				// page is displayed
				if( typeof currentPageRatio === 'number' ){
					var effectiveOffset = currentPage._bookBrowser.offset +
						(currentPageRatio * currentPage.imageHeight);

					var $elem = this._getElem();
					var middleOffset = 0;
					var $outer = $elem.find('.n2BookBrowser_pagesOuter');
					if( $outer.length > 0 ){
						middleOffset = $outer.height() / 2;
					};

					var viewPortTopOffset = effectiveOffset - middleOffset;
					if( viewPortTopOffset < 0 ){
						viewPortTopOffset = 0;
					};

					var $pagesOuter = $elem.find('.n2BookBrowser_pagesOuter');
					$pagesOuter.scrollTop(viewPortTopOffset);
				};
			};
		};
	},

	_handle: function(m, addr, dispatcher){
		if( 'selected' === m.type ){
			var docId = m.docId;
			this.focusDocId = docId;
			this._selectDocId(docId);
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'bookBrowser' ){
		m.isAvailable = true;
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'bookBrowser' ){
		var widgetOptions = m.widgetOptions;
		var contentId = m.contentId;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var opName in widgetOptions){
				options[opName] = widgetOptions[opName];
			};
		};
		
		options.contentId = contentId;
		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
		};
		
		new BookBrowser(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetBookBrowser = {
	BookBrowser: BookBrowser
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
	,Book: Book
	,Page: Page
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetNavigation.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetNavigation'
 ;

//--------------------------------------------------------------------------
var NavigationWidget = $n2.Class({
	elemId: null,
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		var $elem = $(opts.elem);
		this.elemId = $n2.utils.getElementIdentifier($elem);

		if( this.dispatchService ){
			var f = function(m, addr, dispatchService){
				_this._handle(m, addr, dispatchService);
			};
			
			this.dispatchService.register(DH, 'historyReportState', f);
		};
		
		this._display();

		// Get current state
		if( this.dispatchService ){
			var m = {
				type: 'historyGetState'
			};
			this.dispatchService.synchronousCall(DH,m);
			if( m.state ){
				this._handleHistoryState(m.state);
			};
		};
		
		//$n2.log('NavigationWidget',this);
	},
	
	_display: function(){
		var _this = this;

		var $elem = this._getElem();
		
		$elem
			.empty()
			.addClass('n2NavigationWidget_buttons');

		$('<div>')
			.addClass('n2NavigationWidget_button n2NavigationWidget_button_forward')
			.appendTo($elem)
			.click(function(){
				// Enable click only if forward is available
				if( $(this).hasClass('n2NavigationWidget_button_enabled') ){
					if( _this.dispatchService ){
						_this.dispatchService.send(DH,{
							type: 'historyForward'
						});
					};
				};
				return false;
			});
		$('<div>')
			.addClass('n2NavigationWidget_button n2NavigationWidget_button_home n2NavigationWidget_button_enabled')
			.appendTo($elem)
			.click(function(){
				if( _this.dispatchService ){
					_this.dispatchService.send(DH,{
						type: 'userUnselect'
					});
				};
				return false;
			});
		$('<div>')
			.addClass('n2NavigationWidget_button n2NavigationWidget_button_back')
			.appendTo($elem)
			.click(function(){
				// Enable click only if back is available
				if( $(this).hasClass('n2NavigationWidget_button_enabled') ){
					if( _this.dispatchService ){
						_this.dispatchService.send(DH,{
							type: 'historyBack'
						});
					};
				};
				return false;
			});
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_handleHistoryState: function(historyState){
		if( historyState ){
			var $elem = this._getElem();

			if( historyState.backIsAvailable ){
				$elem.addClass('n2NavigationWidget_button_enabled_back');
				$elem
					.find('.n2NavigationWidget_button_back')
					.addClass('n2NavigationWidget_button_enabled')
					.removeClass('n2NavigationWidget_button_disabled');
			} else {
				$elem.removeClass('n2NavigationWidget_button_enabled_back');
				$elem
					.find('.n2NavigationWidget_button_back')
					.addClass('n2NavigationWidget_button_disabled')
					.removeClass('n2NavigationWidget_button_enabled');
			};

			if( historyState.forwardIsAvailable ){
				$elem.addClass('n2NavigationWidget_button_enabled_forward');
				$elem
					.find('.n2NavigationWidget_button_forward')
					.addClass('n2NavigationWidget_button_enabled')
					.removeClass('n2NavigationWidget_button_disabled');
			} else {
				$elem.removeClass('n2NavigationWidget_button_enabled_forward');
				$elem
					.find('.n2NavigationWidget_button_forward')
					.addClass('n2NavigationWidget_button_disabled')
					.removeClass('n2NavigationWidget_button_enabled');
			};
		};
	},
	
	_handle: function(m, addr, dispatchService){
		var $elem = this._getElem();
		if( $elem.length < 1 ){
			// We have disappeared. Unregister from dispatcher
			dispatchService.deregister(addr);
			return;
		};
		
		if( 'historyReportState' === m.type ){
			var state = m.state;
			this._handleHistoryState(state);
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'navigation' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'navigation' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var $elem = null;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		$elem = $('#'+containerId);
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions) {
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.elem = $elem;
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
		};
		
		new NavigationWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetNavigation = {
	NavigationWidget: NavigationWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetLayer.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetLayer'
 ,ALL_LAYERS = '__ALL_LAYERS__'
 ;

//--------------------------------------------------------------------------
var LayerSelectionWidget = $n2.Class({
	
	dispatchService: null,
	
	showService: null,
	
	sourceModelId: null,
	
	elemId: null,

	selectedLayersChangeEventName: null,

	selectedLayersSetEventName: null,

	availableLayersChangeEventName: null,

	availableLayers: null,
	
	lastSelectedLayerId: null,
	
	allLayersLabel: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,showService: null
			,sourceModelId: null
			,allLayersLabel: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.sourceModelId = opts.sourceModelId;
		this.allLayersLabel = opts.allLayersLabel;
		
		this.availableLayers = [];
		this.lastSelectedLayerId = ALL_LAYERS;
		
		// Set up model listener
		if( this.dispatchService ){
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.availableLayers ){
				var paramInfo = sourceModelInfo.parameters.availableLayers;
				this.availableLayersChangeEventName = paramInfo.changeEvent;

				if( paramInfo.value ){
					this.availableLayers = paramInfo.value;
				};
			};
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.selectedLayers ){
				var paramInfo = sourceModelInfo.parameters.selectedLayers;
				this.selectedLayersChangeEventName = paramInfo.changeEvent;
				this.selectedLayersSetEventName = paramInfo.setEvent;

				if( paramInfo.value ){
					this.selectedLayers = paramInfo.value;
				};
			};
			
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			if( this.availableLayersChangeEventName ){
				this.dispatchService.register(DH, this.availableLayersChangeEventName, fn);
			};
			
			if( this.selectedLayersChangeEventName ){
				this.dispatchService.register(DH, this.selectedLayersChangeEventName, fn);
			};
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2layerSelectionWidget')
			.appendTo($container);
		
		this._availableLayersUpdated();
		
		$n2.log('LayerSelectionWidget', this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_availableLayersUpdated: function(){
		var _this = this;

		var $elem = this._getElem();
		$elem.empty();
		
		var $selector = $('<select>')
			.appendTo($elem)
			.change(function(){
				_this._selectionChanged();
			});

		var allLayersLabel = _loc('All Layers');
		if( this.allLayersLabel ){
			allLayersLabel = _loc(this.allLayersLabel);
		};
		$('<option>')
			.text( allLayersLabel )
			.val(ALL_LAYERS)
			.appendTo($selector);
		
		var currentFound = null;
		var optionElements = [];
		this.availableLayers.sort();
		for(var i=0,e=this.availableLayers.length; i<e; ++i){
			var layerId = this.availableLayers[i];
			
			var $option = $('<option>')
				.text(layerId)
				.val(layerId)
				.appendTo($selector);

			optionElements.push($option);
			
			if( layerId === this.lastSelectedLayerId ){
				currentFound = layerId;
			};
			
			if( this.showService ){
				this.showService.printLayerName($option, layerId);
			};
		};
		
		if( currentFound ){
			$selector.val(currentFound);
			//$n2.log('selector => '+currentFound);
		} else {
			$selector.val(ALL_LAYERS);
			//$n2.log('selector => empty');
		};
		
		// Select current
		this._selectionChanged();
	},
	
	// This is called when the selected option within <select> is changed
	_selectionChanged: function(){
		var $elem = this._getElem();
		var $selector = $elem.find('select');
		var val = $selector.val();
		if( ALL_LAYERS === val ){
			var selectedLayerIds = [];
			this.availableLayers.forEach(function(layerId){
				selectedLayerIds.push(layerId);
			});
			
			this.dispatchService.send(DH,{
				type: this.selectedLayersSetEventName
				,value: selectedLayerIds
			});
			
		} else {
			var selectedLayerIds = [];
			selectedLayerIds.push(val);
			
			this.dispatchService.send(DH,{
				type: this.selectedLayersSetEventName
				,value: selectedLayerIds
			});
		};
	},
	
	_selectedLayersUpdated: function(){
		var $elem = this._getElem();
		var $selector = $elem.find('select');
		$selector.val( this.lastSelectedLayerId );
	},

	_handle: function(m, addr, dispatcher){
		var _this = this;

		if( this.availableLayersChangeEventName === m.type ){
			if( m.value ){
				this.availableLayers = m.value;
				
				this._availableLayersUpdated();
			};
			
		} else if( this.selectedLayersChangeEventName === m.type ){
			if( m.value ){
				var selectedMap = {};
				var selectedLayerId = undefined;
				m.value.forEach(function(layerId){
					selectedMap[layerId] = true;
					selectedLayerId = layerId;
				});
				
				// Detect all layers
				var allLayers = true;
				this.availableLayers.forEach(function(layerId){
					if( !selectedMap[layerId] ){
						allLayers = false;
					};
				});
				
				if( allLayers ){
					this.lastSelectedLayerId = ALL_LAYERS;
				} else {
					this.lastSelectedLayerId = selectedLayerId;
				};
				
				this._selectedLayersUpdated();
			};
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'layerSelectionWidget' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'layerSelectionWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.showService = config.directory.showService;
		};
		
		new LayerSelectionWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetLayer = {
	LayerSelectionWidget: LayerSelectionWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetSelectableFilter.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetSelectableFilter'
 ,ALL_CHOICES = '__ALL_CHOICES__'
 ,NO_CHOICE = '__NO_CHOICE_SELECTED__'
 ,UNKNOWN_CHOICE = '__UNKNOWN_CHOICE_SELECTED__'
 ;

//--------------------------------------------------------------------------
var SingleFilterSelectionWidget = $n2.Class('SingleFilterSelectionWidget',{
	
	dispatchService: null,
	
	showService: null,
	
	sourceModelId: null,
	
	elemId: null,

	selectedChoicesChangeEventName: null,

	selectedChoicesSetEventName: null,

	allSelectedChangeEventName: null,

	allSelectedSetEventName: null,

	availableChoicesChangeEventName: null,

	availableChoices: null,
	
	selectedChoices: null,
	
	selectedChoiceIdMap: null,
	
	allSelected: null,
	
	allChoicesLabel: null,
	
	noChoiceLabel: null,
	
	suppressAllChoices: null,

	suppressNoChoice: null,
	
	suppressedChoicesMap: null,
	
	/* 
	 * These are versions of functions that are throttled. These
	 * functions touch the DOM structure and should not be called too.
	 * often as they affect performance.
	 */
	_throttledAvailableChoicesUpdated: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,showService: null
			,sourceModelId: null
			,allChoicesLabel: null
			,noChoiceLabel: null
			,suppressAllChoices: false
			,suppressNoChoice: false
			,suppressChoices: undefined
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.sourceModelId = opts.sourceModelId;
		this.allChoicesLabel = opts.allChoicesLabel;
		this.noChoiceLabel = opts.noChoiceLabel;
		this.suppressAllChoices = opts.suppressAllChoices;
		this.suppressNoChoice = opts.suppressNoChoice;
		
		this.availableChoices = [];
		this.selectedChoices = [];
		this.selectedChoiceIdMap = {};
		this.allSelected = false;
		this.suppressedChoicesMap = [];
		this._throttledAvailableChoicesUpdated = $n2.utils.throttle(this._availableChoicesUpdated, 1500);

		if( opts.suppressChoices ){
			if( $n2.isArray(opts.suppressChoices) ){
				opts.suppressChoices.forEach(function(choice){
					if( typeof choice === 'string' ){
						_this.suppressedChoicesMap[choice] = true;
					} else {
						$n2.logError('SingleFilterSelectionWidget: suppressChoices must be an array of strings');
					};
				});
			} else {
				$n2.logError('SingleFilterSelectionWidget: suppressChoices must be an array');
			};
		};
		
		// Set up model listener
		if( this.dispatchService ){
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.availableChoices ){
				var paramInfo = sourceModelInfo.parameters.availableChoices;
				this.availableChoicesChangeEventName = paramInfo.changeEvent;

				if( paramInfo.value ){
					this._setAvailableChoices(paramInfo.value);
				};
			};
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters  ){
				if( sourceModelInfo.parameters.selectedChoices ){
					var paramInfo = sourceModelInfo.parameters.selectedChoices;
					this.selectedChoicesChangeEventName = paramInfo.changeEvent;
					this.selectedChoicesSetEventName = paramInfo.setEvent;
	
					if( paramInfo.value ){
						this.selectedChoices = paramInfo.value;
						
						this.selectedChoiceIdMap = {};
						this.selectedChoices.forEach(function(choiceId){
							_this.selectedChoiceIdMap[choiceId] = true;
						});
					};
				};

				if( sourceModelInfo.parameters.allSelected ){
					var paramInfo = sourceModelInfo.parameters.allSelected;
					this.allSelectedChangeEventName = paramInfo.changeEvent;
					this.allSelectedSetEventName = paramInfo.setEvent;
	
					if( typeof paramInfo.value === 'boolean' ){
						this.allSelected = paramInfo.value;
					};
				};
			};
			
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			if( this.availableChoicesChangeEventName ){
				this.dispatchService.register(DH, this.availableChoicesChangeEventName, fn);
			};

			if( this.selectedChoicesChangeEventName ){
				this.dispatchService.register(DH, this.selectedChoicesChangeEventName, fn);
			};

			if( this.allSelectedChangeEventName ){
				this.dispatchService.register(DH, this.allSelectedChangeEventName, fn);
			};
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2widget_singleFilterSelection')
			.appendTo($container);
		
		this._availableChoicesUpdated();
		
		$n2.log('SingleFilterSelectionWidget', this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_availableChoicesUpdated: function(){
		var _this = this;

		var $elem = this._getElem();
		$elem.empty();
		
		var $selector = $('<select>')
			.appendTo($elem)
			.change(function(){
				_this._selectionChanged();
			});

		if( !this.suppressNoChoice ){
			// No Choice
			var noChoiceLabel = _loc('--');
			if( this.noChoiceLabel ){
				noChoiceLabel = _loc(this.noChoiceLabel);
			};
			$('<option>')
				.addClass('n2widget_singleFilterSelection_optionNoChoice')
				.text( noChoiceLabel )
				.val(NO_CHOICE)
				.appendTo($selector);
		};

		if( !this.suppressAllChoices ){
			// All Choices
			var allChoicesLabel = _loc('All');
			if( this.allChoicesLabel ){
				allChoicesLabel = _loc(this.allChoicesLabel);
			};
			$('<option>')
				.addClass('n2widget_singleFilterSelection_optionAllChoices')
				.text( allChoicesLabel )
				.val(ALL_CHOICES)
				.appendTo($selector);
		};
		
		for(var i=0,e=this.availableChoices.length; i<e; ++i){
			var choice = this.availableChoices[i];
			
			var label = choice.label;
			if( !label ){
				label = choice.id;
			};
			
			var $option = $('<option>')
				.text(label)
				.val(choice.id)
				.appendTo($selector);
		};
		
		// Adjust classes reflecting if any options are available
		if( this.availableChoices.length > 0 ){
			$elem
				.removeClass('n2widget_singleFilterSelection_noChoiceAvailable')
				.addClass('n2widget_singleFilterSelection_atLeastOneChoiceAvailable');
		} else {
			$elem
				.removeClass('n2widget_singleFilterSelection_atLeastOneChoiceAvailable')
				.addClass('n2widget_singleFilterSelection_noChoiceAvailable');
		};
		
		this._adjustSelectedItem();
		
		// Select current
		//this._selectionChanged();
	},
	
	_adjustSelectedItem: function(){
		var _this = this;
		
		// Select appropriate choice
		var selectedChoiceId;
		if( this.allSelected  ){
			if( !this.suppressAllChoices ){
				selectedChoiceId = ALL_CHOICES;
			};

		} else if( this.selectedChoices.length < 1 ) {
			if( !this.suppressNoChoice ){
				selectedChoiceId = NO_CHOICE;
			};

		} else if( this.selectedChoices.length > 1 ) {
			selectedChoiceId = undefined;

		} else {
			selectedChoiceId = this.selectedChoices[0];
		};
		
		var $elem = this._getElem();
		var $selector = $elem.find('select');
		if( selectedChoiceId ){
			$selector.val( selectedChoiceId );
			$selector.find('option.n2widget_singleFilterSelection_optionUnknown').remove();
		} else {
			// At this point, select UNKNOWN
			var $unknown = $selector.find('option.n2widget_singleFilterSelection_optionUnknown');
			if( $unknown.length < 1 ){
				$('<option>')
					.addClass('n2widget_singleFilterSelection_optionUnknown')
					.text('')
					.val(UNKNOWN_CHOICE)
					.prependTo($selector);
			};
			$selector.val(UNKNOWN_CHOICE);
		};
	},
	
	// This is called when the selected option within <select> is changed
	_selectionChanged: function(){
		var $elem = this._getElem();

		var $selector = $elem.find('select');
		var val = $selector.val();
		if( ALL_CHOICES === val ){
			this.dispatchService.send(DH,{
				type: this.allSelectedSetEventName
				,value: true
			});

		} else if( NO_CHOICE === val ){
			var selectedChoiceIds = [];
			
			this.dispatchService.send(DH,{
				type: this.selectedChoicesSetEventName
				,value: selectedChoiceIds
			});

		} else if( UNKNOWN_CHOICE === val ){
			// Do nothing

		} else {
			var selectedChoiceIds = [];
			selectedChoiceIds.push(val);
			
			this.dispatchService.send(DH,{
				type: this.selectedChoicesSetEventName
				,value: selectedChoiceIds
			});
		};
	},
	
	_setAvailableChoices: function(choices){
		var _this = this;

		this.availableChoices = [];
		
		if( $n2.isArray(choices) ){
			choices.forEach(function(choice){
				if( _this.suppressedChoicesMap[choice.id] ){
					// Do not keep this one
				} else {
					_this.availableChoices.push(choice);
				};
			});
		};
	},
	
	_handle: function(m, addr, dispatcher){
		var _this = this;

		if( this.availableChoicesChangeEventName === m.type ){
			if( m.value ){
				this._setAvailableChoices(m.value);

				//this._availableChoicesUpdated();
				this._throttledAvailableChoicesUpdated();
			};
			
		} else if( this.selectedChoicesChangeEventName === m.type ){
			if( m.value ){
				this.selectedChoices = m.value;
				
				this.selectedChoiceIdMap = {};
				this.selectedChoices.forEach(function(choiceId){
					_this.selectedChoiceIdMap[choiceId] = true;
				});
				
				this._adjustSelectedItem();
			};

		} else if( this.allSelectedChangeEventName === m.type ){
			if( typeof m.value === 'boolean' ){
				this.allSelected = m.value;
				
				this._adjustSelectedItem();
			};
		};
	}
});

//--------------------------------------------------------------------------
var MultiFilterSelectionWidget = $n2.Class('MultiFilterSelectionWidget',{
	
	dispatchService: null,
	
	showService: null,
	
	sourceModelId: null,
	
	elemId: null,

	selectedChoicesChangeEventName: null,

	selectedChoicesSetEventName: null,

	allSelectedChangeEventName: null,

	allSelectedSetEventName: null,

	availableChoicesChangeEventName: null,

	availableChoices: null,
	
	selectedChoices: null,
	
	selectedChoiceIdMap: null,
	
	allSelected: null,
	
	allChoicesLabel: null,

	/* 
	 * These are versions of functions that are throttled. These
	 * functions touch the DOM structure and should not be called too.
	 * often as they affect performance.
	 */
	_throttledAvailableChoicesUpdated: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,showService: null
			,sourceModelId: null
			,allChoicesLabel: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.sourceModelId = opts.sourceModelId;
		this.allChoicesLabel = opts.allChoicesLabel;
		
		this.availableChoices = [];
		this.selectedChoices = [];
		this.selectedChoiceIdMap = {};
		this.allSelected = false;
		this._throttledAvailableChoicesUpdated = $n2.utils.throttle(this._availableChoicesUpdated, 1500);
		
		// Set up model listener
		if( this.dispatchService ){
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.availableChoices ){
				var paramInfo = sourceModelInfo.parameters.availableChoices;
				this.availableChoicesChangeEventName = paramInfo.changeEvent;

				if( paramInfo.value ){
					this.availableChoices = paramInfo.value;
				};
			};
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters ){
				if( sourceModelInfo.parameters.selectedChoices ){
					var paramInfo = sourceModelInfo.parameters.selectedChoices;
					this.selectedChoicesChangeEventName = paramInfo.changeEvent;
					this.selectedChoicesSetEventName = paramInfo.setEvent;
	
					if( paramInfo.value ){
						this.selectedChoices = paramInfo.value;
						
						this.selectedChoiceIdMap = {};
						this.selectedChoices.forEach(function(choiceId){
							_this.selectedChoiceIdMap[choiceId] = true;
						});
					};
				};

				if( sourceModelInfo.parameters.allSelected ){
					var paramInfo = sourceModelInfo.parameters.allSelected;
					this.allSelectedChangeEventName = paramInfo.changeEvent;
					this.allSelectedSetEventName = paramInfo.setEvent;
	
					if( typeof paramInfo.value === 'boolean' ){
						this.allSelected = paramInfo.value;
					};
				};
			};
			
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			if( this.availableChoicesChangeEventName ){
				this.dispatchService.register(DH, this.availableChoicesChangeEventName, fn);
			};

			if( this.selectedChoicesChangeEventName ){
				this.dispatchService.register(DH, this.selectedChoicesChangeEventName, fn);
			};

			if( this.allSelectedChangeEventName ){
				this.dispatchService.register(DH, this.allSelectedChangeEventName, fn);
			};
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2widget_multiFilterSelection')
			.appendTo($container);
		
		this._throttledAvailableChoicesUpdated();
		
		$n2.log(this._classname, this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_availableChoicesUpdated: function(){
		var _this = this;

		var $elem = this._getElem();
		$elem.empty();

		// All Choices
		var allChoicesLabel = _loc('All');
		if( this.allChoicesLabel ){
			allChoicesLabel = _loc(this.allChoicesLabel);
		};
		var $a = $('<a>')
			.addClass('n2widget_multiFilterSelection_optionAllChoices n2widget_multiFilterSelection_option')
			.attr('href','#')
			.attr('n2-choice-id',ALL_CHOICES)
			.appendTo($elem)
			.click(function(){
				var $a = $(this);
				var choiceId = $a.attr('n2-choice-id');
				_this._selectionClicked(choiceId, $a);
				return false;
			});
		$('<span>')
			.text(allChoicesLabel)
			.appendTo($a);
		
		for(var i=0,e=this.availableChoices.length; i<e; ++i){
			var choice = this.availableChoices[i];
			
			var label = choice.label;
			if( !label ){
				label = choice.id;
			};
			
			var $a = $('<a>')
				.addClass('n2widget_multiFilterSelection_option')
				.attr('href',choice.id)
				.attr('n2-choice-id',choice.id)
				.appendTo($elem)
				.click(function(){
					var $a = $(this);
					var choiceId = $a.attr('n2-choice-id');
					_this._selectionClicked(choiceId, $a);
					return false;
				});
			$('<span>')
				.text(label)
				.appendTo($a);
		};
		
		this._adjustSelectedItem();
	},
	
	_adjustSelectedItem: function(){
		var _this = this;
		
		var $elem = this._getElem();
		$elem.find('.n2widget_multiFilterSelection_option').each(function(){
			var $option = $(this);
			var choiceId = $option.attr('n2-choice-id');
			
			var selected = false;
			if( ALL_CHOICES === choiceId ){
				if( _this.allSelected ){
					selected = true;
				};
			} else {
				if( _this.selectedChoiceIdMap[choiceId] ){
					selected = true;
				};
			};
			
			if( selected ){
				$option.removeClass('n2widget_multiFilterSelection_notSelected');
				$option.addClass('n2widget_multiFilterSelection_selected');
			} else {
				$option.removeClass('n2widget_multiFilterSelection_selected');
				$option.addClass('n2widget_multiFilterSelection_notSelected');
			};
		});
	},
	
	// This is called when one of the selection is clicked
	_selectionClicked: function(choiceId, $a){
		var _this = this;

		if( ALL_CHOICES === choiceId ){
			if( this.allSelected ){
				// If already all selected, select none
				this.dispatchService.send(DH,{
					type: this.selectedChoicesSetEventName
					,value: []
				});

			} else {
				// Select all
				this.dispatchService.send(DH,{
					type: this.allSelectedSetEventName
					,value: true
				});
			};

		} else {
			var selectedChoiceIds = [];

			var removed = false;
			this.selectedChoices.forEach(function(selectedChoiceId){
				if( selectedChoiceId === choiceId ){
					removed = true;
				} else {
					selectedChoiceIds.push(selectedChoiceId);
				};
			});
			
			if( !removed ){
				selectedChoiceIds.push(choiceId);
			};
			
			this.dispatchService.send(DH,{
				type: this.selectedChoicesSetEventName
				,value: selectedChoiceIds
			});
		};
	},
	
	_handle: function(m, addr, dispatcher){
		var _this = this;

		if( this.availableChoicesChangeEventName === m.type ){
			if( m.value ){
				this.availableChoices = m.value;
				
				//this._availableChoicesUpdated();
				this._throttledAvailableChoicesUpdated();
			};
			
		} else if( this.selectedChoicesChangeEventName === m.type ){
			if( m.value ){
				this.selectedChoices = m.value;
				
				this.selectedChoiceIdMap = {};
				this.selectedChoices.forEach(function(choiceId){
					_this.selectedChoiceIdMap[choiceId] = true;
				});
				
				this._adjustSelectedItem();
			};

		} else if( this.allSelectedChangeEventName === m.type ){
			if( typeof m.value === 'boolean' ){
				this.allSelected = m.value;
				
				this._adjustSelectedItem();
			};
		};
	}
});

//--------------------------------------------------------------------------
var MultiFilterSelectionDropDownWidget = $n2.Class('MultiFilterSelectionDropDownWidget',{
	
	dispatchService: null,
	
	showService: null,
	
	sourceModelId: null,
	
	elemId: null,

	selectedChoicesChangeEventName: null,

	selectedChoicesSetEventName: null,

	allSelectedChangeEventName: null,

	allSelectedSetEventName: null,

	availableChoicesChangeEventName: null,

	availableChoices: null,
	
	selectedChoices: null,
	
	selectedChoiceIdMap: null,

	allSelected: null,
	
	allChoicesLabel: null,
	
	noChoiceLabel: null,

	label: null,

	showAsLink: null,
	
	/* 
	 * These are versions of functions that are throttled. These
	 * functions touch the DOM structure and should not be called too
	 * often as they affect performance.
	 */
	_throttledAvailableChoicesUpdated: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,showService: null
			,sourceModelId: null
			,allChoicesLabel: null
			,noChoiceLabel: null
			,label: null
			,showAsLink: false
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.sourceModelId = opts.sourceModelId;
		this.allChoicesLabel = opts.allChoicesLabel;
		this.noChoiceLabel = opts.noChoiceLabel;
		this.label = opts.label;
		this.showAsLink = opts.showAsLink;
		
		this.availableChoices = [];
		this.selectedChoices = [];
		this.selectedChoiceIdMap = {};
		this._throttledAvailableChoicesUpdated = $n2.utils.throttle(this._availableChoicesUpdated, 1500);
		
		// Set up model listener
		if( this.dispatchService ){
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.availableChoices ){
				var paramInfo = sourceModelInfo.parameters.availableChoices;
				this.availableChoicesChangeEventName = paramInfo.changeEvent;

				if( paramInfo.value ){
					this.availableChoices = paramInfo.value;
				};
			};
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.selectedChoices ){
				var paramInfo = sourceModelInfo.parameters.selectedChoices;
				this.selectedChoicesChangeEventName = paramInfo.changeEvent;
				this.selectedChoicesSetEventName = paramInfo.setEvent;

				if( paramInfo.value ){
					this.selectedChoices = paramInfo.value;
					
					this.selectedChoiceIdMap = {};
					this.selectedChoices.forEach(function(choiceId){
						_this.selectedChoiceIdMap[choiceId] = true;
					});
				};
			};

			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.allSelected ){
				var paramInfo = sourceModelInfo.parameters.allSelected;
				this.allSelectedChangeEventName = paramInfo.changeEvent;
				this.allSelectedSetEventName = paramInfo.setEvent;

				if( typeof paramInfo.value === 'boolean' ){
					this.allSelected = paramInfo.value;
				};
			};
			
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			if( this.availableChoicesChangeEventName ){
				this.dispatchService.register(DH, this.availableChoicesChangeEventName, fn);
			};
			
			if( this.selectedChoicesChangeEventName ){
				this.dispatchService.register(DH, this.selectedChoicesChangeEventName, fn);
			};
			
			if( this.allSelectedChangeEventName ){
				this.dispatchService.register(DH, this.allSelectedChangeEventName, fn);
			};
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		var $elem = $('<div>')
			.attr('id',this.elemId)
			.addClass('n2widget_multiDropDownFilterSelection n2widget_multiDropDownFilterSelection_selection_hidden')
			.appendTo($container);
		
		if( this.showAsLink ){
			$elem.addClass('n2widget_multiDropDownFilterSelection_asLink');
		};
		
		var $relDiv = $('<div>')
		.css({
			position: 'relative'
		})
		.appendTo($elem);
		
		var buttonLabel = undefined;
		if( this.label ){
			buttonLabel = _loc(this.label);
		};
		if( !buttonLabel ){
			buttonLabel = _loc('Multi-Selection');
		};
		if( this.showAsLink ){
			$('<a>')
				.attr('href',buttonLabel)
				.text( buttonLabel )
				.appendTo($relDiv)
				.click(function(){
					_this._buttonClicked();
					return false;
				});
		} else {
			var $button = $('<button>')
				.appendTo($relDiv)
				.text( buttonLabel )
				.click(function(){
					_this._buttonClicked();
				});
		};
		
		var $position = $('<div>')
			.addClass('n2widget_multiDropDownFilterSelection_position')
			.appendTo($relDiv);
		
		this._throttledAvailableChoicesUpdated();
		
		$n2.log(this._classname, this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_availableChoicesUpdated: function(){
		var _this = this;

		var $elem = this._getElem();
		var $position = $elem.find('.n2widget_multiDropDownFilterSelection_position');
		$position.empty();
		
		var $selectDiv = $('<div>')
			.appendTo($position)
			.addClass('n2widget_multiDropDownFilterSelection_select');

		// All Choices
		var allChoicesLabel = _loc('All');
		if( this.allChoicesLabel ){
			allChoicesLabel = _loc(this.allChoicesLabel);
		};
		addOption($selectDiv, ALL_CHOICES, allChoicesLabel);
		
		for(var i=0,e=this.availableChoices.length; i<e; ++i){
			var choice = this.availableChoices[i];
			
			var label = choice.label;
			if( !label ){
				label = choice.id;
			};
			
			addOption($selectDiv, choice.id, label);
		};
		
		this._adjustSelectedItem();
		
		// Select current
		//this._selectionChanged();
		
		function addOption($selectDiv, choiceId, label){
			var $div = $('<div>')
				.addClass('n2widget_multiDropDownFilterSelection_option')
				.attr('data-n2-choiceId',choiceId)
				.appendTo($selectDiv);

			$('<a>')
				.text(label)
				.attr('data-n2-choiceId',choiceId)
				.appendTo($div)
				.click(function(){
					var $a = $(this);
					var choiceId = $a.attr('data-n2-choiceId');
					_this._selectionChanged(choiceId);
					return false;
				});
		};
	},
	
	_adjustSelectedItem: function(){
		var _this = this;

		var allSelected = this.allSelected;

		var selectedChoiceIdMap = {};
		this.selectedChoices.forEach(function(selectedChoice){
			selectedChoiceIdMap[selectedChoice] = true;
		});
		
		var $elem = this._getElem();
		$elem.find('.n2widget_multiDropDownFilterSelection_option').each(function(){
			var $a = $(this);
			var value = $a.attr('data-n2-choiceId');
			if( allSelected || selectedChoiceIdMap[value] ){
				$a
					.removeClass('n2widget_multiDropDownFilterSelection_optionUnselected')
					.addClass('n2widget_multiDropDownFilterSelection_optionSelected');
			} else {
				$a
					.removeClass('n2widget_multiDropDownFilterSelection_optionSelected')
					.addClass('n2widget_multiDropDownFilterSelection_optionUnselected');
			};
		});
	},
	
	// This is called when the selected option within <select> is changed
	_selectionChanged: function(choiceId){

		if( ALL_CHOICES === choiceId ){
			if( this.allSelected ){
				// If already all selected, select none
				this.dispatchService.send(DH,{
					type: this.selectedChoicesSetEventName
					,value: []
				});

			} else {
				// Select all
				this.dispatchService.send(DH,{
					type: this.allSelectedSetEventName
					,value: true
				});
			};

		} else {
			var selectedChoiceIds = [];

			var removed = false;
			this.selectedChoices.forEach(function(selectedChoiceId){
				if( selectedChoiceId === choiceId ){
					removed = true;
				} else {
					selectedChoiceIds.push(selectedChoiceId);
				};
			});
			
			if( !removed ){
				selectedChoiceIds.push(choiceId);
			};
			
			this.dispatchService.send(DH,{
				type: this.selectedChoicesSetEventName
				,value: selectedChoiceIds
			});
		};
	},
	
	_buttonClicked: function(){
		var $elem = this._getElem();
		
		if( $elem.hasClass('n2widget_multiDropDownFilterSelection_selection_shown') ){
			$elem
				.removeClass('n2widget_multiDropDownFilterSelection_selection_shown')
				.addClass('n2widget_multiDropDownFilterSelection_selection_hidden');
		} else {
			$elem
				.removeClass('n2widget_multiDropDownFilterSelection_selection_hidden')
				.addClass('n2widget_multiDropDownFilterSelection_selection_shown');
		};
	},
		
	_handle: function(m, addr, dispatcher){
		var _this = this;

		if( this.availableChoicesChangeEventName === m.type ){
			if( m.value ){
				this.availableChoices = m.value;
				
				this._throttledAvailableChoicesUpdated();
			};
			
		} else if( this.selectedChoicesChangeEventName === m.type ){
			if( m.value ){
				this.selectedChoices = m.value;
				
				this.selectedChoiceIdMap = {};
				this.selectedChoices.forEach(function(choiceId){
					_this.selectedChoiceIdMap[choiceId] = true;
				});
				
				this._adjustSelectedItem();
			};

		} else if( this.allSelectedChangeEventName === m.type ){
			if( typeof m.value === 'boolean' ){
				this.allSelected = m.value;
				
				this._adjustSelectedItem();
			};
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'singleFilterSelectionWidget' ){
		m.isAvailable = true;

	} else if( m.widgetType === 'multiFilterSelectionWidget' ){
		m.isAvailable = true;

	} else if( m.widgetType === 'multiFilterSelectionDropDownWidget' ){
		m.isAvailable = true;
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'singleFilterSelectionWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.showService = config.directory.showService;
		};
		
		new SingleFilterSelectionWidget(options);

	} else if( m.widgetType === 'multiFilterSelectionWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.showService = config.directory.showService;
		};
		
		new MultiFilterSelectionWidget(options);

	} else if( m.widgetType === 'multiFilterSelectionDropDownWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.showService = config.directory.showService;
		};
		
		new MultiFilterSelectionDropDownWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetSelectableFilter = {
	SingleFilterSelectionWidget: SingleFilterSelectionWidget
	,MultiFilterSelectionDropDownWidget: MultiFilterSelectionDropDownWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetExport.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetExport'
 ;

//--------------------------------------------------------------------------
var ExportWidget = $n2.Class({
	
	dispatchService: null,
	
	exportService: null,
	
	sourceModelId: null,
	
	label: null,
	
	elemId: null,

	modelDocsById: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,exportService: null
			,sourceModelId: null
			,label: _loc('Export')
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.exportService = opts.exportService;
		this.sourceModelId = opts.sourceModelId;
		this.label = opts.label;
		
		this.modelDocsById = {};

		if( !this.exportService ){
			throw new Error('ExportWidget requires export service');
		};
		
		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2widget_export')
			.appendTo($container);
		
		// Set up model listener
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'modelStateUpdated', f);

			// Initialize state
			var m = {
				type:'modelGetState'
				,modelId: this.sourceModelId
			};
			this.dispatchService.synchronousCall(DH, m);
			if( m.state ){
				this._sourceModelUpdated(m.state);
			};
		};
		
		$n2.log('ExportWidget', this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_sourceModelUpdated: function(sourceState){
		var _this = this;
		
		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				this.modelDocsById[doc._id] = doc;
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				this.modelDocsById[doc._id] = doc;
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				delete this.modelDocsById[doc._id];
			};
		};

		// Redraw
		var $elem = this._getElem();
		$elem.empty();
		if( this._atLeastOneDocumentAvailable() ){
			$('<a>')
				.attr('href','Export Documents')
				.text( this.label )
				.appendTo( $elem )
				.click(function(){
					try {
						_this._performExport();
					} catch(e) {
						$n2.log('Error during export: '+e);
					};
					return false;
				});
		};
	},
	
	_atLeastOneDocumentAvailable: function(){
		for(var docId in this.modelDocsById){
			return true;
		};
		return false;
	},
	
	_performExport: function(){
		var docs = [];
		for(var docId in this.modelDocsById){
			var doc = this.modelDocsById[docId];
			docs.push( doc );
		};
		
		this.exportService.createExportApplication({
			docs: docs
			,logger: new $n2.logger.CustomLogger({
				logFn: function(){}
				,reportErrorFn: function(err){
					$n2.log('Export error: '+err);
				}
			})
		});
	},

	_handle: function(m, addr, dispatcher){
		if( 'modelStateUpdated' === m.type ){
			// Does it come from our source?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'exportWidget' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'exportWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.exportService = config.directory.exportService;
		};
		
		new ExportWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetExport = {
	ExportWidget: ExportWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetModelBrowser.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

/*
 To use this widget, add the following definition to a module widget list:
	{
		"_comment": "Debug models"
		,"widgetType": "modelBrowserWidget"
	}
 */
;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetModelBrowser'
 ;

//--------------------------------------------------------------------------
var ModelBrowserWidget = $n2.Class({
	
	dispatchService: null,
	
	showService: null,
	
	sourceModelIds: null,
	
	elemId: null,
	
	browserId: null,
	
	selectedModelId: null,
	
	selectedDocId: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,showService: null
			,sourceModelIds: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.sourceModelIds = opts.sourceModelIds;
		
		this.selectedModelId = null;
		this.selectedDocId = null;

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		this.browserId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2widget_modelBrowser')
			.appendTo($container);
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			//this.dispatchService.register(DH, 'documentContent', f);
		};
		
		$n2.log('ModelBrowserWidget', this);
		
		this._display();
	},
	
	_handle: function(m, addr, dispatcher){
//		if( 'documentContent' === m.type ){
//			if( m.docId === this.selectedDocId ){
//				// Get document tree pane
//				var $dialog = $('#'+this.browserId);
//				var $treePane = $dialog.find('.n2widget_modelBrowser_document_tree');
//				
//				$treePane.empty();
//				new $n2.tree.ObjectTree($treePane, m.doc);
//			};
//		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_display: function(){
		var _this = this;

		var $elem = this._getElem();
		
		$elem.empty();
		
		$('<a>')
			.addClass('n2widget_modelBrowser_button')
			.attr('href','#')
			.text( _loc('Models') )
			.appendTo($elem)
			.click(function(){
				var $browsers = $('#'+_this.browserId);
				if( $browsers.length > 0 ){
					$browsers.dialog('close');
				} else {
					_this._showBrowser();
				};
				return false;
			});
	},

	_showBrowser: function(){
		var _this = this;

		var $dialog = $('<div>')
			.addClass('n2widget_modelBrowser_window')
			.attr('id', this.browserId)
			.appendTo($('body'))
			;
		
		$('<div>')
			.addClass('n2widget_modelBrowser_models')
			.appendTo($dialog);
		
		$('<div>')
			.addClass('n2widget_modelBrowser_list')
			.appendTo($dialog);
		
		$('<div>')
			.addClass('n2widget_modelBrowser_document')
			.appendTo($dialog);
		
		this._refreshModels();
		
		var dialogOptions = {
			autoOpen: true
			,title: _loc('Model Browser')
			,modal: false
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		
		$dialog.dialog(dialogOptions);
	},
	
	_refreshModels: function(){
		var _this = this;

		var $dialog = $('#'+this.browserId);
		var $modelsPane = $dialog.find('.n2widget_modelBrowser_models')
			.empty();
		
		var sourceModelIds = this.sourceModelIds;
		if( !sourceModelIds ){
			// Not specified. Request full list
			var m = {
				type: 'modelGetList'
				,modelIds: []
			};
			this.dispatchService.synchronousCall(DH,m);
			sourceModelIds = m.modelIds;
		};
		
		var sourceModelIdMap = {};

		for(var i=0,e=sourceModelIds.length; i<e; ++i){
			var sourceModelId = sourceModelIds[i];

			sourceModelIdMap[sourceModelId] = true;
			
			var $a = $('<a>')
				.addClass('n2widget_modelBrowser_model')
				.attr('href','#')
				.attr('nunaliit-source-model-id',sourceModelId)
				.text(sourceModelId)
				.appendTo($modelsPane)
				.click(function(){
					var $a = $(this);
					var sourceModelId = $a.attr('nunaliit-source-model-id');
					_this.selectedModelId = sourceModelId;
					_this._refreshModels();
					return false;
				});
			
			if( sourceModelId === this.selectedModelId ){
				$a.addClass('n2widget_modelBrowser_model_selected');
			};
		};
		
		if( !sourceModelIdMap[this.selectedModelId] ){
			this.selectedModelId = null;
		};

		_this._refreshList();
	},
	
	_refreshList: function(){
		var _this = this;

		var $dialog = $('#'+this.browserId);
		var $listPane = $dialog.find('.n2widget_modelBrowser_list')
			.empty();
		
		if( this.selectedModelId ){
			// Get current state
			var sourceState = $n2.model.getModelState({
				dispatchService: this.dispatchService
				,modelId: this.selectedModelId
			});
			var docIdMap = {};
			var docIds = [];
			if( sourceState.added ){
				for(var i=0,e=sourceState.added.length; i<e; ++i){
					var doc = sourceState.added[i];
					var docId = doc._id;
					
					if( docIdMap[docId] ){
						// Ignore
					} else {
						docIdMap[docId] = true;
						docIds.push(docId);
					};
				};
			};
			docIds.sort();
			
			if( !docIdMap[this.selectedDocId] ){
				this.selectedDocId = null;
			};
			
			var $count = $('<div>')
				.addClass('n2widget_modelBrowser_list_count')
				.text( _loc('Number of documents: {count}', {count:docIds.length}) )
				.appendTo($listPane);
			
			var $items = $('<div>')
				.addClass('n2widget_modelBrowser_list_docIds')
				.appendTo($listPane);
			
			docIds.forEach(function(docId){
				var $a = $('<a>')
					.addClass('n2widget_modelBrowser_list_docId')
					.addClass('n2widget_modelBrowser_list_docId_raw')
					.attr('href','#')
					.attr('nunaliit-document-id',docId)
					.appendTo($items)
					.text( docId )
					.click(function(){
						var $a = $(this);
						var docId = $a.attr('nunaliit-document-id');
						_this.selectedDocId = docId;
						_this._refreshList();
						return false;
					})
					.mouseover(function(){
						var $a = $(this);
						if( $a.hasClass('n2widget_modelBrowser_list_docId_raw') ) {
							var docId = $a.attr('nunaliit-document-id');
							if( _this.showService ){
								_this.showService.printBriefDescription($a,docId);
								$a.removeClass('n2widget_modelBrowser_list_docId_raw');
							};
						};
					});
				
				if( _this.selectedDocId === docId ){
					$a.addClass('n2widget_modelBrowser_list_docId_selected');
					if( _this.showService ){
						_this.showService.printBriefDescription($a,docId);
						$a.removeClass('n2widget_modelBrowser_list_docId_raw');
					};
				};
			});
		};
		
		this._refreshDocument();
	},
	
	_refreshDocument: function(){
		var _this = this;

		var $dialog = $('#'+this.browserId);
		var $docPane = $dialog.find('.n2widget_modelBrowser_document')
			.empty();
		
		if( this.selectedDocId ){
			$('<div>')
				.addClass('n2widget_modelBrowser_document_id')
				.text( _loc('Document: {id}', {id:this.selectedDocId}) )
				.appendTo($docPane);

			var $treePane = $('<div>')
				.addClass('n2widget_modelBrowser_document_tree')
				.attr('nunaliit-document', this.selectedDocId)
				.appendTo($docPane);
			
			var doc = this._getDocumentFromSelectedModel(this.selectedDocId);

			new $n2.tree.ObjectTree($treePane, doc);
		};
	},
	
	_getDocumentFromSelectedModel: function(docId){
		// Get current state
		var sourceState = $n2.model.getModelState({
			dispatchService: this.dispatchService
			,modelId: this.selectedModelId
		});

		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				if( docId === doc._id ){
					return doc;
				};
			};
		};

		return undefined;
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'modelBrowserWidget' ){
		m.isAvailable = true;
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'modelBrowserWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			var sourceModelIds = undefined;
			
			for(var key in widgetOptions){
				var value = widgetOptions[key];

				if( 'sourceModelId' === key ){
					if( typeof value === 'string' ){
						if( !sourceModelIds ){
							sourceModelIds = [];
						};
						sourceModelIds.push(value);
					} else {
						throw new Error('In modelBrowserWidget configuration, sourceModelId must be a string');
					};
					
				} else if( 'sourceModelIds' === key ){
					if( $n2.isArray(value) ){
						value.forEach(function(sourceModelId){
							if( typeof sourceModelId === 'string' ){
								if( !sourceModelIds ){
									sourceModelIds = [];
								};
								sourceModelIds.push(sourceModelId);
							} else {
								throw new Error('In modelBrowserWidget configuration, sourceModelIds must be an array of strings');
							};
						});
					} else {
						throw new Error('In modelBrowserWidget configuration, sourceModelIds must be an array of strings');
					};
					
				} else {
					options[key] = value;
				};
			};
			
			options.sourceModelIds = sourceModelIds;
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.showService = config.directory.showService;
		};
		
		new ModelBrowserWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetModelBrowser = {
	ModelBrowserWidget: ModelBrowserWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetLegend.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetLegend'
 ;

//--------------------------------------------------------------------------
var LegendWidget = $n2.Class('LegendWidget',{
	
	dispatchService: null,
	
	sourceCanvasName: null,
	
	labels: null,
	
	elemId: null,
	
	stylesInUse: null,
	
	cachedSymbols: null,

	/* 
	 * These are versions of functions that are throttled. These
	 * functions touch the DOM structure and should not be called too
	 * often as they affect performance.
	 */
	_throttledRefresh: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,sourceCanvasName: null
			,labels: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.sourceCanvasName = opts.sourceCanvasName;
		this.labels = opts.labels;

		this.stylesInUse = null;
		this.cachedSymbols = {};
		this._throttledRefresh = $n2.utils.throttle(this._refresh, 2000);

		if( typeof this.sourceCanvasName !== 'string' ){
			throw new Error('sourceCanvasName must be specified');
		};

		if( this.labels && !$n2.isArray(this.labels) ){
			throw new Error('labels must be an array');
		};

		// Set up model listener
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH,'canvasReportStylesInUse',f);
			
			// Obtain current styles in use
			var msg = {
				type: 'canvasGetStylesInUse'
				,canvasName: this.sourceCanvasName
			};
			this.dispatchService.synchronousCall(DH,msg);
			this.stylesInUse = msg.stylesInUse;
		};

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2widgetLegend')
			.appendTo($container);
		
		$n2.log(this._classname, this);

		this._throttledRefresh();
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_handle: function(m, addr, dispatcher){
		var _this = this;

		if( 'canvasReportStylesInUse' === m.type ){
			if( m.canvasName === this.sourceCanvasName ){
				this.stylesInUse = m.stylesInUse;
				this._throttledRefresh();
			};
		};
	},
	
	_refresh: function(){
		var _this = this;

		var $elem = this._getElem();
		$elem.empty();
		this.refreshCount = this.refreshCount ? this.refreshCount + 1 : 1;
		
		// Make a map of styles by label
		var stylesByLabel = {};
		var atLeastOne = false;
		for(var styleId in this.stylesInUse){
			var styleInfo = _this.stylesInUse[styleId];
			var style = styleInfo.style;
			if( style.label ){
				var effectiveLabel = _loc( style.label );
				var labelInfo = stylesByLabel[effectiveLabel];
				if( !labelInfo ){
					labelInfo = {};
					stylesByLabel[effectiveLabel] = labelInfo;
				};
				labelInfo[styleId] = styleInfo;
				atLeastOne = true;
			};
		};
		
		// If at least one style with label, then must display
		if( atLeastOne ){
			var $outer = $('<div>')
				.addClass('n2widgetLegend_outer')
				.appendTo($elem);
		
			var labelNames = [];

			if( this.labels ){
				this.labels.forEach(function(label){
					var effectiveLabel = _loc(label);
					if( stylesByLabel[effectiveLabel] ){
						labelNames.push(effectiveLabel);
					};
				});

			} else {
				for (var labelName in stylesByLabel){
					labelNames.push(labelName);
				};
				
				labelNames.sort();
			};
			
			labelNames.forEach(function(labelName){
				var labelInfo = stylesByLabel[labelName];

				var $div = $('<div>')
					.addClass('n2widgetLegend_legendEntry')
					.appendTo($outer);

				var $symbolColumn = $('<div>')
					.addClass('n2widgetLegend_symbolColumn')
					.appendTo($div);
				
				var $symbolColumnPoint = $('<div>')
					.addClass('n2widgetLegend_symbolColumn_point')
					.appendTo($symbolColumn);				
				
				var $symbolColumnLine = $('<div>')
					.addClass('n2widgetLegend_symbolColumn_line')
					.appendTo($symbolColumn);				
				
				var $symbolColumnPolygon = $('<div>')
					.addClass('n2widgetLegend_symbolColumn_polygon')
					.appendTo($symbolColumn);
				
				var $symbolColumnCluster = $('<div>')
					.addClass('n2widgetLegend_symbolColumn_cluster')
					.appendTo($symbolColumn);

				var $labelColumn = $('<div>')
					.addClass('n2widgetLegend_labelColumn')
					.appendTo($div);

				$('<div>')
					.addClass('n2widgetLegend_labelEntry')
					.text(labelName)
					.appendTo($labelColumn);
				
				var styleIds = [];
				for(var styleId in labelInfo){
					styleIds.push(styleId);
				};
				styleIds.sort();
				
				styleIds.forEach(function(styleId){
					var styleInfo = labelInfo[styleId];
					var style = styleInfo.style;
					
					// Check if point is a cluster and create either a point or cluster symbol
					if( styleInfo.point && styleInfo.point.cluster && styleInfo.point.cluster.length > 1 ){
						var $preview = $('<div>')
							.addClass('n2widgetLegend_preview n2widgetLegend_previewCluster')
							.attr('n2-style-id',style.id)
							.appendTo($symbolColumnCluster);
						_this._insertSvgPreviewPoint($preview, style, styleInfo.point);
					} else if( styleInfo.point ){
						var $preview = $('<div>')
							.addClass('n2widgetLegend_preview n2widgetLegend_previewPoint')
							.attr('n2-style-id',style.id)
							.appendTo($symbolColumnPoint);
						_this._insertSvgPreviewPoint($preview, style, styleInfo.point);
					};

					if( styleInfo.line ){
						var $preview = $('<div>')
							.addClass('n2widgetLegend_preview n2widgetLegend_previewLine')
							.attr('n2-style-id',style.id)
							.appendTo($symbolColumnLine);
						_this._insertSvgPreviewLine($preview, style, styleInfo.line);
					};

					if( styleInfo.polygon ){
						var $preview = $('<div>')
							.addClass('n2widgetLegend_preview n2widgetLegend_previewPolygon')
							.attr('n2-style-id',style.id)
							.appendTo($symbolColumnPolygon);
						_this._insertSvgPreviewPolygon($preview, style, styleInfo.polygon);
					};
				});
			});
		};
	},

	_insertSvgPreviewPoint: function($parent, style, context_){
		var _this = this;

        var context = {};
        for(var key in context_){
        	var value = context_[key];
        	
        	if( 'n2_hovered' === key ){
        		context[key] = false;
        	} else if( 'n2_selected' === key ){
        		context[key] = false;
        	} else if( 'n2_found' === key ){
        		context[key] = false;
        	} else {
        		context[key] = value;
        	};
        };
        
        var symbolizer = style.getSymbolizer(context);
        
        // SVG
        var svg = this._createSVGNode('svg');
        if( svg ) {
            this._setAttr(svg, 'version', '1.1');
            this._setAttr(svg, 'viewBox', '-7 -7 14 14');
            this._addClass(svg, 'n2widgetLegend_svg');
            var $svg = $(svg);
            
            // Geometry
            var graphicName = symbolizer.getSymbolValue('graphicName',context);
            var geom = null;
            if( graphicName 
             && this.cachedSymbols[graphicName] ){
            	geom = this._createSVGNode('path');
                this._setAttr(geom, 'd', this.cachedSymbols[graphicName]);
                
            } else if( graphicName 
	         && OpenLayers.Renderer.symbol[graphicName] ) {
            	var path = this._computePathFromSymbol(OpenLayers.Renderer.symbol[graphicName]);
            	this.cachedSymbols[graphicName] = path;
            	geom = this._createSVGNode('path');
                this._setAttr(geom, 'd', this.cachedSymbols[graphicName]);
            
            } else {
                geom = this._createSVGNode('circle');
                this._setAttr(geom, 'r', 5);
            };
            if( geom ) {
            	symbolizer.forEachSymbol(function(name,value){
            		if( 'r' === name ){
            			// Do not adjust radius
            		} else if( 'fill-opacity' === name ) {
            			// Make opacity more pronounced
            			var effectiveValue = (value * 0.5) + 0.5;
                		_this._setAttr(geom, name, effectiveValue);
            		} else {
                		_this._setAttr(geom, name, value);
            		};
            	},context);

                svg.appendChild(geom);
            };
            
            $parent.append($svg);
        };
	},

	_insertSvgPreviewLine: function($parent, style, context_){
		var _this = this;

        var context = {};
        for(var key in context_){
        	var value = context_[key];
        	
        	if( 'n2_hovered' === key ){
        		context[key] = false;
        	} else if( 'n2_selected' === key ){
        		context[key] = false;
        	} else if( 'n2_found' === key ){
        		context[key] = false;
        	} else {
        		context[key] = value;
        	};
        };
        
        var symbolizer = style.getSymbolizer(context);
        
        // SVG
        var svg = this._createSVGNode('svg');
        if( svg ) {
            this._setAttr(svg, 'version', '1.1');
            this._setAttr(svg, 'viewBox', '-7 -7 14 14');
            this._addClass(svg, 'n2widgetLegend_svg');
            var $svg = $(svg);
            
            // Geometry
            var geom = this._createSVGNode('line');
            this._setAttr(geom, 'x1', -5);
            this._setAttr(geom, 'y1', 0);
            this._setAttr(geom, 'x2', 5);
            this._setAttr(geom, 'y2', 0);
            if( geom ) {
            	symbolizer.forEachSymbol(function(name,value){
       				_this._setAttr(geom, name, value);
            	},context);

                svg.appendChild(geom);
            };
            
            $parent.append($svg);
        };
	},

	_insertSvgPreviewPolygon: function($parent, style, context_){
		var _this = this;

        var context = {};
        for(var key in context_){
        	var value = context_[key];
        	
        	if( 'n2_hovered' === key ){
        		context[key] = false;
        	} else if( 'n2_selected' === key ){
        		context[key] = false;
        	} else if( 'n2_found' === key ){
        		context[key] = false;
        	} else {
        		context[key] = value;
        	};
        };
        
        var symbolizer = style.getSymbolizer(context);
        
        // SVG
        var svg = this._createSVGNode('svg');
        if( svg ) {
            this._setAttr(svg, 'version', '1.1');
            this._setAttr(svg, 'viewBox', '-7 -7 14 14');
            this._addClass(svg, 'n2widgetLegend_svg');
            var $svg = $(svg);
            
            // Geometry
            var geom = this._createSVGNode('path');
            this._setAttr(geom, 'd', 'M -5 -5 L -2.5 5 L 5 5 L 2.5 -5 Z');
            if( geom ) {
            	symbolizer.forEachSymbol(function(name,value){
        			if( 'fill-opacity' === name ) {
	        			// Make opacity more pronounced
	        			var effectiveValue = (value * 0.5) + 0.5;
	            		_this._setAttr(geom, name, effectiveValue);
        			} else {
        				_this._setAttr(geom, name, value);
        			};
            	},context);

                svg.appendChild(geom);
            };
            
            $parent.append($svg);
        };
	},

	_createSVGNode: function(type, id) {
        var node = null;
        if( document.createElementNS ) {
	        node = document.createElementNS('http://www.w3.org/2000/svg', type);
	        if (id) {
	            node.setAttributeNS(null, 'id', id);
	        };
        };
        return node;    
    },
    
    _setAttr: function(node, name, value) {
    	node.setAttributeNS(null, name, value);
    },
    
    _addClass: function(elem, className) {
    	var classNames = [];

    	var currentClasses = elem.getAttribute('class') || '';
    	if( currentClasses ) {
    		classNames = currentClasses.split(' ');
    	};

    	if( classNames.indexOf(className) < 0 ){
        	classNames.push(className);
    	};
    	
    	elem.setAttribute('class',classNames.join(' '));
    },

    /** 
     * Method: _computePathFromSymbol
     * Given an OpenLayers symbol (array of points, which are tuples of x,y coordinates),
     * create a SVG path with an approximate area of 30 (area of a circle with a radius of 5)
     * Example for symbol: [0,0, 1,0, 1,1, 0,1, 0,0]
     * Examplke fo SVG Path: 'M -4.4 -4.4 L -4.4 4.4 L 4.4 4.4 L 4.4 -4.4 Z'
     */
    _computePathFromSymbol: function(symbol){
    	var area = 0,
    	 minx = undefined,
    	 maxx = undefined,
    	 miny = undefined,
    	 maxy = undefined;

    	// Figure out bounding box
    	for(var i=0,e=symbol.length; i<e; i=i+2){
    		var x = symbol[i];
    		var y = symbol[i+1];
    		
    		if( typeof minx === 'undefined' ){
    			minx = x;
    		} else if( minx > x ){
    			minx = x;
    		};
    		
    		if( typeof maxx === 'undefined' ){
    			maxx = x;
    		} else if( maxx < x ){
    			maxx = x;
    		};
    		
    		if( typeof miny === 'undefined' ){
    			miny = y;
    		} else if( miny > y ){
    			miny = y;
    		};
    		
    		if( typeof maxy === 'undefined' ){
    			maxy = y;
    		} else if( maxy < y ){
    			maxy = y;
    		};
    	};
    	
    	// Compute path, recentering the symbol and adjusting the area so
    	// it fits a bounding box of 10x10
    	var path = [],
    	 transx = (minx+maxx)/2,
    	 transy = (miny+maxy)/2,
    	 width = maxx-minx,
    	 height = maxy-miny,
    	 factor = (width > height) ? width / 10 : height / 10;
    	if( factor <= 0 ){
    		factor = 1;
    	};
    	for(var i=0,e=symbol.length; i<e; i=i+2){
    		var x = symbol[i];
    		var y = symbol[i+1];

    		var effX = (x-transx)/factor;
    		var effY = (y-transy)/factor;
    		
    		// Round to .01
    		effX = Math.floor(effX * 100) / 100;
    		effY = Math.floor(effY * 100) / 100;
    		
    		if( 0 === i ){
        		path.push('M ');
    		} else {
        		path.push('L ');
    		};
    		
    		path.push(''+effX);
    		path.push(' '+effY+' ');
    	};
    	path.push('Z');
    	
    	return path.join('');
    }
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'legendWidget' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'legendWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
		};
		
		new LegendWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetLegend = {
	LegendWidget: LegendWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetCollapsibleContainer.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetCollapsibleContainer'
 ;

//--------------------------------------------------------------------------
var CollapsibleWidgetContainer = $n2.Class('CollapsibleWidgetContainer',{
	
	dispatchService: null,
	
	config: null,
	
	elemId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,config: null
			,widgets: null
			,addClasses: null
			,initiallyOpened: false
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.config = opts.config;

		// Find out which widget is available
		var availableWidgets = [];
		if( $n2.isArray(opts.widgets) && this.dispatchService ){
			opts.widgets.forEach(function(widgetInfo){
				var widgetHandlerAvailable = false;
				if( widgetInfo && widgetInfo.widgetType ) {
					var msg = {
						type: 'widgetIsTypeAvailable'
						,widgetType: widgetInfo.widgetType
						,widgetOptions: widgetInfo
						,isAvailable: false
					};
					
					_this.dispatchService.synchronousCall(DH, msg);
					
					if( msg.isAvailable ){
						widgetHandlerAvailable = true;
					};
				};
				if( widgetInfo && !widgetHandlerAvailable ){
					$n2.log('Widget handler not found for type: '+widgetInfo.widgetType);
				} else {
					availableWidgets.push(widgetInfo);
				};
			});
		};
		
		// If at least one widget is available, then build container
		if( availableWidgets.length > 0 ){

			// Get container
			var containerId = opts.containerId;
			if( !containerId ){
				throw new Error('containerId must be specified');
			};
			var $container = $('#'+containerId);
			
			this.elemId = $n2.getUniqueId();
			
			var $widget = $('<div>')
				.attr('id',this.elemId)
				.addClass('n2widgetCollapsibleContainer')
				.appendTo($container);
			
			// Add classes
			if( typeof opts.addClasses === 'string' ){
				$widget.addClass(opts.addClasses);
			} else if( $n2.isArray(opts.addClasses) ){
				opts.addClasses.forEach(function(className){
					if( typeof className === 'string' ){
						$widget.addClass(className);
					};
				});
			};
			
			if( opts.initiallyOpened ){
				$widget.addClass('n2widgetCollapsibleContainer_opened');
			};
			
			var $button = $('<div>')
				.addClass('n2widgetCollapsibleContainer_button')
				.appendTo($widget)
				.click(function(){
					_this._buttonClicked();
					return false;
				});
			
			var widgetContainerId = $n2.getUniqueId();
			var $widgetContainer = $('<div>')
				.attr('id',widgetContainerId)
				.addClass('n2widgetCollapsibleContainer_widgetContainer n2widgetContainer')
				.appendTo($widget);

			availableWidgets.forEach(function(widgetInfo){
				_this.dispatchService.send(DH,{
					type: 'widgetDisplay'
					,widgetType: widgetInfo.widgetType
					,widgetOptions: widgetInfo
					,containerId: widgetContainerId
					,config: _this.config
				});
			});
			
			$n2.log(this._classname, this);

		} else {
			$n2.log(this._classname+': Not drawing because container is empty');
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
    },
    
    _buttonClicked: function(){
    	var $elem = this._getElem();
    	if( $elem.hasClass('n2widgetCollapsibleContainer_opened') ){
    		$elem.removeClass('n2widgetCollapsibleContainer_opened')
    	} else {
    		$elem.addClass('n2widgetCollapsibleContainer_opened')
    	};
    }
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'collapsibleWidgetContainer' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'collapsibleWidgetContainer' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config ){
			options.config = config;

			if( config.directory ){
				options.dispatchService = config.directory.dispatchService;
			};
		};
		
		new CollapsibleWidgetContainer(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetCollapsibleContainer = {
	CollapsibleWidgetContainer: CollapsibleWidgetContainer
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetResizingContainer.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetResizingContainer'
 ;

//--------------------------------------------------------------------------
var ResizingWidgetContainer = $n2.Class('ResizingWidgetContainer',{

	dispatchService: null,

	config: null,

	elemId: null,

	anchor: null,

	resizeClasses: null,

	intervalId: null,
	
	lastDimensionValue: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,config: null
			,widgets: null
			,addClasses: null
			,anchor: 'bottom'
			,resizeClasses: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.config = opts.config;
		this.anchor = opts.anchor;
		
		if( $n2.isArray(opts.resizeClasses) ){
			this.resizeClasses = [];
			opts.resizeClasses.forEach(function(resizeClass){
				if( typeof resizeClass === 'string' ){
					_this.resizeClasses.push(resizeClass);
				};
			});
		};
		
		this.lastDimensionValue = -1;

		// Find out which widget is available
		var availableWidgets = [];
		if( $n2.isArray(opts.widgets) && this.dispatchService ){
			opts.widgets.forEach(function(widgetInfo){
				var widgetHandlerAvailable = false;
				if( widgetInfo && widgetInfo.widgetType ) {
					var msg = {
						type: 'widgetIsTypeAvailable'
						,widgetType: widgetInfo.widgetType
						,widgetOptions: widgetInfo
						,isAvailable: false
					};
					
					_this.dispatchService.synchronousCall(DH, msg);
					
					if( msg.isAvailable ){
						widgetHandlerAvailable = true;
					};
				};
				if( widgetInfo && !widgetHandlerAvailable ){
					$n2.log('Widget handler not found for type: '+widgetInfo.widgetType);
				} else {
					availableWidgets.push(widgetInfo);
				};
			});
		};
		
		// If at least one widget is available, then build container
		if( availableWidgets.length > 0 ){

			// Get container
			var containerId = opts.containerId;
			if( !containerId ){
				throw new Error('containerId must be specified');
			};
			var $container = $('#'+containerId);
			
			this.elemId = $n2.getUniqueId();

			var $widget = $('<div>')
				.attr('id',this.elemId)
				.addClass('n2widgetResizingContainer n2widgetContainer')
				.css({
					'position':'absolute'
					,'border': 'none'
					,'margin': '0'
					,'padding': '0'
				})
				.appendTo($container);
			
			if( 'bottom' === this.anchor ){
				$widget.css({
					'bottom': '0'
				});

			} else if( 'top' === this.anchor ){
				$widget.css({
					'top': '0'
				});

			} else if( 'left' === this.anchor ){
				$widget.css({
					'left': '0'
				});

			} else if( 'right' === this.anchor ){
				$widget.css({
					'right': '0'
				});
			} else {
				throw new Error('Unknown anchor: '+this.anchor);
			};
			
			// Add classes
			if( typeof opts.addClasses === 'string' ){
				$widget.addClass(opts.addClasses);
			} else if( $n2.isArray(opts.addClasses) ){
				opts.addClasses.forEach(function(className){
					if( typeof className === 'string' ){
						$widget.addClass(className);
					};
				});
			};

			// Add contained widgets
			availableWidgets.forEach(function(widgetInfo){
				_this.dispatchService.send(DH,{
					type: 'widgetDisplay'
					,widgetType: widgetInfo.widgetType
					,widgetOptions: widgetInfo
					,containerId: _this.elemId
					,config: _this.config
				});
			});
			
			this.intervalId = window.setInterval(function(){
				_this._refreshSize();
			},300);
			
			$n2.log(this._classname, this);

		} else {
			$n2.log(this._classname+': Not drawing because container is empty');
		};
	},

	_getElem: function(){
		return $('#'+this.elemId);
	},

    _refreshSize: function(){
    	var _this = this;
    	
    	var $elem = this._getElem();
    	if( $elem.length < 1 ){
    		window.clearInterval(this.intervalId);
    		return;
    	};
    	
		var currentDimensionValue;
		if( 'bottom' === this.anchor ){
			currentDimensionValue = $elem.height();
		} else if( 'top' === this.anchor ){
			currentDimensionValue = $elem.height();
		} else if( 'left' === this.anchor ){
			currentDimensionValue = $elem.width();
		} else if( 'right' === this.anchor ){
			currentDimensionValue = $elem.width();
		};
		
		if( currentDimensionValue !== this.lastDimensionValue ){
			this.lastDimensionValue = currentDimensionValue;
		
			if( $n2.isArray(this.resizeClasses) ){
				this.resizeClasses.forEach(function(resizeClass){
					if( 'bottom' === _this.anchor ){
						$('.'+resizeClass).css('bottom',currentDimensionValue+'px');
					} else if( 'top' === _this.anchor ){
						$('.'+resizeClass).css('top',currentDimensionValue+'px');
					} else if( 'left' === _this.anchor ){
						$('.'+resizeClass).css('left',currentDimensionValue+'px');
					} else if( 'right' === _this.anchor ){
						$('.'+resizeClass).css('right',currentDimensionValue+'px');
					};
				});
			};
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'resizingWidgetContainer' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'resizingWidgetContainer' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config ){
			options.config = config;

			if( config.directory ){
				options.dispatchService = config.directory.dispatchService;
			};
		};
		
		new ResizingWidgetContainer(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetResizingContainer = {
	ResizingWidgetContainer: ResizingWidgetContainer
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetDuplicate.js

/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetDuplicate'
 ;

//--------------------------------------------------------------------------
var DuplicateWidget = $n2.Class('DuplicateWidget', {
	
	dispatchService: null,
	
	label: null,
	
	elemId: null,

	selectedDocId: null,

	docForDuplicate: null,
	
	showAsLink: false,

	duplicateAllDocs: false,
	
	duplicateOnSchemas: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: null
			,dispatchService: null
			,label: _loc('Duplicate')
			,showAsLink: false
			,duplicateAllDocs: undefined
			,duplicateOnSchemas: undefined
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.label = opts.label;
		this.showAsLink = opts.showAsLink;
		
		this.selectedDocId = null;
		this.docForDuplicate = null;

		this.duplicateAllDocs = undefined;
		if( opts.duplicateAllDocs ){
			var selectors = this._parseSelectors(opts.duplicateAllDocs, 'duplicateAllDocs');
			this.duplicateAllDocs = selectors;
		};

		this.duplicateOnSchemas = {};
		if( opts.duplicateOnSchemas ){
			for(var schemaName in opts.duplicateOnSchemas){
				var v = opts.duplicateOnSchemas[schemaName];
				var selectors = this._parseSelectors(v, 'duplicateOnSchemas['+schemaName+']');
				this.duplicateOnSchemas[schemaName] = selectors;
			};
		};
		
		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2widget_duplicate')
			.appendTo($container);
		
		// Set up model listener
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'selected',f);
			this.dispatchService.register(DH,'unselected',f);
			this.dispatchService.register(DH,'documentContent',f);
		};
		
		this._redraw();
		
		$n2.log(this._classname, this);
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_parseSelectors: function(v, position){
		if( 'ALL_ATTRIBUTES' === v ){
			return true;
			
		} else if( typeof v === 'boolean' && !v ) {
			return false;

		} else if( $n2.isArray(v) ){
			var selectors = [];
			v.forEach(function(sel){
				if( typeof sel === 'string' ){
					try {
						var objSel = $n2.objectSelector.parseSelector(sel);
						selectors.push(objSel);
					} catch(e) {
						$n2.logError(this._classname+': Error while parsing object selector for '+position+': '+sel, e);
					};
				} else {
					$n2.logError(this._classname+': Unknown copy scheme for schema '+position+': '+sel, e);
				};
			});
			
			return selectors;
			
		} else {
			$n2.logError(this._classname+': Unrecognized selectors for '+position);
		};
	},

	_handle: function(m, addr, dispatcher){
		if( 'selected' === m.type ){
			this.selectedDocId = null;
			this.docForDuplicate = null;
			if( m.doc ){
				this.selectedDocId = m.doc._id;
				if( this._isDocumentEligibleForDuplicate(m.doc) ){
					this.docForDuplicate = m.doc;
				};

			} else if( m.docId ){
				this.selectedDocId = m.docId;
				var m = {
					type: 'requestDocument'
					,docId: m.docId
				};
				dispatcher.send(DH,m);
			};
			
			this._redraw();

		} else if( 'unselected' === m.type ){
			this.selectedDocId = null;
			this.docForDuplicate = null;
			this._redraw();

		} else if( 'documentContent' === m.type ) {
			var doc = m.doc;
			if( doc 
			 && this.selectedDocId === doc._id 
			 && !this.docForDuplicate 
			 && this._isDocumentEligibleForDuplicate(doc) ){
				this.docForDuplicate = doc;
				this._redraw();
			};
		};
	},
	
	_isDocumentEligibleForDuplicate: function(doc){
		if( !doc ){
			return false;
		};

		if( this.duplicateAllDocs ){
			return true;
		};
		
		var schemaName = doc.nunaliit_schema;
		if( this.duplicateOnSchemas[schemaName] ){
			return true;
		};
		
		return false;
	},
	
	_redraw: function(){
		var _this = this;

		var $elem = this._getElem();
		$elem.empty();
		if( this.docForDuplicate ){
			if( this.showAsLink ) {
				$elem.addClass('n2widget_duplicate_asLink');
				$('<a>')
					.attr('href', _loc('Duplicate'))
					.text( this.label )
					.appendTo( $elem )
					.click(function(){
						try {
							_this._performDuplicate();
						} catch(e) {
							$n2.log('Error during duplicate: '+e);
						};
						return false;
					});
			} else {
				$elem.removeClass('n2widget_duplicate_asLink');
				$('<button>')
					.text( _loc('Duplicate') )
					.appendTo($elem)
					.click(function(){
						_this._performDuplicate();
						return false;
					});
			};
		};
	},
	
	_performDuplicate: function(){
		var _this = this;

		if( this.docForDuplicate ){
			var doc = {
				nunaliit_schema: this.docForDuplicate.nunaliit_schema
			};
			
			var schemaName = doc.nunaliit_schema;
			if( this.duplicateOnSchemas[schemaName] ){
				this._copyOnSelectors(doc, this.docForDuplicate, this.duplicateOnSchemas[schemaName]);
			} else if( this.duplicateAllDocs ) {
				this._copyOnSelectors(doc, this.docForDuplicate, this.duplicateAllDocs);
			};
			
			this.dispatchService.send(DH, {
				type: 'editInitiate'
				,doc: doc
			});
		} else {
			$n2.logError('DuplicateWidget: no document selected for duplicate');
		};
	},
	
	_copyOnSelectors: function(targetDoc, sourceDoc, selectors){
		if( 'ALL_ATTRIBUTES' === selectors ){
			for(var key in sourceDoc){
				if( typeof key === 'string' 
				 && key.length > 0 
				 && key[0] === '_' ){
					// Do not duplicate keys reserved by CouchDB
				} else if( 'nunaliit_import' === key
				 || 'nunaliit_attachments' === key
				 || 'nunaliit_created' === key
				 || 'nunaliit_last_updated' === key
				 || 'nunaliit_geom' === key ) {
					// Do not duplicate keys reserved by Nunaliit
				} else {
					var v = sourceDoc[key];
					targetDoc[key] = $n2.deepCopy(v);
				};
 			};
			
		} else if( $n2.isArray(selectors) ){
			selectors.forEach(function(objSel){
				var v = objSel.getValue(sourceDoc);
				if( undefined === v ){
					objSel.removeValue(targetDoc);
				} else {
					var value = $n2.deepCopy(v);
					objSel.setValue(targetDoc, value, true);
				};
			});

		} else {
			throw new Error(this._classname+' Unknown copy selector',selectors);
		};
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'duplicateDocument' ){
		if( $.fn.slider ) {
			m.isAvailable = true;
		};
    };
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'duplicateDocument' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
		};
		
		new DuplicateWidget(options);
    };
};

//--------------------------------------------------------------------------
$n2.widgetDuplicate = {
	DuplicateWidget: DuplicateWidget
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.widgetTranscript.js

/*
Copyright (c) 2018, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.widgetTranscript'
 ;

//--------------------------------------------------------------------------
var TranscriptWidget = $n2.Class('TranscriptWidget',{
	
	dispatchService: null,

	attachmentService: null,

	elemId: null,

	videoId: null,
	
	transcriptId: null,

	name: null,

	docId: null,

	videoAttName: null,

	srtAttName: null,

	doc: null,

	srtData: null,
	
	transcript_array: null,
	
	// Time source variables
	sourceModelId: null, // id of time model, or null

	intervalChangeEventName: null, // name of event used to report changes in time interval
	intervalGetEventName: null, // name of event used to retrieve current time interval
	intervalSetEventName: null, // name of event used to set current time interval
	intervalMin: null, // integer, current interval minimum
	intervalMax: null, // integer, current interval maximum

	/*
		[
			{
				timeStart: <integer - interval start>
				,timeEnd: <integer - interval end>
				,videoStart: <integer>
				,videoEnd: <integer>
			}
		]
	 */
	timeTable: null,
	transcriptConvertor: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			containerId: undefined
			,dispatchService: undefined
			,attachmentService: undefined
			,name: undefined
			,docId: undefined
			,doc: undefined
			,sourceModelId: undefined
		},opts_);

		var _this = this;

		this.dispatchService = opts.dispatchService;
		this.attachmentService = opts.attachmentService;
		this.name = opts.name;
		this.docId = opts.docId;
		this.sourceModelId = opts.sourceModelId;
		if( opts.doc ){
			this.doc = opts.doc;
			this.docId = this.doc._id;
		};
		if( !this.name ){
			this.name = $n2.getUniqueId();
		};

		this.transcriptConvertor = new SrtToJsonConvertor();
		this.transcript_array = [];

		// Get container
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		var $container = $('#'+containerId);
		
		this.elemId = $n2.getUniqueId();
		
		$('<div>')
			.attr('id',this.elemId)
			.addClass('n2widgetTranscript')
			.appendTo($container);

		// Set up dispatcher
		if( this.dispatchService ){
			if( this.sourceModelId ){
				// Get model info
				var modelInfoRequest = {
					type: 'modelGetInfo'
					,modelId: this.sourceModelId
					,modelInfo: null
				};
				this.dispatchService.synchronousCall(DH, modelInfoRequest);
				var sourceModelInfo = modelInfoRequest.modelInfo;
				
				if( sourceModelInfo 
				 && sourceModelInfo.parameters 
				 && sourceModelInfo.parameters.interval ){
					var paramInfo = sourceModelInfo.parameters.interval;
					this.intervalChangeEventName = paramInfo.changeEvent;
					this.intervalGetEventName = paramInfo.getEvent;
					this.intervalSetEventName = paramInfo.setEvent;

					if( paramInfo.value ){
						this.intervalMin = paramInfo.value.min;
						this.intervalMax = paramInfo.value.max;
					};
				};
			};

			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH,'mediaTimeChanged',f);
			this.dispatchService.register(DH,'documentContent',f);
			if( this.intervalChangeEventName ){
				this.dispatchService.register(DH,this.intervalChangeEventName,f);
			};
			
			// If the widget was built specifying a specific document, then do not change
			// content on user selection. If no document specified, then listen to user selection.
			if( !this.docId ){
				this.dispatchService.register(DH,'selected',f);
			};
		};

		$n2.log(this._classname, this);

		this._documentChanged();
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_handle: function(m, addr, dispatcher){
		var _this = this;

		/*
			mediaTimeChange message
			{
				type:'mediaTimeChange'
				,name: <name of widget>
				,currentTime: <integer>
				,origin: <string>
				      video => event originated from video player
				      text => event originated from clicking text
			}
		*/
		if( 'mediaTimeChanged' === m.type ){
			if( m.name == this.name ){
				this._timeChanged(m.currentTime, m.origin);
			};
			
		} else if( 'documentContent' === m.type ){
			if( m.docId == this.docId ){
				if( !this.doc ){
					this.doc = m.doc;
					this._documentChanged();
				} else if( this.doc._rev != m.doc._rev ){
					this.doc = m.doc;
					this._documentChanged();
				};
			};

		} else if( this.intervalChangeEventName === m.type ) {
			//$n2.log("intervalChangeEvent "+this.intervalChangeEventName+" => ", m);

			if( m.value ){
				this.intervalMin = m.value.min;
				this.intervalMax = m.value.max;
				
				var videoTime = this._convertTimeToVideoTime(this.intervalMin);
				if( typeof videoTime == 'number' ){
					this._timeChanged(videoTime, 'model');
				};
			};
			
		} else if( 'selected' === m.type ){
			if( m.docId != this.docId ){
				this.docId = m.docId;
				this.doc = m.doc;
				this.timeTable = [];
				this._documentChanged();
			};
		};
	},

	_convertTimeToVideoTime: function(t){
		var vTime = undefined;
		
		if( this.timeTable ){
			this.timeTable.forEach(function(timeEntry){
				if( timeEntry.timeStart < t && t < timeEntry.timeEnd ){
					var frac = (t - timeEntry.timeStart) / (timeEntry.timeEnd - timeEntry.timeStart);
					vTime = timeEntry.videoStart + (frac * (timeEntry.videoEnd - timeEntry.videoStart))
				};
			});
		};
		
		return vTime;
	},

	_convertVideoTimeToTime: function(vTime){
		var time = undefined;
		
		if( this.timeTable ){
			this.timeTable.forEach(function(timeEntry){
				if( timeEntry.videoStart < vTime && vTime < timeEntry.videoEnd ){
					var frac = (vTime - timeEntry.videoStart) / (timeEntry.videoEnd - timeEntry.videoStart);
					time = timeEntry.timeStart + (frac * (timeEntry.timeEnd - timeEntry.timeStart));
					time = Math.floor(time);
				};
			});
		};
		
		return time;
	},

	/**
	 * This method is called when we detect that the document has changed. This can be triggered
	 * through a new selection from the user, or an update to the currently selected document.
	 */
	_documentChanged: function(){
		var _this = this;

		if( !this.doc ){
			// We do not have the document. Request it.
			this.dispatchService.send(DH, {
				'type': 'requestDocument'
				,'docId': this.docId
			});

		} else if( !this.transcript ){
			this._loadTranscript(this.doc);

		} else if( !this.srtData ){
			var attSrt = undefined;
			if( this.attachmentService
			 && this.transcript 
			 && this.transcript.srtAttName ){
				attSrt = this.attachmentService.getAttachment(this.doc, this.transcript.srtAttName);
			};

			var srtUrl = undefined;
			if( attSrt ){
				srtUrl = attSrt.computeUrl();
			};

			if( srtUrl ){
				// download content of attachment and call rendering function
				$.ajax({
					url: srtUrl
					,type: 'GET'
					,async: true
					,traditional: true
					,data: {}
					,dataType: 'text'
					,success: function(srtData) {
						_this.srtData = srtData;
						_this.transcript_array = _this.transcriptConvertor.execute(srtData);
						_this._documentChanged();
					}
					,error: function(XMLHttpRequest, textStatus, errorThrown) {
						// error while getting SRT content. Jump into same error
						// as wrongly configured
						_this._documentChanged();
					}
				});
			} else {
				// element is wronly configured. Report error
				_this._renderError('Can not compute URL for SRT');
			};

		} else if( this.transcript.timeTable ){
			if( !$n2.isArray(this.transcript.timeTable) ){
				_this._renderError('timeTable must be an array');
			} else {
				this.timeTable = [];

				this.transcript.timeTable.forEach(function(timeEntry){
					if( typeof timeEntry !== 'object' ){
						throw new Error('Entries in timeTable must be objects');
					} else if( null === timeEntry ){
						throw new Error('Entries in timeTable can not be null');
					};
					
					var videoStart = timeEntry.videoStart;
					var videoEnd = timeEntry.videoEnd;
					var timeStart = timeEntry.timeStart;
					var timeEnd = timeEntry.timeEnd;

					if( typeof videoStart !== 'number' ){
						throw new Error('videoStart in timeTable must be a number');
					};
					if( typeof videoEnd !== 'number' ){
						throw new Error('videoEnd in timeTable must be a number');
					};

					// Try to parse time
					var timeStartInt = $n2.date.parseUserDate(timeStart);
					var timeEndInt = $n2.date.parseUserDate(timeEnd);
					
					var timeObj = {
						intervalStart: timeStartInt
						,intervalEnd: timeEndInt
						,timeStart: timeStartInt.min
						,timeEnd: timeEndInt.min
						,videoStart: videoStart
						,videoEnd: videoEnd
					};
					_this.timeTable.push(timeObj);
				});
			};
		};

		// At the end of all this, refresh
		this._refresh();
	},

	_refresh: function(){
		var _this = this;

		var $elem = this._getElem();
		
		$elem.empty();

		if( !this.docId ){
			return;
		};
		if( !this.transcript ){
			return;
		};

		var attVideoName = undefined;
		if( this.transcript ){
			attVideoName = this.transcript.videoAttName;
		}

		var attVideoDesc = null;
		var data = this.doc; // shorthand
		if( data 
		 && data.nunaliit_attachments
		 && data.nunaliit_attachments.files
		 && attVideoName
		 ) {
			attVideoDesc = data.nunaliit_attachments.files[attVideoName];
			if( attVideoDesc
			 && attVideoDesc.fileClass !== 'video' ){
				attVideoDesc = undefined;
			};
		};

		var thumbnailUrl = null;
		if( attVideoDesc
		 && attVideoDesc.thumbnail ){
			var attThumb = this.attachmentService.getAttachment(this.doc, attVideoDesc.thumbnail);
			if( attThumb ){
				thumbnailUrl = attThumb.computeUrl();
			};
		};

		var attVideoUrl = undefined;
		if( attVideoDesc 
		 && attVideoDesc.status === 'attached' ) {
			var attVideo = this.attachmentService.getAttachment(this.doc, attVideoName);
			if( attVideo ){
				attVideoUrl = attVideo.computeUrl();
			};
		};

		if( attVideoUrl ) {
			var mediaDivId = $n2.getUniqueId();
			this.videoId = $n2.getUniqueId();
			this.transcriptId = $n2.getUniqueId();

			var $mediaDiv = $('<div>')
					.attr('id', mediaDivId)
					.appendTo($elem);
			
		
			//DIV for the Video
			var $video = $('<video>')
				.attr('id', this.videoId)
				.attr('controls', 'controls')
				.attr('width', '100%')
				.attr('height', '360px')
				.appendTo($mediaDiv);

			var $videoSource = $('<source>')
				.attr('src', attVideoUrl)
				.appendTo($video);

			if( attVideoDesc.mimeType ){
				$videoSource.attr('type', attVideoDesc.mimeType);
			};

	
			$video.mediaelementplayer({
				poster: thumbnailUrl
				,features: ['playpause','progress','volume','sourcechooser','fullscreen']
			}); 

			//little refine for css : specically for transcript
			//$('.n2_content_text').css('overflow','hidden');

			var $transcript = $('<div>')
				.attr('id', this.transcriptId)
				.addClass('n2widgetTranscript_transcript')
				.appendTo($mediaDiv);

			/*this.transcript_array = [
				{"start": "0.00",
					"fin": "5.00",
					"text": "Now that we've looked at the architecture of the internet, let's see how you might connect your personal devices to the internet inside your house."},
				{"start": "5.01",
					"fin": "10.00",
					"text": "Well there are many ways to connect to the internet, and most often people connect wirelessly."},
				{"start": "10.01",
					"fin": "15.00",
					"text": "Let's look at an example of how you can connect to the internet."},
				{"start": "15.01",
					"fin": "20.00",
					"text": "If you live in a city or a town, you probably have a coaxial cable for cable Internet, or a phone line if you have DSL, running to the outside of your house, that connects you to the Internet Service Provider, or ISP."},
				{"start": "20.01",
					"fin": "25.00",
					"text": "If you live far out in the country, you'll more likely have a dish outside your house, connecting you wirelessly to your closest ISP, or you might also use the telephone system."},
				{"start": "25.01",
					"fin": "30.00",
					"text": "Whether a wire comes straight from the ISP hookup outside your house, or it travels over radio waves from your roof, the first stop a wire will make once inside your house, is at your modem."},
				
			];*/
		
			prep_transcript($transcript, this.transcript_array);

			// time update function: #highlight on the span to change the color of the text
			$video
				.bind('timeupdate', function() {
					var currentTime = this.currentTime;
					_this._updateCurrentTime(currentTime, 'video');
				});

		} else {
			_this._renderError('Can not compute URL for video');
		};

		function prep_transcript($transcript, transcript_array){
			var temp;
			for (var i = 0; i < transcript_array.length; i++) {
				var transcriptElem = transcript_array[i];
				
				var id = $n2.getUniqueId();
				transcriptElem.id = id;
				
				temp = $('<span/>')
					.attr('id', id)
					.attr('data-start', transcriptElem.start)
					.text(transcriptElem.text+ ' ')
					.appendTo($transcript)
					.click(function(e) {
						var $span = $(this);
						var currentTime = $span.attr('data-start');
						_this._updateCurrentTime(currentTime, 'text');
					});
			}
		}
	},
	
	_loadTranscript: function(doc){
		// Look for transcript in-line
		if( doc && doc.nunaliit_transcript ){
			this.transcript = doc.nunaliit_transcript;
			this._documentChanged();

		} else {
			// Find the attachment for the transcript
			var transcriptAttName = this._findTranscriptAttachmentName(this.doc);
			if( transcriptAttName ){
				// Load transcript
				var att = undefined;
				if( this.attachmentService ){
					att = this.attachmentService.getAttachment(this.doc, transcriptAttName);
				};

				var url = undefined;
				if( att ){
					url = att.computeUrl();
				};

				if( url ){
					// download content of attachment and call rendering function
					$.ajax({
						url: url
						,type: 'GET'
						,async: true
						,traditional: true
						,data: {}
						,dataType: 'json'
						,success: function(transcript) {
							_this.transcript = transcript;
							_this._documentChanged();
						}
						,error: function(XMLHttpRequest, textStatus, errorThrown) {
							// error while getting transcript. Jump into same error
							// as wrongly configured
							_this._renderError('Error fetching transcript');
						}
					});
				} else {
					// element is wronly configured. Report error
					_this._renderError('Can not compute URL for transcript');
				};
			} else {
				_this._renderError('Transcript attachment name not found for '+this.doc._id);
			};
		};
	},
	
	_findTranscriptAttachmentName: function(doc){
		if( doc 
		 && doc.nunaliit_attachments 
		 && doc.nunaliit_attachments.files ){
			for(var attName in doc.nunaliit_attachments.files){
				var att = doc.nunaliit_attachments.files[attName];
				if( 'transcript.json' === attName ){
					return attName;
				};
			};
		};
		
		return undefined;
	},

	_updateCurrentTime: function(currentTime, origin){
		// Send notice to dispatcher
		this.dispatchService.send(DH,{
			type: 'mediaTimeChanged'
			,name: this.name
			,currentTime: currentTime
			,origin: origin
		});
		
		// Inform time model
		if( this.intervalSetEventName ){
			var min = this._convertVideoTimeToTime(currentTime);
			
			if( typeof min == 'number' ){
				var value = new $n2.date.DateInterval({
					min: min
					,max: this.intervalMax
					,ongoing: false
				});

				this.dispatchService.send(DH,{
					type: this.intervalSetEventName
					,value: value
				});
			};
		};
	},

	_timeChanged: function(currentTime, origin){
		// Act upon the text
		for(var i =0;i<this.transcript_array.length;i++) {
			var transcriptElem = this.transcript_array[i];
			var $transcriptElem = $('#'+transcriptElem.id);

			$transcriptElem.removeClass('highlight');

			if(currentTime >= transcriptElem.start 
			 && currentTime <= transcriptElem.fin) {
				$transcriptElem.addClass('highlight');
			};

			//$n2.log('current time: '+ currentTime);
		}
		
		if( 'model' === origin ){
			var $video = $('#'+this.videoId);
			var currentVideoTime = $video[0].currentTime;
			if( Math.abs(currentVideoTime - currentTime) < 0.5 ){
				// Debounce
			} else {
				$video[0].currentTime = currentTime;
			};
			
		} else if( 'text' === origin ){
			var $video = $('#'+this.videoId);
			$video[0].currentTime = currentTime;
			$video[0].play();
		}
	},
	
	_renderError: function(errMsg){
		var $elem = this._getElem();
		
		$elem.empty();
		
		var label = _loc('Unable to display tether content({docId})',{
			docId: this.docId
		});
		$('<span>')
			.addClass('n2widgetTranscript_error')
			.text(label)
			.appendTo($elem);
		
		$n2.logError('Unable to display tether content({docId}): '+errMsg);
	}
});

//--------------------------------------------------------------------------
var SrtToJsonConvertor = $n2.Class('SrtToJsonConvertor',{
	execute: function(srtData) {
		var json = [];
		var lines = srtData.split("\n");
		if( !$n2.isArray(lines) ){
			throw new Error('srtFile data processing error');
		};
		var cur = -1;
		var totalLength = lines.length;
		
		var curSentence = "";
		while( ++cur < totalLength){
			if( lines[cur].replace(/^\s+|\s+$/g,'') === ""){
				continue;
			} else {
				var tmpIdx = lines[cur].replace(/^\s+|\s+$/g,'');
				var tmpTimecode = lines[++cur].replace(/^\s+|\s+$/g,'');
				if(tmpIdx.search(/[0-9]+/i) === -1 || 
						tmpTimecode.search(/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\,[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\,[0-9][0-9][0-9]/i) === -1 ) {
					continue;
				} else {
					var curEntry = {
							"start": null,
							"fin": null,
							"text": ""
					};
					//$n2.log("The"+tmpIdx+"-th transcript");
					//$n2.log("The timecode: "+ tmpTimecode);
					
					curEntry.start  =  tmpTimecode.substring(0,2)*3600 + tmpTimecode.substring(3,5)*60 
					+ tmpTimecode.substring(6,8);
					curEntry.fin = tmpTimecode.substring(17,19)*3600 + tmpTimecode.substring(20,22)*60 
					+ tmpTimecode.substring(23,25);
					while((curSentence = lines[++cur])!== ""){
						curEntry.text += curSentence;
						}
					json.push(curEntry);
					
				}
				
			}
		}
		return json;
	},
});
//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'transcriptWidget' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'transcriptWidget' ){
		var widgetOptions = m.widgetOptions;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
			options.attachmentService = config.directory.attachmentService;
		};
		
		new TranscriptWidget(options);
	};
};

//--------------------------------------------------------------------------
$n2.widgetTranscript = {
	TranscriptWidget: TranscriptWidget
	,SrtToJsonConvertor: SrtToJsonConvertor
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvas.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvas'
 ;
 
//--------------------------------------------------------------------------
var Service = $n2.Class({
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'canvasIsTypeAvailable',f);
			this.dispatchService.register(DH,'canvasDisplay',f);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'canvasIsTypeAvailable' === m.type ){
			if( $n2.canvasForceGraph 
			 && $n2.canvasForceGraph.HandleCanvasAvailableRequest ){
				$n2.canvasForceGraph.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasRadial 
			 && $n2.canvasRadial.HandleCanvasAvailableRequest ){
				$n2.canvasRadial.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasRadialTree 
			 && $n2.canvasRadialTree.HandleCanvasAvailableRequest ){
				$n2.canvasRadialTree.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasCollapsibleRadialTree 
			 && $n2.canvasCollapsibleRadialTree.HandleCanvasAvailableRequest ){
				$n2.canvasCollapsibleRadialTree.HandleCanvasAvailableRequest(m);
			};
			
			if( $n2.canvasGrid 
			 && $n2.canvasGrid.HandleCanvasAvailableRequest ){
				$n2.canvasGrid.HandleCanvasAvailableRequest(m);
			};
					
			if( $n2.canvasPack 
			 && $n2.canvasPack.HandleCanvasAvailableRequest ){
				$n2.canvasPack.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasTree 
			 && $n2.canvasTree.HandleCanvasAvailableRequest ){
				$n2.canvasTree.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasCustomSvg 
			 && $n2.canvasCustomSvg.HandleCanvasAvailableRequest ){
				$n2.canvasCustomSvg.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasCustomHtml 
			 && $n2.canvasCustomHtml.HandleCanvasAvailableRequest ){
				$n2.canvasCustomHtml.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasReferenceBrowser 
			 && $n2.canvasReferenceBrowser.HandleCanvasAvailableRequest ){
				$n2.canvasReferenceBrowser.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasTable 
			 && $n2.canvasTable.HandleCanvasAvailableRequest ){
				$n2.canvasTable.HandleCanvasAvailableRequest(m);
			};

			if( $n2.canvasMap 
			 && $n2.canvasMap.HandleCanvasAvailableRequest ){
				$n2.canvasMap.HandleCanvasAvailableRequest(m);
			};

		} else if( 'canvasDisplay' === m.type ) {
			if( $n2.canvasForceGraph 
			 && $n2.canvasForceGraph.HandleCanvasDisplayRequest ){
				$n2.canvasForceGraph.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasRadial 
			 && $n2.canvasRadial.HandleCanvasDisplayRequest ){
				$n2.canvasRadial.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasRadialTree 
			 && $n2.canvasRadialTree.HandleCanvasDisplayRequest ){
				$n2.canvasRadialTree.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasCollapsibleRadialTree 
			 && $n2.canvasCollapsibleRadialTree.HandleCanvasDisplayRequest ){
				$n2.canvasCollapsibleRadialTree.HandleCanvasDisplayRequest(m);
			};
			
			if( $n2.canvasGrid 
			 && $n2.canvasGrid.HandleCanvasDisplayRequest ){
				$n2.canvasGrid.HandleCanvasDisplayRequest(m);
			};
					
			if( $n2.canvasPack 
			 && $n2.canvasPack.HandleCanvasDisplayRequest ){
				$n2.canvasPack.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasTree 
			 && $n2.canvasTree.HandleCanvasDisplayRequest ){
				$n2.canvasTree.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasCustomSvg 
			 && $n2.canvasCustomSvg.HandleCanvasDisplayRequest ){
				$n2.canvasCustomSvg.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasCustomHtml 
			 && $n2.canvasCustomHtml.HandleCanvasDisplayRequest ){
				$n2.canvasCustomHtml.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasReferenceBrowser 
			 && $n2.canvasReferenceBrowser.HandleCanvasDisplayRequest ){
				$n2.canvasReferenceBrowser.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasTable 
			 && $n2.canvasTable.HandleCanvasDisplayRequest ){
				$n2.canvasTable.HandleCanvasDisplayRequest(m);
			};

			if( $n2.canvasMap
			 && $n2.canvasMap.HandleCanvasDisplayRequest ){
				$n2.canvasMap.HandleCanvasDisplayRequest(m);
			};
		};
	}
});

//--------------------------------------------------------------------------
$n2.canvas = {
	Service: Service
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasElementGenerator.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasElementGenerator'
;
 
// An instance of ElementGenerator is responsible of taking a set of documents
// from a data source and producing a set of graphic elements, based on those
// document, destined to a canvas.
//
// The instance of ElementGenerator is informed when the data set is changed and
// propagates those changes, in terms of elements, to the canvas. It is also
// responsible to keep track of user intents on the source documents, translate
// these intents in terms of elements and inform the canvas.
//
// In reverse, an instance of ElementGenerator is informed by the canvas when the user
// clicks or hovers an element. Then, it translates these intents from elements
// to documents and informs the remainder of the system by sending the appropriate
// events through the dispatcher.
//
// The algorithm used by instances of ElementGenerator is to break up documents into
// fragments and then combine the fragments into elements.
//
// Elements provided to the canvas have the following attributes:
// {
//     id: String. Unique identifier for this element
//     fragments: Array of Objects. Used internally by ElementGenerator
//     n2_selected: Boolean. Set if element is selected
//     n2_selectedIntent: String. Selection intent, if one is specified.
//     n2_hovered: Boolean. Set if element is in focus
//     n2_hoveredIntent: String. Focus intent, if one is specified.
//     n2_found: Boolean. Set if the element is found.
//     n2_intent: String. Effective intention (selected or hovered), if one is specified.
//     n2_doc: Optional Object. Document, if only one is associated with the element.
// }
 
//--------------------------------------------------------------------------
// doc 1---1 context 1---N fragment N---N element
//
// doc
//   must have the following attributes:
//      _id
//
// context
//   must have the following attributes:
//      n2_id : document identifier for the supporting document
//      n2_doc : supporting document
//      fragments : list of fragments generated from supporting document
//
// fragment
//   must have the following attributes:
//      id : unique identifier for fragment
//      n2_id : document identifier for the supporting document
//      n2_doc : supporting document
//      context : context associated with supporting document
//      elements : element map, by element id, for each element associated 
//                 with the fragment
//
// element
//   must have the following attributes:
//      id : unique identifier for element
//      fragments : map of fragments, by fragment id, making up element
var ElementGenerator = $n2.Class('ElementGenerator', {
	
	elementsChanged: null,
	
	intentChanged: null,
	
	contextByDocId: null,

	fragmentById: null,

	elementById: null,
	
	dispatchService: null,
	
	userIntentView: null,
	
	/*
	 * This is a string or object used to set all the attribute "_source" on all events
	 * generated by this element generator. It should be set by the canvas that the element
	 * generator represents. This is useful to determine if an event was produced by
	 * the canvas, or not.
	 */
	eventSource: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,eventSource: null
			,elementsChanged: function(added, updated, removed){}
			,intentChanged: function(updated){}
		},opts_);
		
		var _this = this;
		
		this.elementsChanged = opts.elementsChanged;
		this.intentChanged = opts.intentChanged;
		
		this.contextByDocId = {};
		this.fragmentById = {};
		this.elementById = {};
		
		this.eventSource = undefined;
		if( opts.eventSource ){
			this.eventSource = opts.eventSource;
		};
	
		this.dispatchService = opts.dispatchService;
		
		this.userIntentView = new $n2.userIntentView.IntentView({
			dispatchService: opts.dispatchService
		});
		this.userIntentView.addListener(function(changedNodes){
			_this._intentChangedContexts(changedNodes);
		});
	},
	
	setElementsChangedListener: function(listener){
		this.elementsChanged = listener;
	},
	
	setIntentChangedListener: function(listener){
		this.intentChanged = listener;
	},
	
	setEventSource: function(eventSource){
		this.eventSource = eventSource;
	},
	
	/*
	 * This function gets called when changes in the underlying documents
	 * are detected.
	 */
	sourceModelUpdated: function(opts_){
 		var opts = $n2.extend({
 			added: null
 			,updated: null
 			,removed: null
 		},opts_);
 		
 		//$n2.log('sourceModelUpdated',opts);

 		var contextsAdded = [];
 		var contextsUpdated = [];
 		var contextsRemoved = [];

 		if( opts.added ){
 			for(var i=0,e=opts.added.length; i<e; ++i){
 				var doc = opts.added[i];

 				var context = {
 					n2_id: doc._id
					,n2_doc: doc
					,fragments: []
 				};
 				contextsAdded.push(context);
 				
 				this.contextByDocId[doc._id] = context;
 			};
 		};

 		if( opts.updated ){
 			for(var i=0,e=opts.updated.length; i<e; ++i){
 				var doc = opts.updated[i];

 				var context = this.contextByDocId[doc._id];
 				if( context ){
					context.n2_doc = doc;
					contextsUpdated.push(context);
 					
 				} else {
 	 				var context = {
 	 					n2_id: doc._id
 						,n2_doc: doc
 						,fragments: []
 	 				};
 	 				contextsAdded.push(context);
 	 				
 	 				this.contextByDocId[doc._id] = context;
 				};
 			};
 		};

 		if( opts.removed ){
 			for(var i=0,e=opts.removed.length; i<e; ++i){
 				var doc = opts.removed[i];

 				var context = this.contextByDocId[doc._id];
 				if( context ){
 					delete this.contextByDocId[doc._id];
 					contextsRemoved.push(context);
 				};
 			};
 		};

 		// Before fragments and elements are created, update contexts with user
 		// intent
		if( contextsRemoved 
		 && contextsRemoved.length ){
			this.userIntentView.removeNodes(contextsRemoved);
		};
		if( contextsAdded 
		 && contextsAdded.length ){
			this.userIntentView.addNodes(contextsAdded);
		};

 		if( contextsAdded.length > 0 
 		 || contextsUpdated.length > 0 
 		 || contextsRemoved.length > 0 ){
 			this._contextsUpdated(contextsAdded, contextsUpdated, contextsRemoved);
 		};
 		
	},

	/*
	 * This method is called by the canvas to indicate that an element
	 * has been selected.
	 */
	selectOn: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);
			
			var docIds = [];
			var docs = [];
			for(var docId in docsById){
				var doc = docsById[docId];
				docIds.push(docId);
				docs.push(doc);
			};
			
			if( docIds.length < 1 ){
				this.dispatchService.send(DH,{
					type: 'userUnselect'
					,_source: this.eventSource
				});
			} else if( docIds.length == 1 ){
				this.dispatchService.send(DH,{
					type: 'userSelect'
					,docId: docIds[0]
					,doc: docs[0]
					,_source: this.eventSource
				});
			} else if( docIds.length > 1 ){
				this.dispatchService.send(DH,{
					type: 'userSelect'
					,docIds: docIds
					,docs: docs
					,_source: this.eventSource
				});
			};
		};
	},

	/*
	 * This method is called by the canvas to indicate that an element
	 * has been unselected.
	 */
	selectOff: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);

			for(var docId in docsById){
				var doc = docsById[docId];
				this.dispatchService.send(DH,{
					type: 'userUnselect'
					,docId: docId
					,doc: doc
					,_source: this.eventSource
				});
			};
		};
	},

	/*
	 * This method is called by the canvas to indicate that an element
	 * is hovered by the user (in focus).
	 */
	focusOn: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);
			
			var docIds = [];
			var docs = [];
			for(var docId in docsById){
				var doc = docsById[docId];
				docIds.push(docId);
				docs.push(doc);
			};
			
			if( docIds.length > 1 ){
				this.dispatchService.send(DH,{
					type: 'userFocusOn'
					,docIds: docIds
					,docs: docs
					,_source: this.eventSource
				});

			} else if( docIds.length > 0 ){
				this.dispatchService.send(DH,{
					type: 'userFocusOn'
					,docId: docIds[0]
					,doc: docs[0]
					,_source: this.eventSource
				});
			};
		};
	},

	/*
	 * This method is called by the canvas to indicate that an element
	 * is no longer hovered by the user (out of focus).
	 */
	focusOff: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);

			for(var docId in docsById){
				var doc = docsById[docId];
				this.dispatchService.send(DH,{
					type: 'userFocusOff'
					,docId: docId
					,doc: doc
					,_source: this.eventSource
				});
			};
		};
	},
	
	/*
	 * This gets called as a result of changes in the underlying documents. It
	 * recomputes the fragments from the documents.
	 */
	_contextsUpdated: function(contextsAdded, contextsUpdated, contextsRemoved){

		var fragmentsAdded = [];
		var fragmentsRemoved = [];
		
		if( contextsAdded || contextsUpdated ){
			var addedAndUpdated = [];
			if( contextsAdded ){
				addedAndUpdated.push.apply(addedAndUpdated, contextsAdded);
			};
			if( contextsUpdated ){
				addedAndUpdated.push.apply(addedAndUpdated, contextsUpdated);
			};
			
 			for(var i=0,e=addedAndUpdated.length; i<e; ++i){
 				var context = addedAndUpdated[i];

 				var previousFragments = context.fragments;
 				
 				for(var fragIndex=0; fragIndex<previousFragments.length; ++fragIndex){
 					var frag = previousFragments[fragIndex];
 					fragmentsRemoved.push(frag);
 				};

 				// _createFragmentsFromDoc() is implemented by all subclasses
 				context.fragments = this._createFragmentsFromDoc(context.n2_doc);
 				
 				for(var fragIndex=0; fragIndex<context.fragments.length; ++fragIndex){
 					var frag = context.fragments[fragIndex];
 					frag.context = context;
 					fragmentsAdded.push(frag);
 				};
 			};
 		};
 		
		if( contextsRemoved ){
 			for(var i=0,e=contextsRemoved.length; i<e; ++i){
 				var context = contextsRemoved[i];

 				var previousFragments = context.fragments;
 				
 				for(var fragIndex=0; fragIndex<previousFragments.length; ++fragIndex){
 					var frag = previousFragments[fragIndex];
 					fragmentsRemoved.push(frag);
 				};
 			};
		};

		for(var fragIndex=0; fragIndex<fragmentsRemoved.length; ++fragIndex){
			var frag = fragmentsRemoved[fragIndex];
			frag.context = null;
		};
		
		if( fragmentsAdded.length > 0 
		 || fragmentsRemoved.length > 0 ){
			this._fragmentsUpdated(fragmentsAdded, fragmentsRemoved);
		};
	},
	
	/**
	 * This method should be re-implemented by sub-classes to establish other representations.
	 * 
	 * This method is used to create a set of fragments given a document. A document can generate
	 * 0, 1 or multiple fragments. A fragment should have an id that differentiate it from
	 * all other fragments. It is a good idea to derive the fragment id from the document id
	 * to avoid collision.
	 * 
	 * A fragment created by this method should have at least the following properties:
	 * {
	 *    id : unique identifier for fragment
	 *    n2_id : document identifier for the supporting document
	 *    n2_doc : supporting document
	 * }
	 * 
	 * @param doc Object. Document that fragments should be generated from
	 * @return Array of fragments.
	 * 
	 */
	_createFragmentsFromDoc: function(doc){
		throw new Error('Sub-classes to ElementGenerator must implement _createFragmentsFromDoc()');
	},
	
	/*
	 * This function is called when the set of fragments have changed. This is
	 * ultimately due because of changes in the underlying documents.
	 */
	_fragmentsUpdated: function(fragmentsAdded, fragmentsRemoved){
		
		// Update fragment map
		for(var fragIndex=0; fragIndex<fragmentsRemoved.length; ++fragIndex){
			var frag = fragmentsRemoved[fragIndex];
			var fragId = frag.id;
			frag.elements = {};
			if( this.fragmentById[fragId] ){
				delete this.fragmentById[fragId];
			};
		};
		for(var fragIndex=0; fragIndex<fragmentsAdded.length; ++fragIndex){
			var frag = fragmentsAdded[fragIndex];
			var fragId = frag.id;
			this.fragmentById[fragId] = frag;
		};
		
		// Reset elements on fragments
		for(var fragId in this.fragmentById){
			var frag = this.fragmentById[fragId];
			frag.elements = {};
		};
		
		// Create elements from fragments
		var currentElementMap = {};
		for(var elementId in this.elementById){
			var element = this.elementById[elementId];
			currentElementMap[elementId] = element;
			
			// Remove previous fragments, we are about to get new ones
			element.fragments = {};
		};
		var newElementMap = this._updateElements(this.fragmentById, currentElementMap);
		
		// Assign elements to fragments
		for(var elementId in newElementMap){
			var element = newElementMap[elementId];

			for(var fragId in element.fragments){
				var frag = element.fragments[fragId];
				if( typeof frag.elements === 'undefined' ){
					$n2.log('Undefined elements');
				};
				frag.elements[elementId] = element;
			};
		};
		
		var elementsAdded = [];
		var elementsUpdated = [];
		var elementsRemoved = [];
		
		for(var elementId in this.elementById){
			if( typeof newElementMap[elementId] === 'undefined' ){
				elementsRemoved.push( this.elementById[elementId] );
			};
		};
		
		for(var elementId in newElementMap){
			if( typeof this.elementById[elementId] === 'undefined' ){
				elementsAdded.push( newElementMap[elementId] );
			} else {
				elementsUpdated.push( newElementMap[elementId] );
			};
		};
		
		this.elementById = newElementMap;
		
		// Fix style information
		for(var elementId in this.elementById){
			var element = this.elementById[elementId];
			this._adjustElementIntent(element);
		};
		
		//$n2.log('elementsChanged',elementsAdded, elementsUpdated, elementsRemoved);
		
		this.elementsChanged(elementsAdded, elementsUpdated, elementsRemoved);
	},
	
	/**
	 * This method takes a map of all fragments (fragments by identifier) and a map of
	 * the current elements (elements by identifier). Then, it computes a new set of elements 
	 * based on the fragments.
	 * 
	 * Each element created by this function should have at least the following properties:
	 * {
	 *    id : unique identifier for element
	 *    fragments : map of fragments, by fragment id, making up element
	 * }
	 *  
	 * Sub-classes should re-implement this method.
	 * 
	 * @param fragmentMap Dictionary of fragments, by fragment id
	 * @param currentElementMap Dictionary of current elements, by element id
	 * @return Dictionary of new elements, by element id
	 */
	_updateElements: function(fragmentMap, currentElementMap){
		if( typeof this._createClusters === 'function' ){
			// Support legacy implementations
			$n2.log('ElementGenerator._createClusters() is deprecated. Use _updateElements().');
			this.clusterById = currentElementMap;
			return this._createClusters(fragmentMap);
		};
		
		throw new Error('Subclasses of ElementGenerator should implement _updateElements()');
	},
	
	/*
	 * Given an element, re-compute the element's state based on the supporting
	 * contexts. By default, this method marks an element selected if any of its
	 * fragment is selected. The same is true with the hovered state.
	 * 
	 * As far as intents are concerned, the intent of a fragment is copied to the
	 * element unles it collides with a different fragment, at which point the result
	 * is null.
	 * 
	 * Sub-classes should re-implement this method if a different behaviour is required.
	 */
	_adjustElementIntent: function(element){
		element.n2_selected = false;
		element.n2_selectedIntent = undefined;
		element.n2_hovered = false;
		element.n2_hoveredIntent = undefined;
		element.n2_found = false;
		element.n2_intent = undefined;
		
		if( element.fragments ){
			for(var fragId in element.fragments){
				var fragment = element.fragments[fragId];
				var context = fragment.context;
				
				if( context ){
					if( context.n2_selected ){
						element.n2_selected = true;
					};
					if( context.n2_hovered ){
						element.n2_hovered = true;
					};
					if( context.n2_found ){
						element.n2_found = true;
					};
					if( context.n2_selectedIntent ){
						if( element.n2_selectedIntent === null ){
							// collision
						} else if( element.n2_selectedIntent === undefined ){
							element.n2_selectedIntent = context.n2_selectedIntent;
						} else {
							element.n2_selectedIntent = null;
						};
					};
					if( context.n2_hoveredIntent ){
						if( element.n2_hoveredIntent === null ){
							// collision
						} else if( element.n2_hoveredIntent === undefined ){
							element.n2_hoveredIntent = context.n2_hoveredIntent;
						} else {
							element.n2_hoveredIntent = null;
						};
					};
					if( context.n2_intent ){
						if( element.n2_intent === null ){
							// collision
						} else if( element.n2_intent === undefined ){
							element.n2_intent = context.n2_intent;
						} else {
							element.n2_intent = null;
						};
					};
				};
			};
		};
	},
	
	/*
	 * This method is called by the UserIntentView to notify changes
	 * in the user intent. The input array contains instances of context.
	 */
	_intentChangedContexts: function(changedContextNodes){
		// Accumulate all elements from document contexts
		var changedElementMap = {};
		for(var ci=0,ce=changedContextNodes.length; ci<ce; ++ci){
			var context = changedContextNodes[ci];
			for(var fi=0,fe=context.fragments.length; fi<fe; ++fi){
				var fragment = context.fragments[fi];
				if( fragment.elements ){
					for(var elementId in fragment.elements){
						var element = fragment.elements[elementId];
						changedElementMap[elementId] = element;
					};
				};
			};
		};

		// Adjust all intentions on elements
		var changedElements = [];
		for(var elementId in changedElementMap){
			var element = changedElementMap[elementId];
			this._adjustElementIntent(element);
			changedElements.push(element);
		};
		
		// Report changes
		if( changedElements.length ){
			this.intentChanged(changedElements);
		};
	},
	
	/*
	 * This function returns a map all the documents, indexed by document identifier,
	 * associated with an element.
	 */
	_docsFromElement: function(element_){
		var element = element_;
		if( typeof element === 'string' ){
			element = this.elementById[element];
		};

		var docsById = {};
		if( element && element.fragments ){
			for(var fragId in element.fragments){
				var fragment = element.fragments[fragId];
				var context = fragment.context;

				var doc = null;
				if( context ){
					doc = context.n2_doc;
				};
				
				var docId = null;
				if( doc ){
					docId = doc._id;
				};

				if( docId ){
					docsById[docId] = doc;
				};
			};
		};
		
		return docsById;
	}
});

//--------------------------------------------------------------------------
// This instance of ElementGenerator contribute the following attributes to the
// generated elements:
// {
//     isNode: Boolean. Set for documents
//     isLink: Boolean. Set for reference between two documents
//     n2_doc: Object. Copy of document for nodes
//     n2_geometry: String. Set to 'point' for nodes, and 'line' for reference
//     source: Object. Source element in case of a reference
//     target: Object. Target element in case of a reference
// }
var GenericElementGenerator = $n2.Class('GenericElementGenerator', ElementGenerator, {

	initialize: function(opts_){
		ElementGenerator.prototype.initialize.call(this, opts_);
	},
	
	/*
	 * This method is used to create a set of fragments given a document. The default
	 * implementation is to create a node for each document and a link for each reference
	 * to other document.
	 */
	_createFragmentsFromDoc: function(doc){
		var fragments = [];
		
		var node = {
			isNode: true
			,id: 'node_'+doc._id
			,n2_id: doc._id
			,n2_doc: doc
			,n2_geometry: 'point'
		};
		fragments.push(node);
		
 		// Create links for references
 		var refDocIds = {};
 		var references = [];
 		$n2.couchUtils.extractLinks(doc, references);
 		for(var i=0,e=references.length; i<e; ++i){
 			var ref = references[i];
 			if( ref.doc ){
 				refDocIds[ref.doc] = true;
 			};
 		};
 		for(var refDocId in refDocIds){
 			var link = {
 				isLink: true
 	 			,id: 'link_' + doc._id + '_' + refDocId
 	 			,n2_id: doc._id
 	 			,n2_doc: doc
 	 			,n2_geometry: 'line'
 			};
 			
 			var sourceId = doc._id;
 			var targetId = refDocId;

			link.sourceId = sourceId;
			link.targetId = targetId;

 			fragments.push(link);
 		};
 		
		return fragments;
	},

	/*
	 * This method takes a map of all fragments (fragments by identifier) and computes
	 * a set of elements based on the fragments.
	 * 
	 * By default, it creates one element for each fragment node. It also creates an element
	 * for each link where the source and target are present.
	 */
	_updateElements: function(fragmentMap, currentElementMap){
		var newElementMap = {};

		// Create nodes
		var nodeMap = {};
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isNode ){
				var element = currentElementMap[frag.id];
				if( !element ){
					element = {
						id: fragId
						,fragments: {}
					};
				};
				
				element.fragments[fragId] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'point';
				element.isLink = false;
				element.isNode = frag.isNode;
				
				newElementMap[element.id] = element;
				
				nodeMap[frag.context.n2_id] = element;
			};
		};

		// Create links
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isLink 
			 && nodeMap[frag.sourceId] 
			 && nodeMap[frag.targetId] ){
				var elementId = fragId;
				var element = currentElementMap[elementId];
				if( !element ){
					element = {
						id: elementId
						,fragments: {}
					};
				};
				
				element.fragments[frag.id] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'line';
				element.isLink = frag.isLink;
				element.isNode = false;
				element.source = nodeMap[frag.sourceId];
				element.target = nodeMap[frag.targetId];

				newElementMap[element.id] = element;
			};
		};

		return newElementMap;
	}
});

//--------------------------------------------------------------------------
// The elements generated by this instance of ElementGenerator are similar
// to the GenericElementGenerator. However, duplication of links (references
// between documents) are combined into one element.
//
// This instance of ElementGenerator contribute the following attributes to the
// generated elements:
// {
//   isNode: Boolean. Set for documents
//   isLink: Boolean. Set for reference between two documents
//   n2_doc: Object. Copy of document for nodes
//   n2_geometry: String. Set to 'point' for nodes, and 'line' for reference
//   source: Object. Source element in case of a reference
//   target: Object. Target element in case of a reference
//   count: Integer. For links, the number of links that have been merged
// }
var GroupLinks = $n2.Class('GroupLinks', GenericElementGenerator, {
	initialize: function(opts_){
		GenericElementGenerator.prototype.initialize.call(this, opts_);
	},
	
	_updateElements: function(fragmentMap, currentElementMap){
		var newElementMap = {};
		
		var nodeMap = {};
		var fragMap = {};
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isNode ){
				var element = currentElementMap[frag.id];
				if( !element ){
					element = {
						id: fragId
						,fragments: {}
					};
				};
				
				element.fragments[fragId] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'point';
				element.isLink = frag.isLink;
				element.isNode = frag.isNode;
				
				newElementMap[element.id] = element;
				
				nodeMap[frag.context.n2_id] = element;
				fragMap[frag.context.n2_id] = frag;
			};
		};

		var linkClustersById = {};
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isLink 
			 && nodeMap[frag.sourceId] 
			 && nodeMap[frag.targetId] ){
				var elementId = [frag.sourceId,frag.targetId].sort().join('|');
				var element = linkClustersById[elementId];
				if( !element ){
					element = currentElementMap[elementId];
				};
				if( !element ){
					element = {
						id: elementId
						,fragments: {}
						,count: 0
					};
				};
				newElementMap[elementId] = element;
				linkClustersById[elementId] = element;
				
				element.fragments[frag.id] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'line';
				element.isLink = frag.isLink;
				element.isNode = frag.isNode;
				element.count = element.count + 1;
				element.source = nodeMap[frag.sourceId];
				element.target = nodeMap[frag.targetId];
				
				// Associate the document node fragments with this element
				{
					var nodeFrag = fragMap[frag.sourceId]; 
					element.fragments[nodeFrag.id] = nodeFrag;
				};
				{
					var nodeFrag = fragMap[frag.targetId]; 
					element.fragments[nodeFrag.id] = nodeFrag;
				};
			};
		};

		return newElementMap;
	}
});

//--------------------------------------------------------------------------
var elementGeneratorFactoriesByType = {};

function AddElementGeneratorFactory(opts_){
	var opts = $n2.extend({
		type: null
		,factoryFn: null
	},opts_);
	
	var type = opts.type;
	var factoryFn = opts.factoryFn;
	
	if( typeof type === 'string' 
	 && typeof factoryFn === 'function' ){
		elementGeneratorFactoriesByType[type] = factoryFn;
		
	} else {
		$n2.log('Unable to register ElementGenerator factory: '+opts.type);
	};
};

function CreateElementGenerator(opts_){
	var opts = $n2.extend({
		type: null
		,options: null
		,config: null
	},opts_);
	
	var type = opts.type;
	var options = opts.options;
	var config = opts.config;
	
	var elementGenerator = null;
	
	// Default
	if( 'default' === type 
	 && config 
	 && config.directory 
	 && config.directory.dispatchService ){
		elementGenerator = new GenericElementGenerator({
			dispatchService: config.directory.dispatchService
			,options: options
		});
	};
	
	// GroupLinks
	if( !elementGenerator 
	 && 'GroupLinks' === type 
	 && config 
	 && config.directory 
	 && config.directory.dispatchService ){
		elementGenerator = new GroupLinks({
			dispatchService: config.directory.dispatchService
			,options: options
		});
	};

	// Custom
	if( !elementGenerator 
	 && elementGeneratorFactoriesByType[type]
	 && config ){
		var factoryFn = elementGeneratorFactoriesByType[type];
		elementGenerator = factoryFn({
			type: type
			,options: options
			,config: config
		});
	};
	
	// Fallback on default
	if( !elementGenerator 
	 && config 
	 && config.directory 
	 && config.directory.dispatchService ){
		
		$n2.log('Type of ElementGenerator not recognized: '+type);
		
		elementGenerator = new GenericElementGenerator({
			dispatchService: config.directory.dispatchService
			,options: options
		});
	};
	
	return elementGenerator;
};

//--------------------------------------------------------------------------
$n2.canvasElementGenerator = {
	CreateElementGenerator: CreateElementGenerator
	,AddElementGeneratorFactory: AddElementGeneratorFactory
	,ElementGenerator: ElementGenerator
	,GenericElementGenerator: GenericElementGenerator
	,GroupLinks: GroupLinks
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasForceGraph.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.forceGraph'
 ;
 
// Required library: d3
var $d = window.d3;
if( !$d ) return;
 
//--------------------------------------------------------------------------
 var Popup = $n2.Class({
 	
 	showService: null,
 	
 	delay: null,
 	
 	initialize: function(opts_){
 		var opts = $n2.extend({
 			showService: null
 			,delay: null
 		},opts_);
 		
 		this.showService = opts.showService;
 		this.delay = opts.delay;
 		
 		if( $.fn.qtip ){
 			// OK
 		} else {
 			throw 'qTip2 library is not available';
 		};
 	},
 	
 	installPopup: function(domElem, doc){
 		var _this = this;
 		
 		var $elem = $(domElem);
 		
 		var qtipOptions = {
 			content:{
 				text: function(event, api){
 					var html = null;
 					
 					_this._generateHtml(doc,function(h){
 						if( html ){
 							// already returned
 							api.set('content.text',h);
 						};
 						html = h;
 					});
 					
 					if( !html ){
 						html = '<div class="olkit_wait"></div>';
 					};
 					
 					return html;
 				}
 			}
 		};
 		
 		if( this.delay ){
 			qtipOptions.content.delay = this.delay;
 		};
 		
 		$elem.qtip(qtipOptions);
 	},
 	
 	_generateHtml: function(doc, cb){
 		var $outer = $('<div>');
 		var $elem = $('<span class="n2_popup">')
 			.appendTo($outer);
 		this.showService.displayBriefDescription($elem, {}, doc);
 		var html = $outer.html();
 		cb(html);
 	}
 });
 
 //--------------------------------------------------------------------------
 var SettingsWidget = $n2.Class({
 	
 	elemId: null,
 	
 	modelId: null,
 	
 	dispatchService: null,
 	
 	parameters: null,
 	
 	parametersByEventId: null,
 	
 	addresses: null,
 	
 	initialize: function(opts_){
 		var opts = $n2.extend({
 			modelId: null
 			,dispatchService: null
 			,elemId: null
 			,style: null
 		},opts_);
 		
 		var _this = this;
 		
 		this.modelId = opts.modelId;
 		this.dispatchService = opts.dispatchService;
 		this.parameters = [];
 		this.parametersByEventId = {};
 		this.addresses = [];
 		
 		var modelInfo = null;
 		if( this.dispatchService ){
 			var m = {
 				type: 'modelGetInfo'
 				,modelId: this.modelId
 				,modelInfo: null
 			};
 			this.dispatchService.synchronousCall(DH, m);
 			modelInfo = m.modelInfo;
 		};
 		
 		var handleFn = function(m, addr, dispatcher){
 			_this._handle(m, addr, dispatcher);
 		};
 		
 		if( modelInfo && modelInfo.parameters ){
 			for(var paramKey in modelInfo.parameters){
 				var paramInfo = modelInfo.parameters[paramKey];
 				this.parameters.push(paramInfo);
 				if( paramInfo.setEvent ){
 					this.parametersByEventId[paramInfo.setEvent] = paramInfo;
 				};
 				if( paramInfo.changeEvent ){
 					this.parametersByEventId[paramInfo.changeEvent] = paramInfo;
 					var addr = this.dispatchService.register(DH, paramInfo.changeEvent, handleFn);
 					this.addresses.push(addr);
 				};
 				if( paramInfo.getEvent ){
 					this.parametersByEventId[paramInfo.getEvent] = paramInfo;
 				};
 			};
 		};
 		
 		if( this.parameters.length > 0 ){
 			this.elemId = $n2.getUniqueId();
 			var $outer = $('<div>')
 				.attr('id',this.elemId)
 				.addClass('n2ForceGraph_settings')
 				.appendTo( $('#'+opts.elemId) );
 			
 			if( opts.style ){
 				for(var name in opts.style){
 					var value = opts.style[name];
 					if( value ){
 						$outer.css(name,value);
 					};
 				};
 			};
 			
 			$('<div>')
 				.addClass('n2ForceGraph_settings_button')
 				.appendTo($outer).
 				click(function(){
 					_this._togglePanel();
 				});
 			
 			$('<div>')
 				.addClass('n2ForceGraph_settings_panel')
 				.appendTo($outer);
 			
 			this._hidePanel();
 			
 			this._refresh();
 		};
 	},
 	
 	_refresh: function(){
 		var $elem = this._getElem();
 		var $panel = $elem.find('.n2ForceGraph_settings_panel');
 		$panel.empty();
 		
 		for(var i=0,e=this.parameters.length; i<e; ++i){
 			var parameterInfo = this.parameters[i];
 			this._addParameter($panel, parameterInfo);
 		};
 	},
 	
 	_addParameter: function($elem, parameterInfo){
 		var _this = this;
 		var inputId = $n2.getUniqueId();
 		var $div = $('<div>')
 			.addClass('n2ForceGraph_settings_line')
 			.appendTo($elem);
 		
 		// Obtain current value
 		var m = {
 			type: parameterInfo.getEvent
 			,parameterId: parameterInfo.id
 		};
 		this.dispatchService.synchronousCall(DH, m);
 		var value = m.value;
 		
 		if( parameterInfo.type === 'boolean' ){
 			// Checkbox
 			var $inputDiv = $('<div>')
 				.addClass('n2ForceGraph_settings_line_input')
 				.appendTo($div);
 			var $input = $('<input>')
 				.attr('type','checkbox')
 				.attr('id',inputId)
 				.appendTo($inputDiv)
 				.change(function(){
 					var selected = $('#'+inputId).is(':checked');
 					var m = {
 						type: parameterInfo.setEvent
 						,parameterId: parameterInfo.id
 						,value: selected
 					};
 					_this.dispatchService.send(DH, m);
 				});
 			if( value ){
 				$input.attr('checked','checked');
 			};
 		};
 		
 		// Label
 		var label = _loc(parameterInfo.label);
 		var $labelDiv = $('<div>')
 			.addClass('n2ForceGraph_settings_line_label')
 			.appendTo($div);
 		$('<label>')
 			.attr('for',inputId)
 			.text(label)
 			.appendTo($labelDiv);
 	},
 	
 	_togglePanel: function(){
 		var $elem = this._getElem();
 		var $panel = $elem.find('.n2ForceGraph_settings_panel');
 		
 		if( $panel.hasClass('n2ForceGraph_settings_panel_on') ){
 			this._hidePanel();
 		} else {
 			this._showPanel();
 		};
 	},
 	
 	_showPanel: function(){
 		var $elem = this._getElem();
 		var $panel = $elem.find('.n2ForceGraph_settings_panel');
 		$panel.removeClass('n2ForceGraph_settings_panel_off');
 		$panel.addClass('n2ForceGraph_settings_panel_on');
 	},
 	
 	_hidePanel: function(){
 		var $elem = this._getElem();
 		var $panel = $elem.find('.n2ForceGraph_settings_panel');
 		$panel.removeClass('n2ForceGraph_settings_panel_on');
 		$panel.addClass('n2ForceGraph_settings_panel_off');
 	},
 	
 	_getElem: function(){
 		return $('#'+this.elemId);
 	},
 	
 	_handle: function(m, addr, dispatcher){
 		// Check if widget was removed
 		var $elem = this._getElem();
 		if( $elem.length < 1 ){
 			// De-register events
 			for(var i=0,e=this.addresses.length; i<e; ++i){
 				var address = this.addresses[i];
 				dispatcher.deregister(address);
 			};
 			this.addresses = [];
 			return;
 		};
 		
 		this._refresh();
 	}
 });

 //--------------------------------------------------------------------------
 var ModelParameter = $n2.Class({

 	model: null,

 	modelId: null,

 	parameterId: null,
 	
 	name: null,
 	
 	label: null,
 	
 	updateFn: null,
 	
 	dispatchService: null,
 	
 	eventNameSet: null,
 	
 	eventNameGet: null,
 	
 	eventNameChange: null,
 	
 	initialize: function(opts_){
 		var opts = $n2.extend({
 			model: null
 			,modelId: null // optional
 			,name: null
 			,label: null
 			,updateFn: null
 			,dispatchService: null
 		},opts_);
 		
 		var _this = this;
 		
 		this.model = opts.model;
 		this.modelId = opts.modelId;
 		this.name = opts.name;
 		this.label = opts.label;
 		this.updateFn = opts.updateFn;
 		this.dispatchService = opts.dispatchService;
 		
 		if( !this.modelId ){
 			this.modelId = $n2.getUniqueId('parameter_');
 		};
 		
 		if( !this.label ){
 			this.label = this.name;
 		};
 		
 		this.parameterId = this.modelId + '_' + this.name;
 		this.eventNameSet = this.parameterId + '_set';
 		this.eventNameGet = this.parameterId + '_get';
 		this.eventNameChange = this.parameterId + '_change';
 		
 		if( this.dispatchService ){
 			var fn = function(m, addr, dispatcher){
 				_this._handle(m, addr, dispatcher);
 			};
 			this.dispatchService.register(DH, this.eventNameSet, fn);
 			this.dispatchService.register(DH, this.eventNameGet, fn);
 		};
 	},
 	
 	getInfo: function(){
 		var info = {
 			parameterId: this.parameterId
 			,type: 'boolean'
 			,name: this.name
 			,label: this.label
 			,setEvent: this.eventNameSet
 			,getEvent: this.eventNameGet
 			,changeEvent: this.eventNameChange
 		};
 		
 		var effectiveValue = this.model[this.name];
 		info.value = effectiveValue;
 		
 		return info;
 	},
 	
 	_handle: function(m, addr, dispatcher){
 		if( m.type === this.eventNameSet ){
 			var value = m.value;
 			
 			this.model[this.name] = value;
 			if( this.updateFn ){
 				this.updateFn.call(this.model, this.name, value);
 			};
 			
 			var effectiveValue = this.model[this.name];
 			var reply = {
 				type: this.eventNameChange
 				,parameterId: this.parameterId
 				,value: effectiveValue
 			};
 			this.dispatchService.send(DH, reply);
 			
 		} else if( m.type === this.eventNameGet ){
 			var effectiveValue = this.model[this.name];
 			m.value = effectiveValue;
 		};
 	}
 });
 
// --------------------------------------------------------------------------
// This is a canvas that show nodes and links using a force graph layout. This canvas
// expects elements with the following format:
// {
//    id: <string> Required. Identifier that uniquely identifies the node or the link
//    isNode: <boolean> Set if this element is a node
//    isLink: <boolean> Set if this element is a link between two nodes
//    source: <object> Required for links. Node that is one end of the link
//    target: <object> Required for links. Node that is the other end of the link
// }
//
// The following attributes are added to the elements by the force graph canvas
// x: <number> X position. Added only to nodes.
// y: <number> Y position. Added only to nodes.
//
var ForceGraph = $n2.Class({

 	canvasId: null,
 	
 	interactionId: null,
 	
 	svgId: null,
 	
 	modelId: null,
 	
 	dispatchService: null,

 	showService: null,
 	
 	sourceModelId: null,
 	
 	svgRenderer: null,
 	
 	background: null,
 	
 	forceOptions: null,
 	
 	forceLayout: null,
 	
 	styleRules: null,
 	
 	popup: null,
 	
 	nodesById: null,
 	
 	linksById: null,
 	
 	elementsByDocId: null,
 	
 	elementGenerator: null,
 	
 	currentMouseOver: null,
 	
 	lastElementIdSelected: null,
 	
 	sticky: null,
 	
 	initialize: function(opts_){
 		var opts = $n2.extend({
 			canvasId: null
 			,interactionId: null
 			,config: null
 			,moduleDisplay: null
 			,sourceModelId: null
 			,background: null
 			,force: {}
 			,popup: null
 			,styleRules: null
 			,toggleSelection: true
			,elementGeneratorType: 'default'
			,elementGeneratorOptions: null
			,elementGenerator: null
 			,onSuccess: function(){}
 			,onError: function(err){}
 		},opts_);
 		
 		var _this = this;
 	
 		this.canvasId = opts.canvasId;
 		this.interactionId = opts.interactionId;
 		this.sourceModelId = opts.sourceModelId;
 		this.background = opts.background;
 		this.toggleSelection = opts.toggleSelection;
 		this.elementGenerator = opts.elementGenerator;
 		
 		this.modelId = $n2.getUniqueId('forceGraph');
 		
 		this.forceOptions = $n2.extend({
 			gravity: 0.1
 			,friction: 0.9
 			,theta: 0.8
 			,charge: -30
 			,chargeDistance: null
 			,linkDistance: 30
 			,linkStrength: 1
 		},opts.force);
 		
 		this.styleRules = $n2.styleRule.loadRulesFromObject(opts.styleRules);
 		
 		var config = opts.config;
 		if( config ){
 			if( config.directory ){
 				this.dispatchService = config.directory.dispatchService;
 				this.showService = config.directory.showService;
 			};
 		};
 		
 		try {
	 		if( opts.popup && this.showService ){
	 			var popupOptions = $n2.extend({
	 					delay: null
	 				}
	 				,opts.popup
	 				,{
	 					showService: this.showService
	 				}
	 			);
	 			this.popup = new Popup(popupOptions);
	 		};
 		} catch(err) {
 			$n2.log('ForceGraph can not install popup: '+err);
 		};

 		// Sticky parameter
 		this.sticky = false;
 		this.stickyParameter = new ModelParameter({
 			model: this
 			,modelId: this.modelId
 			,name: 'sticky'
 			,label: _loc('Sticky Nodes')
 			,updateFn: this._updateParameter
 			,dispatchService: this.dispatchService
 		});

 		this.nodesById = {};
 		this.linksById = {};
 		this.elementsByDocId = {};
 		this.currentMouseOver = null;
 		this.lastElementIdSelected = null;

 		// Element generator
 		if( !this.elementGenerator ){
 			// If not defined, use the one specified by type
 	 		this.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: opts.elementGeneratorType
 	 			,options: opts.elementGeneratorOptions
 	 			,config: opts.config
 	 		});
 		};
 		if( this.elementGenerator ){
			this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
				_this._elementsChanged(added, updated, removed);
			});
			this.elementGenerator.setIntentChangedListener(function(updated){
				_this._intentChanged(updated);
			});
 		};
 		
 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m){
 				_this._handleDispatch(m);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 			this.dispatchService.register(DH,'windowResized',f);
 			this.dispatchService.register(DH,'findIsAvailable',f);
 		};
 		
 		this.forceLayout = $d.layout.force()
 			.gravity(this.forceOptions.gravity)
 			.friction(this.forceOptions.friction)
 			.theta(this.forceOptions.theta)
 			.charge(this.forceOptions.charge)
 			.linkDistance(this.forceOptions.linkDistance)
 			.linkStrength(this.forceOptions.linkStrength)
 			;
 		if( this.forceOptions.chargeDistance ){
 			this.forceLayout.chargeDistance(this.forceOptions.chargeDistance);
 		};
 		this.forceLayout.drag()
 			.on('dragstart',function(d){
 				if( _this.sticky ){
 					d.fixed = true;
 				};
 			});
 		
 		this.createGraph();
 		
 		opts.onSuccess();

 		if( this.sourceModelId ){
 			if( this.dispatchService ){
 				var msg = {
 					type: 'modelGetState'
 					,modelId: this.sourceModelId
 					,state: null
 				};
 				this.dispatchService.synchronousCall(DH,msg);
 				if( msg.state ){
 					this._dbPerspectiveUpdated(msg.state);
 				};
 			};
 		};

 		// Setting widget
 		var settingWidget = new SettingsWidget({
 			modelId: this.modelId
 			,dispatchService: this.dispatchService
 			,elemId: this.canvasId
 			,style: null
 		});
 		
 		$n2.log('forceGraph',this);
 		$n2.log('settingWidget',settingWidget);
 	},
 	
 	createGraph: function() {
 		var _this = this; // for use in callbacks

 		this.svgId = $n2.getUniqueId();
 		var $svg = $d.select('#' + this.canvasId)
 			.append('svg')
 			.attr('id',this.svgId)
 			.classed({
 				'n2CanvasForceGraph': true
 			})
 			;
 		
 		var $background = $svg.append('rect')
 			.attr({
 				x: '0'
 				,y:'0'
 			})
 			.classed({
 				'n2CanvasForceGraph_background': true
 			})
 			.on('click', function(){
	 			_this._backgroundClicked();
	 		});
 		if( this.background 
 		 && typeof this.background === 'object' ){
 			var allowedAttributes = $n2.svg.presentationAttributeMap;
 			for(var key in this.background){
 				if( typeof key === 'string' 
 				 && allowedAttributes[key] ){
 	 				var value = this.background[key];
 	 				if( typeof value === 'string' ){
 	 					$background.attr(key,value);
 	 				} else if( typeof value === 'number' ){
 	 					$background.attr(key,value);
 	 				};
 				};
 			};
 		} else {
 			$background.attr({
 				'stroke-opacity': 0
 	 			,'fill-opacity': 0
 			});
 		};

 		$svg.append('g')
 			.attr('class','links');

 		$svg.append('g')
 			.attr('class','nodes');
 		
 		$svg.append('g')
			.attr('class','labels');
		
 		this.svgRenderer = new $n2.svg.Renderer({
 			svgElem: $svg[0][0]
 		});
 		//this.svgRenderer._importGraphic('star');
 		
 		this.resizeGraph();

 		// Report canvas
 		if( this.dispatchService ){
 			this.dispatchService.send(DH,{
 				type: 'canvasForceGraphReportCanvas'
 				,svg: $svg
 			});
 		};
 	},
 	
 	getGraphSize: function() {
 		var $canvas = $('#' + this.canvasId);
 		
 		var width = $canvas.width();
 		var height = $canvas.height();
 		
 		/*
 		 * apply minimum sizes
 		 */
// 		if (width < this.options.sizes.canvas_min.width) {
// 			width = this.options.sizes.canvas_min.width;
// 		};
// 		if (height < this.options.sizes.canvas_min.height) {
// 			height = this.options.sizes.canvas_min.height;
// 		};
 		return [width, height];
 	},
 	
 	resizeGraph: function() {
 		var size = this.getGraphSize();
 		
 		this.forceLayout.size([size[0], size[1]]).start();
 		
 		var $svg = this._getSvgElem()
 			.attr({
 				width: size[0]
				,height: size[1]
 			});
 		
 		var $background = $svg.select('.n2CanvasForceGraph_background')
 			.attr({
 				width: size[0]
				,height: size[1]
 			});
 	},
 	
 	_getSvgElem: function() {
 		return $d.select('#' + this.svgId);
 	},
	
 	_elementsChanged: function(addedElements, updatedElements, removedElements){
		// Remove elements that are no longer there
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removed = removedElements[i];
			
			if( removed.isNode ){
				delete this.nodesById[ removed.id ];
			} else if( removed.isLink ){
				delete this.linksById[ removed.id ];
			};
		};
		
		// Add elements
		for(var i=0,e=addedElements.length; i<e; ++i){
			var added = addedElements[i];
			
			if( added.isNode ){
				this.nodesById[ added.id ] = added;
			} else if( added.isLink ){
				this.linksById[ added.id ] = added;
			};
		};

		// Updated nodes
		var updatedNodes = [];
		var updatedLinks = [];
		for(var i=0,e=updatedElements.length; i<e; ++i){
			var updated = updatedElements[i];
			
			if( updated.isNode ){
				updatedNodes.push(updated);
			} else if( updated.isLink ){
				updatedLinks.push(updated);
			};
		};
		
		// Update elements by doc id map
 		this.elementsByDocId = {};
 		for(var id in this.nodesById){
 			var element = this.nodesById[id];
			if( element.fragments ){
				for(var fragId in element.fragments){
					var frag = element.fragments[fragId];
					
					var context = frag.context;
					if( context ){
						var doc = context.n2_doc;
						if( doc ){
							var docId = doc._id;
							
							var elements = this.elementsByDocId[docId];
							if( !elements ){
								elements = [];
								this.elementsByDocId[docId] = elements;
							};
							elements.push(element);
						};
					};
				};
			};
 		};
 		for(var id in this.linksById){
 			var element = this.linksById[id];
			if( element.fragments ){
				for(var fragId in element.fragments){
					var frag = element.fragments[fragId];
					
					var context = frag.context;
					if( context ){
						var doc = context.n2_doc;
						if( doc ){
							var docId = doc._id;
							
							var elements = this.elementsByDocId[docId];
							if( !elements ){
								elements = [];
								this.elementsByDocId[docId] = elements;
							};
							elements.push(element);
						};
					};
				};
			};
 		};
		
		this._documentsUpdated(updatedNodes, updatedLinks);
		
		this.dispatchService.send(DH,{
			type: 'findAvailabilityChanged'
		});
 	},
 	
	_intentChanged: function(changedNodes){
 		// Segregate nodes and active links
 		var nodes = [];
 		var links = [];
 		var restart = false;
 		for(var i=0,e=changedNodes.length; i<e; ++i){
 			var changedNode = changedNodes[i];
 			
 			// $n2.log(changedNode.n2_id+' sel:'+changedNode.n2_selected+' foc:'+changedNode.n2_hovered+' find:'+changedNode.n2_found);
 			
 			if( changedNode.isNode ){
 				nodes.push(changedNode);
 				
 				if( changedNode.n2_found 
 				 && !changedNode.forceFound ){
 					restart = true;
 					changedNode.forceFound = true;

 				} else if( !changedNode.n2_found 
 				 && changedNode.forceFound ){
 					changedNode.forceFound = false;
 				};
 				
 			} else if( changedNode.isLink ){
 				links.push(changedNode);
 			};
 		};

 		// Update style on nodes
 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(nodes, function(node){ return node.id; });
 		this._adjustElementStyles(selectedNodes);

 		// Update style on links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(links, function(link){ return link.id; });
 		this._adjustElementStyles(selectedLinks, true);

 		// Update style on labels
 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
 			.data(nodes, function(node){ return node.id; });
 		this._adjustElementStyles(selectedLabels);
 		
 		if( restart ){
 			this.forceLayout.start();
 		};
	},
 	
 	_documentsUpdated: function(updatedNodeData, updatedLinkData){
 		var _this = this;
 		
 		var nodes = [];
 		for(var elementId in this.nodesById){
 			var node = this.nodesById[elementId];
 			nodes.push(node);
 		};

 		var links = [];
 		for(var elementId in this.linksById){
 			var link = this.linksById[elementId];
 			links.push(link);
 		};

 		this.forceLayout
 			.nodes(nodes)
 			.links(links)
 			.start();

 		// NODES
 		
 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(nodes, function(node){ return node.id; });
 		
 		var createdNodes = selectedNodes.enter()
 			.append(function(){
 				var args = arguments;
 				return this.ownerDocument.createElementNS(this.namespaceURI, "circle");
 			})
 			.attr('class','node')
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			.call(this.forceLayout.drag)
 			.each(function(datum,i){
 				if( _this.popup && datum.n2_doc ){
 					_this.popup.installPopup(this,datum.n2_doc);
 				};
 			})
 			;
 		this._adjustElementStyles(createdNodes);
 		
 		selectedNodes.exit()
 			.remove();
 		
 		var updatedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(updatedNodeData, function(node){ return node.id; });
 		this._adjustElementStyles(updatedNodes);

 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(links, function(link){ return link.id; });

 		// LINKS
 		
 		var createdLinks = selectedLinks.enter()
 			.append('path')
 			.attr('class','link')
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdLinks, true);
 		
 		selectedLinks.exit()
 			.remove();
 		
 		var updatedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(updatedLinkData, function(link){ return link.id; });
 		this._adjustElementStyles(updatedLinks, true);

 		// LABELS
 		
 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(nodes, function(node){ return node.id; });
		
		var createdLabels = selectedLabels.enter()
			.append(function(){
				var args = arguments;
				return this.ownerDocument.createElementNS(this.namespaceURI, "text");
			})
			.attr('class','label')
			.on('click', function(n,i){
				_this._initiateMouseClick(n);
			})
			.on('mouseover', function(n,i){
				_this._initiateMouseOver(n);
			})
			.on('mouseout', function(n,i){
				_this._initiateMouseOut(n);
			})
			.call(this.forceLayout.drag)
			.each(function(datum,i){
				if( _this.popup && datum.n2_doc ){
					_this.popup.installPopup(this,datum.n2_doc);
				};
			})
			;
		this._adjustElementStyles(createdLabels);
		
		selectedLabels.exit()
			.remove();
		
		var updatedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(updatedNodeData, function(node){ return node.id; });
		this._adjustElementStyles(updatedLabels);

		// Animate force graph
		
 		this.forceLayout.on('tick', function(e) {

 			// Deal with find event
 			var width = $('#' + _this.canvasId).width();
 			var height = $('#' + _this.canvasId).height();
 			var midX = width / 2;
 			var midY = height / 2;
 			selectedNodes.each(function(n,i){
 				if( n.n2_found ){
 					if( n.x > midX ){
 						var k = (n.x - midX) / 2;
 						n.x -= k;
 					} else {
 						var k = (midX - n.x) / 2;
 						n.x += k;
 					};
 					if( n.y > midY ){
 						var k = (n.y - midY) / 2;
 						n.y -= k;
 					} else {
 						var k = (midY - n.y) / 2;
 						n.y += k;
 					};
 				};
 			});
 			
 			selectedNodes
 				.attr('cx', function(d) { return d.x; })
 				.attr('cy', function(d) { return d.y; });
 			
 			selectedLinks
 				.attr('d', function(d){
 					if( typeof d.pathFn === 'function' ){
 						return d.pathFn(d, d.source, d.target);
 					} else {
 	 					var path = [
		 					'M', d.source.x, ' ', d.source.y,
		 					' L ', d.target.x, ' ', d.target.y
	 					].join('');
	 					return path;
 					};
 				});		

 			selectedLabels
				.attr('x', function(d) { return d.x; })
				.attr('y', function(d) { return d.y; });
 		});
 	},
 	
 	_adjustElementStyles: function(selectedElements, isLine){
 		var _this = this;
 		selectedElements.each(function(n,i){
 			n.n2_elem = this;
 			var symbolizer = _this.styleRules.getSymbolizer(n);
 			symbolizer.adjustSvgElement(this,n);
 			delete n.n2_elem;
 		});
 		
 		if( isLine ){
 			selectedElements.attr('fill','none');
 		};
 	},
 	
 	_dispatch: function(m){
 		var d = this.dispatchService;
 		if( d ){
 			d.send(DH,m);
 		};
 	},
 	
 	_dbPerspectiveUpdated: function(opts_){
 		this.elementGenerator.sourceModelUpdated(opts_);
 	},
 	
 	_initiateMouseClick: function(elementData){
 		var elementId = elementData.id;
 		if( this.toggleSelection 
 		 && this.lastElementIdSelected === elementId ){
 			this.elementGenerator.selectOff(elementData);
 			this.lastElementIdSelected = null;
 		} else {
 			this.elementGenerator.selectOn(elementData);
 			this.lastElementIdSelected = elementId;
 		};
 	},
 	
 	_initiateMouseOver: function(elementData){
 		var elementId = elementData.id;
 		if( elementId !== this.currentMouseOver ){
 			// Focus Off before Focus On
 			if( this.currentMouseOver ){
 	 			this.elementGenerator.focusOff(this.currentMouseOver);
 				this.currentMouseOver = null;
 			};
 			
 			this.elementGenerator.focusOn(elementData);
 			this.currentMouseOver = elementId;
 		};
 	},
 	
 	_initiateMouseOut: function(elementData){
 		var elementId = elementData.id;
 		if( elementId === this.currentMouseOver ){
 			this.elementGenerator.focusOff(elementData);
			this.currentMouseOver = null;
 		};
 	},
 	
 	_backgroundClicked: function(){
 		this._dispatch({
 			type: 'userUnselect'
 		});
 	},
 	
 	_handleDispatch: function(m){
 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._dbPerspectiveUpdated(m.state);
 				};
 			};

 		} else if( 'windowResized' === m.type ) {
 			this.resizeGraph();

 		} else if( 'findIsAvailable' === m.type ) {
 			var docId = m.docId;
 			if( docId 
 			 && this.elementsByDocId[docId] 
 			 && this.elementsByDocId[docId].length ){
 				m.isAvailable = true;
 			};
 		};
 	},
 	
 	_getModelInfo: function(){
 		var info = {
 			modelId: this.modelId
 			,modelType: 'obi_force_graph'
 			,parameters: []
 		};
 		
 		info.parameters.push( this.stickyParameter.getInfo() );
 		
 		return info;
 	},
 	
 	_updateParameter: function(paramName, paramValue){
 		if( 'sticky' === paramName ){
 			if( !paramValue ){
 				var restart = false;
 				for(var docId in this.nodesById){
 					var node = this.nodesById[docId];
 					if( node.fixed ){
 						node.fixed = false;
 						restart = true;
 					};
 				};

 				if( restart ){
 					this.forceLayout.start();
 				};
 			};
 		};
 	}
 });
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	if( m.canvasType === 'forceGraph' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'forceGraph' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new ForceGraph(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasForceGraph = {
	ForceGraph: ForceGraph
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasRadial.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.radialCanvas'
 ;
 
// Required library: d3
var $d = window.d3;
if( !$d ) return;

//--------------------------------------------------------------------------
// Fish eye distortion
function RadialFishEye(){
	var radius = 10,
		distortion = 2,
		k0,
		k1,
		focusAngle = null,
		angleAttribute = 'x';
	
	function fisheye(d) {
		var pointAngle = d[angleAttribute];
		
		if( null === focusAngle ){
			return {x: pointAngle, z: 1};

		} else {
			var dx = pointAngle - focusAngle;
			
			if( dx > 180 ) dx -= 360;
			if( dx < -180 ) dx += 360;
			
			var dd = Math.sqrt(dx * dx);
			if (!dd || dd >= radius) return {x: pointAngle, z: 1};
			var k = k0 * (1 - Math.exp(-dd * k1)) / dd * .75 + .25;
			
			var effAngle = focusAngle + (dx * k);
			if( effAngle < 0 ) effAngle += 360;
			if( effAngle > 360 ) effAngle -= 360;
			
			return {
				x: effAngle
				,z: Math.min(k, 10)
			};
		};
 	}

	function rescale() {
		k0 = Math.exp(distortion);
		k0 = k0 / (k0 - 1) * radius;
		k1 = distortion / radius;
		return fisheye;
	}

	fisheye.radius = function(_) {
		if (!arguments.length) return radius;
		radius = +_;
		return rescale();
	};

	fisheye.distortion = function(_) {
		if (!arguments.length) return distortion;
		distortion = +_;
		return rescale();
	};

	fisheye.angle = function(_) {
		if (!arguments.length) return focusAngle;
		focusAngle = _;
		return fisheye;
	};

	fisheye.angleAttribute = function(_) {
		if (!arguments.length) return angleAttribute;
		angleAttribute = _;
		return fisheye;
	};
	
	rescale();
	
	return fisheye;
};

// --------------------------------------------------------------------------
var RadialCanvas = $n2.Class({

	canvasId: null,
 	
	interactionId: null,
 	
	svgId: null,
 	
	modelId: null,
 	
	dispatchService: null,

	sourceModelId: null,
 	
	moduleDisplay: null,
 	
	background: null,
	
	toggleSelection: null,
	
	line: null,
	
	magnify: null,
	
	magnifyThresholdCount: null,
 	
	styleRules: null,

	nodesById: null,
	
	sortedNodes: null,

	linksById: null,
	
	elementGenerator: null,
 	
	currentMouseOver: null,

	lastElementIdSelected: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,interactionId: null
			,config: null
			,moduleDisplay: null
			,sourceModelId: null
			,background: null
			,magnify: null
			,styleRules: null
			,toggleSelection: true
			,elementGeneratorType: 'default'
			,elementGeneratorOptions: null
			,elementGenerator: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
 	
		this.canvasId = opts.canvasId;
		this.interactionId = opts.interactionId;
		this.moduleDisplay = opts.moduleDisplay;
		this.sourceModelId = opts.sourceModelId;
		this.background = opts.background;
		this.toggleSelection = opts.toggleSelection;
		this.elementGenerator = opts.elementGenerator;
 		
		this.modelId = $n2.getUniqueId('radialCanvas');
 		
		this.styleRules = $n2.styleRule.loadRulesFromObject(opts.styleRules);
 		
		var config = opts.config;
		if( config ){
			if( config.directory ){
				this.dispatchService = config.directory.dispatchService;
			};
		};

 		this.nodesById = {};
 		this.sortedNodes = [];
 		this.linksById = {};
 		this.currentMouseOver = null;
 		this.lastElementIdSelected = null;
 		this.focusInfo = null;
 		this.selectInfo = null;
 		this.magnifyThresholdCount = null;

 		// Element generator
 		if( !this.elementGenerator ){
 			// If not defined, use the one specified by type
 	 		this.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: opts.elementGeneratorType
 	 			,options: opts.elementGeneratorOptions
 	 			,config: opts.config
 	 		});
 		};
 		if( this.elementGenerator ){
			this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
				_this._elementsChanged(added, updated, removed);
			});
			this.elementGenerator.setIntentChangedListener(function(updated){
				_this._intentChanged(updated);
			});
 		};
 		
 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m){
 				_this._handleDispatch(m);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 		};
 		
 		this.line = d3.svg.line.radial()
	 	    //.interpolate("bundle")
 			.interpolate("basis")
	 	    .tension(.85)
	 	    .radius(function(d) { return d.y; })
	 	    .angle(function(d) { return d.x / 180 * Math.PI; });
 		
 		// Set-up magnification
 		var magnifyOptions = $n2.extend({
 			radius: 10
 			,distortion: 2
 			,thresholdCount: 120
 		},opts.magnify);
 		this.magnify = RadialFishEye()
			.angleAttribute('orig_x')
 			;
 		for(var optionName in magnifyOptions){
 			var value = magnifyOptions[optionName];
 			
 			if( 'radius' === optionName 
 			 && typeof value === 'number' ){
 				this.magnify.radius(value);
 			};

 			if( 'distortion' === optionName 
 			 && typeof value === 'number' ){
 				this.magnify.distortion(value);
 			};

 			if( 'thresholdCount' === optionName 
 			 && typeof value === 'number' ){
 				this.magnifyThresholdCount = value;
 			};
 		};
 		
 		this.createGraph();
 		
 		opts.onSuccess();

 		if( this.sourceModelId ){
 			if( this.dispatchService ){
 				var msg = {
 					type: 'modelGetState'
 					,modelId: this.sourceModelId
 					,state: null
 				};
 				this.dispatchService.synchronousCall(DH,msg);
 				if( msg.state ){
 					this._sourceModelUpdated(msg.state);
 				};
 			};
 		};

 		$n2.log('RadialCanvas',this);
 	},
 	
 	createGraph: function() {
 		var _this = this; // for use in callbacks

 		if( this.background 
 		 && typeof this.background.color === 'string' ){
 			var $canvas = $('#' + this.canvasId);
 			$canvas.css('background-color',this.background.color);
 		};
 		
 		this.svgId = $n2.getUniqueId();
 		var $svg = $d.select('#' + this.canvasId)
 			.append('svg')
 			.attr('id',this.svgId);
 		
 		var $rootGroup = $svg.append('g')
			.attr('class','radialRoot')
			;

		$rootGroup.append('g')
 			.attr('class','links');

		$rootGroup.append('g')
 			.attr('class','nodes');

		$rootGroup.append('g')
 			.attr('class','labels');
 		
 		this.resizeGraph();
 	},
 	
 	getGraphSize: function() {
 		var $canvas = $('#' + this.canvasId);
 		
 		var width = $canvas.width();
 		var height = $canvas.height();
 		
 		/*
 		 * apply minimum sizes
 		 */
// 		if (width < this.options.sizes.canvas_min.width) {
// 			width = this.options.sizes.canvas_min.width;
// 		};
// 		if (height < this.options.sizes.canvas_min.height) {
// 			height = this.options.sizes.canvas_min.height;
// 		};
 		return [width, height];
 	},
 	
 	resizeGraph: function() {
 		var size = this.getGraphSize();
 		
 		var $svg = this._getSvgElem()
 			.attr('width', size[0])
 			.attr('height', size[1]);
 		
 		var $rootGroup = $svg.select('g.radialRoot')
			.attr("transform", "translate(" + (size[0]/2) + "," + (size[1]/2) + ")");
			;
 		
 		var minDim = size[0];
 		if( minDim > size[1] ){
 			minDim = size[1];
 		};
 		
 		this.canvasWidth = minDim;
 		this.radius = Math.floor( (minDim / 2) - 120 );
 		
 		this._documentsUpdated([],[]);
 	},
 	
 	_getSvgElem: function() {
 		return $d.select('#' + this.svgId);
 	},
	
	_elementsChanged: function(addedElements, updatedElements, removedElements){
		// Remove elements that are no longer there
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removed = removedElements[i];
			
			if( removed.isNode ){
				delete this.nodesById[ removed.id ];
			} else if( removed.isLink ){
				delete this.linksById[ removed.id ];
			};
		};
		
		// Add elements
		for(var i=0,e=addedElements.length; i<e; ++i){
			var added = addedElements[i];
			
			if( added.isNode ){
				added.n2_geometry = 'point';
				this.nodesById[ added.id ] = added;
			} else if( added.isLink ){
				added.n2_geometry = 'line';
				this.linksById[ added.id ] = added;
			};
		};

		// Updated nodes
		var updatedNodes = [];
		var updatedLinks = [];
		for(var i=0,e=updatedElements.length; i<e; ++i){
			var updated = updatedElements[i];
			
			if( updated.isNode ){
				updated.n2_geometry = 'point';
				updatedNodes.push(updated);
			} else if( updated.isLink ){
				updated.n2_geometry = 'line';
				updatedLinks.push(updated);
			};
		};
		
		this._documentsUpdated(updatedNodes, updatedLinks);
	},
	
	_intentChanged: function(changedElements){
 		// Segregate nodes and active links
 		var nodes = [];
 		var links = [];
 		for(var i=0,e=changedElements.length; i<e; ++i){
 			var changedNode = changedElements[i];
 			
 			// $n2.log(changedNode.n2_id+' sel:'+changedNode.n2_selected+' foc:'+changedNode.n2_hovered+' find:'+changedNode.n2_found);
 			
 			if( changedNode.isNode ){
 				nodes.push(changedNode);
 				
 				if( changedNode.n2_found 
 				 && !changedNode.forceFound ){
 					changedNode.forceFound = true;

 				} else if( !changedNode.n2_found 
 				 && changedNode.forceFound ){
 					changedNode.forceFound = false;
 				};
 				
 			} else if( changedNode.isLink ){
 				links.push(changedNode);
 			};
 		};

 		// Update style on nodes
 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(nodes, function(node){ return node.id; });
 		this._adjustElementStyles(selectedNodes);

 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(nodes, function(node){ return node.id; });
		this._adjustElementStyles(selectedLabels);

 		// Update style on links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(links, function(link){ return link.id; });
 		this._adjustElementStyles(selectedLinks);
 		
 		// Re-order the lines so that hovered are above selected, and selected are above
 		// regular
 		links = [];
 		for(var linkId in this.linksById){
 			var link = this.linksById[linkId];
			links.push(link);
 		};
 		this._getSvgElem()
 			.select('g.links')
 			.selectAll('.link')
			.data(links, function(link){ return link.id; })
			.filter(function(l){return l.n2_selected;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;
 		this._getSvgElem()
			.select('g.links')
			.selectAll('.link')
			.data(links, function(link){ return link.id; })
			.filter(function(l){return l.n2_hovered;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;
	},
 	
 	_documentsUpdated: function(updatedNodeData, updatedLinkData){
 		var _this = this;
 		
 		this.sortedNodes = [];
 		for(var id in this.nodesById){
 			var node = this.nodesById[id];
 			this.sortedNodes.push(node);
 		};
 		
 		// Sort the nodes
 		this.sortedNodes.sort(function(a,b){
 			return d3.ascending(a.sortValue, b.sortValue);
 		});
 		
 		// Assign x and y
 		if( this.sortedNodes.length > 0 ){
 	 		var xDelta = 360 / this.sortedNodes.length;
 	 		var x = 0;
 	 		for(var i=0,e=this.sortedNodes.length; i<e; ++i){
 	 			var node = this.sortedNodes[i];
 	 			
 	 			node.orig_x = x;
 	 			node.y = this.radius;
 	 			
 	 			var mag = this.magnify(node);
 	 			node.x = mag.x;
 	 			node.z = mag.z;
 	 			
 	 			x += xDelta;
 	 		};
 		};

 		var links = [];
 		for(var id in this.linksById){
 			var link = this.linksById[id];
 			links.push(link);
 		};

 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(this.sortedNodes, function(node){ return node.id; })
 			;

 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
 			.data(this.sortedNodes, function(node){ return node.id; })
 			;

 		// Animate the position of the nodes around the circle
 		selectedNodes.transition()
		.attr("transform", function(d) { 
			return "rotate(" + (d.x - 90) 
				+ ")translate(" + d.y + ",0)"; 
		})
		;
 		
 		// Animate the position of the labels around the circle
 		selectedLabels.transition()
			.attr("transform", function(d) { 
				return "rotate(" + (d.x - 90) 
					+ ")translate(" + (d.y + 8) + ",0)" 
					+ (d.x < 180 ? "" : "rotate(180)"); 
			})
 			.style("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			;

 		var createdNodes = selectedNodes.enter()
 			.append('circle')
 			.attr('class','node')
 			.attr("r", 3)
 			.attr("transform", function(d) { 
 				return "rotate(" + (d.x - 90) + ")translate(" + d.y + ",0)"; 
 			})
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 				_this._magnifyElement(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdNodes);

 		var createdLabels = selectedLabels.enter()
 			.append(function(){
 				var args = arguments;
 				return this.ownerDocument.createElementNS(this.namespaceURI, "text");
 			})
 			.attr('class','label')
 			.attr("dy", ".31em")
 			.attr("transform", function(d) { 
 				return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" 
 					+ (d.x < 180 ? "" : "rotate(180)"); 
 			})
 			.style("text-anchor", function(d) { 
 				return d.x < 180 ? "start" : "end"; 
 			})
 			.text(function(d) { 
 				//return d.key; 
 				return "";
 			})
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 				_this._magnifyElement(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdLabels);
 		
 		selectedNodes.exit()
 			.remove();

 		selectedLabels.exit()
			.remove();
 		
 		var updatedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(updatedNodeData, function(node){ return node.id; })
 			;
 		this._adjustElementStyles(updatedNodes);

 		var updatedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(updatedNodeData, function(node){ return node.id; })
			;
		this._adjustElementStyles(updatedLabels);

 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(links, function(link){ return link.id; })
			;
 		
 		selectedLinks.transition()
			.attr('d',function(link){ return _this.line([link.source,{x:0,y:0},link.target]); })
			;

 		var createdLinks = selectedLinks.enter()
 			.append('path')
 			.attr('class','link')
 			.attr('d',function(link){ return _this.line([link.source,{x:0,y:0},link.target]); })
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdLinks);
 		
 		selectedLinks.exit()
 			.remove();
 		
 		var updatedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(updatedLinkData, function(link){ return link.linkId; })
			;
 		this._adjustElementStyles(updatedLinks);

 	},
 	
 	_adjustElementStyles: function(selectedElements){
 		var _this = this;
 		selectedElements.each(function(n,i){
 			n.n2_elem = this;
 			var symbolizer = _this.styleRules.getSymbolizer(n);
 			symbolizer.adjustSvgElement(this,n);
 			delete n.n2_elem;
 		});
 	},
 	
 	_dispatch: function(m){
 		var d = this.dispatchService;
 		if( d ){
 			d.send(DH,m);
 		};
 	},
 	
 	_sourceModelUpdated: function(opts_){
 		this.elementGenerator.sourceModelUpdated(opts_);
 	},
 	
 	_magnifyElement: function(magnifiedNode){
 		var _this = this;
 		
 		var focusAngle = magnifiedNode.orig_x;
 		this.magnify.angle(focusAngle);

 		var magnifyEnabled = false;
 		if( typeof this.magnifyThresholdCount === 'number' 
 		 && this.magnifyThresholdCount <= this.sortedNodes.length ){
 			magnifyEnabled = true;
 		};
 		
 		var changedNodes = [];
 		for(var i=0,e=this.sortedNodes.length; i<e; ++i){
 			var node = this.sortedNodes[i];

 			node.transitionNeeded = false;

 			if( magnifyEnabled ){
 	 			var mag = this.magnify(node);

 	 			if( mag.z === node.z ) {
 	 				// nothing to do
 	 			} else {
 	 				node.z = mag.z;
 	 				node.x = mag.x;
 	 				node.transitionNeeded = true;
 	 				
 	 				changedNodes.push(node);
 	 			};
 	 			
 			} else {
 				if( node.z !== 1 ){
 	 				node.z = 1;
 	 				node.x = node.orig_x;
 	 				node.transitionNeeded = true;
 	 				
 	 				changedNodes.push(node);
 				};
 			};
 		};
 		
		// Animate the position of the nodes around the circle
 		this._getSvgElem().select('g.nodes').selectAll('.node')
			.data(changedNodes, function(node){ return node.id; })
			.transition()
			.attr("transform", function(d) { 
				return "rotate(" + (d.x - 90) 
					+ ")translate(" + d.y + ",0)"; 
			})
			;

		// Animate the position of the labels around the circle
 		this._getSvgElem().select('g.labels').selectAll('.label')
			.data(changedNodes, function(node){ return node.id; })
			.transition()
			.attr("transform", function(d) { 
				return "rotate(" + (d.x - 90) 
					+ ")translate(" + (d.y + 8) + ",0)" 
					+ (d.x < 180 ? "" : "rotate(180)"); 
			})
 			.style("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			;

 		var links = [];
 		for(var linkId in this.linksById){
 			var link = this.linksById[linkId];
 			links.push(link);
 		};
 		this._getSvgElem().select('g.links').selectAll('.link')
			.data(links, function(link){ return link.id; })
			.filter(function(link){
				if( link.source.transitionNeeded ) return true;
				if( link.target.transitionNeeded ) return true;
				return false;
			})
			.transition()
			.attr('d',function(link){ return _this.line([link.source,{x:0,y:0},link.target]); })
			;
 	},
 	
 	_initiateMouseClick: function(elementData){
 		var elementId = elementData.id;
 		if( this.toggleSelection 
 		 && this.lastElementIdSelected === elementId ){
 			this.elementGenerator.selectOff(elementData);
 			this.lastElementIdSelected = null;
 		} else {
 			this.elementGenerator.selectOn(elementData);
 			this.lastElementIdSelected = elementId;
 		};
 	},
 	
 	_initiateMouseOver: function(elementData){
 		var elementId = elementData.id;
 		if( elementId !== this.currentMouseOver ){
 			// Focus Off before Focus On
 			if( this.currentMouseOver ){
 	 			this.elementGenerator.focusOff(this.currentMouseOver);
 				this.currentMouseOver = null;
 			};
 			
 			this.elementGenerator.focusOn(elementData);
 			this.currentMouseOver = elementId;
 		};
 	},
 	
 	_initiateMouseOut: function(elementData){
 		var elementId = elementData.id;
 		if( elementId === this.currentMouseOver ){
 			this.elementGenerator.focusOff(elementData);
			this.currentMouseOver = null;
 		};
 	},
 	
 	_handleDispatch: function(m){
 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._sourceModelUpdated(m.state);
 				};
 			};
 		};
 	},
 	
 	_getModelInfo: function(){
 		var info = {
 			modelId: this.modelId
 			,modelType: 'radialCanvas'
 			,parameters: []
 		};
 		
 		return info;
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	if( m.canvasType === 'radial' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'radial' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new RadialCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasRadial = {
	RadialCanvas: RadialCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasRadialTree.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.radialTreeCanvas'
 ;
 
var $d = undefined;

//--------------------------------------------------------------------------
// Fish eye distortion
function RadialFishEye(){
	var radius = 10,
    	distortion = 2,
    	k0,
    	k1,
    	focusAngle = null,
    	angleAttribute = 'x';
	
	function fisheye(d) {
		var pointAngle = d[angleAttribute];
		
		if( null === focusAngle ){
			return {x: pointAngle, z: 1};

		} else {
			var dx = pointAngle - focusAngle;
			
			if( dx > 180 ) dx -= 360;
			if( dx < -180 ) dx += 360;
			
			var dd = Math.sqrt(dx * dx);
			if (dd >= radius) return {x: pointAngle, z: 1};
			if (!dd) return {x: pointAngle, z: 10};
			var k = k0 * (1 - Math.exp(-dd * k1)) / dd * .75 + .25;
			
			var effAngle = focusAngle + (dx * k);
			if( effAngle < 0 ) effAngle += 360;
			if( effAngle > 360 ) effAngle -= 360;
			
			return {
				x: effAngle
				,z: Math.min(k, 10)
			};
		};
    }

    function rescale() {
        k0 = Math.exp(distortion);
        k0 = k0 / (k0 - 1) * radius;
        k1 = distortion / radius;
        return fisheye;
    }

    fisheye.radius = function(_) {
        if (!arguments.length) return radius;
        radius = +_;
        return rescale();
    };

    fisheye.distortion = function(_) {
        if (!arguments.length) return distortion;
        distortion = +_;
        return rescale();
    };

    fisheye.angle = function(_) {
        if (!arguments.length) return focusAngle;
        focusAngle = _;
        return fisheye;
    };

    fisheye.angleAttribute = function(_) {
        if (!arguments.length) return angleAttribute;
        angleAttribute = _;
        return fisheye;
    };
    
    rescale();
	
	return fisheye;
};

// --------------------------------------------------------------------------
// This canvas displays "node elements" in a circle. It draws line between those elements
// using "link elements". Elements are expected to have the following format:
/* 
{
	id: <string>  (Unique identifier for this element)
	parentId: <string>  (If this element is part of a tree, id of parent element)
	isNode: <boolean>  (true if this is a node element [part of tree])
	isLink: <boolean>  (true if this is a link element [lines between nodes])
	source: <object>  (element which is at the beginning of the line [only links])
	target: <object>  (element which is at the end of the line [only links])
	sortValue: <string> (value used to sort the elements between themselves)
}

Here are attributes added by the canvas:
{
	x: <number>  (value computed by layout)
	y: <number>  (value computed by layout)
	parent: <object>  (element which is parent to this one)
	children: <array> (elements which are children to this one)
	n2_geometry: <string> ('line' or 'point', depending on link or node)
}
*/
var RadialTreeCanvas = $n2.Class({

	canvasId: null,
 	
	interactionId: null,
 	
	svgId: null,
 	
	modelId: null,
 	
	dispatchService: null,

	sourceModelId: null,
 	
	moduleDisplay: null,
 	
	background: null,
	
	toggleSelection: null,
 	
	styleRules: null,

	nodesById: null,
	
	sortedNodes: null,

	links: null,
	
	elementGenerator: null,
	
	elementsById: null,

	findableDocsById: null,
	
	dimensions: null,
	
	layout: null,
	
	line: null,
	
	bundle: null,
	
	magnify: null,
	
	magnifyThresholdCount: null,
 	
	currentMouseOver: null,

	lastElementIdSelected: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,interactionId: null
			,config: null
			,moduleDisplay: null
			,sourceModelId: null
			,background: null
			,line: null
			,magnify: null
			,styleRules: null
			,toggleSelection: true
			,elementGeneratorType: 'default'
			,elementGeneratorOptions: null
			,elementGenerator: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
 	
		this.canvasId = opts.canvasId;
		this.interactionId = opts.interactionId;
		this.moduleDisplay = opts.moduleDisplay;
		this.sourceModelId = opts.sourceModelId;
		this.background = opts.background;
		this.toggleSelection = opts.toggleSelection;
		this.elementGenerator = opts.elementGenerator;
 		
		this.modelId = $n2.getUniqueId('radialTreeCanvas');
 		
		this.styleRules = $n2.styleRule.loadRulesFromObject(opts.styleRules);
 		
		var config = opts.config;
		if( config ){
			if( config.directory ){
				this.dispatchService = config.directory.dispatchService;
			};
		};

 		this.nodesById = {};
 		this.sortedNodes = [];
 		this.links = [];
 		this.currentMouseOver = null;
 		this.elementsById = {};
 		this.findableDocsById = {};
 		this.dimensions = {};
 		this.lastElementIdSelected = null;
 		this.focusInfo = null;
 		this.selectInfo = null;
 		this.magnifyThresholdCount = null;

 		// Element generator
 		if( !this.elementGenerator ){
 			// If not defined, use the one specified by type
 	 		this.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: opts.elementGeneratorType
 	 			,options: opts.elementGeneratorOptions
 	 			,config: opts.config
 	 		});
 		};
 		if( this.elementGenerator ){
			this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
				_this._elementsChanged(added, updated, removed);
			});
			this.elementGenerator.setIntentChangedListener(function(updated){
				_this._intentChanged(updated);
			});
 		};
 		
 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m){
 				_this._handleDispatch(m);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 			this.dispatchService.register(DH,'windowResized',f);
			this.dispatchService.register(DH,'findIsAvailable', f);
 		};
 		
 		this.createGraph();
 		
 		this.layout = d3.layout.cluster()
 			.size([360, this.dimensions.radius])
	 	    .sort(function(a,b){
	 	    	return d3.ascending(a.sortValue, b.sortValue);
	 	    })
	 	    .value(function(d) { return d.size; })
 			;

 		// Set up line computing
 		var lineOptions = $n2.extend({
 			interpolate: 'bundle'
 			,tension: 0.85
 		},opts.line);
 		this.line = d3.svg.line.radial()
	 	    .interpolate("bundle")
 			//.interpolate("basis")
 			//.interpolate("linear")
	 	    .tension(.85)
	 	    .radius(function(d) { return d.y; })
	 	    .angle(function(d) { return d.x / 180 * Math.PI; });
 		for(var optionName in lineOptions){
 			var value = lineOptions[optionName];
 			
 			if( 'interpolate' === optionName 
 			 && typeof value === 'string' ){
 				this.line.interpolate(value);
 			};

 			if( 'tension' === optionName 
 			 && typeof value === 'number' ){
 				this.line.tension(value);
 			};
 		};
 		
 		this.bundle = d3.layout.bundle();
 		
 		// Set up magnification
 		var magnifyOptions = $n2.extend({
 			radius: 10
 			,distortion: 2
 			,thresholdCount: 100
 		},opts.magnify);
 		this.magnify = RadialFishEye()
 			.radius(10)
 			.distortion(2)
 			.angleAttribute('orig_x')
 			;
 		for(var optionName in magnifyOptions){
 			var value = magnifyOptions[optionName];
 			
 			if( 'radius' === optionName 
 			 && typeof value === 'number' ){
 				this.magnify.radius(value);
 			};

 			if( 'distortion' === optionName 
 			 && typeof value === 'number' ){
 				this.magnify.distortion(value);
 			};

 			if( 'thresholdCount' === optionName 
 			 && typeof value === 'number' ){
 				this.magnifyThresholdCount = value;
 			};
 		};
 		
 		opts.onSuccess();

 		if( this.sourceModelId ){
 			if( this.dispatchService ){
 				var msg = {
 					type: 'modelGetState'
 					,modelId: this.sourceModelId
 					,state: null
 				};
 				this.dispatchService.synchronousCall(DH,msg);
 				if( msg.state ){
 					this._sourceModelUpdated(msg.state);
 				};
 			};
 		};

 		$n2.log('RadialTreeCanvas',this);
 	},
 	
 	createGraph: function() {
 		var _this = this; // for use in callbacks

 		if( this.background 
 		 && typeof this.background.color === 'string' ){
 			var $canvas = $('#' + this.canvasId);
 			$canvas.css('background-color',this.background.color);
 		};
 		
 		this.svgId = $n2.getUniqueId();
 		var $svg = $d.select('#' + this.canvasId)
 			.append('svg')
 			.attr('id',this.svgId);

 		$svg.append('rect')
			.attr('class','radialBackground')
			.attr('x',0)
			.attr('y',0)
			.attr('stroke','none')
			.attr('fill','#000000')
			.attr('fill-opacity',0)
			.on('click', function(){
 				_this._initiateBackgroundMouseClick();
 			})
			.on('mousemove', function(){
 				_this._magnifyOut();
 			})
			;

 		var $scaleGroup = $svg.append('g')
			.attr('class','radialScale')
			;
 		
 		var $rootGroup = $scaleGroup.append('g')
			.attr('class','radialRoot')
			;

 		$rootGroup.append('circle')
			.attr('class','magnifyEvents')
			.attr('stroke','#000000')
			.attr('stroke-opacity',0)
			.attr('fill','none')
			.on('mouseover',function(){
				var e = $d.event;
				_this._magnifyLocation(e);
			})
			.on('mousemove',function(){
				var e = $d.event;
				_this._magnifyLocation(e);
			})
			;

		$rootGroup.append('g')
 			.attr('class','links');

		$rootGroup.append('g')
 			.attr('class','nodes');

		$rootGroup.append('g')
 			.attr('class','labels');
 		
 		this.resizeGraph();
 	},
 	
 	getGraphSize: function() {
 		var $canvas = $('#' + this.canvasId);
 		
 		var width = $canvas.width();
 		var height = $canvas.height();

 		return [width, height];
 	},
 	
 	resizeGraph: function() {
 		var size = this.getGraphSize();
 		
 		var minDim = size[0];
 		if( minDim > size[1] ){
 			minDim = size[1];
 		};

 		var standardDim = 800;
 		var maxTextWidth = 100;
 		
 		this.dimensions = {
 			width: size[0]
 			,height: size[1]
 			,cx: Math.floor(size[0]/2)
 			,cy: Math.floor(size[1]/2)
 			,canvasWidth: minDim
 			//,radius: Math.floor( (minDim / 2) - (maxTextWidth * 2) )
 			,radius: Math.floor( (standardDim / 2) - maxTextWidth )
 			,textWidth: maxTextWidth
 		};
 		
 		var $svg = this._getSvgElem()
 			.attr('width', size[0])
 			.attr('height', size[1]);

 		$svg.select('g.radialScale')
			.attr('transform', 
				'translate(' + this.dimensions.cx + "," + this.dimensions.cy + ')'
				+' scale(' + (minDim / standardDim) + ')'
					)
			;

 		$svg.select('rect.radialBackground')
			.attr("width", size[0])
 			.attr("height", size[1])
			;
 		
 		var $svgRoot = $svg.select('g.radialRoot')
			;
 		
 		$svgRoot.select('circle.magnifyEvents')
 			.attr('r',this.dimensions.radius + Math.floor(this.dimensions.textWidth / 2) + 5)
 			.attr('stroke-width',(this.dimensions.textWidth + 10))
 			;
 	},
 	
 	_getSvgElem: function() {
 		return $d.select('#' + this.svgId);
 	},
	
	_elementsChanged: function(addedElements, updatedElements, removedElements){

		// Reset attributes that are computed by layout
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			delete elem.parent;
			delete elem.children;
			delete elem.depth;
			delete elem.x;
			delete elem.y;
			delete elem.z;
			delete elem.orig_x;
		};

		// Remove elements that are no longer there
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removed = removedElements[i];
			delete this.elementsById[removed.id];
		};
		
		// Add elements
		for(var i=0,e=addedElements.length; i<e; ++i){
			var added = addedElements[i];
			this.elementsById[ added.id ] = added;
		};
		
		// Update elements
		for(var i=0,e=updatedElements.length; i<e; ++i){
			var updated = updatedElements[i];
			this.elementsById[ updated.id ] = updated;
		};
		
		// Update list of documents that can be found
		this.findableDocsById = {};
		for(var id in this.elementsById){
			var cluster = this.elementsById[id];
			if( cluster.fragments ){
				for(var fragId in cluster.fragments){
					var frag = cluster.fragments[fragId];
					
					var context = frag.context;
					if( context ){
						var doc = context.n2_doc;
						if( doc ){
							var docId = doc._id;
							
							this.findableDocsById[docId] = doc;
						};
					};
				};
			};
		};

		// Compute tree
		var root = {
			id: '__root__'
			,name: ''
			,children: []
		};
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];

			if( elem.parentId ){
				var parent = this.elementsById[elem.parentId];
				if( parent ){
					elem.parent = parent;
					if( !parent.children ){
						parent.children = [];
					};
					parent.children.push(elem);
				};
				
			} else if( null === elem.parentId ) {
				elem.parent = root;
				root.children.push(elem);
			};
		};

		// Layout tree (sets x and y)
		this.layout.nodes(root);

		// Get nodes and links
		this.sortedNodes = [];
		this.links = [];
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.isLink ){
				elem.n2_geometry = 'line';

				if( inTree(elem.source) 
				 && inTree(elem.target) ){
					this.links.push(elem);
				} else {
					$n2.log('link not in tree',elem);
				};
			};
			
			if( elem.isNode ){
				elem.n2_geometry = 'point';
				elem.orig_x = elem.x;
				delete elem.x;
				
				if( inTree(elem) ){
					this.sortedNodes.push(elem);
				} else {
					$n2.log('node not in tree.',elem);
				};
			};
		};
		this.sortedNodes.sort(function(a,b){
			if( a.orig_x < b.orig_x ) return -1;
			if( a.orig_x > b.orig_x ) return 1;
			return 0;
		});
		
		var paths = this.bundle(this.links);
		for(var i=0,e=this.links.length; i<e; ++i){
			this.links[i].path = paths[i];
		};
		
		this._documentsUpdated(this.sortedNodes, this.links);
		
		function inTree(n){
			if( !n ) return false;
			
			if( n === root ) return true;

			return inTree(n.parent);
		};
	},
	
	_intentChanged: function(changedElements){
		// Reset all temp variables
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			elem.temp_hovered = false;
			elem.temp_selected = false;
		};
		
 		// Segregate nodes and links
		var nodeMap = {};
 		var linkMap = {};
 		for(var i=0,e=changedElements.length; i<e; ++i){
 			var changedNode = changedElements[i];
 			
 			// $n2.log(changedNode.n2_id+' sel:'+changedNode.n2_selected+' foc:'+changedNode.n2_hovered+' find:'+changedNode.n2_found);
 			
 			if( changedNode.isNode ){
 				nodeMap[changedNode.id] = changedNode;
 				
 			} else if( changedNode.isLink ){
 				linkMap[changedNode.id] = changedNode;
 			};
 		};

 		// Compute derived selection and hover
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.isLink ){
				// If a link is selected, both associated nodes
				// are selected (derived)
				if( elem.n2_selected ){
					elem.source.temp_selected = true;
					elem.target.temp_selected = true;
				};
				
				// If a link is hovered, both associated nodes
				// are hovered (derived)
				if( elem.n2_hovered ){
					elem.source.temp_hovered = true;
					elem.target.temp_hovered = true;
				};

				// If a link has an associated node which is selected,
				// then both the link and the other node are selected (derived)
				if( elem.source.n2_selected ){
					elem.temp_selected = true;
					elem.target.temp_selected = true;
				};
				if( elem.target.n2_selected ){
					elem.temp_selected = true;
					elem.source.temp_selected = true;
				};

				// If a link has an associated node which is hovered,
				// then both the link and the other node are hovered (derived)
				if( elem.source.n2_hovered ){
					elem.temp_hovered = true;
					elem.target.temp_hovered = true;
				};
				if( elem.target.n2_hovered ){
					elem.temp_hovered = true;
					elem.source.temp_hovered = true;
				};
			};
		};

 		// Detect changes in derived selection and hover
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.n2_derived_selected !== elem.temp_selected ){
				elem.n2_derived_selected = elem.temp_selected;
				if( elem.isLink ){
					linkMap[elem.id] = elem;
				} else if( elem.isNode ){
					nodeMap[elem.id] = elem;
				};
			};
			
			if( elem.n2_derived_hovered !== elem.temp_hovered ){
				elem.n2_derived_hovered = elem.temp_hovered;
				if( elem.isLink ){
					linkMap[elem.id] = elem;
				} else if( elem.isNode ){
					nodeMap[elem.id] = elem;
				};
			};
		};

 		// Convert node map into a node array
 		var nodes = [];
 		for(var nodeId in nodeMap){
			nodes.push( nodeMap[nodeId] );
 		};

 		// Convert link map into a link array
 		var links = [];
 		for(var linkId in linkMap){
			links.push( linkMap[linkId] );
 		};

 		// Update style on nodes
 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(nodes, function(node){ return node.id; });
 		this._adjustElementStyles(selectedNodes);

 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(nodes, function(node){ return node.id; });
		this._adjustElementStyles(selectedLabels);

 		// Update style on links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(links, function(link){ return link.id; });
 		this._adjustElementStyles(selectedLinks, true);
 		
 		this._reOrderLinks();
	},
	
	_reOrderLinks: function(){
 		// Re-order the lines so that hovered are above selected, and selected are above
 		// regular
 		var links = [];
 		for(var elemId in this.elementsById){
 			var elem = this.elementsById[elemId];
 			if( elem.isLink ){
 				links.push(elem);
 			};
 		};
 		this._getSvgElem()
 			.select('g.links')
 			.selectAll('.link')
			.data(links, function(link){ return link.id; })
			.filter(function(l){return l.n2_selected || l.n2_derived_selected;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;
 		this._getSvgElem()
			.select('g.links')
			.selectAll('.link')
			.data(links, function(link){ return link.id; })
			.filter(function(l){return l.n2_found;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;
 		this._getSvgElem()
			.select('g.links')
			.selectAll('.link')
			.data(links, function(link){ return link.id; })
			.filter(function(l){return l.n2_hovered || l.n2_derived_hovered;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;
	},
 	
 	_documentsUpdated: function(updatedNodeData, updatedLinkData){
 		var _this = this;

 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(updatedNodeData, function(node){ return node.id; })
 			;

 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
 			.data(updatedNodeData, function(node){ return node.id; })
 			;

 		var createdNodes = selectedNodes.enter()
 			.append('circle')
 			.attr('class','node')
 			.attr("r", 3)
 			.attr("transform", function(d) { 
 				return "rotate(" + (d.orig_x - 90) + ")translate(" + d.y + ",0)"; 
 			})
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 				_this._magnifyLocation($d.event);
 			})
 			.on('mousemove', function(n,i){
 				_this._magnifyLocation($d.event);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdNodes);

 		var createdLabels = selectedLabels.enter()
 			.append(function(){
 				var args = arguments;
 				return this.ownerDocument.createElementNS(this.namespaceURI, "text");
 			})
 			.attr('class','label')
 			.attr("dy", ".31em")
 			.attr("transform", function(d) { 
 				return "rotate(" + (d.orig_x - 90) + ")translate(" + (d.y + 8) + ",0)" 
 					+ (d.orig_x < 180 ? "" : "rotate(180)"); 
 			})
 			.style("text-anchor", function(d) { 
 				return d.orig_x < 180 ? "start" : "end"; 
 			})
 			.text(function(d) { 
 				return "";
 			})
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 				_this._magnifyLocation($d.event);
 			})
 			.on('mousemove', function(n,i){
 				_this._magnifyLocation($d.event);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdLabels);
 		
 		// Removals
 		selectedNodes.exit()
 			.remove();

 		selectedLabels.exit()
			.remove();

 		// Updates
 		this._adjustElementStyles(selectedNodes);

		this._adjustElementStyles(selectedLabels);

		// Links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(updatedLinkData, function(link){ return link.id; })
			;

 		var createdLinks = selectedLinks.enter()
 			.append('path')
 			.attr('class','link')
// 			.attr('d',function(link){ return _this.line(link.path); })
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdLinks, true);
 		
 		selectedLinks.exit()
 			.remove();
 		
 		this._adjustElementStyles(selectedLinks, true);

 		// Position everything around the circle
 		this._positionElements();

 		// Re-order links
 		this._reOrderLinks();
 	},
 	
 	_adjustElementStyles: function(selectedElements, elementsAreLinks){
 		var _this = this;
 		selectedElements.each(function(n,i){
 			n.n2_elem = this;
 			var symbolizer = _this.styleRules.getSymbolizer(n);
 			symbolizer.adjustSvgElement(this,n);
 			delete n.n2_elem;
 		});
 		
 		if( elementsAreLinks ){
 			selectedElements.attr('fill','none');
 		};
 	},
 	
 	_dispatch: function(m){
 		var d = this.dispatchService;
 		if( d ){
 			d.send(DH,m);
 		};
 	},
 	
 	_sourceModelUpdated: function(opts_){
 		this.elementGenerator.sourceModelUpdated(opts_);
 	},
	
	_focusAngleFromLocation: function(x,y){
		var angle = null;
		
		var effX = x - this.dimensions.cx;
		var effY = this.dimensions.cy - y;
		if( 0 == effX && 0 == effY){
			return null;
			
		} else if( 0 == effY ){
			if( effX < 0 ){
				angle = -90;
			} else {
				angle = 90;
			}
		} else {
			angle = Math.atan(effX / effY) * 180 / Math.PI;
			if( effY < 0 ){
				angle += 180;
			};
			if( angle > 360 ){
				angle = angle - 360;
			};
		};

		return angle;
	},
 	
 	_magnifyLocation: function(e){
 		var m = null;

 		try {
 			var $svg = this._getSvgElem();
 			var svgNode = $svg[0][0];
			var svgCTM = svgNode.getScreenCTM();
			m = svgCTM.inverse();
		} catch(e) {
			// ignore
		};
		
		if( m ){
			var x = (e.clientX * m.a) + (e.clientY * m.c) + m.e;
			var y = (e.clientX * m.b) + (e.clientY * m.d) + m.f;
			
			var focusAngle = this._focusAngleFromLocation(x,y);
			//$n2.log('focusAngle:'+focusAngle);
			
			if( null !== focusAngle ){
		 		this.magnify.angle(focusAngle);
		 		
		 		this._positionElements();
			};
		};
 	},
 	
 	_magnifyOut: function(){
		this.magnify.angle(null);
		this._positionElements();
 	},
 	
 	_positionElements: function(){
 		var _this = this;
 		
 		var magnifyEnabled = false;
 		if( typeof this.magnifyThresholdCount === 'number' 
 		 && this.magnifyThresholdCount <= this.sortedNodes.length ){
 			magnifyEnabled = true;
 		};
 		
 		var changedNodes = [];
 		for(var i=0,e=this.sortedNodes.length; i<e; ++i){
 			var node = this.sortedNodes[i];

 			node.transitionNeeded = false;
 			var x = null;
 			var z = null;

 			if( magnifyEnabled ){
 	 			var mag = this.magnify(node);
 	 			x = mag.x;
 	 			z = mag.z;
 	 			
 			} else {
 				x = node.orig_x;
 				z = 2;
 			};

 			var changed = false;
 			if( typeof node.x !== 'number' ){
 				node.x = x;
 				changed = true;
 			} else {
 	 			var delta = Math.abs(x - node.x);
 				if( delta > 0.01 ){
 	 				node.x = x;
 	 				changed = true;
 				};
 			};
 			if( typeof node.z !== 'number' ){
 				node.z = z;
 				changed = true;
 			} else {
 	 			var delta = Math.abs(z - node.z);
 				if( delta > 0.01 ){
 	 				node.z = z;
 	 				changed = true;
 				};
 			};
			
			if( changed ){
 				node.transitionNeeded = true;
 				changedNodes.push(node);
			};
 		};
 		
		// Animate the position of the nodes around the circle
 		var changedPoints = this._getSvgElem().select('g.nodes').selectAll('.node')
			.data(changedNodes, function(node){ return node.id; });
 		
		changedPoints.transition()
			.attr("transform", function(d) { 
				return "rotate(" + (d.x - 90) 
					+ ")translate(" + d.y + ",0)"; 
			})
			;
 		
 		this._adjustElementStyles(changedPoints);

		// Animate the position of the labels around the circle
 		var changedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(changedNodes, function(node){ return node.id; })
			;
 		
		changedLabels.transition()
			.attr("transform", function(d) { 
				return "rotate(" + (d.x - 90) 
					+ ")translate(" + (d.y + 8) + ",0)" 
					+ (d.x < 180 ? "" : "rotate(180)"); 
			})
 			.style("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			;
 		
 		this._adjustElementStyles(changedLabels);

 		// Animate links
 		this._getSvgElem().select('g.links').selectAll('.link')
			.data(this.links, function(link){ return link.id; })
			.filter(function(link){
				if( link.source.transitionNeeded ) return true;
				if( link.target.transitionNeeded ) return true;
				return false;
			})
			.transition()
			.attr('d',function(link){ return _this.line(link.path); })
			;
 	},

	_initiateBackgroundMouseClick: function(){
		this._dispatch({
			type: 'userUnselect'
		});
	},

 	_initiateMouseClick: function(elementData){
 		var elementId = elementData.id;
 		if( this.toggleSelection 
 		 && this.lastElementIdSelected === elementId ){
 			this.elementGenerator.selectOff(elementData);
 			this.lastElementIdSelected = null;
 		} else {
 			this.elementGenerator.selectOn(elementData);
 			this.lastElementIdSelected = elementId;
 		};
 	},
 	
 	_initiateMouseOver: function(elementData){
 		var elementId = elementData.id;
 		if( elementId !== this.currentMouseOver ){
 			// Focus Off before Focus On
 			if( this.currentMouseOver ){
 	 			this.elementGenerator.focusOff(this.currentMouseOver);
 				this.currentMouseOver = null;
 			};
 			
 			this.elementGenerator.focusOn(elementData);
 			this.currentMouseOver = elementId;
 		};
 	},
 	
 	_initiateMouseOut: function(elementData){
 		var elementId = elementData.id;
 		if( elementId === this.currentMouseOver ){
 			this.elementGenerator.focusOff(elementData);
			this.currentMouseOver = null;
 		};
 	},
 	
 	_handleDispatch: function(m){
 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._sourceModelUpdated(m.state);
 				};
 			};
 			
 		} else if( 'windowResized' === m.type ) {
 			this.resizeGraph();
 			
 		} else if( 'findIsAvailable' === m.type ) {
			var doc = m.doc;
			var docId = doc._id;
 			
 			if( this.findableDocsById[docId] ){
 				m.isAvailable = true;
 			};
 		};
 	},
 	
 	_getModelInfo: function(){
 		var info = {
 			modelId: this.modelId
 			,modelType: 'radialTreeCanvas'
 			,parameters: []
 		};
 		
 		return info;
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	// Required library: d3
	if( !$d && window ) $d = window.d3;

	if( m.canvasType === 'radialTree' ){
		if( $d ) {
			m.isAvailable = true;
		} else {
			$n2.log('Canvas radialTree requires d3 library');
		};
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'radialTree' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new RadialTreeCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasRadialTree = {
	RadialTreeCanvas: RadialTreeCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasCollapsibleRadialTree.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.collapsibleRadialTreeCanvas'
 ,uniqueId = 0
 ;
 
var $d = undefined;


//--------------------------------------------------------------------------
function Degrees(num){
	if( typeof num !== 'number' ){
		throw new Error('Degrees() accepts only numbers');
	};
	
	if( num > 360 ){
		num = num % 360;
	};
	
	if( num < -360 ){
		num = num % 360;
	};

	if( num < 0 ){
		num = num + 360;
	};
	
	return num;
};

Degrees.toRadians = function(num){
	if( typeof num !== 'number' ){
		throw new Error('Degrees.toRadians() accepts only numbers');
	};
	
	return num * Math.PI / 180;
};

Degrees.sin = function(deg){
	var rad = Degrees.toRadians(deg);
	return Math.sin(rad);
};

Degrees.cos = function(deg){
	var rad = Degrees.toRadians(deg);
	return Math.cos(rad);
};

Degrees.atan = function(frac){
	var rad = Math.atan(frac);
	return rad * 180 / Math.PI;
};

//--------------------------------------------------------------------------
var Angle = $n2.Class('Angle',{
	
	degrees: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			degrees: undefined
			,radians: undefined
		},opts_);
		
		if( typeof opts.degrees === 'number' ){
			this.degrees = opts.degrees;
		} else if( typeof opts.radians === 'number' ){
			this.degrees = opts.radians * 180 / Math.PI;
		};
		
		if( typeof this.degrees !== 'number' ){
			throw new Error('An angle must be specified in degrees or radians');
		};
		
		this._adjust();
	},
	
	asDegrees: function(){
		return this.degrees;
	},
	
	asRadians: function(){
		return this.degrees * Math.PI / 180;
	},
	
	sin: function(){
		return Math.sin(this.degrees * Math.PI / 180);
	},
	
	cos: function(){
		return Math.cos(this.degrees * Math.PI / 180);
	},
	
	add: function(angle){
		return new Angle({
			degrees: (this.degrees + angle.degrees)
		});
	},
	
	subtract: function(angle){
		return new Angle({
			degrees: (this.degrees - angle.degrees)
		});
	},
	
	_adjust: function(){
		this.degrees = Degrees(this.degrees);
	}
});

//--------------------------------------------------------------------------
var AngleInterval = $n2.Class('AngleInterval',{
	
	min: null,

	max: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			min: undefined
			,max: undefined
		},opts_);
		
		this.min = opts.min;
		this.max = opts.max;
		
		if( typeof this.min === 'object' 
		 && typeof this.min.degrees === 'number' ){
			// OK
		} else {
			throw new Error('AngleInterval must be given an angle as min property');
		};
		
		if( typeof this.max === 'object' 
		 && typeof this.max.degrees === 'number' ){
			// OK
		} else {
			throw new Error('AngleInterval must be given an angle as max property');
		};
	},
	
	getMin: function(){
		return this.min;
	},
	
	getMax: function(){
		return this.max;
	},
	
	add: function(angle){
		var min = this.min.add(angle);
		var max = this.max.add(angle);
		
		return new AngleInterval({
			min: min
			,max: max
		});
	},
	
	subtract: function(angle){
		var min = this.min.subtract(angle);
		var max = this.max.subtract(angle);
		
		return new AngleInterval({
			min: min
			,max: max
		});
	},

	includes: function(angle){
		if( this.min.degrees === this.max.degrees ){
			if( this.min.degrees === angle.degrees ){
				return true;
			};

		} else if( this.min.degrees < this.max.degrees ){
			if( this.min.degrees <= angle.degrees 
			 && angle.degrees <= this.max.degrees ){
				return true;
			};

		} else if( this.min.degrees > this.max.degrees ){
			if( this.min.degrees >= angle.degrees 
			 || angle.degrees >= this.max.degrees ){
				return true;
			};
		};
		
		return false;
	}
});

//--------------------------------------------------------------------------
// Tree
// node: {
//    parent: <object> node that is parent of this one
//    children: <array> array of nodes that are children to this one
// }
function Tree(){
	
};
// Tree visiting
// root: node from which to start visit
// callback: function(node, depth){
// }
Tree.visitNodes = function(root, callback){
	if( typeof root === 'object' 
	 && null !== root 
	 && typeof callback === 'function' ){
		visitNode(root, 0, callback);
	};
	
	function visitNode(node, depth, callback){
		callback(node, depth);
		
		if( $n2.isArray(node.children) ){
			for(var i=0,e=node.children.length; i<e; ++i){
				var child = node.children[i];
				visitNode(child, (depth+1), callback);
			};
		};
	};
};
Tree.getNodeDepth = function(node){
	if( node && node.parent ){
		return 1 + Tree.getNodeDepth(node.parent);
	};
	return 0;
};
Tree.visitParents = function(node, callback){
	if( node && typeof callback === 'function' ){
		var depth = Tree.getNodeDepth(node);
		if( node.parent ){
			visitParent(node.parent, depth-1, callback);
		};
	};
	
	function visitParent(p, depth, callback){
		callback(p, depth);

		if( p.parent ){
			visitParent(p.parent, depth-1, callback);
		};
	};
};
Tree.isNodeInTree = function(n,root){
	if( !n ) return false;
	if( !root ) return false;
	
	if( n === root ) return true;

	return Tree.isNodeInTree(n.parent,root);
};
Tree.isRoot = function(n){
	if( n.parent ) return false;

	return true;
};

//--------------------------------------------------------------------------
// Fish eye distortion
function RadialFishEye(){
	var radius = 10,
    	distortion = 2,
    	k0,
    	k1,
    	focusAngle = null,
    	angleAttribute = function(d){
			return d.x;
		};
	
	function valueFromPoint(pointAngle) {
		if( typeof focusAngle !== 'number' ){
			return {x: pointAngle, z: 1};

		} else {
			var dx = Degrees(pointAngle) - focusAngle;
			
			if( dx > 180 ) dx -= 360;
			if( dx < -180 ) dx += 360;
			
			var dd = Math.abs(dx);
			if (dd >= radius) return {x: pointAngle, z: 1};
			if (!dd) return {x: pointAngle, z: distortion};
			
			// This formula returns a number between 1 and distortion
			var k = k0 * (1 - Math.exp(-dd * k1)) / dd * .75 + .25;
			
			var effAngle = Degrees(focusAngle + (dx * k));
			
			return {
				x: effAngle
				,z: Math.min(k, distortion)
			};
		};
    };

    function fisheye(d) {
		var pointAngle = angleAttribute(d);
		return valueFromPoint(pointAngle);
    };

    function rescale() {
        k0 = Math.exp(distortion);
        k0 = k0 / (k0 - 1) * radius;
        k1 = distortion / radius;
        return fisheye;
    };

    fisheye.compute = function(_) {
        return valueFromPoint( Degrees(_) );
    };

    fisheye.radius = function(_) {
        if (!arguments.length) return radius;
        radius = +_;
        return rescale();
    };

    fisheye.distortion = function(_) {
        if (!arguments.length) return distortion;
        distortion = +_;
        return rescale();
    };

    fisheye.angle = function(_) {
        if (!arguments.length) return focusAngle;
        if( typeof _ === 'number' ){
            focusAngle = Degrees(_);
        } else {
            focusAngle = _;
        };
        return fisheye;
    };

    fisheye.angleAttribute = function(_) {
        if (!arguments.length) return angleAttribute;
        if( typeof _ === 'function' ){
            angleAttribute = _;
        } else if( typeof _ === 'string' ){
            angleAttribute = function(d){
            	return d[_];
            };
        } else {
        	throw new Error('Invalid angleAttribute property');
        };
        return fisheye;
    };
    
    rescale();
	
	return fisheye;
};

//--------------------------------------------------------------------------
// This is a d3 layout function used to position a collapsible tree in a
// two-dimension space. The layout accepts a tree structure and assigns
// x,y values to each node.
// The tree requires nodes with the following format:
// {
//    parent: <object> Parent node to this node. Not defined for root node.
//    children: <array> Array of nodes that are children to this node
// }
//
// Options to layout:
// xSize: Dimension of X axis. Defaults to 1. All shown nodes are distributed
//        evenly over this axis. The order of the nodes is based on a depth-first
//        visit strategy, respecting sorting of sibling nodes.
// ySize: Dimension of Y axis. Defaults to 1. All shown nodes are given a value on
//        this axis based on the depth of the node in the tree. The root node is assigned
//        0, while the nodes farthest from root are assigned 1.
// shownFn: Function that reports whether a node is shown or not. This function returns a boolean
//          which is true if the node should be considered visible. This function has the
//          following signature: function(node){}. If no shownFn is specified, then all nodes in
//          the tree are considered visible.
// comparatorFn: Function used to compare the sort order of two nodes. This function has the 
//               following signature: function(node1,node2){}. This function returns 0 if both
//               nodes are equivalent in the collation order. It returns -1 is node1 comes before
//               node2. Finally, it return 1 if node1 comes after node2. If this function is
//               not specified, then the order of the children array is respected for assigning
//               values.
// assignFn: Function used to assign values to the node. This function has the following
//           signature: function(node,values){}. If this function is not specified, then a default
//           assignment functions is supplied where x and y are assigned to the properties 'x' and
//           'y', respectively. The format of the argument 'values' is as follow:
//           {
//               x: <number> value on X-axis
//               xMax: <number> maximum value on X-axis from children nodes
//               xMin: <number> minimum value on X-axis from children nodes
//               y: <number> value on Y-axis
//               level: <number> Integer that represents the depth of this node in the tree
//               xIndent: <number> distance between two nodes in the X-axis
//               yIndent: <number> distance between two levels in the Y-axis
//           }
var CollapsibleLayout = $n2.Class({
	
	xSize: null,

	ySize: null,
	
	shownFn: null,
	
	assignFn: null,
	
	comparatorFn: null,
	
	reverseOrder: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			xSize: 1
			,ySize: 1
			,shownFn: null
			,assignFn: null
			,comparatorFn: null
			,reverseOrder: false
		},opts_);

		this.xSize = opts.xSize;
		this.ySize = opts.ySize;
		this.shown( opts.shownFn );
		this.assign( opts.assignFn );
		this.comparator( opts.comparatorFn );
		this.reverseOrder = opts.reverseOrder;
		
		if( !this.shownFn ){
			this.shownFn = function(n){
				return true;
			};
		};

		if( !this.assignFn ){
			this.assignFn = function(n, v){
				n.x = v.x;
				n.y = v.y;
			};
		};
	},

	nodes: function(root){
		var _this = this;
		
		// Capture the nodes that are shown, sorted in order
		// of presentation. Also, compute the depth of the tree.
		// The array 'nodesShown' is an array of node wrappers of the
		// following format:
		// {
		//     level: <number> depth at which the node is at [0,...]
		//     ,node: <object> An original node from the given tree
		//     ,parent: <object> Parent wrapper object, if any
		// }
		var nodesShown = [];
		var numberOfLevels = 0;
		processLevel([ root ], 0, undefined);

		// Compute xIndent
		var xIndent = 0;
		if( this.xSize > 0 && nodesShown.length > 0 ){
			xIndent = this.xSize / nodesShown.length;
		};

		// Compute yIndent
		var yIndent = 0;
		if( this.ySize > 0 && numberOfLevels > 0 ){
			yIndent = this.ySize / numberOfLevels;
		};
		
		// Compute values. Values that are set by visiting
		// all nodes: parent, level
		// Derived values: x, y, xIndent, yIndent, xMax, xMin
		for(var i=0,e=nodesShown.length; i<e; ++i){
			var wrapper = nodesShown[i];

			if( wrapper ){
				wrapper.x = i * xIndent;
				wrapper.y = wrapper.level * yIndent;
				wrapper.xIndent = xIndent;
				wrapper.yIndent = yIndent;
				
				assignMinMaxX(wrapper, wrapper.x);
			};
		};

		// Assign values to shown nodes
		var nodes = [];
		for(var i=0,e=nodesShown.length; i<e; ++i){
			var wrapper = nodesShown[i];

			if( wrapper ){
				var node = wrapper.node;

				this.assignFn(node, wrapper);
				
				nodes.push(node);
			};
		};
		
		return nodes;
		
		function processLevel(nodes, level, parent){
			var anyNodeShown = false;
			
			for(var i=0,e=nodes.length; i<e; ++i){
				var node = nodes[i];
				var wrapper = {
					level: level
					,node: node
					,parent: parent
				};

				var shown = _this.shownFn(node);
				if( shown && !_this.reverseOrder ){
					anyNodeShown = true;
					
					nodesShown.push(wrapper);
				};
				
				if( node.children ){
					if( _this.comparatorFn ){
						var children = node.children.slice(0); // clone
						children.sort(_this.comparatorFn);
						if( _this.reverseOrder ){
							children.reverse();
						};
						processLevel(children, level+1, wrapper);
					} else {
						processLevel(node.children, level+1, wrapper);
					};
				};

				if( shown && _this.reverseOrder ){
					anyNodeShown = true;
					
					nodesShown.push(wrapper);
				};
			};
			
			if( anyNodeShown ){
				// Add a level, if needed
				if( numberOfLevels < level ){
					numberOfLevels = level;
				};
			};
		};
		
		function assignMinMaxX(wrapper, x){
			if( wrapper ){
				if( typeof wrapper.xMax !== 'number' ){
					wrapper.xMax = x;
				} else if( wrapper.xMax < x ){
					wrapper.xMax = x;
				};

				if( typeof wrapper.xMin !== 'number' ){
					wrapper.xMin = x;
				} else if( wrapper.xMin > x ){
					wrapper.xMin = x;
				};

				assignMinMaxX(wrapper.parent, x);
			};
		};
	},
	
	size: function(xSize, ySize){
		this.xSize = xSize;
		this.ySize = ySize;
	},
	
	shown: function(f){
		if( typeof f === 'function' ){
			this.shownFn = f;

		} else if( typeof f === 'string' ){
			this.shownFn = function(n){
				return n[f];
			};
		};
	},
	
	assign: function(f){
		if( typeof f === 'function' ){
			this.assignFn = f;
		};
	},
	
	comparator: function(f){
		if( typeof f === 'function' ){
			this.comparatorFn = f;
		};
	}
});

//--------------------------------------------------------------------------
// Instances of this class keep track of selections
var SelectionTracker = $n2.Class({
	
	dispatchService: null,
	
	selectedMap: null,
	
	onChangeFn: null,
	
	eventSourcesToIgnoreMap: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		this.selectedMap = {};
		this.eventSourcesToIgnoreMap = {};
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};

			this.dispatchService.register(DH, 'selected', f);
			this.dispatchService.register(DH, 'selectedSupplement', f);
			this.dispatchService.register(DH, 'unselected', f);
		};
	},
	
	onChange: function(onChangeFn){
		if( typeof onChangeFn === 'function' ){
			this.onChangeFn = onChangeFn;
		};
	},
	
	addIgnoreEventSource: function(eventSource){
		this.eventSourcesToIgnoreMap[eventSource] = true;
	},
	
	_reportChange: function(){
		if( typeof this.onChangeFn === 'function' ){
			var map = {};
			for(var docId in this.selectedMap){
				map[docId] = true;
			};
			this.onChangeFn(map);
		};
	},
	
	_performUnselected: function(suppressChangeReport){
		var changed = false;

		for(var docId in this.selectedMap){
			changed = true;
		};
		
		this.selectedMap = {};
		
		if( !suppressChangeReport ){
			this._reportChange();
		};
		
		return changed;
	},
	
	_performSelected: function(docIds){
		var changed = this._performUnselected(true);
		
		if( typeof docIds === 'string' ){
			this.selectedMap[docIds] = true;
			changed = true;

		} else if( $n2.isArray(docIds) ){
			for(var i=0,e=docIds.length; i<e; ++i){
				var docId = docIds[i];
				this.selectedMap[docId] = true;
				changed = true;
			};
		};

		if( changed ){
			this._reportChange();
		};
		
		return changed;
	},
	
	_performSelectedSupplement: function(docId){
		var changed = false;
		
		if( !this.selectedMap[docId] ){
			this.selectedMap[docId] = true;
			changed = true;
		};

		if( changed ){
			this._reportChange();
		};
		
		return changed;
	},

	_performFind: function(docId){
		var changed = false;

		if( changed ){
			this._reportChange();
		};
		
		return changed;
	},
	
	_shoudIgnoreEvent: function(m){
		if( m._source ){
			if( this.eventSourcesToIgnoreMap[m._source] ){
				return true;
			};
		};
		
		return false;
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'selected' === m.type ){
			if( !this._shoudIgnoreEvent(m) ){
				if( m.docId ){
					this._performSelected(m.docId);
				} else if( m.docIds ){
					this._performSelected(m.docIds);
				};
			};

		} else if( 'selectedSupplement' === m.type ){
			if( !this._shoudIgnoreEvent(m) ){
				if( m.origin ){
					if( this.selectedMap[m.origin] ){
						this._performSelectedSupplement(m.docId);
					};
				} else if( m.docId ) {
					this._performSelectedSupplement(m.docId);
				};
			};

		} else if( 'unselected' === m.type ){
			//if( !this._shoudIgnoreEvent(m) ){
				this._performUnselected();
			//};
		};
	}
});

// --------------------------------------------------------------------------
// This canvas displays "node elements" in a circle. It draws line between those
// elements
// using "link elements". Elements are expected to have the following format:
/* 
{
	id: <string>  (Unique identifier for this element)
	parentId: <string>  (If this element is part of a tree, id of parent element)
	isNode: <boolean>  (true if this is a node element [part of tree])
	isLink: <boolean>  (true if this is a link element [lines between nodes])
	source: <object>  (element which is at the beginning of the line [only links])
	target: <object>  (element which is at the end of the line [only links])
	sortValue: <string> (value used to sort the elements between themselves)
	group: <string> (Optional. Grouping nodes)
	showArc: <boolean> (Optional. If set, an arc is drawn around this node)
}

Here are attributes added by the canvas:
{
	x: <number>  (value computed by layout)
	y: <number>  (value computed by layout)
	z: <number>  (value computed by magnify range 1 to distortion (generally 2). Defaults to 1)
	zFactor: <number>  (value representing how close nodes are, range 0 to 1. 0 is closer, 1 is farther)
	parent: <object>  (element which is parent to this one)
	children: <array> (elements which are children to this one)
	n2_geometry: <string> ('line' or 'point', depending on link or node)
	expanded: <boolean> True if the children of this element are to appear in the graph
	detailedView: <boolean> Set if the node or link is associated with the expanded nodes
	generalView: <boolean> Set if detailedView is not set
}

The nodes are expected to form a tree. Nodes that do not have a parent identifier are assumed
to be children of the "root" node. If no nodes define a parent, then it is a flat tree with
only one level.

The collapsible radial tree shows only the first level nodes (the ones directly children to
root) until a node is expanded. When a node is expanded, the children of the expanded node are
shown instead of their parent.
*/
var CollapsibleRadialTreeCanvas = $n2.Class({

	canvasId: null,
 	
	interactionId: null,
 	
	svgId: null,
 	
	modelId: null,
 	
	dispatchService: null,

	sourceModelId: null,
 	
	moduleDisplay: null,
	
	radius: null,
 	
	background: null,
	
	toggleSelection: null,
	
	/*
	 * Rotation of the graph as an angle. Positive angle
	 * is clockwise.
	 */
	originAngle: null,
	
	transitionDuration: null,

	collapseBeforeExpand: null,
 	
	styleRules: null,

	/*
	 * Displayed nodes
	 */
	displayedNodesSorted: null,

	/*
	 * Displayed links. These are effective links
	 */
	displayedLinks: null,
	
	eventSource: null,
	
	elementGenerator: null,
	
	/*
	 * This is a dictionary of all elements received by the element
	 * generator, stored by id
	 */
	elementsById: null,

	/*
	 * This is a dictionary of all elements received by the element
	 * generator, organized by group names
	 */
	elementsByGroup: null,
	
	/*
	 * This is a dictionary of all elements received by the generator
	 * that are associated with a group. This dictionary maps element identifier
	 * to group name.
	 */
	elementIdToGroupName: null,

	elementsByDocId: null,
	
	/*
	 * This is a map of all effective elements, stored by
	 * id. Effective elements are displayed on the canvas.
	 * Some effective elements (like nodes) are the source elements
	 * received from the element generator. Other effective elements 
	 * are derived from the ones provided by the generator and might
	 * even combine multiple source elements.
	 */
	effectiveElementsById: null,

	/*
	 * Effective elements are derived from one or multiple
	 * source elements (the ones from the generator). This maps the
	 * source element ids to effective element ids
	 */
	elementToEffectiveId: null,
	
	/*
	 * The canvas operates on a tree. This is the root of the tree
	 * that the canvas uses. Recomputed when elements are changed.
	 */
	elementTreeRoot: null,
	
	sourceLinks: null,
	
	dimensions: null,
	
	layout: null,
	
	line: null,
	
	bundle: null,
	
	magnifyOptions: null,
	
	magnify: null,
	
	magnifyThresholdCount: null,
	
	filterOptions: null,
	
	arcOptions: null,
 	
	currentMouseOver: null,

	lastElementIdSelected: null,
	
	outsideSelectionDocIdMap: null,
	
	expandedNodesById: null,
	
	/*
	 * This is a structure that is used when a node is expanded/collapsed.
	 * It stores the node that is expanded/collapsed and the position
	 * it had at time of expansion/collapse. Used to adjust originOffset. Format:
	 * {
	 * 	  id: <string> Node identifier
	 *    position: <number> Original position of node
	 * }
	 */
	fixOriginOnNode: null,
	
	originOffset: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,interactionId: null
			,config: null
			,moduleDisplay: null
			,sourceModelId: null
			,radius: 300
			,background: null
			,layout: null
			,line: null
			,magnify: null
			,styleRules: null
			,filter: null
			,arcs: null
			,toggleSelection: false
			,originAngle: 0
			,transitionDuration: 250
			,collapseBeforeExpand: true
			,elementGeneratorType: 'default'
			,elementGeneratorOptions: null
			,elementGenerator: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
		
		this.canvasId = opts.canvasId;
		this.interactionId = opts.interactionId;
		this.moduleDisplay = opts.moduleDisplay;
		this.sourceModelId = opts.sourceModelId;
		this.radius = 0 + opts.radius;
		this.background = opts.background;
		this.toggleSelection = opts.toggleSelection;
		this.elementGenerator = opts.elementGenerator;
		this.transitionDuration = opts.transitionDuration;
		this.collapseBeforeExpand = opts.collapseBeforeExpand;
 		
		this.modelId = $n2.getUniqueId('collapsibleRadialTreeCanvas');
 		
		this.styleRules = $n2.styleRule.loadRulesFromObject(opts.styleRules);
 		
		var config = opts.config;
		if( config ){
			if( config.directory ){
				this.dispatchService = config.directory.dispatchService;
			};
		};
		
		// originAngle
		if( typeof opts.originAngle !== 'number' ){
			opts.originAngle = 0 + opts.originAngle;
		};
		if( typeof opts.originAngle !== 'number' ){
			opts.originAngle = 0;
		};
		this.originAngle = Degrees(opts.originAngle);

 		this.elementsByGroup = {};
 		this.elementIdToGroupName = {};
 		this.displayedNodesSorted = [];
 		this.displayedLinks = [];
 		this.currentMouseOver = null;
 		this.elementsById = {};
 		this.elementsByDocId = {};
 		this.effectiveElementsById = {};
		this.elementToEffectiveId = {};
		this.elementTreeRoot = {};
		this.sourceLinks = [];
 		this.dimensions = {};
 		this.lastElementIdSelected = null;
 		this.focusInfo = null;
 		this.selectInfo = null;
 		this.magnifyThresholdCount = null;
 		this.outsideSelectionDocIdMap = null;
 		this.expandedNodesById = {};
 		this.fixOriginOnNode = null;
 		this.originOffset = 0;

 		// Element generator
 		this.eventSource = 'CollapsibleRadialTreeCanvas_' + uniqueId;
 		++uniqueId;
 		if( !this.elementGenerator ){
 			// If not defined, use the one specified by type
 	 		this.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: opts.elementGeneratorType
 	 			,options: opts.elementGeneratorOptions
 	 			,config: opts.config
 	 		});
 		};
 		if( this.elementGenerator ){
			this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
				_this._elementsChanged(added, updated, removed);
			});
			this.elementGenerator.setIntentChangedListener(function(updated){
				_this._intentChanged(updated);
			});
			
			if( typeof this.elementGenerator.setEventSource === 'function' ){
				this.elementGenerator.setEventSource(this.eventSource);
			};
 		};
 		
 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m){
 				_this._handleDispatch(m);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 			this.dispatchService.register(DH,'windowResized',f);
			this.dispatchService.register(DH,'findIsAvailable', f);
			this.dispatchService.register(DH,'find', f);
			
			// Track selection
			this.selectionTracker = new SelectionTracker({
				dispatchService: this.dispatchService
			});
			this.selectionTracker.addIgnoreEventSource(this.eventSource);
			this.selectionTracker.onChange(function(docIdMap){
				_this._selectionChanged(docIdMap);
			});
 		};
 		
 		this.createGraph();
 		
 		var layoutOptions = $n2.extend(
 			{
	 			reverseOrder: false
	 		}
	 		,opts.layout
	 		,{
	 			xSize: 360
	 			,assignFn: function(node,v){
	 				node.x = v.x;
	 				node.xMax = v.xMax;
	 				node.xMin = v.xMin;
	 				node.xIndent = v.xIndent;
	 				node.y = _this.dimensions.radius;
	 			}
	 			,shownFn: function(node){
	 				if( node.canvasVisible ) return true;
	 				if( node.canvasVisibleDerived ) return true;
	 				return false;
	 			}
	 			,comparatorFn: function(n1, n2){
	 				if( n1.sortValue < n2.sortValue ) return -1;
	 				if( n1.sortValue > n2.sortValue ) return 1;
	 				return 0;
	 			}
	 		}
	 	);
 		this.layout = new CollapsibleLayout(layoutOptions);

 		// Set up line computing
 		var lineOptions = $n2.extend({
 			interpolate: 'bundle' // 'bundle' 'basis' 'linear'
 			,tension: 0.85
 		},opts.line);
 		this.line = d3.svg.line.radial()
	 	    .radius(function(d) { return d.y; })
	 	    .angle(function(d) { return d.x / 180 * Math.PI; });
 		for(var optionName in lineOptions){
 			var value = lineOptions[optionName];
 			
 			if( 'interpolate' === optionName 
 			 && typeof value === 'string' ){
 				this.line.interpolate(value);
 			};

 			if( 'tension' === optionName 
 			 && typeof value === 'number' ){
 				this.line.tension(value);
 			};
 		};
 		
 		this.bundle = d3.layout.bundle();
 		
 		// Set up magnification
 		this.magnifyOptions = $n2.extend({
 			enabled: true
 			,radius: 10
 			,distortion: 2
 			,thresholdCount: 100
 		},opts.magnify);
 		this.magnify = RadialFishEye()
 			.radius(10)
 			.distortion(2)
 			.angleAttribute(function(n){
 				return n.orig_x;
 			})
 			;
 		for(var optionName in this.magnifyOptions){
 			var value = this.magnifyOptions[optionName];
 			
 			if( 'radius' === optionName 
 			 && typeof value === 'number' ){
 				this.magnify.radius(value);
 			};

 			if( 'distortion' === optionName 
 			 && typeof value === 'number' ){
 				this.magnify.distortion(value);
 			};

 			if( 'thresholdCount' === optionName 
 			 && typeof value === 'number' ){
 				this.magnifyThresholdCount = value;
 			};
 		};
 		
 		// Filter options
 		this.filterOptions = $n2.extend({
 			expand: false
 			,showGroupMembers: true
 		},opts.filter);
 		
 		// Arc options
 		this.arcOptions = $n2.extend({
 			show: true
 			,offset: 0
 			,extent: 200
 		},opts.arcs);
 		
 		opts.onSuccess();

 		if( this.sourceModelId ){
 			if( this.dispatchService ){
 				var msg = {
 					type: 'modelGetState'
 					,modelId: this.sourceModelId
 					,state: null
 				};
 				this.dispatchService.synchronousCall(DH,msg);
 				if( msg.state ){
 					this._sourceModelUpdated(msg.state);
 				};
 			};
 		};

 		$n2.log('collapsibleRadialTreeCanvas',this);
 	},
 	
 	createGraph: function() {
 		var _this = this; // for use in callbacks

 		if( this.background 
 		 && typeof this.background.color === 'string' ){
 			var $canvas = $('#' + this.canvasId);
 			$canvas.css('background-color',this.background.color);
 		};
 		
 		this.svgId = $n2.getUniqueId();
 		var $svg = d3.select('#' + this.canvasId)
 			.append('svg')
 			.attr('id',this.svgId);

 		$svg.append('rect')
			.attr('class','collapsibleRadialTreeBackground')
			.attr('x',0)
			.attr('y',0)
			.attr('stroke','none')
			.attr('fill','#000000')
			.attr('fill-opacity',0)
			.on('click', function(){
 				_this._initiateBackgroundMouseClick();
 			})
			.on('mousemove', function(){
 				_this._magnifyOut();
 			})
			;

 		var $scaleGroup = $svg.append('g')
			.attr('class','collapsibleRadialTreeScale')
			;
 		
 		var $rootGroup = $scaleGroup.append('g')
			.attr('class','collapsibleRadialTreeRoot')
			;

 		$rootGroup.append('circle')
			.attr('class','magnifyEvents')
			.attr('stroke','#000000')
			.attr('stroke-opacity',0)
			.attr('fill','none')
			.on('click', function(){
 				_this._initiateBackgroundMouseClick();
 			})
			.on('mouseover',function(){
				var e = d3.event;
				_this._magnifyLocation(e);
			})
			.on('mousemove',function(){
				var e = d3.event;
				_this._magnifyLocation(e);
			})
			;

		$rootGroup.append('g')
			.attr('class','arcs');

		$rootGroup.append('g')
 			.attr('class','links');

		$rootGroup.append('g')
 			.attr('class','nodes');

//		$rootGroup.append('g')
//			.attr('class','controls');

		$rootGroup.append('g')
 			.attr('class','labels');
 		
 		this.resizeGraph();

 		// Report canvas
 		if( this.dispatchService ){
 			var m = {
 				type: 'canvasReportSvg'
 				,canvasType: 'collapsibleRadialTree'
 				,canvas: this
 				,svg: undefined
 			};
 			$svg.each(function(){
 				m.svg = this;
 			});
 			this.dispatchService.send(DH,m);
 		};
 	},
 	
 	getGraphSize: function() {
 		var $canvas = $('#' + this.canvasId);
 		
 		var width = $canvas.width();
 		var height = $canvas.height();

 		return [width, height];
 	},
 	
 	resizeGraph: function() {
 		var size = this.getGraphSize();
 		
 		var minDim = size[0];
 		if( minDim > size[1] ){
 			minDim = size[1];
 		};

 		var standardDim = 800;
 		var maxTextWidth = standardDim - this.radius;
 		
 		this.dimensions = {
 			width: size[0]
 			,height: size[1]
 			,cx: Math.floor(size[0]/2)
 			,cy: Math.floor(size[1]/2)
 			,canvasWidth: minDim
 			,radius: Math.floor( this.radius )
 			,textWidth: maxTextWidth
 		};
 		
 		var $svg = this._getSvgElem()
 			.attr('width', size[0])
 			.attr('height', size[1]);

 		$svg.select('g.collapsibleRadialTreeScale')
			.attr('transform', 
				'translate(' + this.dimensions.cx + "," + this.dimensions.cy + ')'
				+' scale(' + (minDim / standardDim) + ')'
					)
			;

 		$svg.select('rect.collapsibleRadialTreeBackground')
			.attr("width", size[0])
 			.attr("height", size[1])
			;
 		
 		var $svgRoot = $svg.select('g.collapsibleRadialTreeRoot')
			;
 		
 		$svgRoot.select('circle.magnifyEvents')
 			.attr('r',this.dimensions.radius + Math.floor(this.dimensions.textWidth / 2) + 5)
 			.attr('stroke-width',(this.dimensions.textWidth + 10))
 			;
 	},
 	
 	_getSvgElem: function() {
 		return d3.select('#' + this.svgId);
 	},
	
	_elementsChanged: function(addedElements, updatedElements, removedElements){

		// Remove elements that are no longer there
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removed = removedElements[i];
			delete this.elementsById[removed.id];
			
			// Groups
			var groupName = this.elementIdToGroupName[removed.id];
			if( groupName ){
				var groupElems = this.elementsByGroup[groupName];
				if( groupElems ){
					groupElems = groupElems.filter(function(elem){
						if( elem.id === removed.id ){
							return false;
						};
						return true;
					});
					this.elementsByGroup[groupName] = groupElems;
				};
				
				delete this.elementIdToGroupName[removed.id];
			};
		};
		
		// Add elements
		for(var i=0,e=addedElements.length; i<e; ++i){
			var added = addedElements[i];
			this.elementsById[ added.id ] = added;
			
			// Groups
			if( added.group ){
				var groupName = added.group;
				var groupElems = this.elementsByGroup[groupName];
				if( !groupElems ){
					groupElems = [];
					this.elementsByGroup[groupName] = groupElems;
				};
				groupElems.push(added);
				this.elementIdToGroupName[added.id] = groupName;
			};
		};
		
		// Update elements
		for(var i=0,e=updatedElements.length; i<e; ++i){
			var updated = updatedElements[i];
			this.elementsById[ updated.id ] = updated;
			
			// Groups
			var groupName = this.elementIdToGroupName[updated.id];
			if( groupName !== updated.group ){
				if( groupName ){
					var groupElems = this.elementsByGroup[groupName];
					if( groupElems ){
						groupElems = groupElems.filter(function(elem){
							if( elem.id === updated.id ){
								return false;
							};
							return true;
						});
						this.elementsByGroup[groupName] = groupElems;
					};

					delete this.elementIdToGroupName[updated.id];
				};
				
				if( updated.group ){
					var groupName = updated.group;
					var groupElems = this.elementsByGroup[groupName];
					if( !groupElems ){
						groupElems = [];
						this.elementsByGroup[groupName] = groupElems;
					};
					groupElems.push(updated);
					this.elementIdToGroupName[updated.id] = groupName;
				};
			};
		};
		
		// Update list of documents that can be found
		this.elementsByDocId = {};
		for(var id in this.elementsById){
			var element = this.elementsById[id];
			if( element.fragments ){
				for(var fragId in element.fragments){
					var frag = element.fragments[fragId];
					
					var context = frag.context;
					if( context ){
						var doc = context.n2_doc;
						if( doc ){
							var docId = doc._id;
							
							var elements = this.elementsByDocId[docId];
							if( !elements ){
								elements = [];
								this.elementsByDocId[docId] = elements;
							};
							elements.push(element);
						};
					};
				};
			};
		};
		
		this._createGraphicalElements();
		
		this.dispatchService.send(DH,{
			type: 'findAvailabilityChanged'
		});
	},
	
	_createGraphicalElements: function(){
		// Reset attributes that are computed by layout
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			delete elem.parent;
			delete elem.children;
			delete elem.expanded;
		};
		
		// Compute tree
		this.elementTreeRoot = {
			id: '__root__'
			,name: ''
			,x: 0
			,y: 0
			,children: []
			,expanded: true
		};
		this.sourceLinks = [];
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.isNode ){
				if( !elem.children ){
					elem.children = [];
				};

				if( elem.parentId ){
					var parent = this.elementsById[elem.parentId];
					elem.parent = parent;
					if( !parent.children ){
						parent.children = [];
					};
					parent.children.push(elem);
					
				} else {
					elem.parent = this.elementTreeRoot;
					this.elementTreeRoot.children.push(elem);
				};
			};

			if( elem.isLink ){
				this.sourceLinks.push(elem);
			};
		};
		
		this._redraw();
	},
	
	_redraw: function(){
		var _this = this;

		// Reset effective map
		this.effectiveElementsById = {};
		this.elementToEffectiveId = {};
		
		// If nodes have been selected, recompute expanded map
		if( this.outsideSelectionDocIdMap ){
	 		// Compute a map of all concerned elements
	 		var selectedElementById = {};
	 		for(var docId in this.outsideSelectionDocIdMap){
	 			var elements = undefined;
	 			if( docId ){
	 				elements = this.elementsByDocId[docId];
	 			};
	 			
	 			if( elements ){
					for(var i=0,e=elements.length; i<e; ++i){
						var element = elements[i];
						selectedElementById[element.id] = element;
					};
	 			};
	 		};
	 		
	 		// Compute a new map of expanded nodes so as to show
	 		// everything selected by the outside selection
	 		var updatedExpandedNodes = {};
	 		for(var elementId in selectedElementById){
	 			var element = selectedElementById[elementId];
	 			
	 			if( element.isNode ){
		 			// If this node was previously visible and it now selected,
		 			// attempt to rotate the graph in such a way that this node
		 			// does not move
	 				if( element.canvasVisible ){
	 					if( !_this.fixOriginOnNode ){
	 						_this.fixOriginOnNode = {
 								id: element.id
			 	 	 			,position: Degrees(element.orig_x - _this.originAngle)	
	 						};
	 					};
	 				};
		 			
	 				Tree.visitParents(element, function(n){
	 					// Skip root
	 					if( !Tree.isRoot(n) ){
 							// This node needs to be expanded
	 						updatedExpandedNodes[n.id] = true;
	 						
	 						// If this node was not previously expanded,
	 						// then try to keep the graph position stable
	 						// on this node
	 						if( !_this.expandedNodesById[n.id] 
	 						 && typeof n.orig_x === 'number'
	 						 && !_this.fixOriginOnNode ){
	 				 	 		_this.fixOriginOnNode = {
 				 	 	 			id: n.id
 				 	 	 			,position: Degrees(n.orig_x - _this.originAngle)
 				 	 	 		};
	 						};
	 					};
	 				});
	 			};
	 		};
			this.expandedNodesById = updatedExpandedNodes;
		};

		// Apply "expanded" on nodes
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.isNode ){
				if( this.expandedNodesById[elemId] ){
					elem.expanded = true;
				} else {
					elem.expanded = false;
				};
			};
		};

		
		// Find which nodes are visible
		if( this.filterOptions.expand ){
			var deepestExpandedNode = undefined;
			var maxDepth = -1;
			
			// Compute which nodes are available for display
			Tree.visitNodes(this.elementTreeRoot,function(n,d){
				n.canvasVisible = false;
				n.canvasVisibleDerived = false;
				
				if( n.expanded && maxDepth < d ){
					deepestExpandedNode = n;
					maxDepth = d;
				};

				if( Tree.isRoot(n) ){
					n.canvasAvailable = false;
				} else if( n.parent && isExpandedNode(n.parent) ) {
					n.canvasAvailable = true;
				} else {
					n.canvasAvailable = false;
				};
			});
			
			// The children of the deepest expanded node are visible, including
			// the parents
			if( deepestExpandedNode && deepestExpandedNode.children ){
				for(var i=0,e=deepestExpandedNode.children.length; i<e; ++i){
					var node = deepestExpandedNode.children[i];
					node.canvasVisible = true;
				};
				
				deepestExpandedNode.canvasVisible = true;

				Tree.visitParents(deepestExpandedNode, function(n,d){
					if( Tree.isRoot(n) ){
						n.canvasVisible = false;
					} else {
						n.canvasVisible = true;
					};
				});
			};
			
			// Nodes that are linked to visible ones are also visible
			for(var i=0,e=this.sourceLinks.length; i<e; ++i){
				var link = this.sourceLinks[i];

				var sourceNodeVisible = findVisibleNode(link.source);
				var targetNodeVisible = findVisibleNode(link.target);

				var sourceNodeAvailable = findAvailableNode(link.source);
				var targetNodeAvailable = findAvailableNode(link.target);
				
				if( sourceNodeVisible && targetNodeVisible ){
					// Both are visible, nothing to do
				} else if( sourceNodeVisible && targetNodeAvailable ){
					targetNodeAvailable.canvasVisibleDerived = true;
				} else if( targetNodeVisible && sourceNodeAvailable ){
					sourceNodeAvailable.canvasVisibleDerived = true;
				};
			};

			// If by option, we show nodes that are grouped, then
			// add back the nodes that are grouped
			var showGroupMembers = this.filterOptions.showGroupMembers;
			Tree.visitNodes(this.elementTreeRoot,function(n,d){
				if( showGroupMembers && n.group ){
					n.canvasAvailable = true;
					n.canvasVisible = true;
				};
			});
			
		} else {
			// Do not filter on expand
			Tree.visitNodes(this.elementTreeRoot,function(n,d){
				if( Tree.isRoot(n) ){
					n.canvasVisible = false;
				} else if( n.parent && n.parent.expanded ) {
					n.canvasVisible = true;
				} else {
					n.canvasVisible = false;
				};
			});
		};
		
		// Never show root node
		this.elementTreeRoot.canvasVisible = false;
		this.elementTreeRoot.canvasVisibleDerived = false;

		// Layout tree (sets x and y)
		this.displayedNodesSorted = this.layout.nodes(this.elementTreeRoot);
		
		// Adjust origin offset based on expanded/collapsed node
		this.originOffset = 0;
		if( this.fixOriginOnNode ){
			var nodeId = this.fixOriginOnNode.id;
			var position = this.fixOriginOnNode.position;
			
			if( typeof position === 'number' ){
				for(var i=0,e=this.displayedNodesSorted.length; i<e; ++i){
					var node = this.displayedNodesSorted[i];
					if( nodeId === node.id ){
						this.originOffset = position - node.x;
					};
				};
			};
		};
		
		// Create links. Here, we collapse the links that join two visible nodes.
		// Since some nodes are collapsed into one, links can collide on source/target
		// combination. 
		this.displayedLinks = [];
		for(var i=0,e=this.sourceLinks.length; i<e; ++i){
			var elem = this.sourceLinks[i];
			var elemId = elem.id;

			var sourceNode = findShownNode(elem.source);
			var targetNode = findShownNode(elem.target);
			
			if( sourceNode && targetNode ){
				var effectiveLinkId = computeEffectiveLinkId(sourceNode,targetNode);
				var effectiveLink = this.effectiveElementsById[effectiveLinkId];
				if( !effectiveLink ){
					effectiveLink = {
						id: effectiveLinkId
						,isLink: true
						,source: sourceNode
						,target: targetNode
						,elementIds: [
							sourceNode.id
							,targetNode.id
						]
						,fragments: {}
						,n2_geometry: 'line'
					};
					this.effectiveElementsById[effectiveLinkId] = effectiveLink;
					this.displayedLinks.push(effectiveLink);
				};
				
				// Adopt the fragments from both nodes. This is to perform translation
				// of selection to the model
				adoptFragments(effectiveLink, sourceNode);
				adoptFragments(effectiveLink, targetNode);
				
				// Remember mapping from element to effective link
				this.elementToEffectiveId[elemId] = effectiveLinkId;

			};
		};

		// Compute paths for displayed links
		for(var i=0,e=this.displayedLinks.length; i<e; ++i){
			var link = this.displayedLinks[i];
			var path = [link.source, this.elementTreeRoot, link.target];
			link.path = path;
			
			// Adjust intent
			this._refreshEffectiveLinkIntent(link);
		};

		// Adjust nodes and sort
		var zFactor = 1;
		if( this.displayedNodesSorted.length > 0 ){
			zFactor = 80 / this.displayedNodesSorted.length;
			if( zFactor > 1 ){
				zFactor = 1;
			};
		};
		for(var i=0,e=this.displayedNodesSorted.length; i<e; ++i){
			var node = this.displayedNodesSorted[i];

			node.n2_geometry = 'point';
			node.orig_x = Degrees(node.x + this.originAngle + this.originOffset);
			delete node.x;
			
			if( typeof node.xMax === 'number' ){
				node.xMax = Degrees(node.xMax + this.originAngle + this.originOffset);
			};
			if( typeof node.xMin === 'number' ){
				node.xMin = Degrees(node.xMin + this.originAngle + this.originOffset);
			};
			
			node.zFactor = zFactor;
			
			// Add to map of displayed elements
			this.effectiveElementsById[node.id] = node;
		};
		
		// Assign attributes on nodes and links to keep track of which part of the
		// graph is part of the detailed look. The algorithm here is to:
		// 1. visit all nodes and comute their depth
		// 2. all nodes with the largest depth, assign the attribute "detailedView"
		// 3. all links that touch a node "detailedView" is marked as "detailedView"
		// 4. all nodes that touch a link "detailedView" is marked as "detailedView"
		// 5. all nodes and links that are not marked "detailedView", are mark "generalView"
		{
			var maxDepth = undefined;
			var maxDepthNodes = undefined;
			Tree.visitNodes(this.elementTreeRoot,function(n,depth){
				delete n.detailedView;
				delete n.generalView;

				if( n.canvasVisible || n.canvasVisibleDerived ){
					if( typeof maxDepth === 'number' ){
						if( maxDepth < depth ){
							maxDepth = depth;
							maxDepthNodes = [];
							maxDepthNodes.push(n);
						} else if( maxDepth === depth ){
							maxDepthNodes.push(n);
						};
					} else {
						maxDepth = depth;
						maxDepthNodes = [];
						maxDepthNodes.push(n);
					};
				};
			});
			
			// Assign "detailedView" to the deepest nodes
			if( maxDepthNodes ){
				for(var i=0,e=maxDepthNodes.length; i<e; ++i){
					var node = maxDepthNodes[i];
					node.detailedView = true;
				};
			};
	
			// Propagate detailedView to links
			for(var i=0,e=this.displayedLinks.length; i<e; ++i){
				var link = this.displayedLinks[i];
				
				delete link.detailedView;
				delete link.generalView;

				if( link.source.detailedView ){
					link.detailedView = true;
				} else if( link.target.detailedView ){
					link.detailedView = true;
				} else {
					link.generalView = true;
				};
			};

			// Propagate detailedView from links to nodes
			for(var i=0,e=this.displayedLinks.length; i<e; ++i){
				var link = this.displayedLinks[i];

				if( link.detailedView ){
					link.source.detailedView = true;
					link.target.detailedView = true;
				};
			};
			
			// Assign general view to nodes
			for(var i=0,e=this.displayedNodesSorted.length; i<e; ++i){
				var node = this.displayedNodesSorted[i];

				if( !node.detailedView ){
					node.generalView = true;
				};
			};
		};

		// Compute derived intents
		this._computeDerivedIntent({}, {});
		
		this._documentsUpdated(this.displayedNodesSorted, this.displayedLinks);
		
		function findVisibleNode(n){
			if( !n ) return null;

			if( !Tree.isNodeInTree(n,_this.elementTreeRoot) ){
				return null;
			};
			
			if( n.canvasVisible ) return n;
			
			var parent = n.parent;
			if( !parent ) return null;

			return findVisibleNode(parent);
		};

		function findAvailableNode(n){
			if( !n ) return null;

			if( !Tree.isNodeInTree(n,_this.elementTreeRoot) ){
				return null;
			};
			
			if( n.canvasAvailable ) return n;
			
			var parent = n.parent;
			if( !parent ) return null;

			return findAvailableNode(parent);
		};
		
		/*
		 * A node is expanded if it is marked expanded and all
		 * parents are also expanded
		 */
		function isExpandedNode(n){
			if( !n ) return false;

			if( !Tree.isNodeInTree(n,_this.elementTreeRoot) ){
				return false;
			};
			
			if( !n.expanded ){
				return false;
			};
			
			if( n.parent && !isExpandedNode(n.parent) ){
				return false;
			};
			
			return true;
		};

		function findShownNode(n){
			if( !n ) return null;

			if( !Tree.isNodeInTree(n,_this.elementTreeRoot) ){
				return null;
			};
			
			if( n.canvasVisible ) return n;
			if( n.canvasVisibleDerived ) return n;
			
			var parent = n.parent;
			if( !parent ) return null;

			return findVisibleNode(parent);
		};
		
		function computeEffectiveLinkId(node1,node2){
			var ids = [ node1.id, node2.id ];
			ids.sort();
			return ids.join('_to_');
		};
		
		/*
		 * cluster1 adopts all the fragments from cluster2
		 */
		function adoptFragments(cluster1, cluster2){
			if( !cluster1 || !cluster2 ) return;
			
			if( !cluster1.fragments ){
				cluster1.fragments = {};
			};

			if( !cluster2.fragments ) return;
			
			for(var fragId in cluster2.fragments){
				var frag = cluster2.fragments[fragId];
				cluster1.fragments[fragId] = frag;
			};
		};
	},
	
	_refreshEffectiveLinkIntent: function(effectiveElement){
		// On links, all elements must be selected for the link to
		// be selected. Start assuming that the link is selected. If any
		// element is not selected, then turn off selection
		effectiveElement.n2_selected = true;
		effectiveElement.n2_selectedIntent = undefined;
		effectiveElement.n2_hovered = true;
		effectiveElement.n2_hoveredIntent = undefined;
		effectiveElement.n2_found = true;
		effectiveElement.n2_intent = undefined;
		
		var atLeastOneElement = false;
		if( effectiveElement.elementIds ){
			for(var i=0,e=effectiveElement.elementIds.length; i<e; ++i){
				var elemId = effectiveElement.elementIds[i];
				var elem = this.elementsById[elemId];
				
				if( elem ){
					atLeastOneElement = true;
					
					if( !elem.n2_selected ){
						effectiveElement.n2_selected = false;
					};
					if( !elem.n2_hovered ){
						effectiveElement.n2_hovered = false;
					};
					if( !elem.n2_found ){
						effectiveElement.n2_found = false;
					};
					if( elem.n2_selectedIntent ){
						if( effectiveElement.n2_selectedIntent === null ){
							// collision
						} else if( effectiveElement.n2_selectedIntent === undefined ){
							effectiveElement.n2_selectedIntent = elem.n2_selectedIntent;
						} else {
							effectiveElement.n2_selectedIntent = null;
						};
					};
					if( elem.n2_hoveredIntent ){
						if( effectiveElement.n2_hoveredIntent === null ){
							// collision
						} else if( effectiveElement.n2_hoveredIntent === undefined ){
							effectiveElement.n2_hoveredIntent = elem.n2_hoveredIntent;
						} else {
							effectiveElement.n2_hoveredIntent = null;
						};
					};
					if( elem.n2_intent ){
						if( effectiveElement.n2_intent === null ){
							// collision
						} else if( effectiveElement.n2_intent === undefined ){
							effectiveElement.n2_intent = elem.n2_intent;
						} else {
							effectiveElement.n2_intent = null;
						};
					};
				};
			};
		};
		
		// It is not selected if not associated with any element
		if( !atLeastOneElement ){
			effectiveElement.n2_selected = false;
			effectiveElement.n2_hovered = false;
			effectiveElement.n2_intent = false;
		};
		
		// Turn off intent if not selected
		if( !effectiveElement.n2_selected ){
			effectiveElement.n2_selectedIntent = undefined;
		};
		if( !effectiveElement.n2_hovered ) {
			effectiveElement.n2_hoveredIntent = undefined;
		};
		if( !effectiveElement.n2_found ){
			effectiveElement.n2_intent = undefined;
		};
	},
	
	_computeDerivedIntent: function(changedNodeMap, changedLinkMap){
 		// Count number of visible nodes selected and hovered.
 		var nodesSelectedCount = 0;
		var nodesHoveredCount = 0;
		for(var elemId in this.effectiveElementsById){
			var elem = this.effectiveElementsById[elemId];
			if( elem.isNode ){
				if( elem.n2_selected ){
					++nodesSelectedCount;
				};
				if( elem.n2_hovered ){
					++nodesHoveredCount;
				};
			};
		};

 		// Compute derived selection and hover
		for(var elemId in this.effectiveElementsById){
			var elem = this.effectiveElementsById[elemId];
			
			if( elem.isLink ){
				// If a link is selected, both associated nodes
				// are selected (derived)
				if( elem.n2_selected ){
					elem.source.temp_selected = true;
					elem.target.temp_selected = true;
				};
				
				// If a link is hovered, both associated nodes
				// are hovered (derived)
				if( elem.n2_hovered ){
					elem.source.temp_hovered = true;
					elem.target.temp_hovered = true;
				};

				// If a link is associated with a node which is the sole node selected,
				// then both the link and the other node are selected (derived)
				if( elem.source.n2_selected 
				 && nodesSelectedCount < 2 ){
					elem.temp_selected = true;
					elem.target.temp_selected = true;
				};
				if( elem.target.n2_selected 
				 && nodesSelectedCount < 2 ){
					elem.temp_selected = true;
					elem.source.temp_selected = true;
				};

				// If a link is associated node which is the sole node hovered,
				// then both the link and the other node are hovered (derived)
				if( elem.source.n2_hovered 
				 && nodesHoveredCount < 2 ){
					elem.temp_hovered = true;
					elem.target.temp_hovered = true;
				};
				if( elem.target.n2_hovered 
				 && nodesHoveredCount < 2 ){
					elem.temp_hovered = true;
					elem.source.temp_hovered = true;
				};
			};
		};

 		// Detect changes in derived selection and hover
		for(var elemId in this.effectiveElementsById){
			var elem = this.effectiveElementsById[elemId];
			
			if( elem.n2_derived_selected !== elem.temp_selected ){
				elem.n2_derived_selected = elem.temp_selected;
				if( elem.isLink ){
					changedLinkMap[elem.id] = elem;
				} else if( elem.isNode ){
					changedNodeMap[elem.id] = elem;
				};
			};
			
			if( elem.n2_derived_hovered !== elem.temp_hovered ){
				elem.n2_derived_hovered = elem.temp_hovered;
				if( elem.isLink ){
					changedLinkMap[elem.id] = elem;
				} else if( elem.isNode ){
					changedNodeMap[elem.id] = elem;
				};
			};
		};
	},
	
	_intentChanged: function(changedElements){
		// Reset all temp variables
		for(var elemId in this.effectiveElementsById){
			var elem = this.effectiveElementsById[elemId];
			elem.temp_hovered = false;
			elem.temp_selected = false;
		};

		// Keep track of modified nodes and links
		var nodeMap = {};
 		var linkMap = {};

		// Update effective elements from the ones received from the element generator
		var effectiveIdsToUpdate = {};
		for(var i=0,e=changedElements.length; i<e; ++i){
			var changedElement = changedElements[i];
			var changedElementId = changedElement.id;
			var changedEffectiveElementId = this.elementToEffectiveId[changedElementId];
			if( changedEffectiveElementId ){
				effectiveIdsToUpdate[changedEffectiveElementId] = true;
			} else {
				effectiveIdsToUpdate[changedElementId] = true;
			};
		};
		for(var changedEffectiveElementId in effectiveIdsToUpdate){
			var effectiveElement = this.effectiveElementsById[changedEffectiveElementId];
			if( effectiveElement ){
				if( effectiveElement.isNode ){
	 				nodeMap[effectiveElement.id] = effectiveElement;
				} else if( effectiveElement.isLink ){
					this._refreshEffectiveLinkIntent(effectiveElement);
	 				linkMap[effectiveElement.id] = effectiveElement;
				};
			};
		};

		// Compute derived intent
		this._computeDerivedIntent(nodeMap, linkMap);

 		// Convert node map into a node array
 		var nodes = [];
 		for(var nodeId in nodeMap){
			nodes.push( nodeMap[nodeId] );
 		};

 		// Convert link map into a link array
 		var links = [];
 		for(var linkId in linkMap){
			links.push( linkMap[linkId] );
 		};

 		// Update style on nodes
 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(nodes, function(node){ return node.id; });
 		this._adjustElementStyles(selectedNodes);

// 		var selectedControls = this._getSvgElem().select('g.controls').selectAll('.control')
//			.data(nodes, function(node){ return node.id; });
// 		this._adjustElementStyles(selectedControls);

 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(nodes, function(node){ return node.id; });
		this._adjustElementStyles(selectedLabels);

		if( this.arcOptions.show ){
	 		var selectedArcs = this._getSvgElem().select('g.arcs').selectAll('.arc')
				.data(nodes, function(node){ return node.id; });
			this._adjustElementStyles(selectedArcs);
		};

 		// Update style on links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(links, function(link){ return link.id; });
 		this._adjustElementStyles(selectedLinks, true);
 		
 		this._reOrderElements();
	},
	
	_reOrderElements: function(){
 		// Re-order the lines so that hovered are above selected, and selected are above
 		// regular
 		this._getSvgElem()
 			.select('g.links')
 			.selectAll('.link')
			.data(this.displayedLinks, function(link){ return link.id; })
			.filter(function(l){return l.n2_selected;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;
 		this._getSvgElem()
			.select('g.links')
			.selectAll('.link')
			.data(this.displayedLinks, function(link){ return link.id; })
			.filter(function(l){return l.n2_found;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;
 		this._getSvgElem()
			.select('g.links')
			.selectAll('.link')
			.data(this.displayedLinks, function(link){ return link.id; })
			.filter(function(l){return l.n2_hovered;})
			.each(function(l){
	 			var svgLink = this;
	 			svgLink.parentNode.appendChild(svgLink);
	 		})
			;

 		// Re-order the arcs so that hovered are above found, found are above
 		// selected, and selected are above regular
 		this._getSvgElem()
 			.select('g.arcs')
 			.selectAll('.arc')
			.data(this.displayedNodesSorted, function(n){ return n.id; })
			.filter(function(n){return n.n2_selected;})
			.each(function(n){
	 			var elem = this;
	 			elem.parentNode.appendChild(elem);
	 		})
			;
 		this._getSvgElem()
			.select('g.arcs')
			.selectAll('.arc')
			.data(this.displayedNodesSorted, function(n){ return n.id; })
			.filter(function(n){return n.n2_found;})
			.each(function(n){
	 			var elem = this;
	 			elem.parentNode.appendChild(elem);
	 		})
			;
 		this._getSvgElem()
			.select('g.arcs')
			.selectAll('.arc')
			.data(this.displayedNodesSorted, function(n){ return n.id; })
			.filter(function(n){return n.n2_hovered;})
			.each(function(n){
	 			var elem = this;
	 			elem.parentNode.appendChild(elem);
	 		})
			;
	},
	
 	_documentsUpdated: function(updatedNodeData, updatedLinkData){
 		var _this = this;

 		// Circles that are used to select/hover nodes
 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(updatedNodeData, function(node){ return node.id; })
 			;

 		var createdNodes = selectedNodes.enter()
 			.append('circle')
 			.attr('class','node')
 			.attr("r", 3)
 			.attr("transform", function(d) { 
 				return "rotate(" + Degrees(d.orig_x - 90) + ")translate(" + d.y + ",0)"; 
 			})
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 				_this._magnifyLocation(d3.event);
 			})
 			.on('mousemove', function(n,i){
 				_this._magnifyLocation(d3.event);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdNodes);

 		selectedNodes.exit().remove();

 		// Elements that are used to expand/collapse nodes
// 		var controlData = updatedNodeData.filter(function(node){
//			return node.children ? (node.children.length > 0) : false;
//		});
// 		var selectedControls = this._getSvgElem().select('g.controls').selectAll('.control')
// 			.data(controlData, function(node){ return node.id; })
// 			;
//
// 		var createdControls = selectedControls.enter()
// 			.append('circle')
// 			.attr('class','control')
// 			.attr("r", 3)
// 			.attr("transform", function(d) { 
// 				return "rotate(" + Degrees(d.orig_x - 90) + ")translate(" + (d.y + 10) + ",0)"; 
// 			})
// 			.on('click', function(n,i){
// 				_this._initiateExpandCollapse(n);
// 			})
// 			.on('mouseover', function(n,i){
// 				_this._initiateMouseOver(n);
// 				_this._magnifyLocation(d3.event);
// 			})
// 			.on('mousemove', function(n,i){
// 				_this._magnifyLocation(d3.event);
// 			})
// 			.on('mouseout', function(n,i){
// 				_this._initiateMouseOut(n);
// 			})
// 			;
// 		this._adjustElementStyles(createdControls);
//
// 		selectedControls.exit().remove();
//
// 		this._adjustElementStyles(selectedControls);

 		// Labels that name the nodes
 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(updatedNodeData, function(node){ return node.id; });

 		var createdLabels = selectedLabels.enter()
 			.append(function(){
 				var args = arguments;
 				return this.ownerDocument.createElementNS(this.namespaceURI, "text");
 			})
 			.attr('class','label')
 			.attr("dy", ".31em")
 			.attr("transform", function(d) { 
 				return "rotate(" + Degrees(d.orig_x - 90) + ")translate(" + (d.y + 6) + ",0)" 
 					+ (d.orig_x < 180 ? "" : "rotate(180)"); 
 			})
 			.style("text-anchor", function(d) { 
 				return d.orig_x < 180 ? "start" : "end"; 
 			})
 			.text(function(d) { 
 				return "";
 			})
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 				_this._initiateExpandCollapse(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 				_this._magnifyLocation(d3.event);
 			})
 			.on('mousemove', function(n,i){
 				_this._magnifyLocation(d3.event);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdLabels);
 		
 		selectedLabels.exit().remove();

		this._adjustElementStyles(selectedLabels);

		// Elements that are used to draw arcs to show parent/children relationship
		if( this.arcOptions.show ){
			var arcData = updatedNodeData.filter(function(node){
				return (typeof node.showArc === 'boolean') ? node.showArc : false;
			});
	 		var selectedArcs = this._getSvgElem().select('g.arcs').selectAll('.arc')
	 			.data(arcData,function(node){ return node.id; });
	
	 		var createdArcs = selectedArcs.enter()
	 			.append('path')
	 			.attr('class','arc')
	 			.on('click', function(n,i){
	 				_this._initiateMouseClick(n);
	 				_this._initiateExpandCollapse(n);
	 			})
	 			.on('mouseover', function(n,i){
	 				_this._initiateMouseOver(n);
	 				_this._magnifyLocation(d3.event);
	 			})
	 			.on('mousemove', function(n,i){
	 				_this._magnifyLocation(d3.event);
	 			})
	 			.on('mouseout', function(n,i){
	 				_this._initiateMouseOut(n);
	 			})
	 			;
	 		this._adjustElementStyles(createdArcs);
	
	 		selectedArcs.exit().remove();
	
	 		this._adjustElementStyles(selectedArcs);
		};

		// Links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(updatedLinkData, function(link){ return link.id; });

 		var createdLinks = selectedLinks.enter()
 			.append('path')
 			.attr('class','link')
// 			.attr('d',function(link){ return _this.line(link.path); })
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;
 		this._adjustElementStyles(createdLinks, true);
 		
 		selectedLinks.exit()
 			.remove();
 		
 		this._adjustElementStyles(selectedLinks, true);

 		// Position everything around the circle
 		this._positionElements();

 		// Re-order links
 		this._reOrderElements();
 	},
 	
 	_adjustElementStyles: function(selectedElements, elementsAreLinks){
 		var _this = this;
 		selectedElements.each(function(n,i){
 			n.n2_elem = this;
 			var symbolizer = _this.styleRules.getSymbolizer(n);
 			symbolizer.adjustSvgElement(this,n);
 			delete n.n2_elem;
 		});
 		
 		if( elementsAreLinks ){
 			selectedElements.attr('fill','none');
 		};
 	},
 	
 	_sourceModelUpdated: function(opts_){
 		this.elementGenerator.sourceModelUpdated(opts_);
 	},
	
	_focusAngleFromLocation: function(x,y){
		var angle = null;
		
		var effX = x - this.dimensions.cx;
		var effY = this.dimensions.cy - y;
		if( 0 == effX && 0 == effY){
			return null;
			
		} else if( 0 == effY ){
			if( effX < 0 ){
				angle = -90;
			} else {
				angle = 90;
			}
		} else {
			angle = Degrees.atan(effX / effY);
			if( effY < 0 ){
				angle += 180;
			};
			if( angle > 360 ){
				angle = angle - 360;
			};
		};

		return angle;
	},
 	
 	_magnifyLocation: function(e){
 		var m = null;

 		try {
 			var $svg = this._getSvgElem();
 			var svgNode = $svg[0][0];
			var svgCTM = svgNode.getScreenCTM();
			m = svgCTM.inverse();
		} catch(e) {
			// ignore
		};
		
		if( m ){
			var x = (e.clientX * m.a) + (e.clientY * m.c) + m.e;
			var y = (e.clientX * m.b) + (e.clientY * m.d) + m.f;
			
			var focusAngle = this._focusAngleFromLocation(x,y);
			//$n2.log('focusAngle:'+focusAngle);
			
			if( null !== focusAngle ){
		 		this.magnify.angle(focusAngle);
		 		
		 		this._positionElements();
			};
		};
 	},
 	
 	_magnifyOut: function(){
		this.magnify.angle(null);
		this._positionElements();
 	},
 	
 	_positionElements: function(){
 		var _this = this;
 		
 		var magnifyEnabled = this.magnifyOptions.enabled;
 		if( magnifyEnabled 
 		 && typeof this.magnifyThresholdCount === 'number' 
 		 && this.magnifyThresholdCount > this.displayedNodesSorted.length ){
 			magnifyEnabled = false;
 		};
 		
 		var changedNodes = [];
 		for(var i=0,e=this.displayedNodesSorted.length; i<e; ++i){
 			var node = this.displayedNodesSorted[i];

 			node.transitionNeeded = false;
 			var m = null;

 			if( magnifyEnabled ){
 	 			m = magnifyNode(node);
 	 			
 			} else {
 				m = {};
 				m.x = node.orig_x;
 				m.z = 1;

 				if( typeof node.xMax === 'number' ){
 	 				m.xArcStart = node.xMin - (node.xIndent / 2);
 	 				m.xArcEnd = node.xMax + (node.xIndent / 2);
 	 			};
 			};

 			var changed = false;
 			if( assignToNode(node, 'x', m.x) ){
 				changed = true;
 			};
 			if( assignToNode(node, 'z', m.z) ){
 				changed = true;
 			};
 			if( assignToNode(node, 'xArcStart', m.xArcStart) ){
 				changed = true;
 			};
 			if( assignToNode(node, 'xArcEnd', m.xArcEnd) ){
 				changed = true;
 			};
			
			if( changed ){
 				node.transitionNeeded = true;
 				changedNodes.push(node);
			};
 		};
 		
		// Animate the position of the nodes around the circle
 		var changedPoints = this._getSvgElem().select('g.nodes').selectAll('.node')
			.data(changedNodes, function(node){ return node.id; });
 		
		changedPoints
			.transition()
			.duration(this.transitionDuration)
			.attr("transform", function(d) { 
				return "rotate(" + (d.x - 90) 
					+ ")translate(" + d.y + ",0)"; 
			})
			;
 		
 		this._adjustElementStyles(changedPoints);

		// Animate the position of the controls around the circle
// 		var changedControls = this._getSvgElem().select('g.controls').selectAll('.control')
//			.data(changedNodes, function(node){ return node.id; });
// 		
// 		changedControls
// 			.transition()
//			.duration(this.transitionDuration)
//			.attr("transform", function(d) { 
//				return "rotate(" + (d.x - 90) 
//					+ ")translate(" + (d.y + 10) + ",0)"; 
//			})
//			;
// 		
// 		this._adjustElementStyles(changedControls);

		// Animate the position of the labels around the circle
 		var changedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(changedNodes, function(node){ return node.id; })
			;
 		
		changedLabels
			.transition()
			.duration(this.transitionDuration)
			.attr("transform", function(d) { 
				return "rotate(" + (d.x - 90) 
					+ ")translate(" + (d.y + 6) + ",0)" 
					+ (d.x < 180 ? "" : "rotate(180)"); 
			})
 			.style("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			;
 		
 		this._adjustElementStyles(changedLabels);

 		// Animate the position of the arcs around the circle
		if( this.arcOptions.show ){
	 		var changedArcs = this._getSvgElem().select('g.arcs').selectAll('.arc')
				.data(changedNodes, function(node){ return node.id; });
	 		
	 		var arcOffset = this.arcOptions.offset;
	 		var arcExtent = this.arcOptions.extent;
	 		
	 		changedArcs
	 			.transition()
				.duration(this.transitionDuration)
		 		.attr('transform', function(d) { 
					return 'rotate(-90)';
				})
				.attr('d', function(d) {
					var innerRadius = d.y + arcOffset;
					var outerRadius = d.y + arcOffset + arcExtent;
					var angleExtent = Degrees(d.xArcEnd - d.xArcStart);
					
					var x1 = innerRadius * Degrees.cos(d.xArcStart);
					var y1 = innerRadius * Degrees.sin(d.xArcStart);
					
					var x2 = innerRadius * Degrees.cos(d.xArcEnd);
					var y2 = innerRadius * Degrees.sin(d.xArcEnd);
					
					var x3 = outerRadius * Degrees.cos(d.xArcEnd);
					var y3 = outerRadius * Degrees.sin(d.xArcEnd);
	
					var x4 = outerRadius * Degrees.cos(d.xArcStart);
					var y4 = outerRadius * Degrees.sin(d.xArcStart);
	
					// A rx ry x-axis-rotation large-arc-flag sweep-flag x y
					var path = [
					   'M', x1, y1
					   ,'A', innerRadius, innerRadius, '0'
					   ,(angleExtent > 180 ? '1' : '0') // large arc
					   ,'1', x2, y2
					   ,'L', x3, y3
					   ,'A', outerRadius, outerRadius, '0'
					   ,(angleExtent > 180 ? '1' : '0') // large arc
					   ,'0', x4, y4
					   ,'Z'
					].join(' ');
					return path;
				})
				;
	 		
	 		this._adjustElementStyles(changedArcs);
		};

 		// Animate links
 		this._getSvgElem().select('g.links').selectAll('.link')
			.data(this.displayedLinks, function(link){ return link.id; })
			.filter(function(link){
				if( link.source.transitionNeeded ) return true;
				if( link.target.transitionNeeded ) return true;
				return false;
			})
			.transition()
			.duration(this.transitionDuration)
			.attr('d',function(link){ 
				return _this.line(link.path); 
			})
			;
 		
 		function magnifyNode(n){
 			var m = _this.magnify(n);
 			
 			if( typeof n.xMin === 'number' ){
 				m.xArcStart = _this.magnify.compute(
 					n.xMin - (n.xIndent / 2)
				).x;
 			};
 	 		if( typeof n.xMax === 'number' ){
 				m.xArcEnd = _this.magnify.compute(
 					n.xMax + (n.xIndent / 2)
				).x;
 			};
 			
 			return m;
 		};

 		function assignToNode(node, attrName, value, resolution){
 			var current = node[attrName];
 			
 			if( typeof current !== typeof value ){
 				node[attrName] = value;
 				return true;
 			};
 			
 			if( typeof current === 'number' 
 			 && typeof resolution === 'number' ){
 	 			var delta = Math.abs(value - current);
 				if( delta > resolution ){
 	 				node[attrName] = value;
 	 				return true;
 				};
 			} else {
 				if( current != value ){
 	 				node[attrName] = value;
 	 				return true;
 				};
 			};
 			
 			return false;
 		};
 	},
 	
 	_initiateBackgroundMouseClick: function(){
		this.lastElementIdSelected = null;
 		this.dispatchService.send(DH,{
 			type: 'userUnselect'
 		});
// 		if( this.lastElementIdSelected ){
// 			this.elementGenerator.selectOff(this.lastElementIdSelected);
// 			this.lastElementIdSelected = null;
// 		};
 	},
 	
 	_initiateExpandCollapse: function(elementData){
 		var _this = this;

 		// No collapse/expand on nodes that do not have children
 		if( !elementData.children ){
 			return;
 		};
 		if( elementData.children.length < 1 ){
 			return;
 		};
 		
 		// Canvas is being interacted with. Ignore outside
 		// selection
 		this.outsideSelectionDocIdMap = null;
 		
 		var elementId = elementData.id;
 		if( this.expandedNodesById[elementId] ){
 			// Collapse
 	 		this.fixOriginOnNode = {
 	 			id: elementData.id
 	 			,position: Degrees(elementData.orig_x - this.originAngle)
 	 		};
 	 	 		
 			delete this.expandedNodesById[elementId];

 		} else {
 			// If expanding a node and the node is part of a group,
 			// then collapse all nodes associated with the same group
 			var groupName = elementData.group;
 			if( groupName ){
 				var groupElems = this.elementsByGroup[groupName];
 				if( groupElems ){
 					for(var i=0,e=groupElems.length; i<e; ++i){
 						var groupNode = groupElems[i];
 						if( groupNode.id !== elementData.id 
 						 && this.expandedNodesById[groupNode.id] ){
 							// Collapse this node
 							if( this.collapseBeforeExpand ){
 	 							// In this option, the node is collapsed before the
 								// new one is expanded
 	 							this._initiateExpandCollapse(groupNode);
 	 							window.setTimeout(
 	 								function(){
 	 									_this._initiateExpandCollapse(elementData);
 	 								}
 	 								,this.transitionDuration
 	 							);
 	 							return;
 							} else {
 								// Mark as collapsed
 	 							delete this.expandedNodesById[groupNode.id];
 							};
 						};
 					};
 				};
 			};

 	 		this.fixOriginOnNode = {
 	 			id: elementData.id
 	 			,position: Degrees(elementData.orig_x - this.originAngle)
 	 		};

 	 		this.expandedNodesById[elementId] = true;
 		};
 		
 		// Need to initiate redrawing
 		this._redraw();
 	},
 	
 	_initiateMouseClick: function(elementData){
 		var elementId = elementData.id;
 		if( this.toggleSelection 
 		 && this.lastElementIdSelected === elementId ){
 			this.elementGenerator.selectOff(elementData);
 			this.lastElementIdSelected = null;
 		} else {
 			this.elementGenerator.selectOn(elementData);
 			this.lastElementIdSelected = elementId;
 		};
 	},
 	
 	_initiateMouseOver: function(elementData){
 		var elementId = elementData.id;
 		if( elementId !== this.currentMouseOver ){
 			// Focus Off before Focus On
 			if( this.currentMouseOver ){
 	 			this.elementGenerator.focusOff(this.currentMouseOver);
 				this.currentMouseOver = null;
 			};
 			
 			this.elementGenerator.focusOn(elementData);
 			this.currentMouseOver = elementId;
 		};
 	},
 	
 	_initiateMouseOut: function(elementData){
 		var elementId = elementData.id;
 		if( elementId === this.currentMouseOver ){
 			this.elementGenerator.focusOff(elementData);
			this.currentMouseOver = null;
 		};
 	},
 	
 	_findElements: function(elements){
 		var _this = this;
 		
 		var redrawRequired = false;
 		
 		for(var i=0,e=elements.length; i<e; ++i){
 			var element = elements[i];
 			if( element.isNode && !element.canvasVisible ){
 				Tree.visitParents(element, function(n){
 					// Skip root
 					if( n.parent ){
 						if( !n.expanded ){
 							// This node needs to be expanded
 							_this.expandedNodesById[n.id] = true;
 							redrawRequired = true;
 						};
 					};
 				});
 			};
 		};
 		
 		if( redrawRequired ){
 			this._redraw();
 		};
 	},
 	
 	_selectionChanged: function(docIdMap){
 		var _this = this;

		this.fixOriginOnNode = null;

 		this.outsideSelectionDocIdMap = docIdMap;

 		this._redraw();
 	},
 	
 	_handleDispatch: function(m){
 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._sourceModelUpdated(m.state);
 				};
 			};
 			
 		} else if( 'windowResized' === m.type ) {
 			this.resizeGraph();
 			
 		} else if( 'findIsAvailable' === m.type ) {
			var doc = m.doc;
			var docId = doc._id;
 			
 			if( this.elementsByDocId[docId] ){
 				m.isAvailable = true;
 			};
 		} else if( 'find' === m.type ) {
 			// If elements are associated with the found document
 			// expand nodes to make found document visible
 			var docId = m.docId;
 			
 			var elements = undefined;
 			if( docId ){
 				elements = this.elementsByDocId[docId];
 			};
 			
 			if( elements ){
				this._findElements(elements);
 			};
 		};
 	},
 	
 	_getModelInfo: function(){
 		var info = {
 			modelId: this.modelId
 			,modelType: 'collapsibleRadialTreeCanvas'
 			,parameters: []
 		};
 		
 		return info;
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){

	if( m.canvasType === 'collapsibleRadialTree' ){
		// Required library: d3
		if( window && window.d3 ) {
			m.isAvailable = true;
		} else {
			$n2.log('Canvas collapsibleRadialTree requires d3 library');
		};
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'collapsibleRadialTree' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new CollapsibleRadialTreeCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasCollapsibleRadialTree = {
	CollapsibleRadialTreeCanvas: CollapsibleRadialTreeCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasGrid.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasGrid'
 ;

// --------------------------------------------------------------------------
/* 
This canvas displays a grid of elements provided by an element generator. The original purpose 
for this canvas is to provide a simple way to display a photo grid which are referenced linked 
to specific documents.  

The attribute for each grid cell is described here:
 - 	id: String. Unique identifier for this element
 -  sort: Optional String. Used to sort the cells in the grid.
 -  fragments: Map map of fragments that make this element. Gives a list of
               documents used to make up this element.
 - 	gridImage: an object which contains two properties (doc and attachment) to provide the required 
 	information for the insertMediaView show service. 
 	- gridImage.doc: provides the doc id of the image
	- gridImage.attachement: provided the filename of the attachment
*/
var GridCanvas = $n2.Class('GridCanvas',{

	canvasId: null,

	sourceModelId: null,
	
	refreshIntervalInMs: null,

	elementGenerator: null,
 
	dispatchService: null,

	showService: null,

	elementsById: null,
	
	sortedElements: null,

	intentView: null,
 
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,sourceModelId: null
			,refreshIntervalInMs: 200
			,elementGenerator: null
			,config: null
			,moduleDisplay: null
			,elemIdToDocId: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
		
		try {
			this.canvasId = opts.canvasId;
			this.sourceModelId = opts.sourceModelId;
			this.refreshIntervalInMs = opts.refreshIntervalInMs;
			this.elementGenerator = opts.elementGenerator;
	
			var config = opts.config;
			if( config ){
				if( config.directory ){
					this.dispatchService = config.directory.dispatchService;
					this.showService = config.directory.showService;
				};
			};
		
			this.elementsById = {};
			this.sortedElements = [];
			
	 		// Element generator
	 		if( this.elementGenerator ){
				this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
					_this._elementsChanged(added, updated, removed);
				});
				this.elementGenerator.setIntentChangedListener(function(updated){
					_this._intentChanged(updated);
				});
	 		};
	
	 		// Register to events
	 		if( this.dispatchService ){
	 			var f = function(m){
	 				_this._handleDispatch(m);
	 			};
	 			
	 			this.dispatchService.register(DH,'modelGetInfo',f);
	 			this.dispatchService.register(DH,'modelStateUpdated',f);
	 			this.dispatchService.register(DH,'windowResized',f);
	 			this.dispatchService.register(DH,'canvasGridRefresh',f);
	 		};
	 		
	 		this._createGrid();
	
	 		$n2.log(this._classname,this);
	 		
		} catch(e) {
			var error = new Error('Unable to create '+this._classname+': '+err);
			opts.onError(error);
		};
 		
 		opts.onSuccess();
 	},

	_getElem: function(){
		var $elem = $('#'+this.canvasId);
		if( $elem.length < 1 ){
			return undefined;
		};
		return $elem;
	},

 	_createGrid: function(){
		var _this = this;

		var $elem = this._getElem();
		if( $elem ){
			$elem
				.empty()
				.addClass('n2gridcanvas')
				.click(function(e){
					var $target = $(e.target);
					if( $target.hasClass('n2gridcanvas_cell') ){
						// Ignore
					} else if( $target.parents('.n2gridcanvas_cell').length > 0 ) {
						// Ignore
					} else {
						_this._backgroundClicked();
					};
				})
				.scroll(function(){
					_this._scrollChanged( $(this) );
					return false;
				});
		};
 	},
 
	_backgroundClicked: function(){
		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'userUnselect'
			});
		};
	},

 	_elementsChanged: function(addedElements, updatedElements, removedElements){
 		var _this = this;
 		
 		// Remove elements that are no longer there
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removed = removedElements[i];
			delete this.elementsById[removed.id];
		};
		
		// Add elements
		for(var i=0,e=addedElements.length; i<e; ++i){
			var addedElement = addedElements[i];
			this.elementsById[addedElement.id] = addedElement;
		};
		
		// Update elements
		for(var i=0,e=updatedElements.length; i<e; ++i){
			var updated = updatedElements[i];
			this.elementsById[ updated.id ] = updated;
		};

		// Keep track of elements in sorted order
		this.sortedElements = [];
		for(var elementId in this.elementsById){
			var element = this.elementsById[elementId];
			this.sortedElements.push(element);
			
			if( typeof element.sort === 'undefined' ){
				element.sort = element.id;
			};
		};
		this.sortedElements.sort(function(a,b){
			if( a.sort < b.sort ){
				return -1;
			};
			if( a.sort > b.sort ){
				return 1;
			};
			return 0;
		});
		
		this._redrawGrid();
 	},
 	
 	_intentChanged: function(updatedElements){
 		var _this = this;

 		updatedElements.forEach(function(updatedElement){
 			var cellId = _this.canvasId + '_cell_' + updatedElement.id;
 			
 			var $cell = $('#'+cellId);
 			
 			_this._adjustIntent(updatedElement, $cell);
 		});
 	},
 	
 	_adjustIntent: function(element, $cell){
 		if( element.n2_hovered ){
 			$cell.addClass('n2gridcanvas_cell_hovered');
 		} else {
 			$cell.removeClass('n2gridcanvas_cell_hovered');
 		};
 		if( element.n2_selected ){
 			$cell.addClass('n2gridcanvas_cell_selected');
 		} else {
 			$cell.removeClass('n2gridcanvas_cell_selected');
 		};
 	},
	
 	_redrawGrid: function() {
		var _this = this;
		var $elem = this._getElem();
		var $grid = $('.n2gridcanvas');
		
		$grid.empty();
		
		this.sortedElements.forEach(function(element){
			var elementId = element.id;
			
			var cellId = _this.canvasId + '_cell_' + elementId;

			// Create an empty grid cell
			var $gridCell = $('<div>')
				.attr('id', cellId)
				.addClass('n2gridcanvas_cell')
				.attr('n2-element-id', elementId)
				.appendTo($grid)
				.click(function(){
					var $cell = $(this);
					var elementId = $cell.attr('n2-element-id');
					_this._cellClicked(elementId);
				})
				.mouseover(function(){
					var $cell = $(this);
					var elementId = $cell.attr('n2-element-id');
					_this._cellMouseOver(elementId);
				})
				.mouseout(function(){
					var $cell = $(this);
					var elementId = $cell.attr('n2-element-id');
					_this._cellMouseOut(elementId);
				});
			
			_this._adjustIntent(element, $gridCell);
		});
		
		this._reloadTiles();
	},
	
	_cellClicked: function(elementId){
 		var element = this.elementsById[elementId];
 		if( this.toggleSelection 
 		 && this.lastElementIdSelected === elementId ){
 			this.elementGenerator.selectOff(element);
 			this.lastElementIdSelected = null;
 		} else {
 			this.elementGenerator.selectOn(element);
 			this.lastElementIdSelected = elementId;
 		};
	},
	
	_cellMouseOver: function(elementId){
 		var element = this.elementsById[elementId];
 		if( elementId !== this.currentMouseOverId ){
 			// Focus Off before Focus On
 			if( this.currentMouseOver ){
 	 			this.elementGenerator.focusOff(this.currentMouseOverId);
 				this.currentMouseOverId = null;
 			};
 			
 			this.elementGenerator.focusOn(element);
 			this.currentMouseOverId = elementId;
 		};
	},
	
	_cellMouseOut: function(elementId){
 		var element = this.elementsById[elementId];
 		if( elementId === this.currentMouseOverId ){
 			this.elementGenerator.focusOff(elementId);
			this.currentMouseOverId = null;
 		};
	},
	
	/*
	 * Attempts to load the content of the visible tiles
	 */
	_reloadTiles: function(){
		var _this = this;

		var $canvas = this._getElem();
		
		var canvasWidth = $canvas.width();
		var canvasHeight = $canvas.height();
		var canvasOffsetTop = $canvas.scrollTop();
		var canvasOffsetLeft = $canvas.scrollLeft();
		
		$canvas.find('.n2gridcanvas_cell').each(function(){
			var $cell = $(this);
			
			var cellPosition = $cell.position();
			var cellHeight = $cell.height();
			var cellWidth = $cell.width();
			
			var show = true;
			if( cellPosition.top > canvasHeight ){
				show = false;
			} else if( (cellPosition.top + cellHeight) < 0 ){
				show = false;
			} else if( cellPosition.left > canvasWidth ){
				show = false;
			} else if( (cellPosition.left + cellWidth) < 0 ){
				show = false;
			};
			
			if( show ){
				if( $cell.hasClass('n2gridcanvas_cell_show') ){
					// Already done
				} else {
					_this._displayTile($cell);
					$cell.addClass('n2gridcanvas_cell_show');
				};
			} else {
				if( $cell.hasClass('n2gridcanvas_cell_show') ){
					$cell.empty().removeClass('n2gridcanvas_cell_show');
				};
			};
		});
	},
	
	_displayTile: function($cell){
		var elementId = $cell.attr('n2-element-id');
		var element = this.elementsById[elementId];
		
		if( element ){
			$cell.empty();

			var $gridCellImage = $('<div>')
				.addClass('n2gridcanvas_cell_image')
				.appendTo($cell);
			
			var $gridCellLabel = $('<div>')
				.addClass('n2gridcanvas_cell_label')
				.appendTo($cell);
						
			// Add image to grid cell if available
			if( element.gridImage ){
				var cellImage = element.gridImage;
				var $GridImage = $('<span>')
				.attr('class','n2s_insertMediaView')
				.attr('nunaliit-document',cellImage.doc)
				.attr('nunaliit-attachment',cellImage.attachment)
				.appendTo($gridCellImage);
			};
		
			// Add label to grid cell if available
			if ( this.elementsById[elementId].id ){
				var $GridLabel = $('<span>')
				.attr('class','n2s_briefDisplay')
				.attr('nunaliit-document',element.id)
				.appendTo($gridCellLabel);
			};

			this.showService.fixElementAndChildren($cell);
		};
	},

	_scrollChanged: function( $canvas ){
		var _this = this;
		
		var scrollTop = $canvas.scrollTop();
		var scrollLeft = $canvas.scrollLeft();

		// Wait a bit before loading images
		this.lastScrollTop = scrollTop;
		this.lastScrollLeft = scrollLeft;
		window.setTimeout(function(){
			if( _this.lastScrollTop === scrollTop 
			 && _this.lastScrollLeft === scrollLeft ){
				_this._reloadTiles();
			};
		},this.refreshIntervalInMs);
	},
 	
 	_sourceModelUpdated: function(state){
 		this.elementGenerator.sourceModelUpdated(state);
 	},

 	_handleDispatch: function(m){
 		var _this = this;

 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._sourceModelUpdated(m.state);
 				};
 			};

 		} else if( 'windowResized' === m.type ) {
 			window.setTimeout(function(){
 	 			_this._reloadTiles();
 			},this.refreshIntervalInMs);

 		} else if( 'canvasGridRefresh' === m.type ) {
 			window.setTimeout(function(){
 	 			_this._reloadTiles();
 			},this.refreshIntervalInMs);
 		};
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	if( m.canvasType === 'grid' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'grid' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
 		if( !options.elementGenerator ){
 			// If not defined, use the one specified by type
 			options.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: options.elementGeneratorType
 	 			,options: options.elementGeneratorOptions
 	 			,config: m.config
 	 		});
 		};
 		
		options.canvasId = m.canvasId;
		options.config = m.config;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new GridCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasGrid = {
	GridCanvas: GridCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasPack.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasPack'
 ;
 
var $d = undefined;
 
// --------------------------------------------------------------------------
var PackCanvas = $n2.Class({

	canvasId: null,
 	
	interactionId: null,
 	
	svgId: null,
 	
	modelId: null,
 	
	dispatchService: null,

	sourceModelId: null,
 	
	moduleDisplay: null,
 	
	background: null,
	
	toggleSelection: null,
	
	pack: null,
	
	line: null,
 	
	styleRules: null,

	elementsById: null,
	
	elementGenerator: null,
 	
	currentMouseOver: null,

	lastElementIdSelected: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,interactionId: null
			,config: null
			,moduleDisplay: null
			,sourceModelId: null
			,background: null
			,styleRules: null
			,toggleSelection: true
			,elementGeneratorType: 'default'
			,elementGeneratorOptions: null
			,elementGenerator: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
 	
		this.canvasId = opts.canvasId;
		this.interactionId = opts.interactionId;
		this.moduleDisplay = opts.moduleDisplay;
		this.sourceModelId = opts.sourceModelId;
		this.background = opts.background;
		this.toggleSelection = opts.toggleSelection;
		this.elementGenerator = opts.elementGenerator;
 		
		this.modelId = $n2.getUniqueId('canvasPack');
 		
		this.styleRules = $n2.styleRule.loadRulesFromObject(opts.styleRules);
 		
		var config = opts.config;
		if( config ){
			if( config.directory ){
				this.dispatchService = config.directory.dispatchService;
			};
		};

 		this.elementsById = {};
 		this.currentMouseOver = null;
 		this.lastElementIdSelected = null;
 		this.focusInfo = null;
 		this.selectInfo = null;

 		// Element generator
 		if( !this.elementGenerator ){
 			// If not defined, use the one specified by type
 	 		this.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: opts.elementGeneratorType
 	 			,options: opts.elementGeneratorOptions
 	 			,config: opts.config
 	 		});
 		};
 		if( this.elementGenerator ){
			this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
				_this._elementsChanged(added, updated, removed);
			});
			this.elementGenerator.setIntentChangedListener(function(updated){
				_this._intentChanged(updated);
			});
 		};
 		
 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m){
 				_this._handleDispatch(m);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 		};
 		
 		this.createGraph();

 		var graphSize = this.getGraphSize();
 		this.pack = d3.layout.pack()
	 	    .size(graphSize)
	 	    .value(function(d) { return d.size; })
	 	    .padding(25);
 		
 		this.line = d3.svg.line()
 			.x(function(d){ return d.x; })
 			.y(function(d){ return d.y; })
 			.interpolate('basis');
 		
 		opts.onSuccess();

 		if( this.sourceModelId ){
 			if( this.dispatchService ){
 				var msg = {
 					type: 'modelGetState'
 					,modelId: this.sourceModelId
 					,state: null
 				};
 				this.dispatchService.synchronousCall(DH,msg);
 				if( msg.state ){
 					this._sourceModelUpdated(msg.state);
 				};
 			};
 		};

 		$n2.log('PackCanvas',this);
 	},
 	
 	createGraph: function() {
 		var _this = this; // for use in callbacks

 		if( this.background 
 		 && typeof this.background.color === 'string' ){
 			var $canvas = $('#' + this.canvasId);
 			$canvas.css('background-color',this.background.color);
 		};
 		
 		this.svgId = $n2.getUniqueId();
 		var $svg = $d.select('#' + this.canvasId)
 			.append('svg')
 			.attr('id',this.svgId);
 		
 		var $rootGroup = $svg.append('g')
			.attr('class','packRoot')
			;

		$rootGroup.append('g')
 			.attr('class','backnodes');

		$rootGroup.append('g')
 			.attr('class','links');

		$rootGroup.append('g')
			.attr('class','forenodes');

 		
 		this.resizeGraph();
 	},
 	
 	getGraphSize: function() {
 		var $canvas = $('#' + this.canvasId);
 		
 		var width = $canvas.width();
 		var height = $canvas.height();
 		
 		/*
 		 * apply minimum sizes
 		 */
// 		if (width < this.options.sizes.canvas_min.width) {
// 			width = this.options.sizes.canvas_min.width;
// 		};
// 		if (height < this.options.sizes.canvas_min.height) {
// 			height = this.options.sizes.canvas_min.height;
// 		};
 		return [width, height];
 	},
 	
 	resizeGraph: function() {
 		var size = this.getGraphSize();
 		
 		var $svg = this._getSvgElem()
 			.attr('width', size[0])
 			.attr('height', size[1]);
 		
 		var $rootGroup = $svg.select('g.packRoot')
			;
 		
 		var minDim = size[0];
 		if( minDim > size[1] ){
 			minDim = size[1];
 		};
 		
 		this.canvasWidth = minDim;
 		this.radius = Math.floor( (minDim / 2) - 120 );
 		
 		this._documentsUpdated([],[],[]);
 	},
 	
 	_getSvgElem: function() {
 		return $d.select('#' + this.svgId);
 	},
	
	_elementsChanged: function(addedElements, updatedElements, removedElements){
		// Reset
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			delete elem.parent;
			delete elem.children;
			delete elem.size;
			delete elem.value;
			delete elem.depth;
			delete elem.x;
			delete elem.y;
			delete elem.r;
		};

		// Remove
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removedElement = removedElements[i];
			delete this.elementsById[removedElement.id];
		};
		
		// Add
		for(var i=0,e=addedElements.length; i<e; ++i){
			var addedElement = addedElements[i];
			this.elementsById[addedElement.id] = addedElement;
		};
		
		// Compute tree
		var root = {
			id: '__root__'
			,name: ''
			,children: []
		};
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];

			if( elem.parentId ){
				var parent = this.elementsById[elem.parentId];
				if( parent ){
					elem.parent = parent;
					if( !parent.children ){
						parent.children = [];
					};
					parent.children.push(elem);
				};
				
			} else if( null === elem.parentId ) {
				elem.parent = root;
				root.children.push(elem);
			};
		};

		// Assign a default size to leaf nodes
		function setLeafSize(node, size){
			if( !node.children ){
				node.size = size;
			} else {
				for(var i=0,e=node.children.length; i<e; ++i){
					var c = node.children[i];
					setLeafSize(c, size);
				};
			};
		};
		setLeafSize(root, 5);
		
		var nodes = this.pack.nodes(root);

		// Keep only nodes marked isNode
		var includeAll = true;
		var backNodes = [];
		var foreNodes = [];
		for(var i=0,e=nodes.length; i<e; ++i){
			var node = nodes[i];
			
			var isIncluded = false;
			if( node === root ){
				// never include root
			} else if( includeAll ) {
				isIncluded = true;
			} else if( node.isNode ){
				isIncluded = true;
			};
			
			if( isIncluded ){
				if( node.isLeaf ){
					foreNodes.push(node);
				} else {
					backNodes.push(node);
				};
			};
		};
		
		var links = [];
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.isLink ){
				elem.n2_geometry = 'line';

				if( inTree(elem.source) 
				 && inTree(elem.target) ){
					elem.path = [elem.source, elem.target];
					links.push(elem);
					$n2.log('path',elem,this.line(elem.path));
				} else {
					$n2.log('link not in tree',elem);
				};
			};
		};

		$n2.log('backnodes: '+backNodes.length + ' forenodes: '+foreNodes.length + ' links: '+links.length);
		
		this._documentsUpdated(backNodes, foreNodes, links);
		
		function inTree(n){
			if( !n ) return false;
			
			if( n === root ) return true;

			return inTree(n.parent);
		};
	},
 	
 	_documentsUpdated: function(backNodes, foreNodes, links){
 		var _this = this;
 		
 		// Back Nodes
 		var backSvg = this._getSvgElem().select('g.backnodes').selectAll('.backnode')
			.data(backNodes, function(d){ return d.id; })
			;

 		backSvg.exit()
 			.remove();

 		var addedNodes = backSvg.enter()
			.append('g')
			.attr('class','backnode')
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
			;

 		addedNodes.append('circle')
 	      ;
 		
 		var allBackSvg = this._getSvgElem().select('g.backnodes').selectAll('.backnode')
			.data(backNodes, function(d){ return d.id; })
			.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
			;
 		
 		allBackSvg.select('circle')
 	      .attr('r', function(d) { return d.r; })
 	      ;

 		this._adjustElementStyles(allBackSvg);

 		
 		// Fore Nodes
 		var foreSvg = this._getSvgElem().select('g.forenodes').selectAll('.forenode')
			.data(foreNodes, function(d){ return d.id; })
			;

 		foreSvg.exit()
 			.remove();

 		var addedNodes = foreSvg.enter()
			.append('g')
			.attr('class','forenode')
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
			;

 		addedNodes.append('circle')
 	      ;
 		
 		var allForeSvg = this._getSvgElem().select('g.forenodes').selectAll('.forenode')
			.data(foreNodes, function(d){ return d.id; })
			.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
			;
 		
 		allForeSvg.select('circle')
 	      .attr('r', function(d) { return d.r; })
 	      ;

 		this._adjustElementStyles(allForeSvg);

 		
 		// Links
 		var svgLinks = this._getSvgElem().select('g.links').selectAll('.link')
			.data(links, function(d){ return d.id; })
			;
 		
 		svgLinks.enter()
 			.append('path')
 			.attr('class','link')
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			})
 			;

 		svgLinks.exit()
			.remove()
			;

 		var allLinks = this._getSvgElem().select('g.links').selectAll('.link')
			.data(links, function(d){ return d.id; })
			.attr('d', function(d){ return _this.line(d.path); })
			;

 		this._adjustElementStyles(allLinks);
 	},
	
	_intentChanged: function(changedElements){
		// Back nodes
		var selectedNodes = this._getSvgElem().select('g.backnodes').selectAll('.backnode')
			.data(changedElements, function(d){ return d.id; });
		
		this._adjustElementStyles(selectedNodes);

 		// Fore nodes
 		var selectedNodes = this._getSvgElem().select('g.forenodes').selectAll('.forenode')
 			.data(changedElements, function(d){ return d.id; });
 		
 		this._adjustElementStyles(selectedNodes);
 		
 		// Update style on links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
			.data(changedElements, function(d){ return d.id; });

		this._adjustElementStyles(selectedLinks);
	},
 	
 	_adjustElementStyles: function(selectedElements){
 		var _this = this;
 		selectedElements.each(function(n,i){
 			n.n2_elem = this;
 			var symbolizer = _this.styleRules.getSymbolizer(n);
 			symbolizer.adjustSvgElement(this,n);
 			delete n.n2_elem;
 		});
 	},
 	
 	_dispatch: function(m){
 		var d = this.dispatchService;
 		if( d ){
 			d.send(DH,m);
 		};
 	},
 	
 	_sourceModelUpdated: function(opts_){
 		this.elementGenerator.sourceModelUpdated(opts_);
 	},
 	
 	_initiateMouseClick: function(elementData){
 		var elementId = elementData.id;
 		if( this.toggleSelection 
 		 && this.lastElementIdSelected === elementId ){
 			this.elementGenerator.selectOff(elementData);
 			this.lastElementIdSelected = null;
 		} else {
 			this.elementGenerator.selectOn(elementData);
 			this.lastElementIdSelected = elementId;
 		};
 	},
 	
 	_initiateMouseOver: function(elementData){
 		var elementId = elementData.id;
 		if( elementId !== this.currentMouseOver ){
 			// Focus Off before Focus On
 			if( this.currentMouseOver ){
 	 			this.elementGenerator.focusOff(this.currentMouseOver);
 				this.currentMouseOver = null;
 			};
 			
 			this.elementGenerator.focusOn(elementData);
 			this.currentMouseOver = elementId;
 		};
 	},
 	
 	_initiateMouseOut: function(elementData){
 		var elementId = elementData.id;
 		if( elementId === this.currentMouseOver ){
 			this.elementGenerator.focusOff(elementData);
			this.currentMouseOver = null;
 		};
 	},
 	
 	_handleDispatch: function(m){
 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._sourceModelUpdated(m.state);
 				};
 			};
 		};
 	},
 	
 	_getModelInfo: function(){
 		var info = {
 			modelId: this.modelId
 			,modelType: 'packCanvas'
 			,parameters: []
 		};
 		
 		return info;
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	// Required library: d3
	if( !$d && window ) $d = window.d3;

	if( m.canvasType === 'pack' ){
		if( $d ) {
			m.isAvailable = true;
		} else {
			$n2.log('Canvas pack requires d3 library');
		};
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'pack' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new PackCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasPack = {
	PackCanvas: PackCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasTree.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasTree'
 ;
 
var $d = undefined;
 
// --------------------------------------------------------------------------
var TreeCanvas = $n2.Class({

	canvasId: null,
 	
	interactionId: null,
 	
	svgId: null,
 	
	modelId: null,
 	
	dispatchService: null,

	sourceModelId: null,
 	
	moduleDisplay: null,
 	
	background: null,
	
	toggleSelection: null,
	
	margin: null,
	
	layoutStyle: null,
	
	treeLayout: null,
	
	diagonalLine: null,
 	
	styleRules: null,

	elementsById: null,
	
	elementGenerator: null,
 	
	currentMouseOver: null,

	lastElementIdSelected: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,interactionId: null
			,config: null
			,moduleDisplay: null
			,sourceModelId: null
			,background: null
			,styleRules: null
			,layoutStyle: 'tree'
			,toggleSelection: true
			,elementGeneratorType: 'default'
			,elementGeneratorOptions: null
			,elementGenerator: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
 	
		this.canvasId = opts.canvasId;
		this.interactionId = opts.interactionId;
		this.moduleDisplay = opts.moduleDisplay;
		this.sourceModelId = opts.sourceModelId;
		this.background = opts.background;
		this.layoutStyle = opts.layoutStyle;
		this.toggleSelection = opts.toggleSelection;
		this.elementGenerator = opts.elementGenerator;
 		
		this.modelId = $n2.getUniqueId('canvasTree');
 		
		this.styleRules = $n2.styleRule.loadRulesFromObject(opts.styleRules);
 		
		var config = opts.config;
		if( config ){
			if( config.directory ){
				this.dispatchService = config.directory.dispatchService;
			};
		};

 		this.elementsById = {};
 		this.currentMouseOver = null;
 		this.lastElementIdSelected = null;
 		this.focusInfo = null;
 		this.selectInfo = null;
 		this.margin = 10;

 		// Element generator
 		if( !this.elementGenerator ){
 			// If not defined, use the one specified by type
 	 		this.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: opts.elementGeneratorType
 	 			,options: opts.elementGeneratorOptions
 	 			,config: opts.config
 	 		});
 		};
 		if( this.elementGenerator ){
			this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
				_this._elementsChanged(added, updated, removed);
			});
			this.elementGenerator.setIntentChangedListener(function(updated){
				_this._intentChanged(updated);
			});
 		};
 		
 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m){
 				_this._handleDispatch(m);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 		};
 		
 		this.createGraph();

 		var graphSize = this.getGraphSize();
 		graphSize[0] = graphSize[0] - (2 * this.margin);
 		graphSize[1] = graphSize[1] - (2 * this.margin);

 		if( 'cluster' === this.layoutStyle ){
 	 		this.treeLayout = d3.layout.cluster()
 	 			.sort(function(a,b){
 		 	    	return d3.ascending(a.sortValue, b.sortValue);
 		 	    })
 	 			.size(graphSize);
 		} else {
 	 		this.treeLayout = d3.layout.tree()
 	 			.sort(function(a,b){
 		 	    	return d3.ascending(a.sortValue, b.sortValue);
 		 	    })
 	 			.size(graphSize);
 		};
		
 		this.diagonalLine = d3.svg.diagonal();
 		
 		opts.onSuccess();

 		if( this.sourceModelId ){
 			if( this.dispatchService ){
 				var msg = {
 					type: 'modelGetState'
 					,modelId: this.sourceModelId
 					,state: null
 				};
 				this.dispatchService.synchronousCall(DH,msg);
 				if( msg.state ){
 					this._sourceModelUpdated(msg.state);
 				};
 			};
 		};

 		$n2.log('TreeCanvas',this);
 	},
 	
 	createGraph: function() {
		var _this = this; // for use in callbacks
		 
		if( this.background 
		&& typeof this.background.color === 'string' ){
			var $canvas = $('#' + this.canvasId);
			$canvas.css('background-color',this.background.color);
		};

		this.svgId = $n2.getUniqueId();
 		var $svg = $d.select('#' + this.canvasId)
 			.append('svg')
 			.attr('id',this.svgId);
 		
 		var $rootGroup = $svg.append('g')
			.attr('class','packRoot')
			;

		$rootGroup.append('rect')
			.attr('x',0)
			.attr('y',0)
			.attr('fill-opacity',0)
			.classed({
				'n2CanvasTree_background': true
			})
			.on('click', function(){
				_this._backgroundClicked();
			});

		$rootGroup.append('g')
 			.attr('class','links');

		$rootGroup.append('g')
			 .attr('class','nodes');
			 
		$rootGroup.append('g')
 			.attr('class','labels');

 		this.resizeGraph();
 	},
 	
 	getGraphSize: function() {
 		var $canvas = $('#' + this.canvasId);
 		
 		var width = $canvas.width();
 		var height = $canvas.height();
 		
 		/*
 		 * apply minimum sizes
 		 */
// 		if (width < this.options.sizes.canvas_min.width) {
// 			width = this.options.sizes.canvas_min.width;
// 		};
// 		if (height < this.options.sizes.canvas_min.height) {
// 			height = this.options.sizes.canvas_min.height;
// 		};
 		return [width, height];
 	},
 	
 	resizeGraph: function() {
 		var size = this.getGraphSize();
 		
 		var $svg = this._getSvgElem()
 			.attr('width', size[0])
 			.attr('height', size[1]);
		
		$svg.select('.n2CanvasTree_background')
			.attr('width', size[0])
			.attr('height', size[1]);
			 
 		var $rootGroup = $svg.select('g.packRoot');
 		
 		var minDim = size[0];
 		if( minDim > size[1] ){
 			minDim = size[1];
 		};
 		
 		this.canvasWidth = minDim;
 		this.radius = Math.floor( (minDim / 2) - 120 );
 		
 		this._documentsUpdated([],[]);
 	},
 	
 	_getSvgElem: function() {
 		return $d.select('#' + this.svgId);
 	},
	
	_elementsChanged: function(addedElements, updatedElements, removedElements){
		var _this = this;
		
		// Remove
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removedElement = removedElements[i];
			if( this.elementsById[removedElement.id] ){
				delete this.elementsById[removedElement.id].parent;
				delete this.elementsById[removedElement.id].children;
				delete this.elementsById[removedElement.id];
			};
		};
		
		// Add
		for(var i=0,e=addedElements.length; i<e; ++i){
			var addedElement = addedElements[i];
			this.elementsById[addedElement.id] = addedElement;
		};

		// Reset attributes that are computed by layout
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			delete elem.parent;
			delete elem.children;
			delete elem.depth;
			delete elem.x;
			delete elem.y;
		};

		// Compute tree
		var root = {
			id: '__root__'
			,name: ''
			,children: []
		};
		var nodes = [];
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.isNode ){
				if( elem.parentId ){
					var parent = this.elementsById[elem.parentId];
					if( parent ){
						elem.parent = parent;
						if( !parent.children ){
							parent.children = [];
						};
						parent.children.push(elem);
					};
				};
					
				if( !elem.parent ) {
					elem.parent = root;
					root.children.push(elem);
				};
				
				elem.n2_geometry = 'point';
				
				nodes.push(elem);
			};
		};

		// Report statistics on tree
		var countParentId = 0;
		var countNested = 0;
		for(var i=0,e=nodes.length; i<e; ++i){
			var node = nodes[i];
			
			if( node.parentId ){
				++countParentId;

				if( node.parent ){
					++countNested;
				};
			};
		};
		$n2.log('nodes: '+nodes.length + ' root children: ' + root.children.length + ' nested: ' + countNested + ' parent id: ' + countParentId);
		
		nodes = this.treeLayout.nodes(root);
		
		nodes.forEach(function(n){
			n.x = n.x + _this.margin;
			n.y = n.y + _this.margin;
		});
		
		var links = [];
		for(var elemId in this.elementsById){
			var elem = this.elementsById[elemId];
			
			if( elem.isLink ){
				elem.n2_geometry = 'line';

				links.push(elem);
			};
		};
		
		this._documentsUpdated(nodes, links);
	},
	
	_intentChanged: function(changedElements){
 		// Segregate nodes and active links
 		var nodes = [];
 		var links = [];
 		for(var i=0,e=changedElements.length; i<e; ++i){
 			var changedNode = changedElements[i];

 			if( changedNode.isNode ){
 				nodes.push(changedNode);
 			} else if( changedNode.isLink ){
 				links.push(changedNode);
 			};
 		};

 		// Update style on nodes
 		var selectedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(nodes, function(d){ return d.id; });
 		this._adjustElementStyles(selectedNodes);

 		// Update style on links
 		var selectedLinks = this._getSvgElem().select('g.links').selectAll('.link')
 			.data(links, function(d){ return d.id; });
		this._adjustElementStyles(selectedLinks);
		 
 		// Update style on labels
 		var selectedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
		 	.data(nodes, function(node){ return node.id; });
	 	this._adjustElementStyles(selectedLabels);

	},
 	
 	_documentsUpdated: function(nodes, links){
 		var _this = this;
		 
		// Update Nodes
 		var updatedNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
			.data(nodes, function(d){ return d.id; });
 		
 		updatedNodes
			.transition()
			.attr('cx', function(d){ return d.x; })
			.attr('cy', function(d){ return d.y; });
 		
 		updatedNodes.exit()
 			.remove();

 		updatedNodes.enter()
			.append('circle')
			.attr('class','node')
			.attr('r', 5)
			.attr('cx', function(d){ return d.x; })
			.attr('cy', function(d){ return d.y; })
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			});

 		var allNodes = this._getSvgElem().select('g.nodes').selectAll('.node')
 			.data(nodes, function(d){ return d.id; });
 		this._adjustElementStyles(allNodes);
		 
		 
		// Update Links
 		var updatedLinks = this._getSvgElem().select('g.links').selectAll('.link')
			.data(links, function(d){ return d.id; });
 		
 		updatedLinks
 			.transition()
			.attr('d', this.diagonalLine);

 		updatedLinks.exit()
 			.remove();
 		
 		updatedLinks.enter()
 			.append('path')
 			.attr('class','link')
 			.attr('d', this.diagonalLine)
 			.attr('fill','none')
 			.attr('stroke','#000000')
 			.attr('stroke-width',1)
 			.attr('stroke-opacity',1)
 			.on('click', function(n,i){
 				_this._initiateMouseClick(n);
 			})
 			.on('mouseover', function(n,i){
 				_this._initiateMouseOver(n);
 			})
 			.on('mouseout', function(n,i){
 				_this._initiateMouseOut(n);
 			});

 		var allLinks = this._getSvgElem().select('g.links').selectAll('.link')
			.data(links, function(d){ return d.id; });
		this._adjustElementStyles(allLinks);


		// Update Labels
		var updatedLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(nodes, function(node){ return node.id; });

		updatedLabels.enter()
			.append(function(){
				var args = arguments;
				return this.ownerDocument.createElementNS(this.namespaceURI, "text");
			})
			.attr('class','label')
			.attr('x', function(d){ return d.x; })
			.attr('y', function(d){ return d.y; })
			.text(function(d) { 
				return "";
			})
			.on('click', function(n,i){
				_this._initiateMouseClick(n);
			})
			.on('mouseover', function(n,i){
				_this._initiateMouseOver(n);
			})
			.on('mouseout', function(n,i){
				_this._initiateMouseOut(n);
			});

		var allLabels = this._getSvgElem().select('g.labels').selectAll('.label')
			.data(nodes, function(d){ return d.id; });
		this._adjustElementStyles(allLabels);


 	},
 	
 	_adjustElementStyles: function(selectedElements){
 		var _this = this;
 		selectedElements.each(function(n,i){
 			n.n2_elem = this;
 			var symbolizer = _this.styleRules.getSymbolizer(n);
 			symbolizer.adjustSvgElement(this,n);
 			delete n.n2_elem;
 		});
 	},
 	
 	_dispatch: function(m){
 		var d = this.dispatchService;
 		if( d ){
 			d.send(DH,m);
 		};
 	},
 	
 	_sourceModelUpdated: function(opts_){
 		this.elementGenerator.sourceModelUpdated(opts_);
 	},
 	
 	_initiateMouseClick: function(elementData){
 		var elementId = elementData.id;
 		if( this.toggleSelection 
 		 && this.lastElementIdSelected === elementId ){
 			this.elementGenerator.selectOff(elementData);
 			this.lastElementIdSelected = null;
 		} else {
 			this.elementGenerator.selectOn(elementData);
 			this.lastElementIdSelected = elementId;
 		};
 	},
 	
 	_initiateMouseOver: function(elementData){
 		var elementId = elementData.id;
 		if( elementId !== this.currentMouseOver ){
 			// Focus Off before Focus On
 			if( this.currentMouseOver ){
 	 			this.elementGenerator.focusOff(this.currentMouseOver);
 				this.currentMouseOver = null;
 			};
 			
 			this.elementGenerator.focusOn(elementData);
 			this.currentMouseOver = elementId;
 		};
 	},
 	
 	_initiateMouseOut: function(elementData){
 		var elementId = elementData.id;
 		if( elementId === this.currentMouseOver ){
 			this.elementGenerator.focusOff(elementData);
			this.currentMouseOver = null;
 		};
	 },
	 
	_backgroundClicked: function(){
		this._dispatch({
			type: 'userUnselect'
		});
	},
 	
 	_handleDispatch: function(m){
 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._sourceModelUpdated(m.state);
 				};
 			};
 		};
 	},
 	
 	_getModelInfo: function(){
 		var info = {
 			modelId: this.modelId
 			,modelType: 'treeCanvas'
 			,parameters: []
 		};
 		
 		return info;
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	// Required library: d3
	if( !$d && window ) $d = window.d3;

	if( m.canvasType === 'tree' ){
		if( $d ) {
			m.isAvailable = true;
		} else {
			$n2.log('Canvas tree requires d3 library');
		};
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'tree' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new TreeCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasTree = {
	TreeCanvas: TreeCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasCustomHTML.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasCustomHTML'
 ;

// --------------------------------------------------------------------------
var CustomHtmlCanvas = $n2.Class({

	canvasId: null,
 	
	interactionId: null,
 	
	dispatchService: null,

	showService: null,

	moduleDisplay: null,
	
	intentView: null,
	
	nodesById: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,interactionId: null
			,config: null
			,moduleDisplay: null
			,htmlAttachment: null
			,cssAttachment: null
			,elemIdToDocId: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
 	
		this.canvasId = opts.canvasId;
		this.interactionId = opts.interactionId;
		this.moduleDisplay = opts.moduleDisplay;

		var config = opts.config;
		if( config ){
			if( config.directory ){
				this.dispatchService = config.directory.dispatchService;
				this.showService = config.directory.showService;
			};
		};
		
		this.nodesById = {};
		
		// Populate nodesById with information from user
		if( typeof opts.elemIdToDocId === 'object' ){
			for(var elemId in opts.elemIdToDocId){
				var docId = opts.elemIdToDocId[elemId];
				
				var node = {
					n2_id: docId
					,nodeId: elemId
				};
				
				this.nodesById[elemId] = node;
			};
		};
		
		// Create intent view to keep track of user requests
		if( this.dispatchService ){
			this.intentView = new $n2.userIntentView.IntentView({
				dispatchService: this.dispatchService
			});
			this.intentView.addListener(function(nodes){
				_this._intentChanged(nodes);
			});
		};

 		// Register to events
 		if( this.dispatchService ){
// 			var f = function(m){
// 				_this._handleDispatch(m);
// 			};
// 			
// 			this.dispatchService.register(DH,'focusOn',f);
 		};
 		
 		if( opts.cssAttachment ){
 			// Load up CSS as an attachment to the module document
 			var cssUrl = this._computeAttachmentUrl(opts.cssAttachment);
 			if( cssUrl ){
 				$.ajax({
 					url: cssUrl
 					,type: 'get'
 					,async: true
 					,dataType: 'text'
 					,success: function(cssDocument) {
 						cssLoaded(cssDocument);
 					}
 					,error: function(XMLHttpRequest, textStatus, errorThrown) {
 						opts.onError( _loc('Error loading CSS from location: {url}',{
 							url: cssUrl
 						}) );
 					}
 				});
 			} else {
 				opts.onError( _loc('Location of CSS is undefined for customHtml canvas') );
 			};
	 			
 		} else {
 			cssLoaded(undefined);
 		};

 		$n2.log('CustomHtmlCanvas',this);
 		
 		function cssLoaded(cssContent){
 			//$n2.log('CSS content',cssContent);
 	 		
 	 		if( opts.htmlAttachment ){
 	 			// Load up SVG as an attachment to the module document
 	 			var htmlUrl = _this._computeAttachmentUrl(opts.htmlAttachment);
 	 			if( htmlUrl ){
 	 				$.ajax({
 	 					url: htmlUrl
 	 					,type: 'get'
 	 					,async: true
 	 					,dataType: 'html'
 	 					,success: function(htmlDocument) {
 							opts.onSuccess();
 							
 							_this._renderHtmlDocument(htmlDocument, cssContent);
 	 					}
 	 					,error: function(XMLHttpRequest, textStatus, errorThrown) {
 	 						opts.onError( _loc('Error loading HTML from location: {url}',{
 	 							url: htmlUrl
 	 						}) );
 	 					}
 	 				});
 	 			} else {
 	 				opts.onError( _loc('Location of HTML is undefined for customHtml canvas') );
 	 			};
 	 			
 	 		} else {
 	 			opts.onError( _loc('A HTML file must be specified for the customHtml canvas') );
 	 		};

 		};
 	},
 	
 	_handleDispatch: function(m){
 	},
 	
 	_renderHtmlDocument: function(htmlDocument, cssContent){
 		var _this = this;
 		
 		$n2.log('custom html loaded');
 		
 		var $canvas = $('#'+this.canvasId)
 			.html(htmlDocument);
 		
 		// Adjust height and width
 		$canvas.children()
 			.css('width','100%')
 			.css('height','100%')
			.css('position','absolute')
			.css('left','0')
			.css('top','0')
 			;
 		
 		// Try to insert style information
 		if( cssContent ){
			var $html = $canvas.find('html');
 	 		if( $html.length < 1 ){
 	 			// Use main page
 	 			$html = $('html');
 	 		};
			
 	 		var $head = $html.find('head');
 	 		if( $head.length < 1 ){
 	 			$head = $('<head>')
 	 				.prependTo($html);
 	 		};
 	 			
 	 		if( $head.length > 0 ){
 				var $style = $('<style>')
					.attr('type','text/css')
					.text(cssContent);

 				$head.first().append( $style );
 	 		};
 		};
 		
 		// Fix URLs associated with images
 		$canvas.find('img').each(function(){
 			var $image = $(this);
 			var attName = $image.attr('src');
 			if( attName ){
 	 			var url = _this._computeAttachmentUrl(attName);
 	 			$image.attr('src',url);
 			};
 		});

 		// Iterate over the elements already in dictionary that
 		// were specified using elemIdToDocId option
 		for(var nodeId in this.nodesById){
 			var node = this.nodesById[nodeId];
 			var docId = node.n2_id;
 			
 			$('#'+nodeId)
 				.attr('n2-doc-id', docId)
 				.mouseover(function(e){
 					_this._mouseOver($(this),e);
 				})
				.mouseout(function(e){
 					_this._mouseOut($(this),e);
 				})
				.click(function(e){
 					_this._mouseClick($(this),e);
 				})
 				;
 		};

 		
 		// Find all elements that are associated with a doc id
 		$canvas.find('.n2canvas_linkDocId').each(function(){
 			var $child = $(this);
 			
 			var nodeId = $child.attr('id');
 			if( !nodeId ){
 				nodeId = $n2.getUniqueId();
 				$child.attr('id',nodeId);
 			};
 			
 			var docId = $child.attr('n2-doc-id');
 			
 			if( docId ){
 				// Create a node for this element/docId
 	 			var node = {
 	 	 			n2_id: docId
 	 	 			,nodeId: nodeId
 	 			};
 	 			_this.nodesById[nodeId] = node;
 	 			
 	 			$child
	 				.mouseover(function(e){
	 					_this._mouseOver($(this),e);
	 				})
					.mouseout(function(e){
	 					_this._mouseOut($(this),e);
	 				})
					.click(function(e){
	 					_this._mouseClick($(this),e);
	 				})
	 				;
 			};

 			$child
				.removeClass('n2canvas_linkDocId')
				.addClass('n2canvas_linkedDocId');
 		});

		// Adjust intention on all nodes. Update our elements accordingly
 		var nodes = [];
 		for(var nodeId in this.nodesById){
 			var node = this.nodesById[nodeId];
 			nodes.push(node);
 		};
		this.intentView.addNodes(nodes);
		this._intentChanged(nodes);
 		
		$canvas.find('.n2canvas_unselect').each(function(){
 			var $child = $(this);
 			
 			$child
				.click(function(e){
 					_this._mouseUnselect($(this),e);
 				})
 				.removeClass('n2canvas_unselect')
 				.addClass('n2canvas_unselected');
 		});
 		
 		// Get show service to fix HTML
 		if( this.showService ){
 			this.showService.fixElementAndChildren($canvas, {}, undefined);
 		};
 	},
 	
 	_mouseOver: function($elem, evt){
 		var docId = $elem.attr('n2-doc-id');
 		if( docId && this.dispatchService ){
 			this.dispatchService.send(DH,{
 				type: 'userFocusOn'
 				,docId: docId
 			});
 		};
 	},
 	
 	_mouseOut: function($elem, evt){
 		var docId = $elem.attr('n2-doc-id');
 		if( docId && this.dispatchService ){
 			this.dispatchService.send(DH,{
 				type: 'userFocusOff'
 				,docId: docId
 			});
 		};
 	},
 	
 	_mouseClick: function($elem, evt){
 		var docId = $elem.attr('n2-doc-id');
 		if( docId && this.dispatchService ){
 			this.dispatchService.send(DH,{
 				type: 'userSelect'
 				,docId: docId
 			});
 		};
 		
 		// Do not continue up the DOM tree
 		evt.stopPropagation();
 	},
 	
 	_mouseUnselect: function($elem, evt){
		this.dispatchService.send(DH,{
			type: 'userUnselect'
		});
 	},
 	
 	/*
 	 * This function is called when the user intent view observes
 	 * changes in the style of some nodes
 	 */
 	_intentChanged: function(nodes){
 		for(var i=0,e=nodes.length; i<e; ++i){
 			var node = nodes[i];
 			
 			var $node = $('#'+node.nodeId);
 
 			if( node.n2_hovered ){
 				$node.addClass('n2canvas_hovered');
 			} else {
 				$node.removeClass('n2canvas_hovered');
 			};
 
 			if( node.n2_selected ){
 				$node.addClass('n2canvas_selected');
 			} else {
 				$node.removeClass('n2canvas_selected');
 			};
 			 
 			if( node.n2_selected && node.n2_hovered ){
 				$node.addClass('n2canvas_selectedHovered');
 			} else {
 				$node.removeClass('n2canvas_selectedHovered');
 			};
 		};
 	},
 	
 	_computeAttachmentUrl: function(attName){
		var url = undefined;
		
		if( this.moduleDisplay 
		 && this.moduleDisplay.module ){
			url = this.moduleDisplay.module.getAttachmentUrl(attName);
		};
		
		return url;
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	if( m.canvasType === 'customHtml' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'customHtml' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new CustomHtmlCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasCustomHtml = {
	CustomHtmlCanvas: CustomHtmlCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasCustomSVG.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasCustomSVG'
 ;
 
var $d = undefined;
 
// --------------------------------------------------------------------------
var CustomSvgCanvas = $n2.Class({

	canvasId: null,
 	
	interactionId: null,
	
	canvasName: null,
 	
	dispatchService: null,

	moduleDisplay: null,
	
	intentView: null,
	
	nodesById: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,interactionId: null
			,canvasName: null
			,config: null
			,moduleDisplay: null
			,svgAttachment: null
			,cssAttachment: null
			,elemIdToDocId: null
			,unselectIds: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
 	
		this.canvasId = opts.canvasId;
		this.interactionId = opts.interactionId;
		this.canvasName = opts.canvasName;
		this.moduleDisplay = opts.moduleDisplay;

		var config = opts.config;
		if( config ){
			if( config.directory ){
				this.dispatchService = config.directory.dispatchService;
			};
		};
		
		this.nodesById = {};
		
		// Populate nodesById with information from user
		if( typeof opts.elemIdToDocId === 'object' ){
			for(var elemId in opts.elemIdToDocId){
				var docId = opts.elemIdToDocId[elemId];
				
				var node = {
					n2_id: docId
					,nodeId: elemId
				};
				
				this.nodesById[elemId] = node;
			};
		};
		
		// Add information about "unselect"
		if( $n2.isArray(opts.unselectIds) ){
			for(var i=0,e=opts.unselectIds.length; i<e; ++i){
				var elemId = opts.unselectIds[i];
				
				var node = {
					nodeId: elemId
					,unselect: true
				};
				
				this.nodesById[elemId] = node;
			};
		};
		
		// Create intent view to keep track of user requests
		if( this.dispatchService ){
			this.intentView = new $n2.userIntentView.IntentView({
				dispatchService: this.dispatchService
			});
			this.intentView.addListener(function(nodes){
				_this._intentChanged(nodes);
			});
		};

 		// Register to events
 		if( this.dispatchService ){
// 			var f = function(m){
// 				_this._handleDispatch(m);
// 			};
// 			
// 			this.dispatchService.register(DH,'focusOn',f);
 		};
 		
 		if( opts.cssAttachment ){
 			// Load up CSS as an attachment to the module document
 			var cssUrl = this._computeAttachmentUrl(opts.cssAttachment);
 			if( cssUrl ){
 				$.ajax({
 					url: cssUrl
 					,type: 'get'
 					,async: true
 					,dataType: 'text'
 					,success: function(cssDocument) {
 						cssLoaded(cssDocument);
 					}
 					,error: function(XMLHttpRequest, textStatus, errorThrown) {
 						opts.onError( _loc('Error loading CSS from location: {url}',{
 							url: cssUrl
 						}) );
 					}
 				});
 			} else {
 				opts.onError( _loc('Location of CSS is undefined for customSvg canvas') );
 			};
	 			
 		} else {
 			cssLoaded(undefined);
 		};

 		$n2.log('CustomSvgCanvas',this);
 		
 		function cssLoaded(cssContent){
 			//$n2.log('CSS content',cssContent);
 	 		
 	 		if( opts.svgAttachment ){
 	 			// Load up SVG as an attachment to the module document
 	 			var svgUrl = _this._computeAttachmentUrl(opts.svgAttachment);
 	 			if( svgUrl ){
 	 				$.ajax({
 	 					url: svgUrl
 	 					,type: 'get'
 	 					,async: true
 	 					,dataType: 'xml'
 	 					,success: function(svgDocument) {
 							opts.onSuccess();
 							
 							_this._renderSvgDocument(svgDocument, cssContent);
 	 					}
 	 					,error: function(XMLHttpRequest, textStatus, errorThrown) {
 	 						opts.onError( _loc('Error loading SVG from location: {url}',{
 	 							url: svgUrl
 	 						}) );
 	 					}
 	 				});
 	 			} else {
 	 				opts.onError( _loc('Location of SVG is undefined for customSvg canvas') );
 	 			};
 	 			
 	 		} else {
 	 			opts.onError( _loc('A SVG file must be specified for the customSvg canvas') );
 	 		};

 		};
 	},
 	
 	_handleDispatch: function(m){
 	},
 	
 	_renderSvgDocument: function(svgDocument, cssContent){
 		var _this = this;
 		
 		$n2.log('custom svg loaded');
 		
 		$('#'+this.canvasId)
 			.empty()
 			.append(svgDocument.documentElement);
 		
 		// Adjust height and width
 		$d.select('#'+this.canvasId).selectAll('svg')
 			.attr('width','100%')
 			.attr('height','100%')
 			.attr('preserveAspectRatio','xMidYMid meet')
 			;
 		
 		// Try to insert style information
 		if( cssContent ){
 	 		var $style = $('#'+this.canvasId).find('style');
 	 		if( $style.length > 0 ){
 	 			$style.append(cssContent);
 	 		} else {
 	 			// No style. Insert one
 	 			var $svg = $('#'+this.canvasId).children('svg');
 	 			if( $svg.length > 0 ){
 	 				// Style node should be under SVG
 	 				$('<style>')
 	 					.attr('type','text/css')
 	 					.text(cssContent)
 	 					.prependTo($svg);
 	 			};
 	 		};
 		};
 		
 		// Fix URLs associated with images
 		$d.select('#'+this.canvasId).selectAll('image').each(function(){
 			var $image = $d.select(this);
 			var attName = $image.attr('xlink:href');
 			if( attName ){
 	 			var url = _this._computeAttachmentUrl(attName);
 	 			$image.attr('xlink:href',url);
 			};
 		});

 		// Iterate over the elements already in dictionary that
 		// were specified using elemIdToDocId option
 		for(var nodeId in this.nodesById){
 			var node = this.nodesById[nodeId];
 			
 			if( node.n2_id ){
 	 			var docId = node.n2_id;
 	 			$d.select('#'+nodeId)
	 				.attr('n2-doc-id', docId)
	 				.on('mouseover',function(d,i){
	 					_this._mouseOver($d.select(this),$d.event);
	 				})
					.on('mouseout',function(d,i){
	 					_this._mouseOut($d.select(this),$d.event);
	 				})
					.on('click',function(d,i){
	 					_this._mouseClick($d.select(this),$d.event);
	 				})
	 				;
 			} else if( node.unselect ) {
 	 			$d.select('#'+nodeId)
					.on('click',function(d,i){
	 					_this._mouseUnselect($d.select(this),$d.event);
	 				});
 			};
 		};

 		
 		// Find all elements that are associated with a doc id
 		$d.select('#'+this.canvasId).selectAll('.n2canvas_linkDocId').each(function(){
 			var $child = $d.select(this);
 			
 			var nodeId = $child.attr('id');
 			if( !nodeId ){
 				nodeId = $n2.getUniqueId();
 				$child.attr('id',nodeId);
 			};
 			
 			var docId = $child.attr('n2-doc-id');
 			
 			if( docId ){
 				// Create a node for this element/docId
 	 			var node = {
 	 	 			n2_id: docId
 	 	 			,nodeId: nodeId
 	 			};
 	 			_this.nodesById[nodeId] = node;
 	 			
 	 			$child
	 				.on('mouseover',function(d,i){
	 					_this._mouseOver($d.select(this),$d.event);
	 				})
					.on('mouseout',function(d,i){
	 					_this._mouseOut($d.select(this),$d.event);
	 				})
					.on('click',function(d,i){
	 					_this._mouseClick($d.select(this),$d.event);
	 				})
	 				;
 			};

 			$child
				.classed({
					'n2canvas_linkDocId':false
					,'n2canvas_linkedDocId':true
				});
 		});

		// Adjust intention on all nodes. Update our elements accordingly
 		var nodes = [];
 		for(var nodeId in this.nodesById){
 			var node = this.nodesById[nodeId];
 			nodes.push(node);
 		};
		this.intentView.addNodes(nodes);
		this._intentChanged(nodes);
 		
 		$d.select('#'+this.canvasId).selectAll('.n2canvas_unselect').each(function(){
 			var $child = $d.select(this);
 			
 			$child
				.on('click',function(d,i){
 					_this._mouseUnselect($d.select(this),$d.event);
 				})
				.classed({
					'n2canvas_unselect':false
					,'n2canvas_unselected':true
				});
 		});
 	},
 	
 	_mouseOver: function($elem, evt){
 		var docId = $elem.attr('n2-doc-id');
 		if( docId && this.dispatchService ){
 			this.dispatchService.send(DH,{
 				type: 'userFocusOn'
 				,docId: docId
 				,_source: this.canvasName
 			});
 		};
 	},
 	
 	_mouseOut: function($elem, evt){
 		var docId = $elem.attr('n2-doc-id');
 		if( docId && this.dispatchService ){
 			this.dispatchService.send(DH,{
 				type: 'userFocusOff'
 				,docId: docId
 				,_source: this.canvasName
 			});
 		};
 	},
 	
 	_mouseClick: function($elem, evt){
 		var docId = $elem.attr('n2-doc-id');
 		if( docId && this.dispatchService ){
 			this.dispatchService.send(DH,{
 				type: 'userSelect'
 				,docId: docId
 				,_source: this.canvasName
 			});
 		};
 		
 		// Do not continue up the DOM tree
 		evt.stopPropagation();
 	},
 	
 	_mouseUnselect: function($elem, evt){
		this.dispatchService.send(DH,{
			type: 'userUnselect'
 			,_source: this.canvasName
		});
 	},
 	
 	/*
 	 * This function is called when the user intent view observes
 	 * changes in the style of some nodes
 	 */
 	_intentChanged: function(nodes){
 		for(var i=0,e=nodes.length; i<e; ++i){
 			var node = nodes[i];
 			
 			$d.select('#'+node.nodeId)
 				.classed({
 					'n2canvas_hovered': node.n2_hovered
 					,'n2canvas_selected': node.n2_selected
 					,'n2canvas_selectedHovered': (node.n2_selected && node.n2_hovered)
 				});
 		};
 	},
 	
 	_computeAttachmentUrl: function(attName){
		var url = undefined;
		
		if( this.moduleDisplay 
		 && this.moduleDisplay.module ){
			url = this.moduleDisplay.module.getAttachmentUrl(attName);
		};
		
		return url;
 	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	// Required library: d3
	if( !$d && window ) $d = window.d3;

	if( m.canvasType === 'customSvg' ){
		if( $d ) {
			m.isAvailable = true;
		} else {
			$n2.log('Canvas customSvg requires d3 library');
		};
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'customSvg' && $d ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new CustomSvgCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasCustomSvg = {
	CustomSvgCanvas: CustomSvgCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasReferenceBrowser.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasReferenceBrowser'
 ;

// --------------------------------------------------------------------------
var ReferenceBrowserCanvas = $n2.Class({

	canvasId: null,
 	
	atlasDesign: null,
	
	schemaRepository: null,
	
	showService: null,
	
	dispatchService: null,
	
	docsById: null,
	
	briefsById: null,
	
	schemaNames: null,
	
	schemaLabelByName: null,
	
	sortingSchemaNames: null,
	
	refs: null,
 	
	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,config: null
			,schemaNames: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
 		
		this.canvasId = opts.canvasId;
		this.docsById = {};
		this.briefsById = {};
		this.schemaLabelByName = {};
		this.refs = [];
		
		this.schemaNames = opts.schemaNames;
		this.sortingSchemaNames = this.schemaNames.slice(); // clone
		
		if( opts.config ){
			this.atlasDesign = opts.config.atlasDesign;
			
			if( opts.config.directory ){
				this.schemaRepository = opts.config.directory.schemaRepository;
				this.showService = opts.config.directory.showService;
				this.dispatchService = opts.config.directory.dispatchService;
			};
		};
		
		if( this.dispatchService ){
			var f = function(m,addr,dispatcher){
				_this._handle(m,addr,dispatcher);
			};
			
			this.dispatchService.register(DH,'documentContent',f);
			this.dispatchService.register(DH,'documentContentCreated',f);
			this.dispatchService.register(DH,'documentContentUpdated',f);
			this.dispatchService.register(DH,'documentDeleted',f);
		};
		
		opts.onSuccess();
		
		this._display();
		
		this._loadDocs();
		
		if( this.schemaRepository ){
			this.schemaRepository.getSchemas({
				names: this.schemaNames
				,onSuccess: function(schemas){
					var schemasByName = {};
					
					schemas.forEach(function(schema){
						var label = schema.name;
						if( schema.label ){
							label = _loc( schema.label );
						};
						_this.schemaLabelByName[schema.name] = label;
					});

					_this._display();
				}
			});
		};
	},
	
	_getElem: function(){
		var $elem = $('#'+this.canvasId);
		if( $elem.length < 1 ){
			return undefined;
		};
		return $elem;
	},
	
	_display: function(){
		var _this = this;
		
		var $elem = this._getElem();
		if( $elem ){
			$elem
				.empty()
				.addClass('n2ReferenceBrowserCanvas')
				.click(function(e){
					_this._backgroundClicked();
				});
			
			$('<button>')
				.text('Export CSV')
				.appendTo($elem)
				.click(function(){
					_this._exportCsv();
					return false;
				});
			
			var $table = $('<table>').appendTo($elem);
			
			// Headings
			var $tr = $('<tr>').appendTo($table);
			for(var i=0,e=_this.schemaNames.length; i<e; ++i){
				var schemaName = _this.schemaNames[i];
				var schemaLabel = _this.schemaLabelByName[schemaName];
				if( !schemaLabel ){
					schemaLabel = schemaName;
				};
				var $th = $('<th>')
					.appendTo($tr);
				
				$('<a>')
					.text(schemaLabel)
					.attr('href','#')
					.attr('data-schema-name',schemaName)
					.appendTo($th)
					.click(function(){
						var $a = $(this);
						var schemaName = $a.attr('data-schema-name');
						_this._sortOnCriteria(schemaName);
						return false;
					})
					;
					
			};
			
			// Data
			for(var i=0,e=_this.refs.length; i<e; ++i){
				var ref = _this.refs[i];
				
				var $tr = $('<tr>').appendTo($table);
				for(var j=0,k=_this.schemaNames.length; j<k; ++j){
					var schemaName = _this.schemaNames[j];
					
					var info = ref[schemaName];
					if( info ){
						var display = info.display;
						var docId = info.id;
						var doc = _this.docsById[docId];
						
							var $td = $('<td>')
								.appendTo($tr);
							var $a = $('<a>')
								.text(display)
								.attr('href','#')
								.attr('n2-doc-id',docId)
								.appendTo($td)
								.click(function(){
									var $a = $(this);
									var docId = $a.attr('n2-doc-id');
									_this._select(docId);
									return false;
								})
								;

						if( _this.showService && doc ){
							_this.showService.displayBriefDescription($a, {}, doc);
						};
						
					} else {
						$('<td>')
							.appendTo($tr);
					};
				};
			};
		};
	},
	
	_backgroundClicked: function(){
		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'userUnselect'
			});
		};
	},
	
	_loadDocs: function(){
		var _this = this;
		
		this.atlasDesign.queryView({
			viewName: 'nunaliit-schema'
			,keys: this.schemaNames
			,include_docs: true
			,onSuccess: function(rows){
				var loaded = false;
				for(var i=0,e=rows.length;i<e;++i){
					var row = rows[i];
					var doc = row.doc;
					var docId = doc._id;
					
					_this.docsById[docId] = doc;
					
					if( _this.briefsById[docId] ){
						delete _this.briefsById[docId];
					};
					
					loaded = true;
				};
				
				if( loaded ){
					_this._computeSortValues({
						onSuccess: sortValuesComputed
					});
				};
			}
			,onError: function(errorMsg){ 
				$n2.reportErrorForced(errorMsg); 
			}
		});
		
		function sortValuesComputed(){
			_this._computeReferences();
			_this._display();
		};
	},
	
	_computeReferences: function(){
		// Accumulate all references in a double map. Sort
		// docIds so that a -> b is the same as b -> a
		var map = {};
		for(var docId in this.docsById){
			var doc = this.docsById[docId];
			
			var refs = [];
			$n2.couchUtils.extractLinks(doc,refs);
			
			for(var i=0,e=refs.length; i<e; ++i){
				var ref = refs[i];
				if( ref && ref.doc ){
					var refId = ref.doc;
					
					// check that reference points back to a document
					// that is interesting
					if( this.docsById[refId] ){
						var a = docId;
						var b = refId;
						if( b < a ){
							a = refId;
							b = docId;
						};
						
						// Put in map
						if( !map[a] ){
							map[a] = {};
						};
						map[a][b] = true;
					};
				};
			};
		};
		
		// Convert into array
		var links = [];
		for(var id1 in map){
			var subMap = map[id1];
			for(var id2 in subMap){
				var doc1 = this.docsById[id1];
				var doc2 = this.docsById[id2];
				
				var schemaName1 = doc1.nunaliit_schema;
				var schemaName2 = doc2.nunaliit_schema;

				var display1 = this.briefsById[id1];
				var display2 = this.briefsById[id2];
				
				var link = {};
				link[schemaName1] = {
					id: id1
					,display: display1
				};
				link[schemaName2] = {
					id: id2
					,display: display2
				};
				links.push(link);
			};
		};
		
		this.refs = links;
		
		this._sortReferences();
	},
	
	_sortOnCriteria: function(name){
		var index = this.sortingSchemaNames.indexOf(name);
		if( index >= 0 ){
			this.sortingSchemaNames.splice(index,1);
			this.sortingSchemaNames.unshift(name);
			
			this._sortReferences();
			
			this._display();
		};
	},
	
	_sortReferences: function(){
		var _this = this;
		
		this.refs.sort(function(a,b){
			for(var i=0,e=_this.sortingSchemaNames.length; i<e; ++i){
				var criteria = _this.sortingSchemaNames[i];
				
				var aInfo = a[criteria];
				var bInfo = b[criteria];
				
				if( aInfo && bInfo ){
					var aDisplay = aInfo.display;
					var bDisplay = bInfo.display;
					
					if( aDisplay < bDisplay ){
						return -1;
					} else if( aDisplay > bDisplay ){
						return 1;
					} else {
						// wait for next criteria
					};
					
				} else if( aInfo ) {
					// no bInfo
					return -1;
				} else if( bInfo ){
					// no aInfo
					return 1;
				};
			};
			
			return 0;
		});
	},
	
	_computeSortValues: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
		},opts_);
		
		var _this = this;
		
		this.schemaRepository.getSchemas({
			names: this.schemaNames
			,onSuccess: function(schemas){
				var schemasByName = {};
				
				for(var i=0,e=schemas.length; i<e; ++i){
					var schema = schemas[i];
					var schemaName = schema.name;
					schemasByName[schemaName] = schema;
				};
				
				for(var docId in _this.docsById){
					var doc = _this.docsById[docId];
					var brief = _this.briefsById[docId];
					if( !brief ){
						var schema = schemasByName[doc.nunaliit_schema];
						
						if( schema ){
							var $elem = $('<div>');
							schema.brief(doc,$elem);
							brief = $elem.text();
						} else {
							brief = doc._id;
						};
						
						_this.briefsById[docId] = brief;
					};
				};
				
				opts.onSuccess();
			}
		});
	},
	
	_select: function(docId){
		var doc = this.docsById[docId];
		
		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'userSelect'
				,docId: docId
				,doc: doc
			});
		};
	},

	_addDocument: function(doc){
		var _this = this;
		
		var docId = doc._id;
		var added = false;
		
		if( ! this.docsById[docId] ){
			this.docsById[docId] = doc;
			added = true;
			
		} else if( this.docsById[docId]._rev !== doc._rev ) {
			this.docsById[docId] = doc;
			delete this.briefsById[docId];
			added = true;
		};
		
		if( added ){
			this._computeSortValues({
				onSuccess: sortValuesComputed
			});
		};

		function sortValuesComputed(){
			_this._computeReferences();
			_this._display();
		};
	},

	_deleteDocument: function(docId){
		if( this.docsById[docId] ){
			delete this.docsById[docId];
			delete this.briefsById[docId];
			this._computeReferences();
			this._display();
		};
	},
	
	_handle: function(m,addr,dispatcher){
		if( 'documentContent' === m.type 
		 || 'documentContentCreated' === m.type 
		 || 'documentContentUpdated' === m.type ){
			var doc = m.doc;
			if( doc ){
				var schemaName = doc.nunaliit_schema;
				if( this.schemaNames.indexOf(schemaName) < 0 ){
					// Should be deleted
					var docId = doc._id;
					this._deleteDocument(docId);
					
				} else {
					// Should be added
					this._addDocument(doc);
				};
			};
			
		} else if( 'documentDeleted' === m.type ){
			var docId = m.docId;
			this._deleteDocument(docId);
		};
	},
	
	_computeCsvContent: function(){
		var table = [];
		
		// Headings
		var headLine = [];
		table.push(headLine);
		for(var i=0,e=this.schemaNames.length; i<e; ++i){
			var schemaName = this.schemaNames[i];
			headLine.push( schemaName + '(docId)' );
			headLine.push( schemaName + '(description)' );
		};
		
		// Data
		for(var i=0,e=this.refs.length; i<e; ++i){
			var ref = this.refs[i];
			
			var line = [];
			table.push(line);
			for(var j=0,k=this.schemaNames.length; j<k; ++j){
				var schemaName = this.schemaNames[j];
				
				var info = ref[schemaName];
				if( info ){
					var display = info.display;
					var docId = info.id;
					line.push(docId);
					line.push(display);
				} else {
					line.push('');
					line.push('');
				};
			};
		};
		
		var csvContent = $n2.csv.ValueTableToCsvString(table);
		
		return csvContent;
	},
	
	_exportCsv: function(){
		var csvContent = this._computeCsvContent();
		
		if( typeof Blob !== 'undefined' 
		 && typeof saveAs === 'function' ){
			var blob = new Blob([csvContent],{type: "text/plain;charset=" + document.characterSet});
			saveAs(blob, 'references.csv');
			
		} else {
			var $dialog = $('<div>')
				.addClass('n2canvasReferenceBrowser_exportCsv_dialog');
			var diagId = $n2.utils.getElementIdentifier($dialog);
			
			$('<textarea>')
				.addClass('n2canvasReferenceBrowser_exportCsv_text')
				.text(csvContent)
				.appendTo($dialog);
			
			$dialog.dialog({
				autoOpen: true
				,title: _loc('References')
				,modal: true
				,width: 370
				,close: function(event, ui){
					var diag = $('#'+diagId);
					diag.dialog('destroy');
					diag.remove();
				}
			});
		};
	}
});
 
//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	if( m.canvasType === 'referenceBrowser' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'referenceBrowser' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.config = m.config;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new ReferenceBrowserCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasReferenceBrowser = {
	ReferenceBrowserCanvas: ReferenceBrowserCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasTable.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasTable'
 ,uniqueId = 0
 ;
 
var $d = undefined;

//--------------------------------------------------------------------------
// ROW ELEMENTS
// Helper functions for elements accepted by the table canvas. These functions
// are used to support element generators that provides elements that are complete
// rows.
//
function Cell(cell){
	cell.getValue = Cell.getValue;
	cell.getSortValue = Cell.getSortValue;
	cell.getExportValue = Cell.getExportValue;
};
Cell.getValue = function(element){
	if( typeof this.value === 'function' ){
		return this.value(this, element);
	}
	return this.value;
};
Cell.getSortValue = function(element){
	var sortValue = this.sortValue;
	if( typeof sortValue === 'undefined' ){
		sortValue = this.getValue(element);
	};
	return sortValue;
};
Cell.getExportValue = function(element){
	var exportValue = undefined;
	if( typeof this.exportValue === 'function' ){
		exportValue = this.exportValue(this, element);
	} else if(  typeof this.exportValue !== 'undefined'  ){
		exportValue = this.exportValue;
	} else {
		exportValue = this.getValue(element);
	};
	return exportValue;
};

function RowElement(element){
	element.getCell = RowElement.getCell;
	element.getValue = RowElement.getValue;
	element.getSortValue = RowElement.getSortValue;
	element.getExportValue = RowElement.getExportValue;
	element.getRowName = RowElement.getRowName;
	element.isRowElement = true;
	
	if( element.cells ){
		for(var name in element.cells){
			var cell = element.cells[name];
			Cell(cell);
			
			// If a cell is not assigned any fragment, then inherit
			// those from the row
			if( !cell.fragments ){
				cell.fragments = element.fragments;
			};
		};
	};
};
RowElement.getCell = function(name){
	var cell = this.cells ? this.cells[name] : undefined;
	return cell;
};
RowElement.getValue = function(name){
	var cell = this.getCell(name);
	var value = cell ? cell.getValue(this) : undefined;
	return value;
};
RowElement.getSortValue = function(name){
	var cell = this.getCell(name);
	var sortValue = cell ? cell.getSortValue(this) : undefined;
	return sortValue;
};
RowElement.getExportValue = function(name){
	var cell = this.getCell(name);
	var exportValue = cell ? cell.getExportValue(this) : undefined;
	return exportValue;
};
RowElement.getRowName = function(){
	// The name of a row in a row element is its id
	return this.id;
};

//--------------------------------------------------------------------------
// CELL ELEMENTS
// Helper functions for elements accepted by the table canvas. These functions
// are used to support element generators that provides elements that are cells.
//
function CellElement(cell){
	cell.getValue = CellElement.getValue;
	cell.getSortValue = CellElement.getSortValue;
	cell.getExportValue = CellElement.getExportValue;

	cell.isCellElement = true;
};
CellElement.getValue = function(row){
	if( typeof this.value === 'function' ){
		return this.value(this, row);
	}
	return this.value;
};
CellElement.getSortValue = function(row){
	var sortValue = this.sortValue;
	if( typeof sortValue === 'undefined' ){
		sortValue = this.getValue(row);
	};
	return sortValue;
};
CellElement.getExportValue = function(row){
	var exportValue = undefined;
	if( typeof this.exportValue === 'function' ){
		exportValue = this.exportValue(this, row);
	} else if(  typeof this.exportValue !== 'undefined'  ){
		exportValue = this.exportValue;
	} else {
		exportValue = this.getValue(row);
	};
	return exportValue;
};

function CompositeRow(row){
	row.addCell = CompositeRow.addCell;
	row.getCell = CompositeRow.getCell;
	row.getValue = CompositeRow.getValue;
	row.getSortValue = CompositeRow.getSortValue;
	row.getExportValue = CompositeRow.getExportValue;
	row.getRowName = CompositeRow.getRowName;
	
	if( !row.cells ){
		row.cells = {};
	};
};
CompositeRow.addCell = function(cell){
	var columnName = cell.column;
	this.cells[columnName] = cell;
};
CompositeRow.getCell = function(name){
	var cell = this.cells ? this.cells[name] : undefined;
	return cell;
};
CompositeRow.getValue = function(name){
	var cell = this.getCell(name);
	var value = cell ? cell.getValue(this) : undefined;
	return value;
};
CompositeRow.getSortValue = function(name){
	var cell = this.getCell(name);
	var sortValue = cell ? cell.getSortValue(this) : undefined;
	return sortValue;
};
CompositeRow.getExportValue = function(name){
	var cell = this.getCell(name);
	var exportValue = cell ? cell.getExportValue(this) : undefined;
	return exportValue;
};
CompositeRow.getRowName = function(){
	return this.rowName;
};

// --------------------------------------------------------------------------
/* 
 This canvas displays tabular data in an HTML table. The elements from the generators
 can take two formats: rows or cells.
 
 In the case of row elements, each element represents a row in a table. Each row has a 
 number of cells, which are the values found under each heading.

 Row elements are expected to have the following format:
{
	id: <string>  (Unique identifier for this element)
	cells: {
		"heading1": {
			value: "value1"
			,sortValue: "value1"
			,exportValue: "value1"
			,type: "string"
		}
		,"heading2": {
			value: "123456789"
			,display: function($td, cell, element){ ... }
			,sortValue: "ABC"
			,exportValue: "ABC"
			,type: "reference"
		}
	}
}

 In the case of cell elements, each element is associated with a single cell. Cell element
 are expected to have the following format:
{
	id: <string>  (Unique identifier for this element)
	,row: <string> (Identifier of the row)
	,column: <string> (Identifier of the colmun)
	,value: "value1"
	,display: function($td, cell, element){ ... }
	,sortValue: "value1"
	,exportValue: "value1"
	,type: "string"  ("string" or "reference")
}

The attribute for each cell is described here:
- value: Required. This is the value of the cell. It can be a string, a number, a boolean, etc.
         If it is a function, it will be called with the following signature: function(cell, row)
         Note that depending on the type of elements provided by the element generator, it is possible
         that the element is the cell or the row.
         
- sortValue: Optional. Value to be used when sorting the column based on this value. If not specified,
             the value is used.

- exportValue: Optional. Value to be used when table is exported. If not specified, the value is
               used. If this is a function, the following signature is used: function(cell, row).
               Note that depending on the type of elements provided by the element generator, it is 
               possible that the element is the cell or the row.
               
- type: Optional. Type of the value. If not specified, it assumed to be 'string'. Supported types
        are 'string' and 'reference'.

- display: Optional. Function to be used when displaying this value to the user. This replaces the
           default behaviour and allows the element generator to supply any display function.
           When used, the following signature is used: function($td, cell, row) 


One element can be provided to specify the columns and the order in which they should be
displayed. This element has the following format:

{
	isHeader: true,
	columns: [
		{
			name: 'heading1'
			,label: 'First'
			,title: 'Explanation of First'
		}
		,{
			name: 'heading2'
			,label: {
				nunaliit_type: 'localized'
				,en: 'Second'
			}
			,title: {
				nunaliit_type: 'localized'
				,en: 'Explanation of Second'
			}
		}
	]
}

*/
var TableCanvas = $n2.Class({

	canvasId: null,
 	
	sourceModelId: null,

	elementGenerator: null,

	dispatchService: null,

	showService: null,
	
	elementsById: null,
	
	rowsByName: null,
	
	sortedRows: null,
	
	headings: null,
	
	sortOrder: null,

	styleRules: null,
	
	useLazyDisplay: null,
	
	refreshIntervalInMs: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: null
			,sourceModelId: null
			,elementGenerator: null
			,useLazyDisplay: false
			,refreshIntervalInMs: 200
			,styleRules: null
			,dispatchService: null
			,showService: null
			,sortOrder: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
 		
		var _this = this;
		
		this.canvasId = opts.canvasId;
		this.sourceModelId = opts.sourceModelId;
		this.elementGenerator = opts.elementGenerator;
		this.useLazyDisplay = opts.useLazyDisplay;
		this.refreshIntervalInMs = opts.refreshIntervalInMs;
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.sortOrder = [];
		if( typeof opts.sortOrder === 'string' ){
			// Only one column, assume ascending
			this.sortOrder.push({
				name: opts.sortOrder
				,direction: 1
			});
		} else if( $n2.isArray(opts.sortOrder) ) {
			for(var i=0,e=opts.sortOrder.length; i<e; ++i){
				var s = opts.sortOrder[i];
				if( typeof s === 'string' ){
					// Column name, assume ascending
					this.sortOrder.push({name: s, direction: 1});
				} else if( typeof s === 'object' 
				 && typeof s.name === 'string' ){
					if( typeof s.direction !== 'number' ){
						// If not specified, assume ascending
						s.direction = 1;
					};
					this.sortOrder.push(s);
				};
			};
		} else if( opts.sortOrder 
		 && typeof opts.sortOrder === 'object' 
		 && typeof opts.sortOrder.name === 'string' ){
			if( typeof opts.sortOrder.direction !== 'number' ){
				// If not specified, assume ascending
				opts.sortOrder.direction = 1;
			};
			this.sortOrder.push(opts.sortOrder);
		};
		
		this.elementsById = {};
		this.rowsByName = {};
		this.sortedRows = [];
		this.headings = [];

		this.styleRules = $n2.styleRule.loadRulesFromObject(opts.styleRules);
 		
 		// Element generator
 		if( this.elementGenerator ){
			this.elementGenerator.setElementsChangedListener(function(added, updated, removed){
				_this._elementsChanged(added, updated, removed);
			});
			this.elementGenerator.setIntentChangedListener(function(updated){
				_this._intentChanged(updated);
			});
 		};
 		
 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m){
 				_this._handleDispatch(m);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 		};
 		
 		this.createGraph();
 		
 		opts.onSuccess();

 		if( this.sourceModelId ){
 			if( this.dispatchService ){
 				var msg = {
 					type: 'modelGetState'
 					,modelId: this.sourceModelId
 					,state: null
 				};
 				this.dispatchService.synchronousCall(DH,msg);
 				if( msg.state ){
 					this._sourceModelUpdated(msg.state);
 				};
 			};
 		};

 		$n2.log('TableCanvas',this);
 	},
	
	_getElem: function(){
		var $elem = $('#'+this.canvasId);
		if( $elem.length < 1 ){
			return undefined;
		};
		return $elem;
	},
 	
 	createGraph: function() {
		var _this = this;
		
		var $elem = this._getElem();
		if( $elem ){
			$elem
				.empty()
				.addClass('n2TableCanvas')
				.click(function(e){
					_this._backgroundClicked();
				});

			$('<button>')
				.text('Export CSV')
				.appendTo($elem)
				.click(function(){
					_this._exportCsv();
					return false;
				});
		

			var $table = $('<table>')
				.appendTo($elem);
			
			$('<tbody>')
				.appendTo($table)
				.scroll(function(){
					_this._scrollChanged( $(this) );
					return true;
				});
		};
 	},
 		
	_backgroundClicked: function(){
		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'userUnselect'
			});
		};
	},

	_scrollChanged: function( $table ){
		if( this.useLazyDisplay ){
			var _this = this;
			
			var scrollTop = $table.scrollTop();

			// Wait a bit before refreshing
			this.lastScrollTop = scrollTop;
			window.setTimeout(function(){
				if( _this.lastScrollTop === scrollTop  ){
					_this._refreshRows();
				};
			},this.refreshIntervalInMs);
		};
	},

 	_elementsChanged: function(addedElements, updatedElements, removedElements){
 		var _this = this;
 		
 		// Remove elements that are no longer there
		for(var i=0,e=removedElements.length; i<e; ++i){
			var removed = removedElements[i];
			delete this.elementsById[removed.id];
		};
		
		// Add elements
		for(var i=0,e=addedElements.length; i<e; ++i){
			var added = addedElements[i];
			if( added.isHeader ){
				installHeader(added);

			} else if( added.cells ) {
				// This is an element that is a complete row
				this.elementsById[ added.id ] = added;
				RowElement(added);
				
			} else if( added.row && added.column ) {
				// This is an element that provides only a cell.
				this.elementsById[ added.id ] = added;
				CellElement(added);
			};
		};
		
		// Update elements
		for(var i=0,e=updatedElements.length; i<e; ++i){
			var updated = updatedElements[i];
			if( updated.isHeader ){
				installHeader(updated);

			} else if( updated.cells ) {
				// This is an element that is a complete row
				this.elementsById[ updated.id ] = updated;
				RowElement(updated);

			} else if( updated.row && updated.column ) {
				// This is an element that provides only a cell.
				this.elementsById[ updated.id ] = updated;
				CellElement(updated);
			};
		};
		
		// Make rows from elements
 		var sortedRows = [];
 		var rowsByName = {};
 		for(var elementId in this.elementsById){
 			var element = this.elementsById[elementId];
 			
 			if( element.cells ){
 				// This is a RowElement. Insert as a row
 				sortedRows.push(element);
	 			rowsByName[element.getRowName()] = element;
 			} else if( element.row && element.column ){
 				// This is a cell element. Insert into a row.
 				var rowName = element.row;
 				var row = rowsByName[rowName];
 				if( !row ){
 	 				row = {
 	 					rowName: rowName
 	 				};
 	 				CompositeRow(row);
 	 				rowsByName[rowName] = row;
 	 				sortedRows.push(row);
 				};
 				row.addCell(element);
 			};
 		};
		this._sortRows(sortedRows);
		this.sortedRows = sortedRows;
		this.rowsByName = rowsByName;

		this._redraw();
		
		function installHeader(element){
			if( element.columns ){
				_this.headings = element.columns;
			};
		};
	},
	
	_redraw: function(){
		var _this = this;

		var $elem = this._getElem();
		var $table = $elem.find('tbody');
		
		$table.empty();
		
		var $tr = $('<tr>')
			.appendTo($table);
		this.headings.forEach(function(heading){
			var label = _loc( heading.label );
			if( !label ){
				label = heading.name;
			};
			var $th = $('<th>')
				.appendTo($tr);
			var $a = $('<a>')
				.attr('href','#')
				.attr('data-sort-name',heading.name)
				.text(label)
				.appendTo($th)
				.click(function(){
					var $a = $(this);
					var headingName = $a.attr('data-sort-name');
					_this._sortOnName(headingName);
					return false;
				});
			
			if( heading.title ){
				$a.attr('title', _loc(heading.title));
			};
		});
		
		this.sortedRows.forEach(function(row){
			var $tr = $('<tr>')
				.attr('nunaliit-row',row.getRowName())
				.appendTo($table);

			// Assign element id to row
			if( !row.elemId ){
				row.elemId = $n2.getUniqueId();
			};
			$tr.attr('id',row.elemId);
			
			// If row is an element, adjust styles
			if( row.isRowElement ) {
				_this._adjustStyles($tr, row);
			};

			_this.headings.forEach(function(heading){
				var name = heading.name;
				var $td = $('<td>')
					.attr('nunaliit-column',name)
					.attr('nunaliit-row',row.getRowName())
					.appendTo($tr);
				var cell = row.getCell(name);
				
				if( cell ){
					if( cell.isCellElement ){
						if( !cell.elemId ){
							cell.elemId = $n2.getUniqueId();
						};
						$td.attr('id',cell.elemId);
	
						_this._adjustStyles($td, cell);
					};

					if( _this.useLazyDisplay ){
						$td.addClass('n2TableCanvas_lazyDisplay');
					} else {
						_this._displayCell($td);
					};
				};
			});
		});

		if( this.useLazyDisplay ){
			this._refreshRows();
		} else {
			this.showService.fixElementAndChildren($table);
		};
	},
	
	/**
	 * Loops through the rows and display those that are visible
	 */
	_refreshRows: function(){
		var _this = this;

		var $canvas = this._getElem();
		var $table = $canvas.find('tbody');

		var elemPosition = $table.position();
		var elemHeight = $table.height();
		var elemOffsetTop = $table.scrollTop();
		
		var atLeastOneShown = false;
		$canvas.find('.n2TableCanvas_lazyDisplay').each(function(){
			var $cell = $(this);
			
			var cellPosition = $cell.position();
			var cellHeight = $cell.height();
			
			var show = true;
			if( cellPosition.top > (elemHeight + elemOffsetTop + elemPosition.top) ){
				show = false;
			} else if( (cellPosition.top + cellHeight) < (elemOffsetTop + elemPosition.top) ){
				show = false;
			};
			
			if( show ){
				_this._displayCell($cell);
				$cell.removeClass('n2TableCanvas_lazyDisplay');
				atLeastOneShown = true;
			} else {
				// Keep content already displayed
			};
		});
		
		if( atLeastOneShown ){
			this.showService.fixElementAndChildren($canvas);
		};
	},
	
	_displayCell: function($td){
		var _this = this;
		
		var colName = $td.attr('nunaliit-column');
		var rowName = $td.attr('nunaliit-row');
		var row = this.rowsByName[rowName];
		var cell = row.getCell(colName);

		if( cell ){
			if( typeof cell.display === 'function' ){
				cell.display($td, cell, row);
				
				$td
					.click(function(){
						var $td = $(this);
						_this._selectedCell($td);
						return false;
					}).mouseover(function(){
						var $td = $(this);
						_this._mouseOver($td);
						return false;
					})
					.mouseout(function(){
						var $td = $(this);
						_this._mouseOut($td);
						return false;
					});

			} else if( typeof cell.display === 'string' ){
				$('<a>')
					.attr('href','#')
					.attr('nunaliit-row',row.getRowName())
					.attr('nunaliit-colmun',colName)
					.text(cell.display)
					.appendTo($td)
					.click(function(){
						var $a = $(this);
						_this._selectedCell($a);
						return false;
					})
					.mouseover(function(){
						var $a = $(this);
						_this._mouseOver($a);
						return false;
					})
					.mouseout(function(){
						var $a = $(this);
						_this._mouseOut($a);
						return false;
					});
				
			} else {
				var value = row.getValue(colName);

				if( typeof value !== 'undefined' ){
					if( 'reference' === cell.type ){
						$('<a>')
							.addClass('n2s_referenceLink')
							.attr('nunaliit-document',value)
							.text(value)
							.appendTo($td);
						
					} else {
						$('<a>')
							.attr('href','#')
							.attr('nunaliit-row',row.getRowName())
							.attr('nunaliit-column',colName)
							.text(value)
							.appendTo($td)
							.click(function(){
								var $a = $(this);
								_this._selectedCell($a);
								return false;
							})
							.mouseover(function(){
								var $a = $(this);
								_this._mouseOver($a);
								return false;
							})
							.mouseout(function(){
								var $a = $(this);
								_this._mouseOut($a);
								return false;
							});
					};
				};
			};
		};
	},
	
	_selectedCell: function($a){
		var element = this._getElementFromHtml($a);

		if( element ){
 			this.elementGenerator.selectOn(element);
		};
	},
	
	_mouseOver: function($a){
		var element = this._getElementFromHtml($a);

		if( element ){
 			this.elementGenerator.focusOn(element);
		};
	},
	
	_mouseOut: function($a){
		var element = this._getElementFromHtml($a);

		if( element ){
 			this.elementGenerator.focusOff(element);
		};
	},
	
	_getElementFromHtml: function($a){
		var rowName = $a.attr('nunaliit-row');
		var columnName = $a.attr('nunaliit-column');
		var row = this.rowsByName[rowName];
		
		if( row ){
			var cell = row.getCell(columnName);
			if( cell && cell.isCellElement ){
				return cell;
			};
			
			if( row.isRowElement ){
				return row;
			};
		};
		
		return undefined;
	},
	
	_sortOnName: function(name){
		// Special case: first time clicking on first column
		// Assume that first column was already clicked
		if( this.sortOrder.length < 1 
		 && this.headings.length > 0
		 && this.headings[0].name === name ){
			this.sortOrder.unshift({
				name: name
				,direction: 1
			});
		};
		
		// Detect if already in array
		var index = -1;
		this.sortOrder.forEach(function(sortEntry, i){
			if( sortEntry.name === name ){
				index = i;
			};
		});
		
		var insert = true;
		if( index == 0 ){
			// Selecting same twice. Reverse direction
			this.sortOrder[0].direction = this.sortOrder[0].direction * -1;
			insert = false;

		} else if( index >= 0  ){
			// remove it
			this.sortOrder.splice(index,1);
		};

		// Insert at the beginning
		if( insert ){
			this.sortOrder.unshift({
				name: name
				,direction: 1
			});
		};
		
		this._sortRows(this.sortedRows);
		
		this._reorderDisplayedRows();
	},
	
	_reorderDisplayedRows: function(){
		this.sortedRows.forEach(function(row){
			var rowId = row.elemId;
			if( rowId ){
				var $row = $('#'+rowId);
				if( $row.length > 0 ){
					var $parent = $row.parent();
					$row.appendTo($parent);
				};
			};
		});
	},

	_intentChanged: function(changedElements){
		var _this = this;

		changedElements.forEach(function(element){
			if( element.elemId ){
				var $elem = $('#'+element.elemId);
				if( $elem.length > 0 ){
					_this._adjustStyles($elem, element);
				};
			};
		});
	},
 	
 	_sourceModelUpdated: function(state){
 		this.elementGenerator.sourceModelUpdated(state);
 	},

 	_handleDispatch: function(m){
 		if( 'modelGetInfo' === m.type ){
 			if( m.modelId === this.modelId ){
 				m.modelInfo = this._getModelInfo();
 			};
 			
 		} else if( 'modelStateUpdated' === m.type ) {
 			if( this.sourceModelId === m.modelId ){
 				if( m.state ){
 					this._sourceModelUpdated(m.state);
 				};
 			};
 		};
 	},

 	_adjustStyles: function($elem, element){
		element.n2_elem = $elem[0];
		var symbolizer = this.styleRules.getSymbolizer(element);
		symbolizer.adjustHtmlElement($elem[0],element);
		delete element.n2_elem;
 	},
 	
 	_sortRows: function(rows){
 		var _this = this;
 		
 		// Figure out the order in which things should be sorted
 		var orderedNames = [];
 		var seenNameMap = {};
 		this.sortOrder.forEach(function(sortEntry){
 			var name = sortEntry.name;

 			if( !seenNameMap[name] ){
 	 			orderedNames.push(sortEntry);
 	 			seenNameMap[name] = true;
 			};
 		});
 		this.headings.forEach(function(heading){
 			var name = heading.name;
 			if( !seenNameMap[name] ){
 	 			orderedNames.push({
 	 				name: name
 	 				,direction: 1
 	 			});
 	 			seenNameMap[name] = true;
 			};
 		});

 		rows.sort(function(a,b){
 			for(var i=0,e=orderedNames.length; i<e; ++i){
 				var name = orderedNames[i].name;
 				var direction = orderedNames[i].direction;

 				var aValue = a.getSortValue(name);
 				var bValue = b.getSortValue(name);
 				
 				if( aValue < bValue ) {
 					return -1 * direction;
 				} else if( aValue > bValue ) {
 					return 1 * direction;
 				};
 			};
 			
 			return 0;
 		});
 	},

 	_computeCsvContent: function(){
 		var _this = this;
 		var table = [];
		
		// Headings
		var headLine = [];
		table.push(headLine);
		this.headings.forEach(function(heading){
			headLine.push(heading.name);
		});
		
		// Data
		if( this.sortedRows ){
			this.sortedRows.forEach(function(element){
				var line = [];
				table.push(line);
				_this.headings.forEach(function(heading){
					var name = heading.name;
					
					var value = element.getExportValue(name);

					line.push(value);
				});
			});
		};
		
		var csvContent = $n2.csv.ValueTableToCsvString(table);
		
		return csvContent;
	},

 	_exportCsv: function(){
		var csvContent = this._computeCsvContent();
		
		if( typeof Blob !== 'undefined' 
		 && typeof saveAs === 'function' ){
			var blob = new Blob([csvContent],{type: "text/plain;charset=" + document.characterSet});
			saveAs(blob, 'table.csv');
			
		} else {
			var $dialog = $('<div>')
				.addClass('n2canvasReferenceBrowser_exportCsv_dialog');
			var diagId = $n2.utils.getElementIdentifier($dialog);
			
			$('<textarea>')
				.addClass('n2canvasTable_exportCsv_text')
				.text(csvContent)
				.appendTo($dialog);
			
			$dialog.dialog({
				autoOpen: true
				,title: _loc('CSV')
				,modal: true
				,width: 370
				,close: function(event, ui){
					var diag = $('#'+diagId);
					diag.dialog('destroy');
					diag.remove();
				}
			});
		};
	}
});

//--------------------------------------------------------------------------
// Define default element generator for table canvas
var ElementGenerator = $n2.canvasElementGenerator.ElementGenerator;

var DefaultTableElementGenerator = $n2.Class('DefaultTableElementGenerator', ElementGenerator, {
	initialize: function(opts_){
		ElementGenerator.prototype.initialize.call(this, opts_);
	},

	_createFragmentsFromDoc: function(doc){
		return [
			{
				id: doc._id
				,n2_id: doc._id
				,n2_doc: doc
			}
		];
	},

	_updateElements: function(fragmentMap, currentElementMap){
		var elementsById = {};
		
		var header = {
			id: '__HEADER__'
			,isHeader: true
			,columns: [
			   {
				   name: 'id'
				   ,label: 'id'
			   }
			   ,{
				   name: 'rev'
				   ,label: 'rev'
			   }
			]
		};
		elementsById[header.id] = header;
		
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			var elementId = fragId;
			var element = currentElementMap[elementId];
			if( !element ){
				element = {
					id: elementId
				};
			};
			element.fragments = {};
			element.fragments[fragId] = frag;
			elementsById[elementId] = element;
			
			var doc = frag.n2_doc;
			element.cells = {
				id: {
					value: doc._id
				}
				,rev: {
					value: doc._rev
				}
			};
			element.n2_id = doc._id;
		};
		
		return elementsById;
	}
});

function DefaultTableElementGeneratorFactory(opts_){
	var opts = $n2.extend({
		type: null
		,options: null
		,config: null
	},opts_);
	
	var options = {};
	if( opts.options ){
		for(var key in opts.options){
			var value = opts.options[key];
			options[key] = value;
		};
	};
	
	if( opts.config 
	 && opts.config.directory ){
		options.dispatchService = opts.config.directory.dispatchService;
	};
	
	return new DefaultTableElementGenerator(options);
};

$n2.canvasElementGenerator.AddElementGeneratorFactory({
	type: 'tableDefault'
	,factoryFn: DefaultTableElementGeneratorFactory
});

//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){

	if( m.canvasType === 'table' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'table' ){
		
		var options = {
			elementGeneratorType: 'tableDefault'
		};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
 		if( !options.elementGenerator ){
 			// If not defined, use the one specified by type
 			options.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: options.elementGeneratorType
 	 			,options: options.elementGeneratorOptions
 	 			,config: m.config
 	 		});
 		};
		
		options.canvasId = m.canvasId;
		options.interactionId = m.interactionId;
		options.moduleDisplay = m.moduleDisplay;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;

		if( m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
				options.showService = m.config.directory.showService;
			};
		};
		
		new TableCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasTable = {
	TableCanvas: TableCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.canvasMap.js

/*
Copyright (c) 2018, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasMap'
 ;

// --------------------------------------------------------------------------
/* 
This canvas displays a map based on OpenLayers5.  

*/
 
//--------------------------------------------------------------------------
 var VENDOR = {
	GOOGLEMAP : 'googlemaps',
	BING : 'bing',
	WMS : 'wms',
	OSM : 'osm',
	STAMEN : 'stamen',
	IMAGE : 'image',
	COUCHDB : 'couchdb'
 };
 

// --------------------------------------------------------------------------

 var CouchDbSource = $n2.Construct(ol.source.Vector,{
 	
 	sourceId: null,
 	sourceModelId: null,
 	dispatchService: null,
 	elementGenerator: null,
 	infoByDocId: null,
 	mapProjCode: null,
 	epsg4326Resolution: null,

 	constructor: function(opts_){
 		var opts = $n2.extend({
 			sourceModelId: undefined
 			,dispatchService: undefined
 			,projCode: undefined
 		},opts_);

 		var _this = this;

 		this.sourceId = $n2.getUniqueId();
 		this.infoByDocId = {};

 		CouchDbSource.base(this, 'constructor', opts_);
 		
 		this.sourceModelId = opts.sourceModelId;
 		this.dispatchService = opts.dispatchService;
 		this.mapProjCode = opts.projCode;

 		// Register to events
 		if( this.dispatchService ){
 			var f = function(m, addr, dispatcher){
 				_this._handleDispatch(m, addr, dispatcher);
 			};
 			
 			this.dispatchService.register(DH,'modelGetInfo',f);
 			this.dispatchService.register(DH,'modelStateUpdated',f);
 			this.dispatchService.register(DH,'simplifiedGeometryReport',f);
 		};
 		
 		// Request for current state
  		if( this.sourceModelId ){
  			if( this.dispatchService ){
  				var msg = {
  					type: 'modelGetState'
  					,modelId: this.sourceModelId
  					,state: null
  				};
  				this.dispatchService.synchronousCall(DH,msg);
  				if( msg.state ){
  					this._sourceModelStateUpdated(msg.state);
  				};
  			};
  		};
 	},

 	_sourceModelStateUpdated: function(state){
 		var _this = this;

 		//$n2.log('map canvas receives update',state);
 		if( state.added ){
 			state.added.forEach(function(addedDoc){
 				var docId = addedDoc._id;
 				var docInfo = _this.infoByDocId[docId];
 				if( !docInfo ){
 					docInfo = {};
 					_this.infoByDocId[docId] = docInfo;
 				};
 				docInfo.doc = addedDoc;
 			});
 		};
 		if( state.updated ){
 			state.updated.forEach(function(updatedDoc){
 				var docId = updatedDoc._id;
 				var docInfo = _this.infoByDocId[docId];
 				if( !docInfo ){
 					docInfo = {};
 					_this.infoByDocId[docId] = docInfo;
 				};
 				if( docInfo.doc ){
 					if( docInfo.doc._rev !== updatedDoc._rev ){
 						// New version of document. Clear simplified info
 						delete docInfo.simplifications;
 						delete docInfo.simplifiedName;
 						delete docInfo.simplifiedResolution;
 						delete docInfo.simplifiedInstalled;
 					};
 				}
 				docInfo.doc = updatedDoc;
 			});
 		};
 		if( state.removed ){
 			state.removed.forEach(function(removedDoc){
 				var docId = removedDoc._id;
 				delete _this.infoByDocId[docId];
 			});
 		};

 		this._reloadAllFeatures();
 	},

 	_handleDispatch: function(m, addr, dispatcher){
 		var _this = this;

 		if('modelStateUpdated' === m.type) {
 			if( this.sourceModelId === m.modelId ){
 				this._sourceModelStateUpdated(m.state);
 			};
 		} else if('simplifiedGeometryReport' === m.type) {
 			if( $n2.isArray(m.simplifiedGeometries) ){
 				var atLeastOne = false;
 				m.simplifiedGeometries.forEach(function(simplifiedGeom){
 					var docId = simplifiedGeom.id;
 					var attName = simplifiedGeom.attName;
 					var wkt = simplifiedGeom.wkt;
 					
 					var docInfo = _this.infoByDocId[docId];
 					if( docInfo ){
 						if( !docInfo.simplifications ){
 							docInfo.simplifications = {};
 						};
 						docInfo.simplifications[attName] = wkt;
 						atLeastOne = true;
 					};
 				});
 				
 				if( atLeastOne ){
 					this._reloadAllFeatures();
 				};
 			};
 		}
 	},
 	
 	/**
 	 * This function is called when the map resolution is changed
 	 */
 	changedResolution: function(res,proj){
 		//$n2.log('resolution',res,proj);
 		this.epsg4326Resolution = this._getResolutionInProjection(res,proj);
 		
 		for(var docId in this.infoByDocId){
 			var docInfo = this.infoByDocId[docId];
 			var doc = docInfo.doc;
 			if( doc && doc.nunaliit_geom
 			 && doc.nunaliit_geom.simplified 
 			 && doc.nunaliit_geom.simplified.resolutions ){
 				var bestAttName = undefined;
 				var bestResolution = undefined;
 				for(var attName in doc.nunaliit_geom.simplified.resolutions){
 					var attRes = 1 * doc.nunaliit_geom.simplified.resolutions[attName];
 					if( attRes < this.epsg4326Resolution ){
 						if( typeof bestResolution === 'undefined' ){
 							bestResolution = attRes;
 							bestAttName = attName;
 						} else if( attRes > bestResolution ){
 							bestResolution = attRes;
 							bestAttName = attName;
 						};
 					};
 				};
 				
 				// At this point, if bestResolution is set, then this is the geometry we should
 				// be displaying
 				if( undefined !== bestResolution ){
 					docInfo.simplifiedName = bestAttName;
 					docInfo.simplifiedResolution = bestResolution;
 				};
 			};
 		};
 		
 		var geometriesRequested = [];
 		for(var docId in this.infoByDocId){
 			var docInfo = this.infoByDocId[docId];
 			var doc = docInfo.doc;
 			if( docInfo.simplifiedName ) {
 				// There is a simplification needed, do I have it already?
 				var wkt = undefined;
 				if( docInfo.simplifications ){
 					wkt = docInfo.simplifications[docInfo.simplifiedName];
 				};

 				// If I do not have it, request it
 				if( !wkt ){
 					var geomRequest = {
 						id: docId
 						,attName: docInfo.simplifiedName
 						,doc: doc
 					};
 					geometriesRequested.push(geomRequest);
 				};
 			};
 		}
 		
 		this.dispatchService.send(DH,{
 			type: 'simplifiedGeometryRequest'
 			,geometriesRequested: geometriesRequested
 			,requester: this.sourceId
 		});
 		
 		this._reloadAllFeatures();
 	},

 	_getResolutionInProjection: function(targetResolution, proj){

 		if( proj.getCode() !== 'EPSG:4326' ){
 			var transformFn = ol.proj.getTransform(proj.getCode(), 'EPSG:4326')
 			// Convert [0,0] and [0,1] to proj
 			var p0 = transformFn([0,0]);
 			var p1 = transformFn([0,1]);
 			
 			var factor = Math.sqrt( ((p0[0]-p1[0])*(p0[0]-p1[0])) + ((p0[1]-p1[1])*(p0[1]-p1[1])) );
 			
 			targetResolution = targetResolution * factor;
 		};
 		
 		return targetResolution;
 	},

 	_reloadAllFeatures: function(){
 		var _this = this;

 		var wktFormat = new ol.format.WKT();

 		var features = [];
 		for(var docId in this.infoByDocId){
 			var docInfo = this.infoByDocId[docId];
 			var doc = docInfo.doc;
 			if( doc
 			 && doc.nunaliit_geom
 			 && doc.nunaliit_geom.wkt ){
 				var wkt = doc.nunaliit_geom.wkt;
 				if( docInfo.simplifiedName
 				 && docInfo.simplifications 
 				 && docInfo.simplifications[docInfo.simplifiedName] ){
 					// If there is a simplification loaded for this geometry,
 					// use it
 					wkt = docInfo.simplifications[docInfo.simplifiedName];
 					docInfo.simplifiedInstalled = docInfo.simplifiedName;
 				};

 				var geometry = wktFormat.readGeometryFromText(wkt);
 				geometry.transform('EPSG:4326', _this.mapProjCode);

 				var feature = new ol.Feature();
 				feature.setGeometry(geometry);
 				feature.setId(docId);
 				
 				docInfo.feature = feature;

// 				if (geoJSONFeature['properties']) {
// 					feature.setProperties(geoJSONFeature['properties']);
// 				}
 				
 				features.push(feature);
 			};
 		};

 		this.clear();
 		this.addFeatures(features);
 	}
 })
// ================================= 
 
var MapCanvas = $n2.Class('MapCanvas',{

	canvasId: null,

	sourceModelId: null,
	
	elementGenerator: null,

	dispatchService: null,

	showService: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			canvasId: undefined
			,sourceModelId: undefined
			,elementGenerator: undefined
			,config: undefined
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		
		try {
			this.canvasId = opts.canvasId;
			this.sourceModelId = opts.sourceModelId;
			this.elementGenerator = opts.elementGenerator;
	
			var config = opts.config;
			if( config ){
				if( config.directory ){
					this.dispatchService = config.directory.dispatchService;
					this.showService = config.directory.showService;
				};
			};

			this.sources = [];
			if( $n2.isArray(opts.overlays) ){
				opts.overlays.forEach(function(overlay){
					if( 'couchdb' === overlay.type ){
						var sourceModelId = undefined;
						if( overlay.options
						 && 'string' === typeof overlay.options.sourceModelId ){
							sourceModelId = overlay.options.sourceModelId;
						} else if( overlay.options
						 && 'string' === typeof overlay.options.layerName ){
							sourceModelId = overlay.options.layerName;
						} else {
							$n2.logError('Map canvas overlay is not named. Will be ignored');
						};

						if( sourceModelId ){
							var source = new CouchDbSource({
								sourceModelId: sourceModelId
								,dispatchService: _this.dispatchService
								,projCode: 'EPSG:3857'
							});
							_this.sources.push(source);
						};
					} else {
						$n2.logError('Can not handle overlay type: '+overlay.type);
					}
				});
			};
	
			// Register to events
			if( this.dispatchService ){
				var f = function(m){
					_this._handleDispatch(m);
				};
				
			};
			
			$n2.log(this._classname,this);
			
			this.bgSources = opts.backgrounds || [];
			this._drawMap();
			
		} catch(err) {
			var error = new Error('Unable to create '+this._classname+': '+err);
			opts.onError(error);
		};
		
		opts.onSuccess();
	}
	
	,_getElem: function(){
		var $elem = $('#'+this.canvasId);
		if( $elem.length < 1 ){
			return undefined;
		};
		return $elem;
	},

	_drawMap: function() {
		var _this = this;
		 var image = new ol.style.Circle({
		        radius: 5,
		        fill: null,
		        stroke: new ol.style.Stroke({color: 'red', width: 1})
		      });

		      var styles = {
		        'Point': new ol.style.Style({
		          image: image
		        }),
		        'LineString': new ol.style.Style({
		          stroke: new ol.style.Stroke({
		            color: 'green',
		            width: 1
		          })
		        }),
		        'MultiLineString': new ol.style.Style({
		          stroke: new ol.style.Stroke({
		            color: 'green',
		            width: 1
		          })
		        }),
		        'MultiPoint': new ol.style.Style({
		          image: image
		        }),
		        'MultiPolygon': new ol.style.Style({
		          stroke: new ol.style.Stroke({
		            color: 'yellow',
		            width: 1
		          }),
		          fill: new ol.style.Fill({
		            color: 'rgba(255, 255, 0, 0.1)'
		          })
		        }),
		        'Polygon': new ol.style.Style({
		          stroke: new ol.style.Stroke({
		            color: 'blue',
		            lineDash: [4],
		            width: 3
		          }),
		          fill: new ol.style.Fill({
		            color: 'rgba(0, 0, 255, 0.1)'
		          })
		        }),
		        'GeometryCollection': new ol.style.Style({
		          stroke: new ol.style.Stroke({
		            color: 'magenta',
		            width: 2
		          }),
		          fill: new ol.style.Fill({
		            color: 'magenta'
		          }),
		          image: new ol.style.Circle({
		            radius: 10,
		            fill: null,
		            stroke: new ol.style.Stroke({
		              color: 'magenta'
		            })
		          })
		        }),
		        'Circle': new ol.style.Style({
		          stroke: new ol.style.Stroke({
		            color: 'red',
		            width: 2
		          }),
		          fill: new ol.style.Fill({
		            color: 'rgba(255,0,0,0.2)'
		          })
		        })
		      };

		      var styleFunction = function(feature) {
		        return styles[feature.getGeometry().getType()];
		      };
		      
		/**
		 * declare and init two layers array -- map and overlay 
		 */
		var mapLayers = [];
		var overlayLayers = [];
		
		/**
		 * filling in the vector layers
		 */
		/**
		 * Define the geometryFunction for the clusterSource
		 *
		 */
		function n2geometryFunc(feature) {
			var geom = feature.getGeometry();
			//console.log("A new geometry with type: " + geom.getType());
			if(geom.getType() == 'Point'){
				return geom;
			} else if(geom.getType() == 'LineString'){
				return new ol.geom.Point(geom.getLastCoordinate());
			} else if(geom.getType() == 'Polygon'){
				return geom.getInteriorPoint();
			} else if(geom.getType() == 'MultiPoint'){
				return new ol.geom.Point(geom.getLastCoordinate());
			} else if(geom.getType() == 'MultiPolygon') {
				return new ol.geom.Point(geom.getLastCoordinate());
			} else if(geom.getType() == 'MultiLineString'){
				return new ol.geom.Point(geom.getLastCoordinate());
			}
			return null;
			
		};
		
//		/**
//		 * Testing the N2Cluster performance
//		 *
//		 */
//		var count = 200;
//		var features = new Array(count);
//		var e = 4500000;
//		var ox = 2*e *Math.random() -e;
//		var oy = 2*e *Math.random() -e;
//		for(var i=0;i<count;++i) {
//			
//			var coordinates = [[[ox, oy],[ ox+10000, oy-100*i],[ox+100000, oy+100*i]]];
//			features[i] = new ol.Feature(new ol.geom.Polygon(coordinates));
//		}
//		this.sources.push(new ol.source.Vector({features: features}));
		
		
		this.sources.forEach(function(source){
			
			/** 
			 * Testing the cluster wrapper (I wonder what polygon and line are going to 
			 * be rendered in default cluster class
			 */
			var clusterSource = new n2es6.ol5support.N2Cluster({
				distance : 20,
				source: source
			});
			var vectorLayer = new ol.layer.Vector({
				title: "CouchDb",
				source: clusterSource,
				style: styleFunction,
				renderOrder: function(feature1, feature2){
					return $n2.olUtils.ol5FeatureSorting(feature1, feature2);
				}
			});
			overlayLayers.push(vectorLayer);
		});
		
		
		mapLayers = this._genBackgroundMapLayers(this.bgSources);
		
		/**
		 * Two Groups : Overlay and Background
		 */
		var overlayGroup = new ol.layer.Group({
			title: 'Overlays',
			layers: overlayLayers
		});
		var bgGroup = new ol.layer.Group({
			title: 'Background',
			layers: mapLayers
		});
		
		/**
		 * ol.View tweaking listen on the resolution changing
		 */
		var olView = new ol.View({
			center: ol.proj.transform([-75, 45.5], 'EPSG:4326', 'EPSG:3857'),
			projection: 'EPSG:3857',
			zoom: 6
		});
		olView.on('change:resolution',function(event){
			var olView = event.target;
			if( olView ){
				var res = olView.getResolution();
				var proj = olView.getProjection();
				//$n2.log('resolution',res,proj);
				_this.sources.forEach(function(source){
					source.changedResolution(res,proj);
				});
				
			};
		});
		var customMap = new ol.Map({
			target : this.canvasId,
			layers: [
				bgGroup,
				overlayGroup
			],
			view: olView
		});
		
		
		
		var customLayerSwitcher = new ol.control.N2LayerSwitcher({
			tipLabel: 'Legend' // Optional label for button
		});
		
		
		customMap.addControl(customLayerSwitcher);
		
		var selectClick = new ol.interaction.Select({
			condition: ol.events.condition.click
		});
		selectClick.on('select', function(e){
			console.log('Test select func; Selected Feature: ' + e.selected.length);
		})
		
		customMap.addInteraction(selectClick);
		
	}
	,_genBackgroundMapLayers: function (bgSources) {
		var _this = this;
		var bg = null;
		if( bgSources ) {
					// This is the method used when background layers are specified
					// via couchModule
			for(var i=0,e=bgSources.length; i<e; ++i){
				var layerDefiniton = bgSources[i];
				var l = this._createOLLayerFromDefinition(layerDefiniton, 
						_computeDefaultLayer( bgSources , i)
						);
				if( l && !bg ) bg = [];
				if( l ) bg[bg.length] = l;
			};
					
		};
		
		return(bg);
		
		
		function _computeDefaultLayer(backgrounds, idx) {
			if( typeof _computeDefaultLayer.defaultLayerIdx == 'undefined' ) {
				_computeDefaultLayer.defaultLayerIdx = -1;
		    }
			if( _computeDefaultLayer.defaultLayerIdx === -1 ){
				_computeDefaultLayer.defaultLayerIdx = 0;
				for(var i=0,e=backgrounds.length; i<e; ++i){
					var layerDefiniton = backgrounds[i];
					if ( typeof (layerDefiniton.defaultLayer) !== undefined 
						&& layerDefiniton.defaultLayer ) {
						_computeDefaultLayer.defaultLayerIdx = i;
					}
				};
			};
			return (_computeDefaultLayer.defaultLayerIdx === idx);
		}
	}
	
	,_createOLLayerFromDefinition: function(layerDefinition, isDefaultLayer) {
		var name = _loc(layerDefinition.name);
		var _this = this;
		
		if( layerDefinition ) {
			var ol5layer = new ol.layer.Tile({
				title: layerDefinition.name,
				type: 'base',
				visible: isDefaultLayer,
				source: _this._createBackgroundMapSource(layerDefinition)
			});
			return ol5layer;
		} else {
			$n2.reportError('Bad configuration for layer: ' + name);
			return null;
		};
		

		
	}
	, _createBackgroundMapSource : function(layerDefinition) {
		
		var sourceTypeInternal = 
			layerDefinition.type.replace(/\W/g,'').toLowerCase();
		var sourceOptionsInternal = layerDefinition.options;
			
		if ( sourceTypeInternal == VENDOR.GOOGLEMAP ) {
			
			$n2.log('Background of Google map is under construction');
			
		} else if ( sourceTypeInternal == VENDOR.BING) {
			
			return new BingMaps(sourceOptionsInternal);
			
		} else if ( sourceTypeInternal == VENDOR.WMS ) {
			if (sourceOptionsInternal 
				&& sourceOptionsInternal.url 
				&& sourceOptionsInternal.layers
				&& sourceOptionsInternal.styles ) {
			var parameters = {};
			for ( var key in sourceOptionsInternal){
				if( 'LAYERS' === key.toUpperCase()
					|| 'STYLES' === key.toUpperCase()
					|| 'WIDTH' === key.toUpperCase()
					|| 'VERSION' === key.toUpperCase()
					||  'HEIGHT'  === key.toUpperCase()
					||  'BBOX' === key.toUpperCase()
					||  'CRS'=== key.toUpperCase()){
					
					parameters[key.toUpperCase()] = sourceOptionsInternal[key]
				}
				
			}
			return new TileWMS({
				url: sourceOptionsInternal.url,
				params: parameters
			});
			} else {
				
				$n2.reportError('Parameter is missing for source: ' + sourceTypeInternal );
			}
			
		} else if ( sourceTypeInternal == VENDOR.OSM) {
			
			if (sourceOptionsInternal
					&& sourceOptionsInternal.url ){
				return new OSM({
					url : sourceOptionsInternal.url
				});
			} else {
				$n2.reportError('Parameter is missing for source: ' + sourceTypeInternal );
			}
			
			
		} else if ( sourceTypeInternal == VENDOR.STAMEN) {
			if (sourceOptionsInternal
					&& sourceOptionsInternal.layerName ){
				return new ol.source.Stamen({
					layer:  sourceOptionsInternal.layerName
				});
			} else {
				$n2.reportError('Parameter is missing for source: ' + sourceTypeInternal );
			}
		} else if ( sourceTypeInternal == VENDOR.IMAGE) {
			
		} else if ( sourceTypeInternal == VENDOR.COUCHDB) {
			
		} else {
			
			$n2.reportError('Unrecognized type (' + layerDefinition.type + ')');
		}
	}
	
	,_handleDispatch: function(m, addr, dispatcher){
	}
});

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
function HandleCanvasAvailableRequest(m){
	if( m.canvasType === 'map' ){
		m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleCanvasDisplayRequest(m){
	if( m.canvasType === 'map' ){
		
		var options = {};
		if( m.canvasOptions ){
			for(var key in m.canvasOptions){
				options[key] = m.canvasOptions[key];
			};
		};
		
 		if( !options.elementGenerator ){
 			// If not defined, use the one specified by type
 			options.elementGenerator = $n2.canvasElementGenerator.CreateElementGenerator({
 	 			type: options.elementGeneratorType
 	 			,options: options.elementGeneratorOptions
 	 			,config: m.config
 	 		});
 		};
 		
		options.canvasId = m.canvasId;
		options.config = m.config;
		options.onSuccess = m.onSuccess;
		options.onError = m.onError;
		
		new MapCanvas(options);
	};
};

//--------------------------------------------------------------------------
$n2.canvasMap = {
	MapCanvas: MapCanvas
	,HandleCanvasAvailableRequest: HandleCanvasAvailableRequest
	,HandleCanvasDisplayRequest: HandleCanvasDisplayRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.display.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.display'
 ;
 
//--------------------------------------------------------------------------
var Service = $n2.Class({
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'displayIsTypeAvailable',f);
			this.dispatchService.register(DH,'displayRender',f);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'displayIsTypeAvailable' === m.type ){
			if( $n2.couchDisplay 
			 && $n2.couchDisplay.HandleDisplayAvailableRequest ){
				$n2.couchDisplay.HandleDisplayAvailableRequest(m);
			};

			if( $n2.couchDisplayTiles 
			 && $n2.couchDisplayTiles.HandleDisplayAvailableRequest ){
				$n2.couchDisplayTiles.HandleDisplayAvailableRequest(m);
			};

			if( $n2.displayRibbon 
			 && $n2.displayRibbon.HandleDisplayAvailableRequest ){
				$n2.displayRibbon.HandleDisplayAvailableRequest(m);
			};

			if( $n2.displayRibbon2 
			 && $n2.displayRibbon2.HandleDisplayAvailableRequest ){
				$n2.displayRibbon2.HandleDisplayAvailableRequest(m);
			};

		} else if( 'displayRender' === m.type ) {
			if( $n2.couchDisplay 
			 && $n2.couchDisplay.HandleDisplayRenderRequest ){
				$n2.couchDisplay.HandleDisplayRenderRequest(m);
			};

			if( $n2.couchDisplayTiles 
			 && $n2.couchDisplayTiles.HandleDisplayRenderRequest ){
				$n2.couchDisplayTiles.HandleDisplayRenderRequest(m);
			};

			if( $n2.displayRibbon 
			 && $n2.displayRibbon.HandleDisplayRenderRequest ){
				$n2.displayRibbon.HandleDisplayRenderRequest(m);
			};

			if( $n2.displayRibbon2 
			 && $n2.displayRibbon2.HandleDisplayRenderRequest ){
				$n2.displayRibbon2.HandleDisplayRenderRequest(m);
			};
		};
	}
});

//--------------------------------------------------------------------------
$n2.display = {
	Service: Service
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.displayRibbon.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.displayRibbon'
;

function docCreationTimeSort(lhs, rhs) {
	var timeLhs = 0;
	var timeRhs = 0;
	
	if( lhs && lhs.doc && lhs.doc.nunaliit_created && lhs.doc.nunaliit_created.time ) {
		timeLhs = lhs.doc.nunaliit_created.time;
	}
	if( rhs && rhs.doc && rhs.doc.nunaliit_created && rhs.doc.nunaliit_created.time ) {
		timeRhs = rhs.doc.nunaliit_created.time;
	}
	
	if( timeLhs < timeRhs ) return -1;
	if( timeLhs > timeRhs ) return 1;
	return 0;
};

function startsWith(s, prefix) {
	var left = s.substr(0,prefix.length);
	return (left === prefix);
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*
* Template for document display
*/
var GridTemplateDocument = $n2.Class({
	height: null,
	
	tileHeight: null,
	
	initialize: function(height, tileHeight){
		this.height = (height ? height : 0);
		this.tileHeight = (tileHeight ? tileHeight : 150);
	},
	
	get: function(numCols, targetTiles) {
		// Have space to grow
		targetTiles = targetTiles + 12;
		
      var numRows = Math.ceil(targetTiles / numCols),
	        rects = [],
	        x, y, i;
	
      var firstTileHeight = Math.max(1, Math.ceil(this.height / this.tileHeight));
      
      // First tile is 2x1
      var firstTileWidth = 2;
      rects.push(new Tiles.Rectangle(0, 0, firstTileWidth, firstTileHeight));
      
      x = firstTileWidth - 1;
      y = 0;
      
      for(i = 1; i<targetTiles; ++i){
      	x = x + 1;
      	while( x >= numCols ){
      		y = y + 1;
      		x = 0;
      		
      		if( y < firstTileHeight ){
      			x = firstTileWidth;
      		};
      	};
      	
          rects.push(new Tiles.Rectangle(x, y, 1, 1));
      };
	
	    return new Tiles.Template(rects, numCols, numRows);
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var SchemaFilter = $n2.Class({
	
	elemId: null,
	
	changeCallback: null,
	
	schemaRepository: null,
	
	selectedSchema: null,
	
	initialize: function(elem, changeCallback, schemaRepository){
		var $elem = $(elem);
		this.elemId = $elem.attr('id');
		if( !this.elemId ){
			this.elemId = $n2.getUniqueId();
			$elem.attr('id',this.elemId);
		};
		
		this.changeCallback = changeCallback;
		this.schemaRepository = schemaRepository;
	},
	
	display: function(infos){
		var _this = this;
		
		var schemas = {};
		if( infos ){
			for(var i=0,e=infos.length; i<e; ++i){
				var info = infos[i];
				if( info.schema ){
					schemas[info.schema] = true;
				};
			};
		};
		
		var schemaNames = [];
		for(var schemaName in schemas){
			schemaNames.push(schemaName);
		};
		
		this.schemaRepository.getSchemas({
			names: schemaNames
			,onSuccess: function(schemas){
				_this._displaySchemas(schemas);
			}
			,onError: function(err){
				$n2.log('Error getting schemas for displaying schema filter',err);
			}
		});
	},
	
	filter: function(infos){
		if( this.selectedSchema ){
			var filteredInfos = [];
			
			for(var i=0,e=infos.length; i<e; ++i){
				var info = infos[i];
				
				if( info.schema === this.selectedSchema ){
					filteredInfos.push(info);
				};
			};
			
			return filteredInfos;
			
		} else {
			// Return all
			return infos;
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_displaySchemas: function(schemas){
		var _this = this;
		
		var $elem = this._getElem();
		
		$elem.empty();
		
		var clickFn = function(){
			var $a = $(this);
			
			var schemaName = $a.attr('n2SchemaName');
			schemaName = schemaName ? schemaName : null;
			
			_this._schemaSelected(schemaName);
			
			return false;
		};
		
		$('<a>')
			.attr('href','#')
			.text( _loc('All') )
			.addClass('n2DisplayRibbon_filter')
			.addClass('n2DisplayRibbon_filter_all')
			.appendTo($elem)
			.click(clickFn);

		var keepCurrentSelection = false;
		for(var i=0,e=schemas.length; i<e; ++i){
			var schema = schemas[i];
			
			if( schema.name === this.selectedSchema ){
				keepCurrentSelection = true;
			};
			
			var schemaLabel = schema.name;
			if( schema.label ){
				schemaLabel = _loc(schema.label);
			};

			$('<a>')
				.attr('href','#')
				.attr('n2SchemaName',schema.name)
				.text( schemaLabel )
				.addClass('n2DisplayRibbon_filter_schema')
				.addClass('n2DisplayRibbon_filter_schema_'+$n2.utils.stringToHtmlId(schema.name))
				.appendTo($elem)
				.click(clickFn);
		};
		
		if( !keepCurrentSelection ) {
			this.selectedSchema = null;
		};
		
		this._adjustSelection();
	},
	
	_adjustSelection: function(){
		var $elem = this._getElem();
		
		$elem.find('.n2DisplayRibbon_filter_selected')
			.removeClass('n2DisplayRibbon_filter_selected');
		
		if( this.selectedSchema ){
			$elem.find('.n2DisplayRibbon_filter_schema_'+$n2.utils.stringToHtmlId(this.selectedSchema))
				.addClass('n2DisplayRibbon_filter_selected');
			
		} else {
			$elem.find('.n2DisplayRibbon_filter_all')
				.addClass('n2DisplayRibbon_filter_selected');
		};
	},
	
	_schemaSelected: function(schemaName){
		this.selectedSchema = schemaName;
		this._adjustSelection();
		this.changeCallback();
	}
});

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var SchemaFilterFactory = $n2.Class({
	
	schemaRepository: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			schemaRepository: null
		},opts_);
		
		this.schemaRepository = opts.schemaRepository;
	},

	get: function(elem, changeCallback){
		return new SchemaFilter(elem, changeCallback, this.schemaRepository);
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var ReferenceRelatedDocumentDiscovery = $n2.Class({
	
	documentSource: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: null
		},opts_);
		
		this.documentSource = opts.documentSource;
	},
	
	getRelatedDocumentIds: function(opts_){
		var opts = $n2.extend({
			doc: null
			,onSuccess: function(doc, refDocIds){}
			,onError: function(err){}
		},opts_);
		
		var doc = opts.doc;

		this.documentSource.getReferencesFromId({
			docId: doc._id
			,onSuccess: loadedRefIds
			,onError: function(errorMsg){
				opts.onError(errorMsg);
			}
		});
		
		function loadedRefIds(referenceIds){
			// Map to accumulate all references
			var docIdMap = {};
			
			// Forward references
			var references = [];
			$n2.couchUtils.extractLinks(doc, references);
			for(var i=0, e=references.length; i<e; ++i){
				var linkDocId = references[i].doc;
				docIdMap[linkDocId] = true;
			};
			
			// Reverse links
			for(var i=0, e=referenceIds.length; i<e; ++i){
				var linkDocId = referenceIds[i];
				docIdMap[linkDocId] = true;
			};
			
			// Convert map to array
			var refDocIds = [];
			for(var docId in docIdMap){
				refDocIds.push(docId);
			};
			
			opts.onSuccess(doc, refDocIds);
		};
	},
	
	areDocumentsRelated: function(opts_){
		var opts = $n2.extend({
			selectedDoc: null
			,relatedDoc: null
			,onRelated: function(selectedDoc, relatedDoc){}
			,onNotRelated: function(selectedDoc, relatedDoc){}
			,onError: function(err){}
		},opts_);
		
		var selectedDoc = opts.selectedDoc;
		var relatedDoc = opts.relatedDoc;
		
		// Try to find related document in selected document
		var references = [];
		$n2.couchUtils.extractLinks(selectedDoc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			if( linkDocId === relatedDoc._id ){
				opts.onRelated(selectedDoc, relatedDoc);
				return;
			};
		};
		
		// Try to find selected document in related document
		var references = [];
		$n2.couchUtils.extractLinks(relatedDoc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			if( linkDocId === selectedDoc._id ){
				opts.onRelated(selectedDoc, relatedDoc);
				return;
			};
		};
		
		// At this point, the two documents are deemed not related
		opts.onNotRelated(selectedDoc, relatedDoc);
	}
});

//===================================================================================
// This is a class used to display and manage the information displayed when a
// selected document is clicked again on the ribbon

var RibbonInfoDisplay = $n2.Class({
	
	showService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			showService: undefined
		},opts_);
		
		this.showService = opts.showService;
	},
	
	showInfo: function(opts_){
		var opts = $n2.extend({
			doc: undefined
			,locationElem: undefined
			,onClose: function(){}
		},opts_);

		var $elem = $(opts.locationElem);
		var doc = opts.doc;
		var docId = doc._id;
		
		var $outerLayout = $('<div>')
			.addClass('n2DisplayRibbon_popup_outer_layout n2DisplayRibbon_popup_'+$n2.utils.stringToHtmlId(docId))
			.appendTo($elem);
		var $layout = $('<div>')
			.addClass('n2DisplayRibbon_popup_layout')
			.appendTo($outerLayout);
		var $container = $('<div>')
			.addClass('n2DisplayRibbon_popup_container')
			.appendTo($layout);
		
		var $content = $('<div>')
			.addClass('n2DisplayRibbon_popup_content')
			.appendTo($container);

		if( this.showService ) {
			this.showService.printDocument($content, docId);
		} else {
			$content.text( docId );
		};

		var $buttons = $('<div>')
			.addClass('n2DisplayRibbon_popup_buttons')
			.appendTo($container);
		
		$('<a>')
			.attr('href','#')
			.addClass('n2DisplayRibbon_popup_button n2DisplayRibbon_popup_button_close')
			.text( _loc('Close') )
			.click(function(){
				var $a = $(this);
				$a.parents('.n2DisplayRibbon_popup_outer_layout').first().remove();
				opts.onClose();
				return false;
			})
			.appendTo($buttons);
	},
	
	removeInfo: function(opts_){
		var opts = $n2.extend({
			docId: undefined
			,locationElem: undefined
		},opts_);

		var $elem = $(opts.locationElem);
		var docId = opts.docId;
		
		var outerClass = 'n2DisplayRibbon_popup_'+$n2.utils.stringToHtmlId(docId);
		var $outer = $elem.find('.'+outerClass);
		$outer.remove();
	}
});

//===================================================================================
// Copied and adapted from http://thinkpixellab.com/tilesjs

var Tile = $n2.Class({

	id: null,
	top: null,
	left: null,
	width: null,
	height: null,
	$el: null,
	parentId: null,
	
	initialize: function(tileId, element){
	    this.id = tileId;

	    // position and dimensions of tile inside the parent panel
	    this.top = 0;
	    this.left = 0;
	    this.width = 0;
	    this.height = 0;

	    // cache the tile container element
	    this.$el = $(element || document.createElement('div'));
	    this.$el.addClass('n2DisplayRibbon_tile_invisible');
	},
	
	appendTo: function($parent, fadeIn, delay, duration) {
		var parentId = $n2.utils.getElementIdentifier($parent);
		if( parentId !== this.parentId ){
			this.parentId = parentId;

			this.$el
		        .hide()
		        .appendTo($parent);
	
		    if (fadeIn) {
		        this.$el.delay(delay).fadeIn(duration);
		    } else {
		        this.$el.show();
		    };
		    
		    return true; // added
		};
		
		return false; // was already in
	},
	
	remove: function(animate, duration) {
	    if( animate ) {
	        this.$el.fadeOut({
	            complete: function() {
	                $(this).remove();
	            }
	        });
	    } else {
	        this.$el.remove();
	    }
	},
	
	// updates the tile layout with optional animation
	resize: function(pixelRect, animate, duration, onComplete) {
	   
	    // store the list of needed changes
	    var cssChanges = {},
	        changed = false;

	    // update position and dimensions
	    if (this.left !== pixelRect.x) {
	        cssChanges.left = pixelRect.x;
	        this.left = pixelRect.x;
	        changed = true;
	    }
	    if (this.top !== pixelRect.y) {
	        cssChanges.top = pixelRect.y;
	        this.top = pixelRect.y;
	        changed = true;
	    }
	    if (this.width !== pixelRect.width) {
	        cssChanges.width = pixelRect.width;
	        this.width = pixelRect.width;
	        changed = true;
	    }
	    if (this.height !== pixelRect.height) {
	        cssChanges.height = pixelRect.height;
	        this.height = pixelRect.height;
	        changed = true;
	    }

	    // Sometimes animation fails to set the css top and left correctly
	    // in webkit. We'll validate upon completion of the animation and
	    // set the properties again if they don't match the expected values.
	    var tile = this,
	        validateChangesAndComplete = function() {
	            var el = tile.$el[0];
	            if (tile.left !== el.offsetLeft) {
	                //console.log ('mismatch left:' + tile.left + ' actual:' + el.offsetLeft + ' id:' + tile.id);
	                tile.$el.css('left', tile.left);
	            }
	            if (tile.top !== el.offsetTop) {
	                //console.log ('mismatch top:' + tile.top + ' actual:' + el.offsetTop + ' id:' + tile.id);
	                tile.$el.css('top', tile.top);
	            }

	            if (onComplete) {
	                onComplete();
	            }
	        };


	    // make css changes with animation when requested
	    if (animate && changed) {

	        this.$el.animate(cssChanges, {
	            duration: duration,
	            easing: 'swing',
	            complete: validateChangesAndComplete
	        });
	    }
	    else {

	        if (changed) {
	            this.$el.css(cssChanges);
	        }

	        setTimeout(validateChangesAndComplete, duration);
	    }
	},
	
	isVisible: function(){
		var vis = this.$el.hasClass('n2DisplayRibbon_tile_visible');
		return vis;
	},
	
	setVisible: function(vis){
		if( vis ){
			this.$el
				.removeClass('n2DisplayRibbon_tile_invisible')
				.addClass('n2DisplayRibbon_tile_visible');
		} else {
			this.$el
				.removeClass('n2DisplayRibbon_tile_visible')
				.addClass('n2DisplayRibbon_tile_invisible');
		};
	}
});

//===================================================================================
// Reimplements the grid class from http://thinkpixellab.com/tilesjs
// This instance creates a long horizontal ribbon where the left most location is
// privileged for the current document. Then, all the other documents are positioned
// to the right in a single line. These can be browsed using end arrows
var RibbonGrid = $n2.Class({
	
	// Function to create a new tile
	createTile: null,
	
	// Current size of a cell
	cellSize: null,
	
	cellSizeMin: null,

    cellPadding: null,
    
    numColumnMin: null,
    
	animationDuration: null,
	
	// The identifier for the current element
	elemId: null,
	
	// If set, the left most tile
	currentTile: null,
	
	// Array of tiles that are on the right
	relatedTiles: null,
	
	// Tiles that should be removed on next redraw
	removedTiles: null,
	
	rateOfChange: null,
	
	rateOfChangeEnd: null,
	
	relatedOffset: null,

	relatedOffsetMin: null,
	
	intervalId: null,
	
	tileVisibilityChangedFn: null,
	
	initialize: function(element){
        var _this = this;

        var $elem = $(element);
		this.elemId = $n2.utils.getElementIdentifier($elem);
		
		this.createTile = function(tileId){
			var $elem = $('div')
				.css({
					position: 'absolute'
				});
			return new Tile(tileId, $elem);
		};

		// animation lasts 500 ms by default
        this.animationDuration = 500;

        // spacing between tiles
        this.cellPadding = 10;

        // min width and height of a cell in the grid
        this.cellSizeMin = 150;
        
        // Show at least 3 tiles in the given width
        this.numColumnMin = 3;
        
        this.currentTile = undefined;
        this.relatedTiles = [];
        this.removedTiles = [];
        this.rateOfChange = 0;
        this.rateOfChangeEnd = true;
        this.relatedOffset = 0;
        this.relatedOffsetMin = 0;

        this.intervalId = window.setInterval(function(){
        	_this._intervalTask();
        },300);
        	
		$elem
			.empty()
			;
		var currentPosition = $elem.css('position');
		if( !currentPosition ){
			$elem.css('position','relative');
		} else if( 'absolute' === currentPosition ){
			// OK
		} else {
			$elem.css('position','relative');
		};
		$('<div>')
			.addClass('n2DisplayRibbon_grid_current')
			.css({
				position: 'absolute'
				,left: '0'
				,top: '0'
				,bottom: '0'
				,right: 'auto'
				,width: '170px'
			})
			.appendTo($elem);
		var $extra = $('<div>')
			.addClass('n2DisplayRibbon_grid_extra')
			.css({
				position: 'absolute'
				,left: '170px'
				,top: '0'
				,bottom: '0'
				,right: '0'
			})
			.appendTo($elem);
		$('<div>')
			.addClass('n2DisplayRibbon_grid_related')
			.css({
				position: 'absolute'
				,left: '0'
				,top: '0'
				,bottom: '0'
			})
			.appendTo($extra);
		$('<div>')
			.addClass('n2DisplayRibbon_grid_button_previous')
			.appendTo($extra)
			.mousedown(function(){
				_this._buttonChanged('down','previous');
				return false;
			})
			.mouseup(function(){
				_this._buttonChanged('up','previous');
				return false;
			})
			;
		$('<div>')
			.addClass('n2DisplayRibbon_grid_button_next')
			.appendTo($extra)
			.mousedown(function(){
				_this._buttonChanged('down','next');
				return false;
			})
			.mouseup(function(){
				_this._buttonChanged('up','next');
				return false;
			})
			;
		
	},

	updateTiles: function(currentTileId, relatedTileIds){
		// Make a map of all current tiles, for easy access
		var tilesById = {};
		if( this.currentTile ){
			tilesById[this.currentTile.id] = this.currentTile;
		};
		for(var i=0,e=this.relatedTiles.length; i<e; ++i){
			var tile = this.relatedTiles[i];
			tilesById[tile.id] = tile;
		};

		// Load all the ids in a map to remove duplicates
		var newTilesById = {};
		
		var newCurrentTile = undefined;
		if( currentTileId ){
			var id = currentTileId;
			var tile = tilesById[id];
			
			if( !tile ){
				tile = this.createTile(id);
				tile.id = id;
			};

			if( tile ){
				newTilesById[id] = tile;
				newCurrentTile = tile;
			};
		};
		
		var newRelatedTiles = [];
		for(var i=0,e=relatedTileIds.length; i<e; ++i){
			var id = relatedTileIds[i];
			var tile = tilesById[id];
			
			if( !tile ){
				tile = this.createTile(id);
				tile.id = id;
			};
			
			if( tile ){
				newTilesById[id] = tile;
				newRelatedTiles.push(tile);
			};
		};
		
		var newRemovedTiles = [];
		for(var id in tilesById){
			var tile = tilesById[id];
			if( !newTilesById[id] ){
				newRemovedTiles.push(tile);
			};
		};
		
		// Update
		this.currentTile = newCurrentTile;
		this.relatedTiles = newRelatedTiles;
		this.removedTiles = newRemovedTiles;
	},
	
	/**
	 * This function moves the tiles around according to the new state
	 * of the instance (currentTile, relatedTiles, removedTiles)
	 * @param animate Boolean If set, use animation
	 * @param onComplete Function If specified, called when movement is done, or animation is complete
	 */
	redraw: function(animate, onComplete){
        // see if we should redraw
        if( !this._shouldRedraw() ) {
            if (onComplete) {
                onComplete(false); // tell callback that we did not redraw
            }
            return;
        };
        
        var $elem = this._getElem();
        var $currentElem = $elem.find('.n2DisplayRibbon_grid_current');
        var $extraElem = $elem.find('.n2DisplayRibbon_grid_extra');
        var $relatedElem = $elem.find('.n2DisplayRibbon_grid_related');
        
        var height = $elem.height();
        var width = $elem.width();
        
        var cellSizeOnHeight = height - (2 * this.cellPadding);
        if( cellSizeOnHeight < this.cellSizeMin ){
        	cellSizeOnHeight = this.cellSizeMin;
        };

        var cellSizeOnWidth = ((width - this.cellPadding) / this.numColumnMin) - this.cellPadding;
        if( cellSizeOnWidth < this.cellSizeMin ){
        	cellSizeOnWidth = this.cellSizeMin;
        };
        
        this.cellSize = Math.min(cellSizeOnHeight, cellSizeOnWidth);

        var duration = this.animationDuration;

        // Reset position of related div
		this.relatedOffset = 0;
		$elem.find('.n2DisplayRibbon_grid_related').css({
			left: this.relatedOffset
		}); 
        
        // Move the current and related div
    	var currentDivWidth = 0;
        if( this.currentTile ){
        	// Current tile is visible. Show div and
        	// shrink extra
        	currentDivWidth = this.cellSize + (2 * this.cellPadding);
        	$currentElem.css({
        		display: 'block'
        		,width: ''+currentDivWidth+'px'
        	});
        	$extraElem.css({
        		left: ''+currentDivWidth+'px'
        	});
        	
        	// Move current tile to current div
        	this.currentTile.resize(
        		{
        			width: this.cellSize
        			,height: this.cellSize
        			,x: this.cellPadding
        			,y: this.cellPadding
        		}
        		,true // animate
        		,duration
        		,undefined // onComplete
        		);
        	this.currentTile.appendTo($currentElem, false, 0, duration);
        	
        } else {
        	$currentElem.css({
        		display: 'none'
        	});
        	$extraElem.css({
        		left: '0px'
        	});
        };

	    // fade out all removed tiles
	    for(var i=0, e=this.removedTiles.length; i<e; ++i) {
	        var tile = this.removedTiles[i];
	        tile.remove(animate, duration);
	    }
	    this.removedTiles = [];
        
	    // Deal with related tiles
	    var currentLeft = this.cellPadding;
	    for(var i=0,e=this.relatedTiles.length; i<e; ++i){
	    	var tile = this.relatedTiles[i];
        	tile.resize(
        		{
        			width: this.cellSize
        			,height: this.cellSize
        			,x: currentLeft
        			,y: this.cellPadding
        		}
        		,true // animate
        		,duration
        		,undefined // onComplete
        		);
	    	tile.appendTo($relatedElem, false, 0, duration);
	    	
	    	currentLeft += (this.cellSize + this.cellPadding);
	    };
	    
	    // width - currentDivWidth is equal to the width of the div where related
	    //                            tiles are shown
	    // currentLeft is the total width of the related tiles, including padding
	    // this.relatedOffsetMin is the lowest offset allowable so that user does not scroll
	    //                          passed the last displayed related tile
	    this.relatedOffsetMin = width - currentDivWidth - currentLeft;
	    if( this.relatedOffsetMin > 0 ){
	    	// If not enough tiles to fill related div, then fix offset to 0
	    	this.relatedOffsetMin = 0;
	    };
	    this._updateRelatedOffset(this.relatedOffset);
	    
	    this._updateVisibleTiles();
        
	    if( typeof onComplete === 'function' ) {
	        setTimeout(function() { onComplete(true); }, duration + 10);
	    };
	},
	
	setTileVisibilityChangeFunction: function(tileVisibilityChangedFn){
		this.tileVisibilityChangedFn = tileVisibilityChangedFn;
	},
	
	_shouldRedraw: function(){
		return true;
	},
	
	_buttonChanged: function(state, id){
		if( 'up' === state ){
			this.rateOfChangeEnd = true;
		} else {
			this.rateOfChangeEnd = false;
			if( 'next' === id ){
				this.rateOfChange = -250;
			} else {
				this.rateOfChange = 250;
			};
		};
	},
	
	_intervalTask: function(){
		var $elem = this._getElem();
		if( $elem.length < 1 ){
			// This grid is oo longer in use
			window.clearInterval(this.intervalId);
		} else {
			if( this.rateOfChange != 0 ){
				var newOffset = this.relatedOffset;
				
				newOffset += this.rateOfChange;
				
				this._updateRelatedOffset(newOffset);
			    this._updateVisibleTiles();
				
				if( this.rateOfChangeEnd ){
					this.rateOfChange = 0;
				};
			};
		};
	},
	
	_updateRelatedOffset: function(newRelatedOffset){
		if( newRelatedOffset > 0 ){
			newRelatedOffset = 0;
		};
		if( newRelatedOffset < this.relatedOffsetMin ){
			newRelatedOffset = this.relatedOffsetMin;
		};
		
		if( newRelatedOffset != this.relatedOffset ){
			this.relatedOffset = newRelatedOffset;
			var $elem = this._getElem();
			var $related = $elem.find('.n2DisplayRibbon_grid_related');
			var cssChanges = {
				left: this.relatedOffset
			};
			$related.animate(cssChanges, {
	            duration: 300,
	            easing: 'linear'
	        });
		};
		
		var $elem = this._getElem();
		if( this.relatedOffset <= this.relatedOffsetMin ){
			$elem.addClass('n2DisplayRibbon_grid_related_max');
		} else {
			$elem.removeClass('n2DisplayRibbon_grid_related_max');
		};
		if( this.relatedOffset >= 0 ){
			$elem.addClass('n2DisplayRibbon_grid_related_min');
		} else {
			$elem.removeClass('n2DisplayRibbon_grid_related_min');
		};
	},
	
	_updateVisibleTiles: function(){
		var $elem = this._getElem();
        var width = $elem.width();
		
		// Report tiles that are visible and tiles that are no longer visible
    	var currentDivWidth = 0;
        if( this.currentTile ){
        	currentDivWidth = this.cellSize + (2 * this.cellPadding);
    		if( !this.currentTile.isVisible() ){
    			// Is visible, but was not.
    			this.currentTile.setVisible(true);
    		};
        };
		var minOffsetVisible = 0 - this.relatedOffset;
		var maxOffsetVisible = minOffsetVisible + (width - currentDivWidth);
		var minPosition = this.cellPadding; // position of first tile
		var maxPosition = minPosition + this.cellSize;
	    for(var i=0,e=this.relatedTiles.length; i<e; ++i){
	    	var tile = this.relatedTiles[i];
	    	
	    	var tileIsVisible = true;
	    	if( minPosition > maxOffsetVisible ){
	    		tileIsVisible = false;
	    	} else if( maxPosition < minOffsetVisible ) {
	    		tileIsVisible = false;
	    	};
	    	
	    	var callCallback = false;
	    	if( tileIsVisible ){
	    		if( !tile.isVisible() ){
	    			// Is visible, but was not.
	    			tile.setVisible(true);
	    			callCallback = true;
	    		};
	    	} else {
	    		if( tile.isVisible() ){
	    			// Is not visible, but it was.
	    			tile.setVisible(false);
	    			callCallback = true;
	    		};
	    	};
	    	
	    	if( callCallback ){
	    		if( typeof this.tileVisibilityChangedFn === 'function' ){
	    			this.tileVisibilityChangedFn({
	    				visible: tileIsVisible
	    				,docId: tile.id
	    				,tile: tile
	    			});
	    		};
	    	};
	    	
	    	// Move to next tile
			minPosition = minPosition + this.cellSize + this.cellPadding;
			maxPosition = minPosition + this.cellSize;
	    };
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	}
});

// ===================================================================================

var RibbonDisplay = $n2.Class('RibbonDisplay', {
	
	documentSource: null,
	
	displayPanelName: null,
	
	showService: null,
	
	requestService: null,
	
	schemaRepository: null,
	
	customService: null,
	
	dispatchService: null,
	
	boolOptions: null,
	
	restrictAddRelatedButtonToLoggedIn: null,
	
	currentDetails: null,
	
	displayedDocumentsOrder: null,
	
	displayedDocuments: null,
	
	grid: null,
	
	createDocProcess: null,
	
	defaultSchema: null,
	
	relatedDocumentDiscoveryProcess: null,
	
	documentInfoFunction: null,
	
	sortFunction: null,
	
	filterFactory: null,
	
	filter: null,
	
	hoverInFn: null,
	
	hoverOutFn: null,

	clickFn: null,
	
	hoverDocId: null,
	
	infoDisplay: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			documentSource: null
			,displayPanelName: null
			,showService: null
			,requestService: null
			,schemaRepository: null
			,customService: null
			,dispatchService: null
			,createDocProcess: null
			,displayRelatedInfoFunction: null
			
			// Boolean options
			,displayOnlyRelatedSchemas: false
			,displayBriefInRelatedInfo: false
			,restrictAddRelatedButtonToLoggedIn: false
			
			// Process used to discover related information from
			// a document
			,relatedDocumentDiscoveryProcess: null
			
			// Function to obtain document information structures based on
			// document ids
			,documentInfoFunction: null
			
			// Function to sort documents based on info structures
			,sortFunction: null
			
			// Factory to create filters
			,filterFactory: null
			
			// Name of display for document info
			,infoDisplay: null
		},opts_);

		var _this = this;
		
		/*
			currentDetails = {
				// single document selection
				docId // document identifier
				doc // document content
				schema // schema associated with the document
				height // last detected content height for current document
				referenceDocIds // doc ids of related info
				
				// multiple document selection
				docIds // document identifiers
				docs // map of document contents by id
			}
		 */
		this.currentDetails = {};
		/*
		 	displayedDocuments = {
		 		<doc-id>: {
		 			id: <doc-id>
		 			,info: <info object>
		 			,doc: <content>
		 		}
		 	}
		 */
		this.displayedDocuments = {};
		/*
		 	Array of document ids
		 */
		this.displayedDocumentsOrder = null;
		
		this.documentSource = opts.documentSource;
		this.displayPanelName = opts.displayPanelName;
		this.showService = opts.showService;
		this.requestService = opts.requestService;
		this.schemaRepository = opts.schemaRepository;
		this.customService = opts.customService;
		this.dispatchService = opts.dispatchService;
		this.createDocProcess = opts.createDocProcess;
		
		// Initialize display
		this._getDisplayDiv();
		
		// Boolean options
		this.boolOptions = {
			displayOnlyRelatedSchemas: opts.displayOnlyRelatedSchemas
			,displayBriefInRelatedInfo: opts.displayBriefInRelatedInfo
		};
		this.restrictAddRelatedButtonToLoggedIn = opts.restrictAddRelatedButtonToLoggedIn;
		if( !this.restrictAddRelatedButtonToLoggedIn 
		 && this.customService ){
			this.restrictAddRelatedButtonToLoggedIn = 
				this.customService.getOption('restrictAddRelatedButtonToLoggedIn',false);
		};

		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			var f = function(msg, addr, d){
				_this._handleDispatch(msg, addr, d);
			};
			dispatcher.register(DH, 'selected', f);
			dispatcher.register(DH, 'searchResults', f);
			dispatcher.register(DH, 'documentDeleted', f);
			dispatcher.register(DH, 'authLoggedIn', f);
			dispatcher.register(DH, 'authLoggedOut', f);
			dispatcher.register(DH, 'editClosed', f);
			dispatcher.register(DH, 'documentContent', f);
			dispatcher.register(DH, 'documentContentCreated', f);
			dispatcher.register(DH, 'documentContentUpdated', f);
			dispatcher.register(DH, 'windowResized', f);
		};
		
		if( !opts.displayRelatedInfoFunction ) {
			var flag = this._getBooleanOption('displayOnlyRelatedSchemas');
			if( flag ) {
				opts.displayRelatedInfoFunction = function(opts_){
					_this._displayRelatedInfo(opts_);
				};
			} else {
				opts.displayRelatedInfoFunction = function(opts_){
					_this._displayLinkedInfo(opts_);
				};
			};
		};
		
		// Related document discovery process
		this.relatedDocumentDiscoveryProcess = opts.relatedDocumentDiscoveryProcess;
		if( !this.relatedDocumentDiscoveryProcess 
		 && this.customService ){
			this.relatedDocumentDiscoveryProcess = 
				this.customService.getOption('relatedDocumentDiscoveryProcess',null);
		};
		if( !this.relatedDocumentDiscoveryProcess ){
			this.relatedDocumentDiscoveryProcess = new ReferenceRelatedDocumentDiscovery({
				documentSource: this.documentSource
			});
		};
		
		// Document info function
		this.documentInfoFunction = opts.documentInfoFunction;
		if( !this.documentInfoFunction 
		 && this.customService ){
			var docInfoFn = this.customService.getOption('displayDocumentInfoFunction');
			if( typeof docInfoFn === 'function' ){
				this.documentInfoFunction = docInfoFn;
			};
		};
		if( !this.documentInfoFunction ){
			this.documentInfoFunction = function(opts_){
				var opts = $n2.extend({
					docIds: null
					,display: null
					,onSuccess: function(docInfos){}
					,onError: function(err){}
				},opts_);
				
				var ds = opts.display.documentSource;
				ds.getDocumentInfoFromIds({
					docIds: opts.docIds
					,onSuccess: opts.onSuccess
					,onError: opts.onError
				});
			};
		};
		
		// Sort function
		this.sortFunction = opts.sortFunction;
		if( !this.sortFunction 
		 && this.customService ){
			var sortFn = this.customService.getOption('displaySortFunction');
			if( typeof sortFn === 'function' ){
				this.sortFunction = sortFn;
			};
		};
		if( !this.sortFunction ){
			this.sortFunction = function(infos){
				infos.sort(function(a,b){
					if( a.updatedTime && b.updatedTime ){
						if( a.updatedTime > b.updatedTime ){
							return -1;
						};
						if( a.updatedTime < b.updatedTime ){
							return 1;
						};
					};

					if( a.id > b.id ){
						return -1;
					};
					if( a.id < b.id ){
						return 1;
					};
					
					return 0;
				});
			};
		};
		
		// Filter factory
		this.filterFactory = opts.filterFactory;
		if( !this.filterFactory 
		 && this.customService ){
			var factory = this.customService.getOption('displayFilterFactory');
			if( factory && typeof factory.get === 'function' ){
				this.filterFactory = factory;
			};
		};
		if( !this.filterFactory ){
			this.filterFactory = new SchemaFilterFactory({
				schemaRepository: this.schemaRepository
			});
		};
		
		// Hover in and out
		this.hoverInFn = function(){
			var $tile = $(this);
			_this._hoverInTile($tile);
			return false;
		};
		this.hoverOutFn = function(){
			var $tile = $(this);
			_this._hoverOutTile($tile);
			return false;
		};
		
		// Click function
		this.clickFn = function(e){
			if( e && e.target ){
				var $target = $(e.target);
				var $popupParents = $target.parents('.n2DisplayRibbon_popup');
				if( $popupParents.length > 0 ){
					// This click originated from inside a popup
					return true;
				};
			};

			var $tile = $(this);
			_this._clickedTile($tile);

			return false;
		};
		
		// Detect changes in displayed current content size
		var intervalID = window.setInterval(function(){
			var $set = _this._getDisplayDiv();
			if( $set.length < 0 ) {
				window.clearInterval(intervalID);
			} else {
				_this._performIntervalTask();
			};
		}, 500);
		
		// Info display logic
		if( opts.infoDisplay ){
			if( typeof opts.infoDisplay === 'string' ){
				// Obtain from dispatcher
				if( this.dispatchService ){
					var m = {
						type: 'ribbonGetInfoDisplay'
						,name: opts.infoDisplay
						,infoDisplay: null
					};
					this.dispatchService.synchronousCall(DH,m);
					this.infoDisplay = m.infoDisplay;
				};
			};
		}
		if( !this.infoDisplay ){
			this.infoDisplay = new RibbonInfoDisplay({
				showService: this.showService
			});
		};

		$('body').addClass('n2_display_format_ribbon');
		
		$n2.log('DisplayRibbon',this);
	},

	// external
	setSchema: function(schema) {
		this.defaultSchema = schema;
	},
	
	_handleDispatch: function(msg, addr, dispatcher){
		var $div = this._getDisplayDiv();
		if( $div.length < 1 ){
			// No longer displaying. Un-register this event.
			dispatcher.deregister(addr);
			return;
		};
		
		// Selected document
		if( msg.type === 'selected' ) {
			if( msg.doc ) {
				this._displayDocument(msg.doc._id, msg.doc);
				
			} else if( msg.docId ) {
				this._displayDocument(msg.docId, null);
				
			} else if( msg.docs ) {
				var ids = [];
				for(var i=0, e=msg.docs.length; i<e; ++i){
					ids.push( msg.docs[i]._id );
				};
				this._displayMultipleDocuments(ids, msg.docs);
				
			} else if( msg.docIds ) {
				this._displayMultipleDocuments(msg.docIds, null);
			};
			
		} else if( msg.type === 'searchResults' ) {
			this._displaySearchResults(msg.results);
			
		} else if( msg.type === 'documentDeleted' ) {
	//		var docId = msg.docId;
	//		this._handleDocumentDeletion(docId);
			
		} else if( msg.type === 'authLoggedIn' 
			|| msg.type === 'authLoggedOut' ) {
			
			// Redisplay buttons
			if( this.currentDetails 
			 && this.currentDetails.docId 
			 && this.currentDetails.doc ){
				this._receiveDocumentContent(this.currentDetails.doc);
				this._displayDocumentButtons(this.currentDetails.doc, this.currentDetails.schema);
			};
			
		} else if( msg.type === 'editClosed' ) {
			var deleted = msg.deleted;
			if( !deleted ) {
				var doc = msg.doc;
				if( doc ) {
					this._displayDocument(doc._id, doc);
				};
			};
			
		} else if( msg.type === 'documentContent' ) {
			this._receiveDocumentContent(msg.doc);
			
		} else if( msg.type === 'documentContentCreated' ) {
			this._receiveDocumentContent(msg.doc);
			
		} else if( msg.type === 'documentContentUpdated' ) {
			this._receiveDocumentContent(msg.doc);
			
		} else if( msg.type === 'windowResized' ) {
			if( this.grid ){
		        this.grid.redraw(true);
			};
		};
	},
	
	_displayDocument: function(docId, doc) {
	
	//	var _this = this;
		
		this._reclaimDisplayDiv();
		
		if( this.currentDetails
		 && this.currentDetails.docId === docId ){
			// Already in process of displaying this document
			return;
		};
		
		this.currentDetails = {
			docId: docId
		};
	
		this._addDisplayedDocument(docId, doc);
	
		var $set = this._getDisplayDiv();
	
		var $current = $set.find('.n2DisplayRibbon_info');
		$current.hide();
	
		this._adjustCurrentTile(docId);
		
		// Request document
		if( doc ){
			this._receiveDocumentContent(doc);
		} else {
			this._requestDocumentWithId(docId);
		};
	},
	
	/*
	 * Accepts search results and display them in tiled mode
	 */
	_displaySearchResults: function(results){
		
		this._reclaimDisplayDiv();
		
		var ids = [];
		if( results && results.sorted && results.sorted.length ) {
			for(var i=0,e=results.sorted.length; i<e; ++i){
				ids.push(results.sorted[i].id);
			};
		};
		
		this._displayMultipleDocuments(ids, null);
		
		if( ids.length < 1 ){
			var $set = this._getDisplayDiv();
			var $current = $set.find('.n2DisplayRibbon_info');
			$current
				.text( _loc('Empty search results') )
				.show();
		};
	},
	
	/*
	 * Displays multiple documents
	 */
	_displayMultipleDocuments: function(ids, docs){
		
		this._reclaimDisplayDiv();
	
		var $set = this._getDisplayDiv();
		var $current = $set.find('.n2DisplayRibbon_info');
		$current.hide();
		
		this.currentDetails = {
			docIds: ids
			,docs: {}
		};
		
		this._adjustCurrentTile(null);
		
		var docsById = {};
		if( docs ){
			for(var i=0,e=docs.length; i<e; ++i){
				var doc = docs[i];
				this.currentDetails.docs[doc._id] = doc;
				docsById[doc._id] = doc;
			};
		};
	
		this._changeDisplayedDocuments(ids, docsById);
	},
	
	_displayDocumentButtons: function(doc, schema){
		
		var _this = this;
		
		if( doc 
		 && doc._id 
		 && this.currentDetails.docId === doc._id ){
			var $set = this._getDisplayDiv();
			var $btnDiv = $set.find('.n2DisplayRibbon_current_buttons')
				.empty();
	
	 		// 'edit' button
	 		if( $n2.couchMap.canEditDoc(doc) ) {
	 			$('<a href="#"></a>')
	 				.addClass('n2DisplayRibbon_current_button n2DisplayRibbon_current_button_edit')
	 				.text( _loc('Edit') )
	 				.appendTo($btnDiv)
	 				.click(function(){
						_this._performDocumentEdit(doc);
						return false;
					});
	 		};
	
	 		// Show 'delete' button
	 		if( $n2.couchMap.canDeleteDoc(doc) ) {
	 			$('<a href="#"></a>')
	 				.addClass('n2DisplayRibbon_current_button n2DisplayRibbon_current_button_delete')
	 				.text( _loc('Delete') )
	 				.appendTo($btnDiv)
	 				.click(function(){
						_this._performDocumentDelete(doc);
						return false;
					});
	 		};
	
	 		// 'add related' button
			if( schema
			 && schema.relatedSchemaNames 
			 && schema.relatedSchemaNames.length
			 ) {
				var showAddRelatedButton = true;
				if( this.restrictAddRelatedButtonToLoggedIn ){
					var isLoggedIn = false;
	
					if( this.dispatchService ){
						var m = {
							type: 'authIsLoggedIn'
							,isLoggedIn: false
						};
						this.dispatchService.synchronousCall(DH,m);
						isLoggedIn = m.isLoggedIn;
					};
					
					if( !isLoggedIn ){
						showAddRelatedButton = false;
					};
				};
				
				if( showAddRelatedButton ) {
					var $placeHolder = $('<span>')
						.appendTo($btnDiv);
					this.createDocProcess.insertAddRelatedSelection({
						placeHolderElem: $placeHolder
						,doc: doc
						,onElementCreated: function($elem){
							$elem.addClass('n2DisplayRibbon_current_button n2DisplayRibbon_current_button_add_related_item');
						}
					});
				}; // show button
			};
			
	 		// Show 'find on map' button
			if( this.dispatchService 
			 && this.dispatchService.isEventTypeRegistered('findIsAvailable')
			 && this.dispatchService.isEventTypeRegistered('find')
			 ) {
				// Check if document can be displayed on a map
				var showFindOnMapButton = false;
				var m = {
					type: 'findIsAvailable'
					,doc: doc
					,isAvailable: false
				};
				this.dispatchService.synchronousCall(DH,m);
				if( m.isAvailable ){
					showFindOnMapButton = true;
				};
	
				if( showFindOnMapButton ) {
					$('<a href="#"></a>')
						.addClass('n2DisplayRibbon_current_button n2DisplayRibbon_current_button_find_on_map')
		 				.text( _loc('Find on Map') )
		 				.appendTo($btnDiv)
		 				.click(function(){
		 					_this._dispatch({
		 						type: 'find'
	 							,docId: doc._id
	 							,doc: doc
	 						});
							return false;
						});
				};
			};
	
			// Show 'Add Layer' button
			if( doc
			 && doc.nunaliit_layer_definition
			 && this.dispatchService
			 && this.dispatchService.isEventTypeRegistered('addLayerToMap')
			 ) {
				$('<a href="#"></a>')
					.addClass('n2DisplayRibbon_current_button n2DisplayRibbon_current_button_add_layer')
	 				.text( _loc('Add Layer') )
	 				.appendTo($btnDiv)
	 				.click(function(){
	 					_this._performAddLayerToMap(doc);
						return false;
					});
			};
	
			// Show 'Tree View' button
			if( doc ) {
				$('<a href="#"></a>')
					.addClass('n2DisplayRibbon_current_button n2DisplayRibbon_current_button_tree_view')
	 				.text( _loc('Tree View') )
	 				.appendTo($btnDiv)
	 				.click(function(){
	 					_this._performTreeView(doc);
						return false;
					});
			};
		};
	},
	
	_currentDocReferencesUpdated: function(){
		if( this.currentDetails 
		 && this.currentDetails.doc 
		 && this.currentDetails.referenceDocIds ){
			// Accumulate all references
			var refDocIds = {};
			for(var i=0, e=this.currentDetails.referenceDocIds.length; i<e; ++i){
				var linkDocId = this.currentDetails.referenceDocIds[i];
				refDocIds[linkDocId] = true;
			};
			
			// Figure out information that must be removed
			var idsToRemove = [];
			for(var docId in this.displayedDocuments){
				if( docId === this.currentDetails.docId ) {
					// OK
				} else if( !refDocIds[docId] ){
					idsToRemove.push(docId);
				};
			};
			for(var i=0,e=idsToRemove.length; i<e; ++i){
				this._removeDisplayedDocument(idsToRemove[i]);
			};
			
			// Add new ones
			for(var docId in refDocIds){
				this._addDisplayedDocument(docId);
			};
			
			// Use dynamic sorting
			this.displayedDocumentsOrder = null;
	
			// Perform updates
			this._updateDisplayedDocuments();
		};
	},
	
	/*
	 * Verify information found in the instance variable displayedDocuments
	 * and affect the displaying accordingly
	 */
	_updateDisplayedDocuments: function(){
		var _this = this;
		
		// Get all the required info
		var neededInfoIds = [];
		for(var docId in this.displayedDocuments){
			if( !this.displayedDocuments[docId].info ) {
				neededInfoIds.push(docId);
			};
		};
		if( neededInfoIds.length > 0 ) {
			this.documentInfoFunction({
				docIds: neededInfoIds
				,display: this
				,onSuccess: function(docInfos){
					for(var i=0, e=docInfos.length; i<e; ++i){
						var docInfo = docInfos[i];
						var docId = docInfo.id;
						if( _this.displayedDocuments[docId] ){
							_this.displayedDocuments[docId].info = docInfo;
						};
					};
					performUpdate();
				}
				,onError: function(errorMsg){
					$n2.log('Unable to obtain document information',errorMsg);
				}
			});
		} else {
			performUpdate();
		};
	
		function performUpdate() {
			// Ensure we have display
			_this._getDisplayDiv();
	
			// Sort
			var currentDocId = null;
			var sortedDocIds = null;
			if( _this.displayedDocumentsOrder ){
				sortedDocIds = _this.displayedDocumentsOrder;
	
				var infos = [];
				for(var i=0,e=sortedDocIds.length; i<e; ++i){
					var docId = sortedDocIds[i];
					if( _this.displayedDocuments[docId] 
					 && _this.displayedDocuments[docId].info ){
						infos.push( _this.displayedDocuments[docId].info );
					};
				};
				
				_this.filter.display(infos,_this);
				infos = _this.filter.filter(infos,_this);
	
				sortedDocIds = [];
				for(var i=0,e=infos.length; i<e; ++i){
					var info = infos[i];
					sortedDocIds.push(info.id);
				};
				
			} else {
				var infos = [];
				for(var docId in _this.displayedDocuments){
					if( _this.displayedDocuments[docId].info ){
						infos.push( _this.displayedDocuments[docId].info );
					};
				};
	
				_this.filter.display(infos,_this);
				infos = _this.filter.filter(infos,_this);
				
				_this.sortFunction(infos);
	
				var alreadySorted = {};
				sortedDocIds = [];
				if( _this.currentDetails
				 && _this.currentDetails.docId ){
					currentDocId = _this.currentDetails.docId;
					alreadySorted[_this.currentDetails.docId] = true;
				};
				
				for(var i=0,e=infos.length; i<e; ++i){
					var docId = infos[i].id;
					
					// Remove duplicates
					if( !alreadySorted[docId] ) {
						sortedDocIds.push(docId);
						alreadySorted[docId] = true;
					};
				};
			};
			
			_this.grid.updateTiles(currentDocId, sortedDocIds);
			_this.grid.isDirty = true; // force redraw to reflect change in order
	        _this.grid.redraw(true);
	
	        // Request content for documents
	        if( currentDocId ){
	        	_this._requestDocumentWithId(currentDocId);
	        };
		};
	},
	
	/*
	 * Changes the list of displayed documents
	 */
	_changeDisplayedDocuments: function(docIds, docsById){
		var displayDocsByIds = {};
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			displayDocsByIds[docId] = true;
		};
		
		for(var docId in this.displayedDocuments){
			if( !displayDocsByIds[docId] ){
				this._removeDisplayedDocument(docId);
			};
		};
		
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			var doc = null;
			if( docsById && docsById[docId] ){
				doc = docsById[docId];
			};
			
			this._addDisplayedDocument(docId, doc);
		};
		
		this.displayedDocumentsOrder = docIds;
		
		this._updateDisplayedDocuments();
	},
	
	/*
	 * This function adds a new document to be displayed among the related items
	 * of the display. _updateDisplayedDocuments should be called, next.
	 */
	_addDisplayedDocument: function(docId, doc){
		if( !this.displayedDocuments[docId] ){
			this.displayedDocuments[docId] = {
				id: docId
			};
		};
		
		if( doc ){
			this.displayedDocuments[docId].doc = doc;
		};
	},
	
	/*
	 * This function removes the information relating to the document
	 * associated with the given document id. _updateDisplayedDocuments
	 * should be called, next.
	 */
	_removeDisplayedDocument: function(docId){
		// Remove information
		if( this.displayedDocuments[docId] ){
			delete this.displayedDocuments[docId];
		};
	},
	
	_receiveDocumentContent: function(doc){
		var _this = this;
	
		var $set = this._getDisplayDiv();
		
		var docId = doc._id;
		if( this.displayedDocuments[docId] ){
			// We are interested in this document. Save the content
			this.displayedDocuments[docId].doc = doc;
		};
	
		// Currently displayed document?
		if( doc._id === this.currentDetails.docId ){
			
			var update = false;
			
			if( !this.currentDetails.doc ) {
				// We do not yet have the content of the current document
				this.currentDetails.doc = doc;
				update = true;
				
			} else {
				// We already have the content. Check for update.
				
				if( doc._rev !== this.currentDetails.doc._rev ) {
					this.currentDetails.doc = doc;
					update = true;
				};
			};
			
			if( update ){
				// Renew related document ids
				this.relatedDocumentDiscoveryProcess.getRelatedDocumentIds({
					doc: doc
					,onSuccess: function(doc, refDocIds){
						if( _this.currentDetails.docId === doc._id ){
							_this.currentDetails.referenceDocIds = refDocIds;
							_this._currentDocReferencesUpdated();
						};
					}
					,onError: function(err){
						$n2.log('Error obtaining reference ids',err);
					}
				});
			};
		};
		
		// Display brief associated with the document
		var waitClassName = 'n2DisplayRibbon_wait_brief_' + $n2.utils.stringToHtmlId(docId);
		$set.find('.'+waitClassName).each(function(){
			var $div = $(this);
			if( _this.showService ) {
				_this.showService.displayBriefDescription($div, {}, doc);
			};
			$div.removeClass(waitClassName);
		});
		
		// Display full document for currently selected document
		var waitClassName = 'n2DisplayRibbon_wait_current_' + $n2.utils.stringToHtmlId(docId);
		var buttonClassName = 'n2DisplayRibbon_current_buttons_' + $n2.utils.stringToHtmlId(docId);
		$set.find('.'+waitClassName).each(function(){
			var $div = $(this)
				.empty();
	
			$('<div>')
				.addClass('n2DisplayRibbon_current_buttons')
				.addClass(buttonClassName)
				.appendTo($div);			
	
			var $content = $('<div>')
				.appendTo($div);
			if( _this.showService ) {
				_this.showService.displayDocument($content, {}, doc);
			} else {
				$content.text( doc._id );
			};
			
			$div.removeClass(waitClassName);
		});
		
		// Refresh buttons
		$('.'+buttonClassName).each(function(){
			var $div = $(this);
			
			_this._displayDocumentButtons(doc, _this.currentDetails.schema);
		});
		
		// Set tile classes based on media associated with document, and schema name
		var includesImage = false;
		var includesAudio = false;
		var includesVideo = false;
		var thumbnailName = null;
		var schemaName = null;
		if( doc.nunaliit_attachments 
		 && doc.nunaliit_attachments.files ){
			for(var attName in doc.nunaliit_attachments.files){
				var att = doc.nunaliit_attachments.files[attName];
				if( att.source ) {
					// discount thumbnails
				} else {
					if( 'image' === att.fileClass ) {
						includesImage = true;
					} else if( 'audio' === att.fileClass ) {
						includesAudio = true;
					} else if( 'video' === att.fileClass ) {
						includesVideo = true;
					};
					if( att.thumbnail ){
						thumbnailName = att.thumbnail;
					};
				};
			};
		};
		if( doc.nunaliit_schema ){
			schemaName = doc.nunaliit_schema;
		};
		$set.find('.n2DisplayRibbon_tile_' + $n2.utils.stringToHtmlId(docId)).each(function(){
			var $tile = $(this);
			
			$tile.removeClass('n2DisplayRibbon_tile_image n2DisplayRibbon_tile_audio n2DisplayRibbon_tile_video');
			if(includesVideo){
				$tile.addClass('n2DisplayRibbon_tile_video');
			} else if(includesAudio){
				$tile.addClass('n2DisplayRibbon_tile_audio');
			} else if(includesImage){
				$tile.addClass('n2DisplayRibbon_tile_image');
			};
			
			if( schemaName ){
				$tile.addClass('n2DisplayRibbon_tile_schema_'+$n2.utils.stringToHtmlId(schemaName));
			};
		});
		if( thumbnailName ){
			// Check that thumbnail is attached
			if( doc.nunaliit_attachments.files[thumbnailName]
			 && doc.nunaliit_attachments.files[thumbnailName].status === 'attached' ){
				// OK
			} else {
				thumbnailName = null;
			};
		};
		if( thumbnailName ){
			var url = this.documentSource.getDocumentAttachmentUrl(doc,thumbnailName);
			if( url ){
				$set.find('.n2DisplayRibbon_wait_thumb_' + $n2.utils.stringToHtmlId(docId)).each(function(){
					var $div = $(this);
					$div.empty();
					$('<img>')
						.attr('src',url)
						.appendTo($div);
				});
			};
		};
		
	
		// Obtain the schema associated with the document
		if( doc.nunaliit_schema 
		 && this.schemaRepository ){
			this.schemaRepository.getSchema({
				name: doc.nunaliit_schema
				,onSuccess: function(schema){
					schemaLoaded(doc, schema);
				}
				,onError: function(err){
					schemaLoaded(doc, null);
				}
			});
		} else {
			schemaLoaded(doc, null);
		};
		
		// Check if the given document contains links to the currently
		// displayed document
		if( this.currentDetails.doc 
		 && doc._id !== this.currentDetails.docId ){
			
			this.relatedDocumentDiscoveryProcess.areDocumentsRelated({
				selectedDoc: this.currentDetails.doc
				,relatedDoc: doc
				,onRelated: function(selectedDoc, relatedDoc){
					// Check validity of callback
					if( selectedDoc._id === _this.currentDetails.docId ){
						var refIndex = -1;
						if( _this.currentDetails.referenceDocIds ) {
							refIndex = _this.currentDetails.referenceDocIds.indexOf(doc._id);
						};
						
						if( refIndex < 0 ) {
							// The previous time we saw this document, there were no reference to the
							// currently displayed document. Now, this new version of the document
							// contains a reference to the displayed document. Add reference and
							// re-display.
							if( !_this.currentDetails.referenceDocIds ){
								_this.currentDetails.referenceDocIds = [];
							};
							_this.currentDetails.referenceDocIds.push(doc._id);
							_this._currentDocReferencesUpdated();
						};
					};
				}
				,onNotRelated: function(selectedDoc, relatedDoc){
					// Check validity of callback
					if( selectedDoc._id === _this.currentDetails.docId ){
						var refIndex = -1;
						if( _this.currentDetails.referenceDocIds ) {
							refIndex = _this.currentDetails.referenceDocIds.indexOf(doc._id);
						};
	
						if( refIndex >= 0 ) {
							// The previous time we saw this document, it had a reference to the
							// currently displayed document. Now, this reference is no longer there.
							// Remove the reference and redisplay
							_this.currentDetails.referenceDocIds.splice(refIndex,1);
							_this._currentDocReferencesUpdated();
						};
					};
				}
				,onError: function(err){
					$n2.log('Error in displayTiled. Unable to check relation.',err);
				}
			});
		};
		
		function schemaLoaded(doc, schema){
			if( _this.currentDetails.docId === doc._id ){
				// This is the schema associated with the current
				// document.
				if( schema && !_this.currentDetails.schema ){
					_this.currentDetails.schema = schema;
					_this._displayDocumentButtons(doc, schema);
					
				} else if( _this.currentDetails.schema && !schema ) {
					_this.currentDetails.schema = null;
					_this._displayDocumentButtons(doc, null);
				
				} else if( _this.currentDetails.schema 
				 && schema
				 && _this.currentDetails.schema.name !== schema.name
				 ) {
					// Schema is changed
					_this.currentDetails.schema = schema;
					_this._displayDocumentButtons(doc, schema);
				};
			};
		};
	},
	
	/*
	 * Initiates the editing of a document
	 */
	_performDocumentEdit: function(doc){
		var _this = this;
		
		this.documentSource.getDocument({
			docId: doc._id
			,onSuccess: function(doc){
				_this._dispatch({
					type: 'editInitiate'
					,doc: doc
				});
			}
			,onError: function(errorMsg){
				$n2.log('Unable to load document: '+errorMsg);
			}
		});
	},
	
	/*
	 * Initiates the deletion of a document
	 */
	_performDocumentDelete: function(doc){
		if( confirm( _loc('You are about to delete this document. Do you want to proceed?') ) ) {
			this.documentSource.deleteDocument({
				doc: doc
				,onSuccess: function() {}
			});
		};
	},
	
	/*
	 * Initiates the 'Add Layer to Map' action for the button
	 */
	_performAddLayerToMap: function(doc){
		var layerDefinition = doc.nunaliit_layer_definition;
		var layerId = layerDefinition.id;
		if( !layerId ){
			layerId = doc._id;
		};
		var layerDef = {
			name: layerDefinition.name
			,type: 'couchdb'
			,options: {
				layerName: layerId
				,documentSource: this.documentSource
			}
		};
		
		this._dispatch({
			type: 'addLayerToMap'
			,layer: layerDef
			,options: {
				setExtent: {
					bounds: layerDefinition.bbox
					,crs: 'EPSG:4326'
				}
			}
		});
	},
	
	/*
	 * Opens a tree view dialog
	 */
	_performTreeView: function(doc){
		new $n2.couchDisplay.TreeDocumentViewer({
			doc: doc
		});
	},
	
	/*
	 * This function should be called before any displaying is performed.
	 * This ensures that the div element in use still contains the required
	 * elements for performing display.
	 */
	_reclaimDisplayDiv: function() {
		var _this = this;
		
		var $set = this._getDisplayDiv();
		
		var $filters = $set.find('.n2DisplayRibbon_filters');
		var $buttons = $set.find('.n2DisplayRibbon_buttons');
		var $current = $set.find('.n2DisplayRibbon_info');
		var $docs = $set.find('.n2DisplayRibbon_documents');
		if( $filters.length < 1
		 || $buttons.length < 1 
		 || $current.length < 1
		 || $docs.length < 1 ){
			$set.empty();
			$filters = $('<div>')
				.addClass('n2DisplayRibbon_filters')
			$buttons = $('<div>')
				.addClass('n2DisplayRibbon_buttons')
				.appendTo($set);
			$current = $('<div>')
				.addClass('n2DisplayRibbon_info')
				.appendTo($set);
			$docs = $('<div>')
				.addClass('n2DisplayRibbon_documents')
				.appendTo($set);
			
			// When the side panel must be re-claimed, then we must
			// forget what is currently displayed since it has to be
			// re-computed
			this.currentDetails = {};
			
			// Create grid
			this.grid = new RibbonGrid($docs);
			this.grid.createTile = function(docId) {
				return _this._createTile(docId);
		    };
		    this.grid.setTileVisibilityChangeFunction(function(opts_){
		    	_this._tileVisibilityChanged(opts_);
		    });
		    
			// Create document filter
		    this.filter = this.filterFactory.get($filters,function(){
		    	_this._documentFilterChanged();
		    });
		    		    
		    // Create navigation buttons
		    new $n2.widgetNavigation.NavigationWidget({
				elem: $buttons
				,dispatchService: this.dispatchService
		    });
		};
	},
	
	_createTile: function(docId){
        var $elem = $('<div>')
	    	.addClass('n2DisplayRibbon_tile')
	    	.addClass('n2DisplayRibbon_tile_' + $n2.utils.stringToHtmlId(docId))
	    	.attr('n2DocId',docId);
	    
	    $elem.hover(
			this.hoverInFn
			,this.hoverOutFn
	    );
		
		$elem.click(this.clickFn);
	
	    var tile = new Tile(docId, $elem);
	    
	    if( this.currentDetails
	     && this.currentDetails.docId === docId ){
	    	// Current document
	    	$elem.addClass('n2DisplayRibbon_tile_current');
	    	this._generateCurrentDocumentContent($elem, docId);
	
	    } else {
	    	// Not current document
	    	$elem.removeClass('n2DisplayRibbon_tile_current');
	    	this._generateRelatedDocumentContent($elem, docId);
	    };

	    return tile;
	},
	
	_tileVisibilityChanged: function(opts_){
		if( opts_ 
		 && opts_.visible 
		 && opts_.docId 
		 && opts_.tile ){
			var docId = opts_.docId;
			this._requestDocumentWithId(docId);
		};
	},
	
	_clickedTile: function($tile){
		var docId = $tile.attr('n2DocId');
		
		if( this.currentDetails
		 && this.currentDetails.docId === docId ){
			this._showCurrentPopUp();
			
		} else {
			// Related tile, select document
			this._dispatch({
				type:'userSelect'
				,docId: docId
			});
		};
	},
	
	_hoverInTile: function($tile){
		var docId = $tile.attr('n2DocId');
		if( docId && docId !== this.hoverDocId ) {
			this.hoverDocId = docId;
			this._dispatch({
				type: 'userFocusOn'
				,docId: docId
			});
		};
	},
	
	_hoverOutTile: function($tile){
		var docId = $tile.attr('n2DocId');
		if( docId && docId === this.hoverDocId ) {
			this.hoverDocId = null;
			this._dispatch({
				type: 'userFocusOff'
				,docId: docId
			});
		};
		
		$tile.find('.n2DisplayRibbon_tile_menu').remove();
	},
	
	_showCurrentPopUp: function(){
		if( this.currentDetails
		 && this.currentDetails.docId ){
			var docId = this.currentDetails.docId;
			var doc = this.currentDetails.doc;
	    	var tileClass = '.n2DisplayRibbon_tile_' + $n2.utils.stringToHtmlId(docId);

	    	var $display = this._getDisplayDiv();
	    	var $tile = $display.find(tileClass);

	    	if( $tile.length > 0 ){
	    		// Look if pop-up is already showing
	    		var $popup = $tile.find('.n2DisplayRibbon_popup');
	    		if( $popup.length < 1 ){
	    			$popup = $('<div>')
	    				.addClass('n2DisplayRibbon_popup')
	    				.appendTo($tile);
	    			
	    			this.infoDisplay.showInfo({
    					doc: doc
    					,locationElem: $popup
    					,onClose: function(){
    						$popup.remove();
    					}
	    			});

	    		} else {
	    			// Toggle off
	    			this.infoDisplay.removeInfo({
    					docId: docId
    					,locationElem: $popup
	    			});

	    			$popup.remove();
	    		};
	    	};
		};
	},
	
	/*
	 * Goes over all the tiles and remove the class 'n2DisplayRibbon_tile_current'
	 * to from tiles that should not have it. Also, it adds the class to the tile
	 * that should have it, if it exists.
	 * 
	 * When adding and removing the class, adjust the content accordingly.
	 */
	_adjustCurrentTile: function(docId){
		var _this = this;
		
		var $set = this._getDisplayDiv();
		var $docs = $set.find('.n2DisplayRibbon_documents');
		
		var targetClass = null;
		if( docId ){
			targetClass = 'n2DisplayRibbon_tile_' + $n2.utils.stringToHtmlId(docId);
		};
		
		// Remove
		$docs.find('.n2DisplayRibbon_tile_current').each(function(){
			var $elem = $(this);
			if( targetClass && $elem.hasClass(targetClass) ) {
				// That's OK. Leave it
			} else {
				$elem.removeClass('n2DisplayRibbon_tile_current');
				var id = $elem.attr('n2DocId');
				_this._generateRelatedDocumentContent($elem, id);
			};
		});
		
		// Add
		if( targetClass ) {
			$docs.find('.'+targetClass).each(function(){
				var $elem = $(this);
				if( $elem.hasClass('n2DisplayRibbon_tile_current') ) {
					// That's OK. Leave it
				} else {
					$elem.addClass('n2DisplayRibbon_tile_current');
					var id = $elem.attr('n2DocId');
					_this._generateCurrentDocumentContent($elem, id);
				};
			});
		};
	},
	
	_getDisplayDiv: function(){
		var divId = this.displayPanelName;
		return $('#'+divId);
	},
	
	_dispatch: function(m){
		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			dispatcher.send(DH,m);
		};
	},
	
	/*
	 * Get a boolean option based on a name and return it. Defaults
	 * to false. If the option is found set in either the options map
	 * or the custom service, then the result is true.
	 */
	_getBooleanOption: function(optionName){
		var flag = false;
		
		if( this.boolOptions[optionName] ){
			flag = true;
		};
		
		var cs = this.customService;
		if( cs && !flag ){
			var o = cs.getOption(optionName);
			if( o ){
				flag = true;
			};
		};
		
		return flag;
	},
	
	/*
	 * Look at documents stored in display code and return if one
	 * found with the correct identifier.
	 */
	_getCachedDocumentFromId: function(docId){
		if( this.displayedDocuments 
		 && this.displayedDocuments[docId]
		 && this.displayedDocuments[docId].doc ){
			return this.displayedDocuments[docId].doc;
		};
		
		if( this.currentDetails 
		 && this.currentDetails.docId === docId 
		 && this.currentDetails.doc ){
			return this.currentDetails.doc;
		};
		
		return null;
	},
	
	/*
	 * Given a document identifier, request the document content.
	 */
	_requestDocumentWithId: function(docId){
		// Look internally, first
		var doc = this._getCachedDocumentFromId(docId);
		if( doc ){
			this._receiveDocumentContent(doc);
			return;
		};
		
		if( this.requestService ){
			this.requestService.requestDocument(docId);
		};
	},
	
	_generateCurrentDocumentContent: function($elem, docId){
		$elem.empty();

		var $container = $('<div>')
	    	.addClass('n2DisplayRibbon_tile_container')
	    	.appendTo($elem);
		
		$('<div>')
			.addClass('n2DisplayRibbon_thumb n2DisplayRibbon_wait_thumb_' + $n2.utils.stringToHtmlId(docId))
			.appendTo($container);
		
		$('<div>')
			.addClass('n2DisplayRibbon_wait_brief_' + $n2.utils.stringToHtmlId(docId))
			.addClass('n2DisplayRibbon_tile_brief')
			.text(docId)
			.appendTo($container);
	},
	
	_generateRelatedDocumentContent: function($elem, docId){
		var _this = this;
		
		$elem.empty();
	    
	    var $container = $('<div>')
	    	.addClass('n2DisplayRibbon_tile_container')
	    	.appendTo($elem);
		
		$('<div>')
			.addClass('n2DisplayRibbon_thumb n2DisplayRibbon_wait_thumb_' + $n2.utils.stringToHtmlId(docId))
			.appendTo($container);
		
		$('<div>')
			.addClass('n2DisplayRibbon_wait_brief_' + $n2.utils.stringToHtmlId(docId))
			.addClass('n2DisplayRibbon_tile_brief')
			.text(docId)
			.appendTo($container);
	},
	
	_performIntervalTask: function(){
		var $set = this._getDisplayDiv();
		var $docs = $set.find('.n2DisplayRibbon_documents');
	
//		if( this.currentDetails
//		 && this.currentDetails.docId ){
//			var $currentTile = $docs.find('.n2DisplayRibbon_tile_current')
//				.find('.n2DisplayRibbon_tile_content');
//			if( $currentTile.length > 0 ){
//				var height = $currentTile.height();
//				if( height != this.currentDetails.height ){
//					this.currentDetails.height = height;
//					var cellSize = this.grid.cellSize;
//					this.grid.template = null;
//					this.grid.templateFactory = new GridTemplateDocument(height,cellSize);
//					this.grid.redraw(true);
//				};
//			};
//		};
	},
	
	_documentFilterChanged: function(){
		this._updateDisplayedDocuments();
	}
});

//===================================================================================
function HandleDisplayAvailableRequest(m){
	if( m.displayType === 'ribbon' ){
		m.isAvailable = true;
	};
};

function HandleDisplayRenderRequest(m){
	if( m.displayType === 'ribbon' ){
		var options = {};
		if( m.displayOptions ){
			for(var key in m.displayOptions){
				options[key] = m.displayOptions[key];
			};
		};
		
		options.documentSource = m.config.documentSource;
		options.displayPanelName = m.displayId;
		options.showService = m.config.directory.showService;
		options.createDocProcess = m.config.directory.createDocProcess;
		options.requestService = m.config.directory.requestService;
		options.schemaRepository = m.config.directory.schemaRepository;
		options.customService = m.config.directory.customService;
		options.dispatchService = m.config.directory.dispatchService;
		
		var displayControl = new RibbonDisplay(options);

		m.onSuccess(displayControl);
	};
};

//===================================================================================

// Exports
$n2.displayRibbon = {
	RibbonDisplay: RibbonDisplay
	,HandleDisplayAvailableRequest: HandleDisplayAvailableRequest
	,HandleDisplayRenderRequest: HandleDisplayRenderRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.displayRibbon2.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
,DH = 'n2.displayRibbon2'
;

function docCreationTimeSort(lhs, rhs) {
	var timeLhs = 0;
	var timeRhs = 0;
	
	if( lhs && lhs.doc && lhs.doc.nunaliit_created && lhs.doc.nunaliit_created.time ) {
		timeLhs = lhs.doc.nunaliit_created.time;
	}
	if( rhs && rhs.doc && rhs.doc.nunaliit_created && rhs.doc.nunaliit_created.time ) {
		timeRhs = rhs.doc.nunaliit_created.time;
	}
	
	if( timeLhs < timeRhs ) return -1;
	if( timeLhs > timeRhs ) return 1;
	return 0;
};

function startsWith(s, prefix) {
	var left = s.substr(0,prefix.length);
	return (left === prefix);
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*
* Template for document display
*/
var GridTemplateDocument = $n2.Class({
	height: null,
	
	tileHeight: null,
	
	initialize: function(height, tileHeight){
		this.height = (height ? height : 0);
		this.tileHeight = (tileHeight ? tileHeight : 150);
	},
	
	get: function(numCols, targetTiles) {
		// Have space to grow
		targetTiles = targetTiles + 12;
		
      var numRows = Math.ceil(targetTiles / numCols),
	        rects = [],
	        x, y, i;
	
      var firstTileHeight = Math.max(1, Math.ceil(this.height / this.tileHeight));
      
      // First tile is 2x1
      var firstTileWidth = 2;
      rects.push(new Tiles.Rectangle(0, 0, firstTileWidth, firstTileHeight));
      
      x = firstTileWidth - 1;
      y = 0;
      
      for(i = 1; i<targetTiles; ++i){
      	x = x + 1;
      	while( x >= numCols ){
      		y = y + 1;
      		x = 0;
      		
      		if( y < firstTileHeight ){
      			x = firstTileWidth;
      		};
      	};
      	
          rects.push(new Tiles.Rectangle(x, y, 1, 1));
      };
	
	    return new Tiles.Template(rects, numCols, numRows);
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var SchemaFilter = $n2.Class({
	
	elemId: null,
	
	changeCallback: null,
	
	schemaRepository: null,
	
	selectedSchema: null,
	
	initialize: function(elem, changeCallback, schemaRepository){
		var $elem = $(elem);
		this.elemId = $elem.attr('id');
		if( !this.elemId ){
			this.elemId = $n2.getUniqueId();
			$elem.attr('id',this.elemId);
		};
		
		this.changeCallback = changeCallback;
		this.schemaRepository = schemaRepository;
	},
	
	display: function(infos){
		var _this = this;
		
		var schemas = {};
		if( infos ){
			for(var i=0,e=infos.length; i<e; ++i){
				var info = infos[i];
				if( info.schema ){
					schemas[info.schema] = true;
				};
			};
		};
		
		var schemaNames = [];
		for(var schemaName in schemas){
			schemaNames.push(schemaName);
		};
		
		this.schemaRepository.getSchemas({
			names: schemaNames
			,onSuccess: function(schemas){
				_this._displaySchemas(schemas);
			}
			,onError: function(err){
				$n2.log('Error getting schemas for displaying schema filter',err);
			}
		});
	},
	
	filter: function(infos){
		if( this.selectedSchema ){
			var filteredInfos = [];
			
			for(var i=0,e=infos.length; i<e; ++i){
				var info = infos[i];
				
				if( info.schema === this.selectedSchema ){
					filteredInfos.push(info);
				};
			};
			
			return filteredInfos;
			
		} else {
			// Return all
			return infos;
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_displaySchemas: function(schemas){
		var _this = this;
		
		var $elem = this._getElem();
		
		$elem.empty();
		
		var clickFn = function(){
			var $a = $(this);
			
			var schemaName = $a.attr('n2SchemaName');
			schemaName = schemaName ? schemaName : null;
			
			_this._schemaSelected(schemaName);
			
			return false;
		};
		
		$('<a>')
			.attr('href','#')
			.text( _loc('All') )
			.addClass('n2DisplayRibbon2_filter')
			.addClass('n2DisplayRibbon2_filter_all')
			.appendTo($elem)
			.click(clickFn);

		var keepCurrentSelection = false;
		for(var i=0,e=schemas.length; i<e; ++i){
			var schema = schemas[i];
			
			if( schema.name === this.selectedSchema ){
				keepCurrentSelection = true;
			};
			
			var schemaLabel = schema.name;
			if( schema.label ){
				schemaLabel = _loc(schema.label);
			};

			$('<a>')
				.attr('href','#')
				.attr('n2SchemaName',schema.name)
				.text( schemaLabel )
				.addClass('n2DisplayRibbon2_filter_schema')
				.addClass('n2DisplayRibbon2_filter_schema_'+$n2.utils.stringToHtmlId(schema.name))
				.appendTo($elem)
				.click(clickFn);
		};
		
		if( !keepCurrentSelection ) {
			this.selectedSchema = null;
		};
		
		this._adjustSelection();
	},
	
	_adjustSelection: function(){
		var $elem = this._getElem();
		
		$elem.find('.n2DisplayRibbon2_filter_selected')
			.removeClass('n2DisplayRibbon2_filter_selected');
		
		if( this.selectedSchema ){
			$elem.find('.n2DisplayRibbon2_filter_schema_'+$n2.utils.stringToHtmlId(this.selectedSchema))
				.addClass('n2DisplayRibbon2_filter_selected');
			
		} else {
			$elem.find('.n2DisplayRibbon2_filter_all')
				.addClass('n2DisplayRibbon2_filter_selected');
		};
	},
	
	_schemaSelected: function(schemaName){
		this.selectedSchema = schemaName;
		this._adjustSelection();
		this.changeCallback();
	}
});

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var SchemaFilterFactory = $n2.Class({
	
	schemaRepository: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			schemaRepository: null
		},opts_);
		
		this.schemaRepository = opts.schemaRepository;
	},

	get: function(elem, changeCallback){
		return new SchemaFilter(elem, changeCallback, this.schemaRepository);
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var ReferenceRelatedDocumentDiscovery = $n2.Class({
	
	documentSource: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: null
		},opts_);
		
		this.documentSource = opts.documentSource;
	},
	
	getRelatedDocumentIds: function(opts_){
		var opts = $n2.extend({
			doc: null
			,onSuccess: function(doc, refDocIds){}
			,onError: function(err){}
		},opts_);
		
		var doc = opts.doc;

		this.documentSource.getReferencesFromId({
			docId: doc._id
			,onSuccess: loadedRefIds
			,onError: function(errorMsg){
				opts.onError(errorMsg);
			}
		});
		
		function loadedRefIds(referenceIds){
			// Map to accumulate all references
			var docIdMap = {};
			
			// Forward references
			var references = [];
			$n2.couchUtils.extractLinks(doc, references);
			for(var i=0, e=references.length; i<e; ++i){
				var linkDocId = references[i].doc;
				docIdMap[linkDocId] = true;
			};
			
			// Reverse links
			for(var i=0, e=referenceIds.length; i<e; ++i){
				var linkDocId = referenceIds[i];
				docIdMap[linkDocId] = true;
			};
			
			// Convert map to array
			var refDocIds = [];
			for(var docId in docIdMap){
				refDocIds.push(docId);
			};
			
			opts.onSuccess(doc, refDocIds);
		};
	},
	
	areDocumentsRelated: function(opts_){
		var opts = $n2.extend({
			selectedDoc: null
			,relatedDoc: null
			,onRelated: function(selectedDoc, relatedDoc){}
			,onNotRelated: function(selectedDoc, relatedDoc){}
			,onError: function(err){}
		},opts_);
		
		var selectedDoc = opts.selectedDoc;
		var relatedDoc = opts.relatedDoc;
		
		// Try to find related document in selected document
		var references = [];
		$n2.couchUtils.extractLinks(selectedDoc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			if( linkDocId === relatedDoc._id ){
				opts.onRelated(selectedDoc, relatedDoc);
				return;
			};
		};
		
		// Try to find selected document in related document
		var references = [];
		$n2.couchUtils.extractLinks(relatedDoc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			if( linkDocId === selectedDoc._id ){
				opts.onRelated(selectedDoc, relatedDoc);
				return;
			};
		};
		
		// At this point, the two documents are deemed not related
		opts.onNotRelated(selectedDoc, relatedDoc);
	}
});

//===================================================================================
// Copied and adapted from http://thinkpixellab.com/tilesjs

var Tile = $n2.Class({

	id: null,
	top: null,
	left: null,
	width: null,
	height: null,
	$el: null,
	parentId: null,
	
	initialize: function(tileId, element){
	    this.id = tileId;

	    // position and dimensions of tile inside the parent panel
	    this.top = 0;
	    this.left = 0;
	    this.width = 0;
	    this.height = 0;

	    // cache the tile container element
	    this.$el = $(element || document.createElement('div'));
	},
	
	appendTo: function($parent, fadeIn, delay, duration) {
		var parentId = $n2.utils.getElementIdentifier($parent);
		if( parentId !== this.parentId ){
			this.parentId = parentId;

			this.$el
		        .hide()
		        .appendTo($parent);
	
		    if (fadeIn) {
		        this.$el.delay(delay).fadeIn(duration);
		    } else {
		        this.$el.show();
		    };
		    
		    return true; // added
		};
		
		return false; // was already in
	},
	
	remove: function(animate, duration) {
	    if( animate ) {
	        this.$el.fadeOut({
	            complete: function() {
	                $(this).remove();
	            }
	        });
	    } else {
	        this.$el.remove();
	    }
	},
	
	// updates the tile layout with optional animation
	resize: function(pixelRect, animate, duration, onComplete) {
	   
	    // store the list of needed changes
	    var cssChanges = {},
	        changed = false;

	    // update position and dimensions
	    if (this.left !== pixelRect.x) {
	        cssChanges.left = pixelRect.x;
	        this.left = pixelRect.x;
	        changed = true;
	    }
	    if (this.top !== pixelRect.y) {
	        cssChanges.top = pixelRect.y;
	        this.top = pixelRect.y;
	        changed = true;
	    }
	    if (this.width !== pixelRect.width) {
	        cssChanges.width = pixelRect.width;
	        this.width = pixelRect.width;
	        changed = true;
	    }
	    if (this.height !== pixelRect.height) {
	        cssChanges.height = pixelRect.height;
	        this.height = pixelRect.height;
	        changed = true;
	    }

	    // Sometimes animation fails to set the css top and left correctly
	    // in webkit. We'll validate upon completion of the animation and
	    // set the properties again if they don't match the expected values.
	    var tile = this,
	        validateChangesAndComplete = function() {
	            var el = tile.$el[0];
	            if (tile.left !== el.offsetLeft) {
	                //console.log ('mismatch left:' + tile.left + ' actual:' + el.offsetLeft + ' id:' + tile.id);
	                tile.$el.css('left', tile.left);
	            }
	            if (tile.top !== el.offsetTop) {
	                //console.log ('mismatch top:' + tile.top + ' actual:' + el.offsetTop + ' id:' + tile.id);
	                tile.$el.css('top', tile.top);
	            }

	            if (onComplete) {
	                onComplete();
	            }
	        };


	    // make css changes with animation when requested
	    if (animate && changed) {

	        this.$el.animate(cssChanges, {
	            duration: duration,
	            easing: 'swing',
	            complete: validateChangesAndComplete
	        });
	    }
	    else {

	        if (changed) {
	            this.$el.css(cssChanges);
	        }

	        setTimeout(validateChangesAndComplete, duration);
	    }
	}
});

//===================================================================================
// Implements a film strip where a set of tiles are shown from left to right. A current
// document is the first tile on the left, if specified. Other documents (related) are
// displayed in order from left to right with the ability to scroll through them
var FilmStrip = $n2.Class({

	showService: null,
	
	documentSource: null,

	requestService: null,

	relatedDocumentDiscoveryProcess: null,

	documentInfoFunction: null,

	sortFunction: null,

	filterFactory: null,

	elemId: null,
	
	currentDocId: null,

	docIds: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,currentDocId: null
			,docIds: null
			,showService: null
			,documentSource: null
			,requestService: null
			,relatedDocumentDiscoveryProcess: null
			,documentInfoFunction: null
			,sortFunction: null
			,filterFactory: null
		},opts_);
		
		this.showService = opts.showService;
		this.documentSource = opts.documentSource;
		this.relatedDocumentDiscoveryProcess = opts.relatedDocumentDiscoveryProcess;
		this.documentInfoFunction = opts.documentInfoFunction;
		this.sortFunction = opts.sortFunction;
		this.documentSource = opts.documentSource;
		this.requestService = opts.requestService;
		this.filterFactory = opts.filterFactory;
		this.currentDocId = opts.currentDocId;
		this.docIds = opts.docIds;
		if( !this.docIds ){
			this.docIds = [];
		};
		
		var $elem = $(opts.elem);
		this.elemId = $n2.utils.getElementIdentifier($elem);
		
		this._display();
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_display: function(){
		var _this = this;
		
		var $elem = this._getElem();
		$elem
			.empty()
			.addClass('n2DisplayRibbon2_film');

		var $filters = $('<div>')
			.addClass('n2DisplayRibbon2_film_filters')
			.appendTo($elem);
		
	    this.filter = this.filterFactory.get($filters,function(){
	    	_this._documentFilterChanged();
	    });

		var $currentLayout = $('<div>')
			.addClass('n2DisplayRibbon2_film_currentLayout')
			.appendTo($elem);
		
		var $outer = $('<div>')
			.addClass('n2DisplayRibbon2_film_tilesOuter')
			.appendTo($elem);
		var $inner = $('<div>')
			.addClass('n2DisplayRibbon2_film_tilesInner')
			.appendTo($outer);
		$('<div>')
			.addClass('n2DisplayRibbon2_film_tilesPrevious')
			.appendTo($outer);
		$('<div>')
			.addClass('n2DisplayRibbon2_film_tilesNext')
			.appendTo($outer);

		if( this.currentDocId ){
			this._displaySingle();
		} else {
			this._displayMultiple();
		};
	},

	_displaySingle: function(){
		var _this = this;

		var $elem = this._getElem()
			.addClass('n2DisplayRibbon2_film_containsCurrent');
		
		this.requestService.requestDocument(this.currentDocId, receiveCurrentDoc);
		
		function receiveCurrentDoc(currentDoc){
			_this.relatedDocumentDiscoveryProcess.getRelatedDocumentIds({
				doc: currentDoc
				,onSuccess: receiveRelatedDocIds
				,onError: function(err){}
			});
		};
		
		function receiveRelatedDocIds(currentDoc, relatedDocIds){
			var uniqueMap = {};
			for(var i=0,e=relatedDocIds.length; i<e; ++i){
				var docId = relatedDocIds[i];
				uniqueMap[docId] = true;
			};
			
			var docIds = [];
			for(var docId in uniqueMap){
				docIds.push(docId);
			};
			
			_this.documentInfoFunction({
				docIds: docIds
				,display: this
				,onSuccess: function(docInfos){
					receiveDocInfos(currentDoc, docInfos);
				}
				,onError: function(errorMsg){}
			});
		};
		
		function receiveDocInfos(currentDoc, docInfos){
			_this.filter.display(docInfos,_this);
			docInfos = _this.filter.filter(docInfos,_this);

			_this.sortFunction(docInfos);
			
			show(currentDoc, docInfos);
		};
		
		function show(currentDoc, docInfos){
			var $currentLayout = $elem.find('.n2DisplayRibbon2_film_currentLayout');
			var $currentContainer = $('<div>')
				.addClass('n2DisplayRibbon2_film_currentContainer')
				.appendTo($currentLayout);
			var $currentContent = $('<div>')
				.addClass('n2DisplayRibbon2_film_currentContent')
				.appendTo($currentContainer);
			_this.showService.printBriefDescription($currentContent, currentDoc._id);
			
			var currentLeft = 0;
			var $outer = $('<div>')
				.addClass('n2DisplayRibbon2_film_tilesOuter')
				.appendTo($elem);
			var $inner = $('<div>')
				.addClass('n2DisplayRibbon2_film_tilesInner')
				.appendTo($outer);
			for(var i=0,e=docInfos.length; i<e; ++i){
				var docInfo = docInfos[i];
				var docId = docInfo.id;

				var $tileLayout = $('<div>')
					.addClass('n2DisplayRibbon2_film_tileLayout')
					.css({
						position: 'absolute'
						,left: currentLeft
						,top: 0
					})
					.appendTo($inner);
				
				currentLeft += $tileLayout.width();
				
				var $tileContainer = $('<div>')
					.addClass('n2DisplayRibbon2_film_tileContainer')
					.appendTo($tileLayout);
				
				var $thumb = $('<div>')
					.addClass('n2DisplayRibbon2_film_thumb n2s_insertFirstThumbnail')
					.attr('nunaliit-document',docId)
					.appendTo($tileContainer);

				var $tileContent = $('<div>')
					.addClass('n2DisplayRibbon2_film_tileContent n2s_briefDisplay')
					.attr('nunaliit-document',docId)
					.appendTo($tileContainer);
			};

			_this._installCallBacks();

			_this.showService.fixElementAndChildren($elem);
		};
	},

	_displayMultiple: function(){
		var $elem = this._getElem();
		
		var currentLeft = 0;
		var $inner = $elem.find('.n2DisplayRibbon2_film_tilesInner');
		for(var i=0,e=this.docIds.length; i<e; ++i){
			var docId = this.docIds[i];

			var $tileLayout = $('<div>')
				.addClass('n2DisplayRibbon2_film_tileLayout')
				.css({
					position: 'absolute'
					,left: currentLeft
					,top: 0
				})
				.appendTo($inner);
			
			currentLeft += $tileLayout.width();
			
			var $tileContainer = $('<div>')
				.addClass('n2DisplayRibbon2_film_tileContainer')
				.appendTo($tileLayout);

			var $thumb = $('<div>')
				.addClass('n2DisplayRibbon2_film_thumb n2s_insertFirstThumbnail')
				.attr('nunaliit-document',docId)
				.appendTo($tileContainer);
	
			var $tileContent = $('<div>')
				.addClass('n2DisplayRibbon2_film_tileContent n2s_briefDisplay')
				.attr('nunaliit-document',docId)
				.appendTo($tileContainer);
			this.showService.printBriefDescription($tileContent, docId);
		};
		
		this._installCallBacks();

		this.showService.fixElementAndChildren($elem);
	},
	
	_installCallBacks: function(){
		
	},
	
	_documentFilterChanged: function(){
		
	}
});

//===================================================================================
// Reimplements the grid class from http://thinkpixellab.com/tilesjs
// This instance creates a long horizontal ribbon where the left most location is
// privileged for the current document. Then, all the other documents are positioned
// to the right in a single line. These can be browsed using end arrows
var RibbonGrid = $n2.Class({
	
	// Function to create a new tile
	createTile: null,
	
	// Current size of a cell
	cellSize: null,
	
	cellSizeMin: null,

    cellPadding: null,
    
    numColumnMin: null,
    
	animationDuration: null,
	
	// The identifier for the current element
	elemId: null,
	
	// If set, the left most tile
	currentTile: null,
	
	// Array of tiles that are on the right
	relatedTiles: null,
	
	// Tiles that should be removed on next redraw
	removedTiles: null,
	
	rateOfChange: null,
	
	rateOfChangeEnd: null,
	
	relatedOffset: null,

	relatedOffsetMin: null,
	
	intervalId: null,
	
	initialize: function(element){
        var _this = this;

        var $elem = $(element);
		this.elemId = $n2.utils.getElementIdentifier($elem);
		
		this.createTile = function(tileId){
			var $elem = $('div')
				.css({
					position: 'absolute'
				});
			return new Tile(tileId, $elem);
		};

		// animation lasts 500 ms by default
        this.animationDuration = 500;

        // spacing between tiles
        this.cellPadding = 10;

        // min width and height of a cell in the grid
        this.cellSizeMin = 150;
        
        // Show at least 3 tiles in the given width
        this.numColumnMin = 3;
        
        this.currentTile = undefined;
        this.relatedTiles = [];
        this.removedTiles = [];
        this.rateOfChange = 0;
        this.rateOfChangeEnd = true;
        this.relatedOffset = 0;
        this.relatedOffsetMin = 0;

        this.intervalId = window.setInterval(function(){
        	_this._intervalTask();
        },300);
        	
		$elem
			.empty()
			;
		var currentPosition = $elem.css('position');
		if( !currentPosition ){
			$elem.css('position','relative');
		} else if( 'absolute' === currentPosition ){
			// OK
		} else {
			$elem.css('position','relative');
		};
		$('<div>')
			.addClass('n2DisplayRibbon2_grid_current')
			.css({
				position: 'absolute'
				,left: '0'
				,top: '0'
				,bottom: '0'
				,right: 'auto'
				,width: '170px'
			})
			.appendTo($elem);
		var $extra = $('<div>')
			.addClass('n2DisplayRibbon2_grid_extra')
			.css({
				position: 'absolute'
				,left: '170px'
				,top: '0'
				,bottom: '0'
				,right: '0'
			})
			.appendTo($elem);
		$('<div>')
			.addClass('n2DisplayRibbon2_grid_related')
			.css({
				position: 'absolute'
				,left: '0'
				,top: '0'
				,bottom: '0'
			})
			.appendTo($extra);
		$('<div>')
			.addClass('n2DisplayRibbon2_grid_button_previous')
			.appendTo($extra)
			.mousedown(function(){
				_this._buttonChanged('down','previous');
				return false;
			})
			.mouseup(function(){
				_this._buttonChanged('up','previous');
				return false;
			})
			;
		$('<div>')
			.addClass('n2DisplayRibbon2_grid_button_next')
			.appendTo($extra)
			.mousedown(function(){
				_this._buttonChanged('down','next');
				return false;
			})
			.mouseup(function(){
				_this._buttonChanged('up','next');
				return false;
			})
			;
		
	},

	updateTiles: function(currentTileId, relatedTileIds){
		// Make a map of all current tiles, for easy access
		var tilesById = {};
		if( this.currentTile ){
			tilesById[this.currentTile.id] = this.currentTile;
		};
		for(var i=0,e=this.relatedTiles.length; i<e; ++i){
			var tile = this.relatedTiles[i];
			tilesById[tile.id] = tile;
		};

		// Load all the ids in a map to remove duplicates
		var newTilesById = {};
		
		var newCurrentTile = undefined;
		if( currentTileId ){
			var id = currentTileId;
			var tile = tilesById[id];
			
			if( !tile ){
				tile = this.createTile(id);
			};

			if( tile ){
				newTilesById[id] = tile;
				newCurrentTile = tile;
			};
		};
		
		var newRelatedTiles = [];
		for(var i=0,e=relatedTileIds.length; i<e; ++i){
			var id = relatedTileIds[i];
			var tile = tilesById[id];
			
			if( !tile ){
				tile = this.createTile(id);
			};
			
			if( tile ){
				newTilesById[id] = tile;
				newRelatedTiles.push(tile);
			};
		};
		
		var newRemovedTiles = [];
		for(var id in tilesById){
			var tile = tilesById[id];
			if( !newTilesById[id] ){
				newRemovedTiles.push(tile);
			};
		};
		
		// Update
		this.currentTile = newCurrentTile;
		this.relatedTiles = newRelatedTiles;
		this.removedTiles = newRemovedTiles;
	},
	
	/**
	 * This function moves the tiles around according to the new state
	 * of the instance (currentTile, relatedTiles, removedTiles)
	 * @param animate Boolean If set, use animation
	 * @param onComplete Function If specified, called when movement is done, or animation is complete
	 */
	redraw: function(animate, onComplete){
        // see if we should redraw
        if( !this._shouldRedraw() ) {
            if (onComplete) {
                onComplete(false); // tell callback that we did not redraw
            }
            return;
        };
        
        var $elem = this._getElem();
        var $currentElem = $elem.find('.n2DisplayRibbon2_grid_current');
        var $extraElem = $elem.find('.n2DisplayRibbon2_grid_extra');
        var $relatedElem = $elem.find('.n2DisplayRibbon2_grid_related');
        
        var height = $elem.height();
        var width = $elem.width();
        
        var cellSizeOnHeight = height - (2 * this.cellPadding);
        if( cellSizeOnHeight < this.cellSizeMin ){
        	cellSizeOnHeight = this.cellSizeMin;
        };

        var cellSizeOnWidth = ((width - this.cellPadding) / this.numColumnMin) - this.cellPadding;
        if( cellSizeOnWidth < this.cellSizeMin ){
        	cellSizeOnWidth = this.cellSizeMin;
        };
        
        this.cellSize = Math.min(cellSizeOnHeight, cellSizeOnWidth);

        var duration = this.animationDuration;

        // Reset position of related div
		this.relatedOffset = 0;
		$elem.find('.n2DisplayRibbon2_grid_related').css({
			left: this.relatedOffset
		}); 
        
        // Move the current and related div
    	var currentDivWidth = 0;
        if( this.currentTile ){
        	// Current tile is visible. Show div and
        	// shrink extra
        	currentDivWidth = this.cellSize + (2 * this.cellPadding);
        	$currentElem.css({
        		display: 'block'
        		,width: ''+currentDivWidth+'px'
        	});
        	$extraElem.css({
        		left: ''+currentDivWidth+'px'
        	});
        	
        	// Move current tile to current div
        	this.currentTile.resize(
        		{
        			width: this.cellSize
        			,height: this.cellSize
        			,x: this.cellPadding
        			,y: this.cellPadding
        		}
        		,true // animate
        		,duration
        		,undefined // onComplete
        		);
        	this.currentTile.appendTo($currentElem, false, 0, duration);
        	
        } else {
        	$currentElem.css({
        		display: 'none'
        	});
        	$extraElem.css({
        		left: '0px'
        	});
        };

	    // fade out all removed tiles
	    for(var i=0, e=this.removedTiles.length; i<e; ++i) {
	        var tile = this.removedTiles[i];
	        tile.remove(animate, duration);
	    }
	    this.removedTiles = [];
        
	    // Deal with related tiles
	    var currentLeft = this.cellPadding;
	    for(var i=0,e=this.relatedTiles.length; i<e; ++i){
	    	var tile = this.relatedTiles[i];
        	tile.resize(
        		{
        			width: this.cellSize
        			,height: this.cellSize
        			,x: currentLeft
        			,y: this.cellPadding
        		}
        		,true // animate
        		,duration
        		,undefined // onComplete
        		);
	    	tile.appendTo($relatedElem, false, 0, duration);
	    	
	    	currentLeft += (this.cellSize + this.cellPadding);
	    };
	    
	    this.relatedOffsetMin = width - currentDivWidth - currentLeft;
	    if( this.relatedOffsetMin > 0 ){
	    	this.relatedOffsetMin = 0;
	    };
	    this._updateRelatedOffset(this.relatedOffset);
        
	    if( typeof onComplete === 'function' ) {
	        setTimeout(function() { onComplete(true); }, duration + 10);
	    };
	},
	
	_shouldRedraw: function(){
		return true;
	},
	
	_buttonChanged: function(state, id){
		if( 'up' === state ){
			this.rateOfChangeEnd = true;
		} else {
			this.rateOfChangeEnd = false;
			if( 'next' === id ){
				this.rateOfChange = -250;
			} else {
				this.rateOfChange = 250;
			};
		};
	},
	
	_intervalTask: function(){
		var $elem = this._getElem();
		if( $elem.length < 1 ){
			// This grid is oo longer in use
			window.clearInterval(this.intervalId);
		} else {
			if( this.rateOfChange != 0 ){
				var newOffset = this.relatedOffset;
				
				newOffset += this.rateOfChange;
				
				this._updateRelatedOffset(newOffset);
				
				if( this.rateOfChangeEnd ){
					this.rateOfChange = 0;
				};
			};
		};
	},
	
	_updateRelatedOffset: function(newRelatedOffset){
		if( newRelatedOffset > 0 ){
			newRelatedOffset = 0;
		};
		if( newRelatedOffset < this.relatedOffsetMin ){
			newRelatedOffset = this.relatedOffsetMin;
		};
		
		if( newRelatedOffset != this.relatedOffset ){
			this.relatedOffset = newRelatedOffset;
			var $elem = this._getElem();
			var $related = $elem.find('.n2DisplayRibbon2_grid_related');
			var cssChanges = {
				left: this.relatedOffset
			};
			$related.animate(cssChanges, {
	            duration: 300,
	            easing: 'linear'
	        });
		};
		
		var $elem = this._getElem();
		if( this.relatedOffset <= this.relatedOffsetMin ){
			$elem.addClass('n2DisplayRibbon2_grid_related_max');
		} else {
			$elem.removeClass('n2DisplayRibbon2_grid_related_max');
		};
		if( this.relatedOffset >= 0 ){
			$elem.addClass('n2DisplayRibbon2_grid_related_min');
		} else {
			$elem.removeClass('n2DisplayRibbon2_grid_related_min');
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	}
});

// ===================================================================================

var RibbonDisplay = $n2.Class('RibbonDisplay', {
	
	documentSource: null,
	
	displayPanelName: null,
	
	showService: null,
	
	requestService: null,
	
	schemaRepository: null,
	
	customService: null,
	
	dispatchService: null,
	
	boolOptions: null,
	
	restrictAddRelatedButtonToLoggedIn: null,
	
	currentDetails: null,
	
	displayedDocumentsOrder: null,
	
	displayedDocuments: null,
	
	grid: null,
	
	createDocProcess: null,
	
	defaultSchema: null,
	
	relatedDocumentDiscoveryProcess: null,
	
	documentInfoFunction: null,
	
	sortFunction: null,
	
	filterFactory: null,
	
	filter: null,
	
	hoverInFn: null,
	
	hoverOutFn: null,

	clickFn: null,
	
	hoverDocId: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			documentSource: null
			,displayPanelName: null
			,showService: null
			,requestService: null
			,schemaRepository: null
			,customService: null
			,dispatchService: null
			,createDocProcess: null
			,displayRelatedInfoFunction: null
			
			// Boolean options
			,displayOnlyRelatedSchemas: false
			,displayBriefInRelatedInfo: false
			,restrictAddRelatedButtonToLoggedIn: false
			
			// Process used to discover related information from
			// a document
			,relatedDocumentDiscoveryProcess: null
			
			// Function to obtain document information structures based on
			// document ids
			,documentInfoFunction: null
			
			// Function to sort documents based on info structures
			,sortFunction: null
			
			// Factory to create filters
			,filterFactory: null
		},opts_);

		var _this = this;
		
		/*
			currentDetails = {
				// single document selection
				docId // document identifier
				doc // document content
				schema // schema associated with the document
				height // last detected content height for current document
				referenceDocIds // doc ids of related info
				
				// multiple document selection
				docIds // document identifiers
				docs // map of document contents by id
			}
		 */
		this.currentDetails = {};
		/*
		 	displayedDocuments = {
		 		<doc-id>: {
		 			id: <doc-id>
		 			,info: <info object>
		 			,doc: <content>
		 		}
		 	}
		 */
		this.displayedDocuments = {};
		/*
		 	Array of document ids
		 */
		this.displayedDocumentsOrder = null;
		
		this.documentSource = opts.documentSource;
		this.displayPanelName = opts.displayPanelName;
		this.showService = opts.showService;
		this.requestService = opts.requestService;
		this.schemaRepository = opts.schemaRepository;
		this.customService = opts.customService;
		this.dispatchService = opts.dispatchService;
		this.createDocProcess = opts.createDocProcess;
		
		// Initialize display
		this._getDisplayDiv();
		
		// Boolean options
		this.boolOptions = {
			displayOnlyRelatedSchemas: opts.displayOnlyRelatedSchemas
			,displayBriefInRelatedInfo: opts.displayBriefInRelatedInfo
		};
		this.restrictAddRelatedButtonToLoggedIn = opts.restrictAddRelatedButtonToLoggedIn;
		if( !this.restrictAddRelatedButtonToLoggedIn 
		 && this.customService ){
			this.restrictAddRelatedButtonToLoggedIn = 
				this.customService.getOption('restrictAddRelatedButtonToLoggedIn',false);
		};

		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			var f = function(msg, addr, d){
				_this._handleDispatch(msg, addr, d);
			};
			dispatcher.register(DH, 'selected', f);
			dispatcher.register(DH, 'searchResults', f);
			dispatcher.register(DH, 'documentDeleted', f);
			dispatcher.register(DH, 'authLoggedIn', f);
			dispatcher.register(DH, 'authLoggedOut', f);
			dispatcher.register(DH, 'editClosed', f);
			dispatcher.register(DH, 'documentContent', f);
			dispatcher.register(DH, 'documentContentCreated', f);
			dispatcher.register(DH, 'documentContentUpdated', f);
		};
		
		if( !opts.displayRelatedInfoFunction ) {
			var flag = this._getBooleanOption('displayOnlyRelatedSchemas');
			if( flag ) {
				opts.displayRelatedInfoFunction = function(opts_){
					_this._displayRelatedInfo(opts_);
				};
			} else {
				opts.displayRelatedInfoFunction = function(opts_){
					_this._displayLinkedInfo(opts_);
				};
			};
		};
		
		// Related document discovery process
		this.relatedDocumentDiscoveryProcess = opts.relatedDocumentDiscoveryProcess;
		if( !this.relatedDocumentDiscoveryProcess 
		 && this.customService ){
			this.relatedDocumentDiscoveryProcess = 
				this.customService.getOption('relatedDocumentDiscoveryProcess',null);
		};
		if( !this.relatedDocumentDiscoveryProcess ){
			this.relatedDocumentDiscoveryProcess = new ReferenceRelatedDocumentDiscovery({
				documentSource: this.documentSource
			});
		};
		
		// Document info function
		this.documentInfoFunction = opts.documentInfoFunction;
		if( !this.documentInfoFunction 
		 && this.customService ){
			var docInfoFn = this.customService.getOption('displayDocumentInfoFunction');
			if( typeof docInfoFn === 'function' ){
				this.documentInfoFunction = docInfoFn;
			};
		};
		if( !this.documentInfoFunction ){
			this.documentInfoFunction = function(opts_){
				var opts = $n2.extend({
					docIds: null
					,display: null
					,onSuccess: function(docInfos){}
					,onError: function(err){}
				},opts_);
				
				var ds = _this.documentSource;
				ds.getDocumentInfoFromIds({
					docIds: opts.docIds
					,onSuccess: opts.onSuccess
					,onError: opts.onError
				});
			};
		};
		
		// Sort function
		this.sortFunction = opts.sortFunction;
		if( !this.sortFunction 
		 && this.customService ){
			var sortFn = this.customService.getOption('displaySortFunction');
			if( typeof sortFn === 'function' ){
				this.sortFunction = sortFn;
			};
		};
		if( !this.sortFunction ){
			this.sortFunction = function(infos){
				infos.sort(function(a,b){
					if( a.updatedTime && b.updatedTime ){
						if( a.updatedTime > b.updatedTime ){
							return -1;
						};
						if( a.updatedTime < b.updatedTime ){
							return 1;
						};
					};

					if( a.id > b.id ){
						return -1;
					};
					if( a.id < b.id ){
						return 1;
					};
					
					return 0;
				});
			};
		};
		
		// Filter factory
		this.filterFactory = opts.filterFactory;
		if( !this.filterFactory 
		 && this.customService ){
			var factory = this.customService.getOption('displayFilterFactory');
			if( factory && typeof factory.get === 'function' ){
				this.filterFactory = factory;
			};
		};
		if( !this.filterFactory ){
			this.filterFactory = new SchemaFilterFactory({
				schemaRepository: this.schemaRepository
			});
		};
		
		// Hover in and out
		this.hoverInFn = function(){
			var $tile = $(this);
			_this._hoverInTile($tile);
			return false;
		};
		this.hoverOutFn = function(){
			var $tile = $(this);
			_this._hoverOutTile($tile);
			return false;
		};
		
		// Click function
		this.clickFn = function(){
			var $tile = $(this);
			_this._clickedTile($tile);
			return false;
		};
		
		// Detect changes in displayed current content size
		var intervalID = window.setInterval(function(){
			var $set = _this._getDisplayDiv();
			if( $set.length < 0 ) {
				window.clearInterval(intervalID);
			} else {
				_this._performIntervalTask();
			};
		}, 500);

		$('body').addClass('n2_display_format_ribbon');
		
		$n2.log('DisplayRibbon2',this);
	},

	// external
	setSchema: function(schema) {
		this.defaultSchema = schema;
	},
	
	_handleDispatch: function(msg, addr, dispatcher){
		var $div = this._getDisplayDiv();
		if( $div.length < 1 ){
			// No longer displaying. Un-register this event.
			dispatcher.deregister(addr);
			return;
		};
		
		// Selected document
		if( msg.type === 'selected' ) {
			if( msg.doc ) {
				this._displayDocument(msg.doc._id, msg.doc);
				
			} else if( msg.docId ) {
				this._displayDocument(msg.docId, null);
				
			} else if( msg.docs ) {
				var ids = [];
				for(var i=0, e=msg.docs.length; i<e; ++i){
					ids.push( msg.docs[i]._id );
				};
				this._displayMultipleDocuments(ids, msg.docs);
				
			} else if( msg.docIds ) {
				this._displayMultipleDocuments(msg.docIds, null);
			};
			
		} else if( msg.type === 'searchResults' ) {
			this._displaySearchResults(msg.results);
			
		} else if( msg.type === 'documentDeleted' ) {
	//		var docId = msg.docId;
	//		this._handleDocumentDeletion(docId);
			
		} else if( msg.type === 'authLoggedIn' 
			|| msg.type === 'authLoggedOut' ) {
			
			// Redisplay buttons
			if( this.currentDetails 
			 && this.currentDetails.docId 
			 && this.currentDetails.doc ){
				this._receiveDocumentContent(this.currentDetails.doc);
				this._displayDocumentButtons(this.currentDetails.doc, this.currentDetails.schema);
			};
			
		} else if( msg.type === 'editClosed' ) {
			var deleted = msg.deleted;
			if( !deleted ) {
				var doc = msg.doc;
				if( doc ) {
					this._displayDocument(doc._id, doc);
				};
			};
			
		} else if( msg.type === 'documentContent' ) {
			this._receiveDocumentContent(msg.doc);
			
		} else if( msg.type === 'documentContentCreated' ) {
			this._receiveDocumentContent(msg.doc);
			
		} else if( msg.type === 'documentContentUpdated' ) {
			this._receiveDocumentContent(msg.doc);
		};
	},
	
	_displayDocument: function(docId, doc) {
	
	//	var _this = this;
		
		this._reclaimDisplayDiv();
		
		if( this.currentDetails
		 && this.currentDetails.docId === docId ){
			// Already in process of displaying this document
			return;
		};
		
		this.currentDetails = {
			docId: docId
		};
	
		this._addDisplayedDocument(docId, doc);
	
		var $set = this._getDisplayDiv();
	
		var $current = $set.find('.n2DisplayRibbon2_info');
		$current.hide();
		
		var $docs = $set.find('.n2DisplayRibbon2_documents');
		var filmStrip = new FilmStrip({
			elem: $docs
			,currentDocId: docId
			,docIds: []
			,showService: this.showService
			,requestService: this.requestService
			,documentSource: this.documentSource
			,relatedDocumentDiscoveryProcess: this.relatedDocumentDiscoveryProcess
			,documentInfoFunction: this.documentInfoFunction
			,sortFunction: this.sortFunction
			,filterFactory: this.filterFactory
		});
	},
	
	/*
	 * Accepts search results and display them in tiled mode
	 */
	_displaySearchResults: function(results){
		
		this._reclaimDisplayDiv();
		
		var ids = [];
		if( results && results.sorted && results.sorted.length ) {
			for(var i=0,e=results.sorted.length; i<e; ++i){
				ids.push(results.sorted[i].id);
			};
		};
		
		this._displayMultipleDocuments(ids, null);
		
		if( ids.length < 1 ){
			var $set = this._getDisplayDiv();
			var $current = $set.find('.n2DisplayRibbon2_info');
			$current
				.text( _loc('Empty search results') )
				.show();
		};
	},
	
	/*
	 * Displays multiple documents
	 */
	_displayMultipleDocuments: function(ids, docs){
		
		this._reclaimDisplayDiv();
	
		var $set = this._getDisplayDiv();
		var $current = $set.find('.n2DisplayRibbon2_info');
		$current.hide();
		
		this.currentDetails = {
			docIds: ids
			,docs: {}
		};

		var $docs = $set.find('.n2DisplayRibbon2_documents');
		var filmStrip = new FilmStrip({
			elem: $docs
			,currentDocId: null
			,docIds: ids
			,showService: this.showService
			,requestService: this.requestService
			,documentSource: this.documentSource
			,relatedDocumentDiscoveryProcess: this.relatedDocumentDiscoveryProcess
			,documentInfoFunction: this.documentInfoFunction
			,sortFunction: this.sortFunction
			,filterFactory: this.filterFactory
		});
	},
	
	_displayDocumentButtons: function(doc, schema){
		
		var _this = this;
		
		if( doc 
		 && doc._id 
		 && this.currentDetails.docId === doc._id ){
			var $set = this._getDisplayDiv();
			var $btnDiv = $set.find('.n2DisplayRibbon2_current_buttons')
				.empty();
	
	 		// 'edit' button
	 		if( $n2.couchMap.canEditDoc(doc) ) {
	 			$('<a href="#"></a>')
	 				.addClass('n2DisplayRibbon2_current_button n2DisplayRibbon2_current_button_edit')
	 				.text( _loc('Edit') )
	 				.appendTo($btnDiv)
	 				.click(function(){
						_this._performDocumentEdit(doc);
						return false;
					});
	 		};
	
	 		// Show 'delete' button
	 		if( $n2.couchMap.canDeleteDoc(doc) ) {
	 			$('<a href="#"></a>')
	 				.addClass('n2DisplayRibbon2_current_button n2DisplayRibbon2_current_button_delete')
	 				.text( _loc('Delete') )
	 				.appendTo($btnDiv)
	 				.click(function(){
						_this._performDocumentDelete(doc);
						return false;
					});
	 		};
	
	 		// 'add related' button
			if( schema
			 && schema.relatedSchemaNames 
			 && schema.relatedSchemaNames.length
			 ) {
				var showAddRelatedButton = true;
				if( this.restrictAddRelatedButtonToLoggedIn ){
					var isLoggedIn = false;
	
					if( this.dispatchService ){
						var m = {
							type: 'authIsLoggedIn'
							,isLoggedIn: false
						};
						this.dispatchService.synchronousCall(DH,m);
						isLoggedIn = m.isLoggedIn;
					};
					
					if( !isLoggedIn ){
						showAddRelatedButton = false;
					};
				};
				
				if( showAddRelatedButton ) {
					var $placeHolder = $('<span>')
						.appendTo($btnDiv);
					this.createDocProcess.insertAddRelatedSelection({
						placeHolderElem: $placeHolder
						,doc: doc
						,onElementCreated: function($elem){
							$elem.addClass('n2DisplayRibbon2_current_button n2DisplayRibbon2_current_button_add_related_item');
						}
					});
				}; // show button
			};
			
	 		// Show 'find on map' button
			if( this.dispatchService 
			 && this.dispatchService.isEventTypeRegistered('findIsAvailable')
			 && this.dispatchService.isEventTypeRegistered('find')
			 ) {
				// Check if document can be displayed on a map
				var showFindOnMapButton = false;
				var m = {
					type: 'findIsAvailable'
					,doc: doc
					,isAvailable: false
				};
				this.dispatchService.synchronousCall(DH,m);
				if( m.isAvailable ){
					showFindOnMapButton = true;
				};
	
				if( showFindOnMapButton ) {
					$('<a href="#"></a>')
						.addClass('n2DisplayRibbon2_current_button n2DisplayRibbon2_current_button_find_on_map')
		 				.text( _loc('Find on Map') )
		 				.appendTo($btnDiv)
		 				.click(function(){
		 					_this._dispatch({
		 						type: 'find'
	 							,docId: doc._id
	 							,doc: doc
	 						});
							return false;
						});
				};
			};
	
			// Show 'Add Layer' button
			if( doc
			 && doc.nunaliit_layer_definition
			 && this.dispatchService
			 && this.dispatchService.isEventTypeRegistered('addLayerToMap')
			 ) {
				$('<a href="#"></a>')
					.addClass('n2DisplayRibbon2_current_button n2DisplayRibbon2_current_button_add_layer')
	 				.text( _loc('Add Layer') )
	 				.appendTo($btnDiv)
	 				.click(function(){
	 					_this._performAddLayerToMap(doc);
						return false;
					});
			};
	
			// Show 'Tree View' button
			if( doc ) {
				$('<a href="#"></a>')
					.addClass('n2DisplayRibbon2_current_button n2DisplayRibbon2_current_button_tree_view')
	 				.text( _loc('Tree View') )
	 				.appendTo($btnDiv)
	 				.click(function(){
	 					_this._performTreeView(doc);
						return false;
					});
			};
		};
	},
	
	_currentDocReferencesUpdated: function(){
		if( this.currentDetails 
		 && this.currentDetails.doc 
		 && this.currentDetails.referenceDocIds ){
			// Accumulate all references
			var refDocIds = {};
			for(var i=0, e=this.currentDetails.referenceDocIds.length; i<e; ++i){
				var linkDocId = this.currentDetails.referenceDocIds[i];
				refDocIds[linkDocId] = true;
			};
			
			// Figure out information that must be removed
			var idsToRemove = [];
			for(var docId in this.displayedDocuments){
				if( docId === this.currentDetails.docId ) {
					// OK
				} else if( !refDocIds[docId] ){
					idsToRemove.push(docId);
				};
			};
			for(var i=0,e=idsToRemove.length; i<e; ++i){
				this._removeDisplayedDocument(idsToRemove[i]);
			};
			
			// Add new ones
			for(var docId in refDocIds){
				this._addDisplayedDocument(docId);
			};
			
			// Use dynamic sorting
			this.displayedDocumentsOrder = null;
	
			// Perform updates
			this._updateDisplayedDocuments();
		};
	},
	
	/*
	 * Verify information found in the instance variable displayedDocuments
	 * and affect the displaying accordingly
	 */
	_updateDisplayedDocuments: function(){
		var _this = this;
		
		// Get all the required info
		var neededInfoIds = [];
		for(var docId in this.displayedDocuments){
			if( !this.displayedDocuments[docId].info ) {
				neededInfoIds.push(docId);
			};
		};
		if( neededInfoIds.length > 0 ) {
			this.documentInfoFunction({
				docIds: neededInfoIds
				,display: this
				,onSuccess: function(docInfos){
					for(var i=0, e=docInfos.length; i<e; ++i){
						var docInfo = docInfos[i];
						var docId = docInfo.id;
						if( _this.displayedDocuments[docId] ){
							_this.displayedDocuments[docId].info = docInfo;
						};
					};
					performUpdate();
				}
				,onError: function(errorMsg){
					$n2.log('Unable to obtain document information',errorMsg);
				}
			});
		} else {
			performUpdate();
		};
	
		function performUpdate() {
			// Ensure we have display
			_this._getDisplayDiv();
	
			// Sort
			var currentDocId = null;
			var sortedDocIds = null;
			if( _this.displayedDocumentsOrder ){
				sortedDocIds = _this.displayedDocumentsOrder;
	
				var infos = [];
				for(var i=0,e=sortedDocIds.length; i<e; ++i){
					var docId = sortedDocIds[i];
					if( _this.displayedDocuments[docId] 
					 && _this.displayedDocuments[docId].info ){
						infos.push( _this.displayedDocuments[docId].info );
					};
				};
				
				_this.filter.display(infos,_this);
				infos = _this.filter.filter(infos,_this);
	
				sortedDocIds = [];
				for(var i=0,e=infos.length; i<e; ++i){
					var info = infos[i];
					sortedDocIds.push(info.id);
				};
				
			} else {
				var infos = [];
				for(var docId in _this.displayedDocuments){
					if( _this.displayedDocuments[docId].info ){
						infos.push( _this.displayedDocuments[docId].info );
					};
				};
	
				_this.filter.display(infos,_this);
				infos = _this.filter.filter(infos,_this);
				
				_this.sortFunction(infos);
	
				var alreadySorted = {};
				sortedDocIds = [];
				if( _this.currentDetails
				 && _this.currentDetails.docId ){
					currentDocId = _this.currentDetails.docId;
					alreadySorted[_this.currentDetails.docId] = true;
				};
				
				for(var i=0,e=infos.length; i<e; ++i){
					var docId = infos[i].id;
					
					// Remove duplicates
					if( !alreadySorted[docId] ) {
						sortedDocIds.push(docId);
						alreadySorted[docId] = true;
					};
				};
			};
			
			_this.grid.updateTiles(currentDocId, sortedDocIds);
			_this.grid.isDirty = true; // force redraw to reflect change in order
	        _this.grid.redraw(true);
	
	        // Request content for documents
	        if( currentDocId ){
	        	_this._requestDocumentWithId(currentDocId);
	        };
			for(var i=0,e=sortedDocIds.length; i<e; ++i){
				var docId = sortedDocIds[i];
				_this._requestDocumentWithId(docId);
			};
		};
	},
	
	/*
	 * Changes the list of displayed documents
	 */
	_changeDisplayedDocuments: function(docIds, docsById){
		var displayDocsByIds = {};
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			displayDocsByIds[docId] = true;
		};
		
		for(var docId in this.displayedDocuments){
			if( !displayDocsByIds[docId] ){
				this._removeDisplayedDocument(docId);
			};
		};
		
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			var doc = null;
			if( docsById && docsById[docId] ){
				doc = docsById[docId];
			};
			
			this._addDisplayedDocument(docId, doc);
		};
		
		this.displayedDocumentsOrder = docIds;
		
		this._updateDisplayedDocuments();
	},
	
	/*
	 * This function adds a new document to be displayed among the related items
	 * of the display. _updateDisplayedDocuments should be called, next.
	 */
	_addDisplayedDocument: function(docId, doc){
		if( !this.displayedDocuments[docId] ){
			this.displayedDocuments[docId] = {
				id: docId
			};
		};
		
		if( doc ){
			this.displayedDocuments[docId].doc = doc;
		};
	},
	
	/*
	 * This function removes the information relating to the document
	 * associated with the given document id. _updateDisplayedDocuments
	 * should be called, next.
	 */
	_removeDisplayedDocument: function(docId){
		// Remove information
		if( this.displayedDocuments[docId] ){
			delete this.displayedDocuments[docId];
		};
	},
	
	_receiveDocumentContent: function(doc){
		var _this = this;
	
		var $set = this._getDisplayDiv();
		
		var docId = doc._id;
		if( this.displayedDocuments[docId] ){
			// We are interested in this document. Save the content
			this.displayedDocuments[docId].doc = doc;
		};
	
		// Currently displayed document?
		if( doc._id === this.currentDetails.docId ){
			
			var update = false;
			
			if( !this.currentDetails.doc ) {
				// We do not yet have the content of the current document
				this.currentDetails.doc = doc;
				update = true;
				
			} else {
				// We already have the content. Check for update.
				
				if( doc._rev !== this.currentDetails.doc._rev ) {
					this.currentDetails.doc = doc;
					update = true;
				};
			};
			
			if( update ){
				// Renew related document ids
				this.relatedDocumentDiscoveryProcess.getRelatedDocumentIds({
					doc: doc
					,onSuccess: function(doc, refDocIds){
						if( _this.currentDetails.docId === doc._id ){
							_this.currentDetails.referenceDocIds = refDocIds;
							_this._currentDocReferencesUpdated();
						};
					}
					,onError: function(err){
						$n2.log('Error obtaining reference ids',err);
					}
				});
			};
		};
		
		// Display brief associated with the document
		var waitClassName = 'n2DisplayRibbon2_wait_brief_' + $n2.utils.stringToHtmlId(docId);
		$set.find('.'+waitClassName).each(function(){
			var $div = $(this);
			if( _this.showService ) {
				_this.showService.displayBriefDescription($div, {}, doc);
			};
			$div.removeClass(waitClassName);
		});
		
		// Display full document for currently selected document
		var waitClassName = 'n2DisplayRibbon2_wait_current_' + $n2.utils.stringToHtmlId(docId);
		var buttonClassName = 'n2DisplayRibbon2_current_buttons_' + $n2.utils.stringToHtmlId(docId);
		$set.find('.'+waitClassName).each(function(){
			var $div = $(this)
				.empty();
	
			$('<div>')
				.addClass('n2DisplayRibbon2_current_buttons')
				.addClass(buttonClassName)
				.appendTo($div);			
	
			var $content = $('<div>')
				.appendTo($div);
			if( _this.showService ) {
				_this.showService.displayDocument($content, {}, doc);
			} else {
				$content.text( doc._id );
			};
			
			$div.removeClass(waitClassName);
		});
		
		// Refresh buttons
		$('.'+buttonClassName).each(function(){
			var $div = $(this);
			
			_this._displayDocumentButtons(doc, _this.currentDetails.schema);
		});
		
		// Set tile classes based on media associated with document, and schema name
		var includesImage = false;
		var includesAudio = false;
		var includesVideo = false;
		var thumbnailName = null;
		var schemaName = null;
		if( doc.nunaliit_attachments 
		 && doc.nunaliit_attachments.files ){
			for(var attName in doc.nunaliit_attachments.files){
				var att = doc.nunaliit_attachments.files[attName];
				if( att.source ) {
					// discount thumbnails
				} else {
					if( 'image' === att.fileClass ) {
						includesImage = true;
					} else if( 'audio' === att.fileClass ) {
						includesAudio = true;
					} else if( 'video' === att.fileClass ) {
						includesVideo = true;
					};
					if( att.thumbnail ){
						thumbnailName = att.thumbnail;
					};
				};
			};
		};
		if( doc.nunaliit_schema ){
			schemaName = doc.nunaliit_schema;
		};
		$set.find('.n2DisplayRibbon2_tile_' + $n2.utils.stringToHtmlId(docId)).each(function(){
			var $tile = $(this);
			
			$tile.removeClass('n2DisplayRibbon2_tile_image n2DisplayRibbon2_tile_audio n2DisplayRibbon2_tile_video');
			if(includesVideo){
				$tile.addClass('n2DisplayRibbon2_tile_video');
			} else if(includesAudio){
				$tile.addClass('n2DisplayRibbon2_tile_audio');
			} else if(includesImage){
				$tile.addClass('n2DisplayRibbon2_tile_image');
			};
			
			if( schemaName ){
				$tile.addClass('n2DisplayRibbon2_tile_schema_'+$n2.utils.stringToHtmlId(schemaName));
			};
		});
		if( thumbnailName ){
			// Check that thumbnail is attached
			if( doc.nunaliit_attachments.files[thumbnailName]
			 && doc.nunaliit_attachments.files[thumbnailName].status === 'attached' ){
				// OK
			} else {
				thumbnailName = null;
			};
		};
		if( thumbnailName ){
			var url = this.documentSource.getDocumentAttachmentUrl(doc,thumbnailName);
			if( url ){
				$set.find('.n2DisplayRibbon2_wait_thumb_' + $n2.utils.stringToHtmlId(docId)).each(function(){
					var $div = $(this);
					$div.empty();
					$('<img>')
						.attr('src',url)
						.appendTo($div);
				});
			};
		};
		
	
		// Obtain the schema associated with the document
		if( doc.nunaliit_schema 
		 && this.schemaRepository ){
			this.schemaRepository.getSchema({
				name: doc.nunaliit_schema
				,onSuccess: function(schema){
					schemaLoaded(doc, schema);
				}
				,onError: function(err){
					schemaLoaded(doc, null);
				}
			});
		} else {
			schemaLoaded(doc, null);
		};
		
		// Check if the given document contains links to the currently
		// displayed document
		if( this.currentDetails.doc 
		 && doc._id !== this.currentDetails.docId ){
			
			this.relatedDocumentDiscoveryProcess.areDocumentsRelated({
				selectedDoc: this.currentDetails.doc
				,relatedDoc: doc
				,onRelated: function(selectedDoc, relatedDoc){
					// Check validity of callback
					if( selectedDoc._id === _this.currentDetails.docId ){
						var refIndex = -1;
						if( _this.currentDetails.referenceDocIds ) {
							refIndex = _this.currentDetails.referenceDocIds.indexOf(doc._id);
						};
						
						if( refIndex < 0 ) {
							// The previous time we saw this document, there were no reference to the
							// currently displayed document. Now, this new version of the document
							// contains a reference to the displayed document. Add reference and
							// re-display.
							if( !_this.currentDetails.referenceDocIds ){
								_this.currentDetails.referenceDocIds = [];
							};
							_this.currentDetails.referenceDocIds.push(doc._id);
							_this._currentDocReferencesUpdated();
						};
					};
				}
				,onNotRelated: function(selectedDoc, relatedDoc){
					// Check validity of callback
					if( selectedDoc._id === _this.currentDetails.docId ){
						var refIndex = -1;
						if( _this.currentDetails.referenceDocIds ) {
							refIndex = _this.currentDetails.referenceDocIds.indexOf(doc._id);
						};
	
						if( refIndex >= 0 ) {
							// The previous time we saw this document, it had a reference to the
							// currently displayed document. Now, this reference is no longer there.
							// Remove the reference and redisplay
							_this.currentDetails.referenceDocIds.splice(refIndex,1);
							_this._currentDocReferencesUpdated();
						};
					};
				}
				,onError: function(err){
					$n2.log('Error in displayTiled. Unable to check relation.',err);
				}
			});
		};
		
		function schemaLoaded(doc, schema){
			if( _this.currentDetails.docId === doc._id ){
				// This is the schema associated with the current
				// document.
				if( schema && !_this.currentDetails.schema ){
					_this.currentDetails.schema = schema;
					_this._displayDocumentButtons(doc, schema);
					
				} else if( _this.currentDetails.schema && !schema ) {
					_this.currentDetails.schema = null;
					_this._displayDocumentButtons(doc, null);
				
				} else if( _this.currentDetails.schema 
				 && schema
				 && _this.currentDetails.schema.name !== schema.name
				 ) {
					// Schema is changed
					_this.currentDetails.schema = schema;
					_this._displayDocumentButtons(doc, schema);
				};
			};
		};
	},
	
	/*
	 * Initiates the editing of a document
	 */
	_performDocumentEdit: function(doc){
		var _this = this;
		
		this.documentSource.getDocument({
			docId: doc._id
			,onSuccess: function(doc){
				_this._dispatch({
					type: 'editInitiate'
					,doc: doc
				});
			}
			,onError: function(errorMsg){
				$n2.log('Unable to load document: '+errorMsg);
			}
		});
	},
	
	/*
	 * Initiates the deletion of a document
	 */
	_performDocumentDelete: function(doc){
		if( confirm( _loc('You are about to delete this document. Do you want to proceed?') ) ) {
			this.documentSource.deleteDocument({
				doc: doc
				,onSuccess: function() {}
			});
		};
	},
	
	/*
	 * Initiates the 'Add Layer to Map' action for the button
	 */
	_performAddLayerToMap: function(doc){
		var layerDefinition = doc.nunaliit_layer_definition;
		var layerId = layerDefinition.id;
		if( !layerId ){
			layerId = doc._id;
		};
		var layerDef = {
			name: layerDefinition.name
			,type: 'couchdb'
			,options: {
				layerName: layerId
				,documentSource: this.documentSource
			}
		};
		
		this._dispatch({
			type: 'addLayerToMap'
			,layer: layerDef
			,options: {
				setExtent: {
					bounds: layerDefinition.bbox
					,crs: 'EPSG:4326'
				}
			}
		});
	},
	
	/*
	 * Opens a tree view dialog
	 */
	_performTreeView: function(doc){
		new $n2.couchDisplay.TreeDocumentViewer({
			doc: doc
		});
	},
	
	/*
	 * This function should be called before any displaying is performed.
	 * This ensures that the div element in use still contains the required
	 * elements for performing display.
	 */
	_reclaimDisplayDiv: function() {
		var _this = this;
		
		var $set = this._getDisplayDiv();

		var $filters = $set.find('.n2DisplayRibbon2_filters');
		var $buttons = $set.find('.n2DisplayRibbon2_buttons');
		var $current = $set.find('.n2DisplayRibbon2_info');
		var $docs = $set.find('.n2DisplayRibbon2_documents');
		if( $filters.length < 1
		 || $buttons.length < 1 
		 || $current.length < 1
		 || $docs.length < 1 ){
			$set.empty();
			$filters = $('<div>')
				.addClass('n2DisplayRibbon2_filters')
			$buttons = $('<div>')
				.addClass('n2DisplayRibbon2_buttons')
				.appendTo($set);
			$current = $('<div>')
				.addClass('n2DisplayRibbon2_info')
				.appendTo($set);
			$docs = $('<div>')
				.addClass('n2DisplayRibbon2_documents')
				.appendTo($set);
			
			// When the side panel must be re-claimed, then we must
			// forget what is currently displayed since it has to be
			// re-computed
			this.currentDetails = {};
			
			// Create grid
			this.grid = new RibbonGrid($docs);
			this.grid.createTile = function(docId) {
				return _this._createTile(docId);
		    };
		    
			// Create document filter
		    this.filter = this.filterFactory.get($filters,function(){
		    	_this._documentFilterChanged();
		    });
		    		    
		    // Create navigation buttons
		    new $n2.widgetNavigation.NavigationWidget({
				elem: $buttons
				,dispatchService: this.dispatchService
		    });
		};
	},
	
	_createTile: function(docId){
        var $elem = $('<div>')
	    	.addClass('n2DisplayRibbon2_tile')
	    	.addClass('n2DisplayRibbon2_tile_' + $n2.utils.stringToHtmlId(docId))
	    	.attr('n2DocId',docId);
	    
	    $elem.hover(
			this.hoverInFn
			,this.hoverOutFn
	    );
		
		$elem.click(this.clickFn);
	
	    var tile = new Tile(docId, $elem);
	    
	    if( this.currentDetails
	     && this.currentDetails.docId === docId ){
	    	// Current document
	    	$elem.addClass('n2DisplayRibbon2_tile_current');
	    	this._generateCurrentDocumentContent($elem, docId);
	
	    } else {
	    	// Not current document
	    	$elem.removeClass('n2DisplayRibbon2_tile_current');
	    	this._generateRelatedDocumentContent($elem, docId);
	    };

	    return tile;
	},
	
	_clickedTile: function($tile){
		var docId = $tile.attr('n2DocId');
		
		if( this.currentDetails
		 && this.currentDetails.docId === docId ){
//			var $menu = $tile.find('.n2DisplayRibbon2_tile_menu');
//			if( $menu.length < 1 ){
//				$menu = $('<div>')
//					.addClass('n2DisplayRibbon2_tile_menu n2DisplayRibbon2_current_buttons')
//					.appendTo($tile);
//				
//				if( this.currentDetails 
//				 && this.currentDetails.doc 
//				 && this.currentDetails.schema ){
//					this._displayDocumentButtons(this.currentDetails.doc, this.currentDetails.schema);
//				};
//			};
			
			this._showCurrentPopUp();
			
		} else {
			// Related tile, select document
			this._dispatch({
				type:'userSelect'
				,docId: docId
			});
		};
	},
	
	_hoverInTile: function($tile){
		var docId = $tile.attr('n2DocId');
		if( docId && docId !== this.hoverDocId ) {
			this.hoverDocId = docId;
			this._dispatch({
				type: 'userFocusOn'
				,docId: docId
			});
		};
	},
	
	_hoverOutTile: function($tile){
		var docId = $tile.attr('n2DocId');
		if( docId && docId === this.hoverDocId ) {
			this.hoverDocId = null;
			this._dispatch({
				type: 'userFocusOff'
				,docId: docId
			});
		};
		
		$tile.find('.n2DisplayRibbon2_tile_menu').remove();
	},
	
	_showCurrentPopUp: function(){
		if( this.currentDetails
		 && this.currentDetails.docId ){
			var docId = this.currentDetails.docId;
	    	var tileClass = '.n2DisplayRibbon2_tile_' + $n2.utils.stringToHtmlId(docId);

	    	var $display = this._getDisplayDiv();
	    	var $tile = $display.find(tileClass);

	    	if( $tile.length > 0 ){
	    		// Look if pop-up is already showing
	    		var $popup = $tile.find('.n2DisplayRibbon2_popup');
	    		if( $popup.length < 1 ){
	    			$popup = $('<div>')
	    				.addClass('n2DisplayRibbon2_popup')
	    				.appendTo($tile);
	    			
	    			this._populateCurrentPopUp(docId, $popup);
	    		} else {
	    			// Toggle off
	    			$popup.remove();
	    		};
	    	};
		};
	},
	
	_hideCurrentPopUp: function(){
    	var $display = this._getDisplayDiv();
		$display.find('.n2DisplayRibbon2_popup').remove();
	},
	
	_populateCurrentPopUp: function(docId, $popup){
		var _this = this;
		
		var $layout = $('<div>')
			.addClass('n2DisplayRibbon2_popup_layout')
			.appendTo($popup);
		var $container = $('<div>')
			.addClass('n2DisplayRibbon2_popup_container')
			.appendTo($layout);
		
		var $content = $('<div>')
			.addClass('n2DisplayRibbon2_popup_content')
			.appendTo($container);

		if( this.showService ) {
			this.showService.printDocument($content, docId);
		} else {
			$content.text( docId );
		};

		var $buttons = $('<div>')
			.addClass('n2DisplayRibbon2_popup_buttons')
			.appendTo($container);
		
		$('<a>')
			.attr('href','#')
			.addClass('n2DisplayRibbon2_popup_button n2DisplayRibbon2_popup_button_close')
			.text( _loc('Close') )
			.click(function(){
				var $a = $(this);
				$a.parents('.n2DisplayRibbon2_popup').first().remove();
				return false;
			})
			.appendTo($buttons);
	},
	
	/*
	 * Goes over all the tiles and remove the class 'n2DisplayRibbon2_tile_current'
	 * to from tiles that should not have it. Also, it adds the class to the tile
	 * that should have it, if it exists.
	 * 
	 * When adding and removing the class, adjust the content accordingly.
	 */
	_adjustCurrentTile: function(docId){
		var _this = this;
		
		var $set = this._getDisplayDiv();
		var $docs = $set.find('.n2DisplayRibbon2_documents');
		
		var targetClass = null;
		if( docId ){
			targetClass = 'n2DisplayRibbon2_tile_' + $n2.utils.stringToHtmlId(docId);
		};
		
		// Remove
		$docs.find('.n2DisplayRibbon2_tile_current').each(function(){
			var $elem = $(this);
			if( targetClass && $elem.hasClass(targetClass) ) {
				// That's OK. Leave it
			} else {
				$elem.removeClass('n2DisplayRibbon2_tile_current');
				var id = $elem.attr('n2DocId');
				_this._generateRelatedDocumentContent($elem, id);
			};
		});
		
		// Add
		if( targetClass ) {
			$docs.find('.'+targetClass).each(function(){
				var $elem = $(this);
				if( $elem.hasClass('n2DisplayRibbon2_tile_current') ) {
					// That's OK. Leave it
				} else {
					$elem.addClass('n2DisplayRibbon2_tile_current');
					var id = $elem.attr('n2DocId');
					_this._generateCurrentDocumentContent($elem, id);
				};
			});
		};
	},
	
	_getDisplayDiv: function(){
		var divId = this.displayPanelName;
		return $('#'+divId);
	},
	
	_dispatch: function(m){
		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			dispatcher.send(DH,m);
		};
	},
	
	/*
	 * Get a boolean option based on a name and return it. Defaults
	 * to false. If the option is found set in either the options map
	 * or the custom service, then the result is true.
	 */
	_getBooleanOption: function(optionName){
		var flag = false;
		
		if( this.boolOptions[optionName] ){
			flag = true;
		};
		
		var cs = this.customService;
		if( cs && !flag ){
			var o = cs.getOption(optionName);
			if( o ){
				flag = true;
			};
		};
		
		return flag;
	},
	
	/*
	 * Look at documents stored in display code and return if one
	 * found with the correct identifier.
	 */
	_getCachedDocumentFromId: function(docId){
		if( this.displayedDocuments 
		 && this.displayedDocuments[docId]
		 && this.displayedDocuments[docId].doc ){
			return this.displayedDocuments[docId].doc;
		};
		
		if( this.currentDetails 
		 && this.currentDetails.docId === docId 
		 && this.currentDetails.doc ){
			return this.currentDetails.doc;
		};
		
		return null;
	},
	
	/*
	 * Given a document identifier, request the document content.
	 */
	_requestDocumentWithId: function(docId){
		// Look internally, first
		var doc = this._getCachedDocumentFromId(docId);
		if( doc ){
			this._receiveDocumentContent(doc);
			return;
		};
		
		if( this.requestService ){
			this.requestService.requestDocument(docId);
		};
	},
	
	_generateCurrentDocumentContent: function($elem, docId){
		$elem.empty();

		var $container = $('<div>')
	    	.addClass('n2DisplayRibbon2_tile_container')
	    	.appendTo($elem);
		
		$('<div>')
			.addClass('n2DisplayRibbon2_thumb n2DisplayRibbon2_wait_thumb_' + $n2.utils.stringToHtmlId(docId))
			.appendTo($container);
		
		$('<div>')
			.addClass('n2DisplayRibbon2_wait_brief_' + $n2.utils.stringToHtmlId(docId))
			.addClass('n2DisplayRibbon2_tile_brief')
			.text(docId)
			.appendTo($container);
	},
	
	_generateRelatedDocumentContent: function($elem, docId){
		var _this = this;
		
		$elem.empty();
	    
	    var $container = $('<div>')
	    	.addClass('n2DisplayRibbon2_tile_container')
	    	.appendTo($elem);
		
		$('<div>')
			.addClass('n2DisplayRibbon2_thumb n2DisplayRibbon2_wait_thumb_' + $n2.utils.stringToHtmlId(docId))
			.appendTo($container);
		
		$('<div>')
			.addClass('n2DisplayRibbon2_wait_brief_' + $n2.utils.stringToHtmlId(docId))
			.addClass('n2DisplayRibbon2_tile_brief')
			.text(docId)
			.appendTo($container);
	},
	
	_performIntervalTask: function(){
		var $set = this._getDisplayDiv();
		var $docs = $set.find('.n2DisplayRibbon2_documents');
	
//		if( this.currentDetails
//		 && this.currentDetails.docId ){
//			var $currentTile = $docs.find('.n2DisplayRibbon2_tile_current')
//				.find('.n2DisplayRibbon2_tile_content');
//			if( $currentTile.length > 0 ){
//				var height = $currentTile.height();
//				if( height != this.currentDetails.height ){
//					this.currentDetails.height = height;
//					var cellSize = this.grid.cellSize;
//					this.grid.template = null;
//					this.grid.templateFactory = new GridTemplateDocument(height,cellSize);
//					this.grid.redraw(true);
//				};
//			};
//		};
	},
	
	_documentFilterChanged: function(){
		this._updateDisplayedDocuments();
	}
});

//===================================================================================
function HandleDisplayAvailableRequest(m){
	if( m.displayType === 'ribbon2' ){
		m.isAvailable = true;
	};
};

function HandleDisplayRenderRequest(m){
	if( m.displayType === 'ribbon2' ){
		var options = {};
		if( m.displayOptions ){
			for(var key in m.displayOptions){
				options[key] = m.displayOptions[key];
			};
		};
		
		options.documentSource = m.config.documentSource;
		options.displayPanelName = m.displayId;
		options.showService = m.config.directory.showService;
		options.createDocProcess = m.config.directory.createDocProcess;
		options.requestService = m.config.directory.requestService;
		options.schemaRepository = m.config.directory.schemaRepository;
		options.customService = m.config.directory.customService;
		options.dispatchService = m.config.directory.dispatchService;
		
		var displayControl = new RibbonDisplay(options);

		m.onSuccess(displayControl);
	};
};

//===================================================================================

// Exports
$n2.displayRibbon2 = {
	RibbonDisplay: RibbonDisplay
	,HandleDisplayAvailableRequest: HandleDisplayAvailableRequest
	,HandleDisplayRenderRequest: HandleDisplayRenderRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.comment.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); },
DH = 'n2.comment';

//===================================================================================
/*
 * There should be one instance of this class, per Nunaliit configuration. This is
 * because this component registers events with the dispatcher.
 */

var CommentStreamDisplay = $n2.Class({
	
	commentService: null,
	
	dispatchService: null,
	
	documentSource: null,
	
	showService: null,
	
	createDocProcess: null,
	
	cachedCommentsByDocId: null,
	
	reinsertElementsId: null,
	
	initialize: function(opts_){
		
		var opts = $n2.extend({
			commentService: null
			,dispatchService: null
			,documentSource: null
			,showService: null
			,createDocProcess: null
		},opts_);
		
		var _this = this;
		
		this.commentService = opts.commentService;
		this.dispatchService = opts.dispatchService;
		this.documentSource = opts.documentSource;
		this.showService = opts.showService;
		this.createDocProcess = opts.createDocProcess;
		
		if( this.dispatchService ){
			var f = function(msg, addr, dispatcher){
				_this._handleDispatch(msg, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'documentContentCreated', f);
			this.dispatchService.register(DH, 'documentContentUpdated', f);
			this.dispatchService.register(DH, 'documentDeleted', f);
			this.dispatchService.register(DH, 'cacheRetrieveDocument', f);
		};
		
		// Create an area to keep elements that should be re-inserted in the
		// comment stream on a redraw.
		var $reinsertElements = $('<div>')
			.css({
				position: 'absolute'
				,display: 'none'
			})
			.addClass('n2comment_reinsert_cache')
			.appendTo( $('body') );
		this.reinsertElementsId = $n2.utils.getElementIdentifier($reinsertElements);
	},
	
	display: function(opts_){
		var opts = $n2.extend({
			divId: null
			,div: null
			,doc: null
		},opts_);
		
		var _this = this;
		
		var doc = opts.doc;
		var docId = doc._id;
		var showService = this.showService;
		
		var buttonDisplay = new $n2.couchDisplay.ButtonDisplay();
		
		var $elem = opts.div;
		if( ! $elem ) {
			$elem = $('#'+opts.divId);
		};
		if( ! $elem.length) {
			return;
		};
		if( !showService ) {
			$n2.log('Show service not available for comment process');
			return;
		};
		
		$elem.empty();
		
		// Insert comment stream
		$('<div>')
			.addClass('n2Comment_stream n2Comment_stream_'+$n2.utils.stringToHtmlId(docId))
			.appendTo($elem);
		this._refreshStream({
			docId: docId
		});

		// Insert 'Add Comment' section
		var $addSection = $('<div>')
			.addClass('n2Comment_add_section')
			.appendTo($elem);
		this._resetAddSection(doc, $addSection);
	},
	
	_refreshStream: function(opts_){
		var opts = $n2.extend({
			docId: null
		},opts_);
		
		var _this = this;

		var originId = opts.docId;
		var buttonDisplay = new $n2.couchDisplay.ButtonDisplay();
		
		// Get references
		this.documentSource.getReferencesFromOrigin({
			docId: originId
			,onSuccess: loadedDocIds
		});
		
		function loadedDocIds(refDocIds){
			// Get documents that include comments
			_this.documentSource.getDocuments({
				docIds: refDocIds
				,onSuccess: loadedDocs
			});
		};
		
		function loadedDocs(docs){
			// Cache documents to save show service from reloading them
			_this.cachedCommentsByDocId = {};
			docs.forEach(function(doc){
				var docId = doc._id;
				_this.cachedCommentsByDocId[docId] = doc;
			});
			
			// Sort comments by last updated time
			docs.sort(function(a,b){
				var aTime = undefined;
				if( a && a.nunaliit_created ){
					aTime = a.nunaliit_created.time;
				};
				if( a && a.nunaliit_last_updated ){
					aTime = a.nunaliit_last_updated.time;
				};

				var bTime = undefined;
				if( b && b.nunaliit_created ){
					bTime = b.nunaliit_created.time;
				};
				if( b && b.nunaliit_last_updated ){
					bTime = b.nunaliit_last_updated.time;
				};
				
				if( typeof aTime === 'number' 
				 && typeof bTime === 'number' ){
					return bTime - aTime;
				};
				if( aTime ) return -1;
				if( bTime ) return 1;
				
				if( a._id > b._id ) {
					return 1;
				}
				return -1;
			});
			
			// Create comment stream tree
			var leavesByDocId = {};
			var tree = {};
			docs.forEach(function(doc){
				var docId = doc._id;
				var leaf = {
					docId: docId
					,doc: doc
					,replies: {}
					,inReplyToId: undefined
				};
				leavesByDocId[docId] = leaf;
			});
			for(var docId in leavesByDocId){
				var leaf = leavesByDocId[docId];
				var doc = leaf.doc;
				var topLevelLeaf = true;
				if( doc 
				 && doc.nunaliit_source 
				 && typeof doc.nunaliit_source.doc === 'string' ){
					var inReplyToId = doc.nunaliit_source.doc;
					var replyToLeaf = leavesByDocId[inReplyToId];
					if( replyToLeaf ){
						leaf.inReplyToId = inReplyToId;
						replyToLeaf.replies[docId] = leaf;
						topLevelLeaf = false;
					};
				};
				
				if( topLevelLeaf ){
					tree[docId] = leaf;
				};
			};
			
			// Retrieve display element cache
			var $reinsertElementsCache = $('#'+_this.reinsertElementsId);

			// Display comments
			var $stream = $('.n2Comment_stream_'+$n2.utils.stringToHtmlId(originId));
			if( $stream.length > 0 ){
				// Save elements that require surviving of redraw
				var $reinsertElements = $stream.find('.n2Comment_reinsert');
				$reinsertElements.appendTo($reinsertElementsCache);
				
				$stream.empty();
				var commentIndex = 0;
				docs.forEach(function(doc){
					var docId = doc._id;
					var $commentDiv = $('<div>')
						.addClass('n2Comment_doc n2Comment_doc_'+$n2.utils.stringToHtmlId(docId))
						.attr('n2DocId',docId)
						.appendTo($stream);
					var $content = $('<div>')
						.addClass('n2Comment_content nunaliit_list_mod2_'+(commentIndex%2))
						.appendTo($commentDiv);
					_this.showService.printDocument($content, docId);

					var $buttons = $('<div>')
						.addClass('n2Comment_buttons')
						.appendTo($commentDiv);
					
					buttonDisplay.drawButton({
						elem: $buttons
						,name: 'reply'
						,label: _loc('Reply')
						,click: function(){
							var $outer = $(this).parents('.n2Comment_doc');
							var docId = $outer.attr('n2DocId');
							_this._addReply(docId,$outer);
						}
					});

					buttonDisplay.drawButton({
						elem: $buttons
						,name: 'more_details'
						,label: _loc('More Details')
						,click: function(){
							var docId = $(this).parents('.n2Comment_doc').attr('n2DocId');
							_this._changeFocus(docId);
						}
					});
					
					// Re-insert the elements, if present
					$reinsertElementsCache
						.find('.n2Comment_reinsert_'+$n2.utils.stringToHtmlId(docId))
						.appendTo($commentDiv);
					
					++commentIndex;
				});
			};

			// No need for cached elements, anymore
			$reinsertElementsCache.empty();
		};
	},
	
	_resetAddSection: function(doc, $addSection){
		var _this = this;

		var buttonDisplay = new $n2.couchDisplay.ButtonDisplay();

		$addSection.empty();
		buttonDisplay.drawButton({
			elem: $addSection
			,name: 'add_comment'
			,label: _loc('Add Comment')
			,click: function(){
				var $addSection = $(this).parents('.n2Comment_add_section');
				$addSection.empty();
				_this._addComment(doc,$addSection);
			}
		});

	},

	_addComment: function(doc, $elem){
		var _this = this;

		var createRelatedDocProcess = this.createDocProcess;
		var commentSchema = this.commentService.getCommentSchema();

		var $outerDiv = $('<div>')
			.appendTo($elem);
		
		createRelatedDocProcess.replyToDocument({
			doc: doc
			,schema: commentSchema
			,originDocId: doc._id
			,elem: $outerDiv
			,onSuccess: function(docId){
				_this._resetAddSection(doc, $elem);
			}
			,onError: function(err){
				_this._resetAddSection(doc, $elem);
			}
			,onCancel: function(){
				_this._resetAddSection(doc, $elem);
			}
		});
	},
	
	_addReply: function(docId, $outerDiv){
		var _this = this;
		var documentSource = this.documentSource;
		var createRelatedDocProcess = this.createDocProcess;
		var commentSchema = this.commentService.getCommentSchema();
		
		var $elem = undefined;
		if( $outerDiv.length > 0 ){
			$elem = $('<div>')
				.addClass('n2Comment_reply n2Comment_reinsert n2Comment_reinsert_'+$n2.utils.stringToHtmlId(docId))
				.appendTo($outerDiv);
		};
		
		documentSource.getDocument({
			docId: docId
			,onSuccess: function(doc){
				createRelatedDocProcess.replyToDocument({
					doc: doc
					,schema: commentSchema
					,elem: $elem
				});
			}
		});
	},
	
	_changeFocus: function(docId){
		var _this = this;

		this.dispatchService.send(DH,{
			type: 'userSelect'
			,docId: docId
		});
	},
	
	_handleDispatch: function(m, address, dispatcher){
		if( 'documentContentCreated' === m.type ){
			var doc = m.doc;
			this._handleDocumentContent(doc);

		} else if( 'documentContentUpdated' === m.type ){
			var doc = m.doc;
			this._handleDocumentContent(doc);

		} else if( 'documentDeleted' === m.type ){
			var docId = m.docId;
			this._handleDocumentDeleted(docId);

		} else if( 'cacheRetrieveDocument' === m.type ){
			// Synchronous call
			var docId = m.docId;
			if( this.cachedCommentsByDocId ){
				var doc = this.cachedCommentsByDocId[docId];
				
				if( doc ){
					m.doc = doc;
				};
			};
		};
	},
	
	_handleDocumentContent: function(doc){
		// Update cache
		if( this.cachedCommentsByDocId 
		 && this.cachedCommentsByDocId[doc._id]){
			this.cachedCommentsByDocId[doc._id] = doc;
		};
		
		if( doc.nunaliit_origin 
		 && typeof doc.nunaliit_origin.doc === 'string' ){
			var originId = doc.nunaliit_origin.doc;
			var $stream = $('.n2Comment_stream_'+$n2.utils.stringToHtmlId(originId));
			if( $stream.length > 0 ){
				// OK, need to refresh this stream
				this._refreshStream({
					docId: originId
				});
			};
		} else {
			// This document does not have an origin. Should no longer be part of a
			// comment stream
			var $commentDoc = $('.n2Comment_doc_'+$n2.utils.stringToHtmlId(doc._id));
			$commentDoc.remove();
		};
	},
	
	_handleDocumentDeleted: function(docId){
		// Remove associated streams
		var $section = $( '.n2Comment_stream_'+$n2.utils.stringToHtmlId(docId) );
		$section.remove();
		
		// Remove associated sections
		var $section = $( '.n2Comment_doc_'+$n2.utils.stringToHtmlId(docId) );
		$section.remove();
	}
});

//===================================================================================
var CommentService = $n2.Class({

	documentSource: null,

	showService: null,

	createDocProcess: null,
	
	dispatchService: null,
	
	customService: null,
	
	commentSchema: null,
	
	commentStreamDisplay: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: null
			,showService: null
			,createDocProcess: null
			,dispatchService: null
			,customService: null
			,commentSchema: null
		},opts_);
		
		this.documentSource = opts.documentSource;
		this.showService = opts.showService;
		this.createDocProcess = opts.createDocProcess;
		this.dispatchService = opts.dispatchService;
		this.customService = opts.customService;
		this.commentSchema = opts.commentSchema;
	},

	getCommentSchema: function(){
		return this.commentSchema;
	},

	setCommentSchema: function(commentSchema){
		this.commentSchema = commentSchema;
		
		if( this.commentSchema ){
			$('.n2Comment_button_addcomment')
				.removeClass('n2Comment_button_addcomment_unavailable')
				.addClass('n2Comment_button_addcomment_available');
		} else {
			$('.n2Comment_button_addcomment')
				.removeClass('n2Comment_button_addcomment_available')
				.addClass('n2Comment_button_addcomment_unavailable');
		};
	},

	/**
	 * Use this function to add a button to an element. The button
	 * initiates adding a comment associated with the given document.
	 */
	insertAddCommentButton: function(opts_){
		var opts = $n2.extend({
			div: null
			,doc: null
			,buttonDisplay: null
		},opts_);
		
		var _this = this;

		var doc = opts.doc;
		var $buttons = $(opts.div);
		
		var buttonDisplay = opts.buttonDisplay;
		if( !buttonDisplay ){
			buttonDisplay = new $n2.couchDisplay.ButtonDisplay();
		};
		
		var classNames = ['n2Comment_button_addcomment'];
		if( this.commentSchema ){
			classNames.push('n2Comment_button_addcomment_available');
		} else {
			classNames.push('n2Comment_button_addcomment_unavailable');
		};

		// Show 'add comment' button
		buttonDisplay.drawButton({
			elem: $buttons
			,name: 'add_comment'
			,label: _loc('Add Comment')
			,classNames: classNames
			,click: function(){
				_this._addComment(doc);
			}
		});
	},
	
	_addComment: function(doc){
		var createRelatedDocProcess = this.createDocProcess;
		createRelatedDocProcess.replyToDocument({
			doc: doc
			,schema: this.commentSchema
			,originDocId: doc._id
		});
	},
	
	getCommentStreamDisplay: function(){
		if( !this.commentStreamDisplay ){
			this.commentStreamDisplay = new CommentStreamDisplay({
				commentService: this
				,dispatchService: this.dispatchService
				,documentSource: this.documentSource
				,showService: this.showService
				,createDocProcess: this.createDocProcess
			});
		};
		
		return this.commentStreamDisplay;
	}
});


//===================================================================================

// Exports
$n2.comment = {
	Service: CommentService
	,CommentStreamDisplay: CommentStreamDisplay
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.zoomify.js

/*******************************************************************************************
 * zoomify
 * Written by Craig Francis
 * Absolutely minimal version of GSIV to work with touch screens and very slow processors.
********************************************************************************************/

(function($,$n2) {
"use strict";

//--------------------------------------------------
var ZoomImage = $n2.Class({

	img_ref: null,
	
	div_ref: null,

	div_half_width: null,

	div_half_height: null,

	zoom_control_refs: null,

	zoom_levels: null,

	zoom_level_count: null,

	img_current_left: null,

	img_current_top: null,

	zoom_level: null,

	img_orig_width: null,

	img_orig_height: null,
	
	img_zoom_width: null,
	
	img_zoom_height: null,
	
	click_last: null,

	img_start_left: null,

	img_start_top: null,

	origin: null,
		
	initialize: function(opts_) {
		var opts = $n2.extend({
			imageElem: null
			,wrapperElem: null
		},opts_);
		
		var _this = this;

		this.img_current_left = null;
		this.zoom_control_refs = {};
		this.zoom_levels = [];
		this.zoom_level_count = 0;
		this.zoom_level = 0;
		this.click_last = 0;
		this.img_start_left = null;
		this.img_start_top = null;
		this.origin = null;

		this.img_ref = $(opts.imageElem)
			.addClass('n2_zoomify_image');

		if(this.img_ref.length > 0) {
			if( opts.wrapperElem ){
				this.div_ref = $(opts.wrapperElem);
			} else {
				this.div_ref = $('<div>')
					.insertBefore( this.img_ref );
				this.img_ref.appendTo(this.div_ref);
			};
			this.div_ref.addClass('n2_zoomify_image_wrapper');

			//--------------------------------------------------
			// Wrapper size

			var div_border;
			try {
				var div_style = getComputedStyle(this.div_ref[0], '');
				div_border = div_style.getPropertyValue('border-top-width');
				this.div_half_width = div_style.getPropertyValue('width');
				this.div_half_height = div_style.getPropertyValue('height');
			} catch(e) {
				div_border = this.div_ref.css('border-top-width');
				this.div_half_width = this.div_ref.css('width');
				this.div_half_height = this.div_ref.css('height');
			}

			this.div_half_width = Math.round(parseInt(this.div_half_width, 10) / 2);
			this.div_half_height = Math.round(parseInt(this.div_half_height, 10) / 2);

			//--------------------------------------------------
			// Original size

			this.img_orig_width = this.img_ref.width();
			this.img_orig_height = this.img_ref.height();

			//--------------------------------------------------
			// Add zoom controls

			var buttons = [{'t' : 'in', 's' : 'on'}, {'t' : 'in', 's' : 'off'}, {'t' : 'out', 's' : 'on'}, {'t' : 'out', 's' : 'off'}];

			for(var k = 0, len = buttons.length; k < len; ++k) {

				var button = buttons[k];
				var name = button.t + '-' + button.s;

				this.zoom_control_refs[name] = $('<div>')
					.addClass('n2_zoomify_control n2_zoomify_' + button.t + ' n2_zoomify_' + button.s);

				if (button.t === 'in') {
					if (button.s === 'on') {
						this.zoom_control_refs[name]
							.mousedown(function(){
								return _this.image_zoom_in();
							});
					};
				} else {
					if (button.s === 'on') {
						this.zoom_control_refs[name]
							.mousedown(function(){
								return _this.image_zoom_out();
							});
					};
				};

				if (button.s === 'on') {
					this.zoom_control_refs[name].css({cursor:'pointer'});
				};

				this.zoom_control_refs[name].appendTo(this.div_ref);
			};

			//--------------------------------------------------
			// Zoom levels

			//--------------------------------------------------
			// Defaults

			var div_width = (this.div_half_width * 2);
			var div_height = (this.div_half_height * 2);

			var width = this.img_orig_width;
			var height = this.img_orig_height;

			this.zoom_levels[this.zoom_levels.length] = width;

			while (width > div_width || height > div_height) {
				width = (width * 0.75);
				height = (height * 0.75);
				this.zoom_levels[this.zoom_levels.length] = Math.round(width);
			}

			this.zoom_levels.reverse(); 

			//--------------------------------------------------
			// Mobile phone, over zoom

			//if (parseInt(div_border, 10) === 5) { // img width on webkit will return width before CSS is applied
				this.zoom_levels[this.zoom_levels.length] = Math.round(this.img_orig_width * 1.75);
				this.zoom_levels[this.zoom_levels.length] = Math.round(this.img_orig_width * 3);
			//};

			//--------------------------------------------------
			// Set default

			this.zoom_level_count = (this.zoom_levels.length - 1);

			this.image_zoom(0);

			//--------------------------------------------------
			// Make visible

			this.img_ref.css({visibility:'visible'});
			
			this.div_ref.addClass('js-active');

			//--------------------------------------------------
			// Add events

			this.img_ref
				.mousedown(function(){
					return _this.image_move_start();
				})
				.bind('touchstart', function(){
					return _this.image_move_start();
				});

			this.div_ref.bind('DOMMouseScroll',function(e){
				return _this.scroll_event(e);
			});
			this.div_ref.bind('mousewheel',function(e){
				return _this.scroll_event(e);
			});

			document.onkeyup = function(e) {
				var keyCode = (e ? e.which : window.event.keyCode);

				if (keyCode === 37 || keyCode === 39) { // left or right

					_this.img_current_left = (_this.img_current_left + (keyCode === 39 ? 50 : -50));

					_this.image_move_update();

				} else if (keyCode === 38 || keyCode === 40) { // up or down

					_this.img_current_top = (_this.img_current_top + (keyCode === 40 ? 50 : -50));

					_this.image_move_update();

				} else if (keyCode === 107 || keyCode === 187 || keyCode === 61) { // + or = (http://www.javascripter.net/faq/keycodes.htm)

					_this.image_zoom_in();

				} else if (keyCode === 109 || keyCode === 189) { // - or _

					_this.image_zoom_out();

				};
			};
		};
		
		$n2.log('ZoomImage',this);
	},

	//--------------------------------------------------
	// Zooming

	image_zoom: function(change) {
		var _this = this;
		
		//--------------------------------------------------
		// Zoom level

		var new_zoom = (this.zoom_level + change);

		if( new_zoom >= this.zoom_level_count ) {
			if( new_zoom > this.zoom_level_count ) {
				this.div_ref.css({opacity:0.5});
				setTimeout(function() {
					_this.div_ref.css({opacity:1});
				}, 150);
				return;
			};
			this.zoom_control_refs['in-on'].css({display:'none'});
			this.zoom_control_refs['in-off'].css({display:'block'});
		} else {
			this.zoom_control_refs['in-on'].css({display:'block'});
			this.zoom_control_refs['in-off'].css({display:'none'});
		};

		if( new_zoom <= 0 ) {
			if( new_zoom < 0 ) {
				this.div_ref.css({opacity:0.5});
				setTimeout(function() {
					_this.div_ref.css({opacity:1});
				}, 150);
				return;
			};
			this.zoom_control_refs['out-on'].css({display:'none'});
			this.zoom_control_refs['out-off'].css({display:'block'});
		} else {
			this.zoom_control_refs['out-on'].css({display:'block'});
			this.zoom_control_refs['out-off'].css({display:'none'});
		};

		this.zoom_level = new_zoom;

		//--------------------------------------------------
		// New width

		var new_zoom_width = this.zoom_levels[new_zoom];
		var new_zoom_height = (this.zoom_levels[new_zoom] * (this.img_orig_height / this.img_orig_width));

		this.img_ref.width(new_zoom_width);
		this.img_ref.height(new_zoom_height);

		//--------------------------------------------------
		// Update position

		if (this.img_current_left === null) { // Position in the middle on page load

			this.img_current_left = (this.div_half_width - (new_zoom_width  / 2));
			this.img_current_top  = (this.div_half_height - (new_zoom_height / 2));

		} else {

			var ratio = (new_zoom_width / this.img_zoom_width);

			this.img_current_left = (this.div_half_width - ((this.div_half_width - this.img_current_left) * ratio));
			this.img_current_top  = (this.div_half_height - ((this.div_half_height - this.img_current_top)  * ratio));

		}

		this.img_zoom_width = new_zoom_width;
		this.img_zoom_height = new_zoom_height;

		this.img_ref.css({
			'left': this.img_current_left + 'px'
			,'top': this.img_current_top + 'px'
		});

	},

	image_zoom_in: function() {
		this.image_zoom(1);
	},

	image_zoom_out: function() {
		this.image_zoom(-1);
	},

	scroll_event: function(e) {

		//--------------------------------------------------
		// Event

		e = e || window.event;

		var wheelData = (e.detail ? e.detail * -1 : e.wheelDelta / 40);

		this.image_zoom(wheelData > 0 ? 1 : -1);

		//--------------------------------------------------
		// Prevent default

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		};

		return false;
	},

	//--------------------------------------------------
	// Movement

	event_coords: function(e) {
		var coords = [];
		if( e.touches && e.touches.length ) {
			coords[0] = e.touches[0].clientX;
			coords[1] = e.touches[0].clientY;
		} else {
			coords[0] = e.clientX;
			coords[1] = e.clientY;
		};
		return coords;
	},

	image_move_update: function() {

		//--------------------------------------------------
		// Boundary check

		var max_left = (this.div_half_width - this.img_zoom_width),
			max_top = (this.div_half_height - this.img_zoom_height);

		if (this.img_current_left > this.div_half_width)  { this.img_current_left = this.div_half_width; };
		if (this.img_current_top  > this.div_half_height) { this.img_current_top  = this.div_half_height; };
		if (this.img_current_left < max_left)        { this.img_current_left = max_left; };
		if (this.img_current_top  < max_top)         { this.img_current_top  = max_top;  };

		//--------------------------------------------------
		// Move

		this.img_ref.css({
			left:this.img_current_left + 'px'
			,top:this.img_current_top + 'px'
		});

	},

	image_move_event: function(e) {

		//--------------------------------------------------
		// Calculations

		e = e || window.event;

		var currentPos = this.event_coords(e);

		this.img_current_left = (this.img_start_left + (currentPos[0] - this.origin[0]));
		this.img_current_top = (this.img_start_top + (currentPos[1] - this.origin[1]));

		this.image_move_update();

		//--------------------------------------------------
		// Prevent default

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}

		return false;
	},

	image_move_start: function(e) {

		//--------------------------------------------------
		// Event

		e = e || window.event;

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false; // IE: http://stackoverflow.com/questions/1000597/
		};

		//--------------------------------------------------
		// Double tap/click event

		var now = new Date().getTime();
		if( this.click_last > (now - 200) ) {
			this.image_zoom_in();
		} else {
			this.click_last = now;
		};

		//--------------------------------------------------
		// Add events

		// http://www.quirksmode.org/blog/archives/2010/02/the_touch_actio.html
		// http://www.quirksmode.org/m/tests/drag.html

//		if (e.type === 'touchstart') {
//
//			this.img_ref.onmousedown = null;
//			this.img_ref.ontouchmove = image_move_event;
//			this.img_ref.ontouchend = function() {
//				this.img_ref.ontouchmove = null;
//				this.img_ref.ontouchend = null;
//			};
//
//		} else {
//
//			document.onmousemove = image_move_event;
//			document.onmouseup = function() {
//				document.onmousemove = null;
//				document.onmouseup = null;
//			};
//
//		};

		//--------------------------------------------------
		// Record starting position

		this.img_start_left = this.img_current_left;
		this.img_start_top = this.img_current_top;

		this.origin = this.event_coords(e);
	}
});

//----------------------------------------------------------
function zoomImage(opts_){
	return new ZoomImage(opts_);
};

//----------------------------------------------------------
$n2.zoomify = {
	zoomImage: zoomImage
};
		
}(jQuery,nunaliit2));

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.html.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.html'
 ;
 
//--------------------------------------------------------------------------
// List of HTML attributes that are valid for all elements
var globalAttributeMap = {
	'accesskey': true
	,'class': true
	,'contenteditable': true
	,'contextmenu': true
	,'dir': true
	,'draggable': true
	,'dropzone': true
	,'hidden': true
	,'id': true
	,'itemid': true
	,'itemprop': true
	,'itemref': true
	,'itemscope': true
	,'itemtype': true
	,'lang': true
	,'spellcheck': true
	,'style': true
	,'tabindex': true
	,'title': true
	,'translate': true
};

//--------------------------------------------------------------------------
function isAttributeNameValid(attrName){
	var attrName = attrName.toLowerCase();
	
	if( globalAttributeMap[attrName] ){
		return true;
	};
	
	// Accessibility attribute
	if( 'aria-' === attrName.substr(0, 'aria-'.length) ){
		return true;
	};
	
	// DOM attributes
	if( 'data-' === attrName.substr(0, 'data-'.length) ){
		return true;
	};
	
	return false;
};

//--------------------------------------------------------------------------
$n2.html = {
	isAttributeNameValid: isAttributeNameValid
	,globalAttributeMap: globalAttributeMap
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.wiki.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($n2){
"use strict";

//var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

//*******************************************************
var regBlank = /^\s*$/;
function isBlankLine(line){
	if( '' === line ) return true;
	if( regBlank.test(line) ){
		return true;
	};
	return false;
};

//*******************************************************
var regBlock = /^[=-]/;
function isBlockLine(line){
	if( isBlankLine(line) ) return true;
	
	if( regBlock.test(line) ){
		return true;
	};
	return false;
};

//*******************************************************
function getCharAt(line, index){
	var c = undefined;
	if( line.length > index ){
		c = line[index];
	};
	return c;
};

//*******************************************************
function escapeCharacters(text){
	
	text = text.replace(/[&><\r]/g,function(m){
		if( '&' === m ) return '&amp;';
		if( '>' === m ) return '&gt;';
		if( '<' === m ) return '&lt;';
		if( '\r' === m ) return '';
		return m;
	});
	
	return text;
};

//*******************************************************
function escapeOptions(text){
	
	text = text.replace(/[><]/g,function(m){
		if( '>' === m ) return '&gt;';
		if( '<' === m ) return '&lt;';
		return m;
	});
	
	return text;
};

//*******************************************************
// Remove comments
var gStartComment = "<!--";
var gEndComment = "-->";
function removeComments(lines){
	function stripCommentFromLine(info){
		if( info.commentOpen ){
			if( info.line.indexOf(gEndComment) >= 0 ){
				var index = info.line.indexOf(gEndComment);
				var after = within.substr(index+gEndComment.length);
				
				info.line = after;
				info.commentOpen = false;
			} else {
				info.skipLine = true;
				return;
			};
		};
		
		if( info.line.indexOf(gStartComment) >= 0 ){
			var index = info.line.indexOf(gStartComment);
			var before = info.line.substr(0,index);
			var within = info.line.substr(index+gStartComment.length);
			
			info.commentOpen = true;
			info.commentFound = true;
			info.line = before;
			
			if( within.indexOf(gEndComment) >= 0 ){
				var index = within.indexOf(gEndComment);
				var after = within.substr(index+gEndComment.length);
				
				info.line = before + after;
				info.commentOpen = false;
				
				stripCommentFromLine(info);
			};
		};
	};
	
	var newLines = [];
	var info = {
		commentOpen: false
		,commentFound: false
		,skipLine: false
	};
	
	for(var i=0,e=lines.length; i<e; ++i){
		var line = lines[i];

		info.line = line;
		info.skipLine = false;
		info.commentFound = false;
		
		stripCommentFromLine(info);

		if( info.skipLine ){
			// skip line
		} else if( info.commentFound ){
			if( $n2.trim(info.line) !== '' ){
				newLines.push( info.line );
			};
			
		} else {
			newLines.push( info.line );
		};
	};
	
	return newLines;
};

//*******************************************************
// Look at consecutive lines and merge them into one if
// a line is a continuation of another
function mergeLines(lines){
	function isInstructionLine(line){
		if( isBlockLine(line) ) return true;
		if( '*' === line[0] ) return true;
		if( '#' === line[0] ) return true;
		if( '{' === line[0] ) return true;
		if( '}' === line[0] ) return true;
		if( '|' === line[0] ) return true;
		if( '!' === line[0] ) return true;
			
		return false;
	};
	
	var newLines = [];
	
	var previousLine = null;
	
	for(var i=0,e=lines.length; i<e; ++i){
		var line = lines[i];
	
		if( null === previousLine ){
			if( isInstructionLine(line) ){
				// This line contains an instruction and should not be continued

			} else {
				previousLine = line;
			};

			// Simply add this one
			newLines.push(line);
			
			
		} else {
			if( ! isInstructionLine(line) ){
				// Should continue previous line
				previousLine = previousLine + ' ' + line;
				newLines[newLines.length-1] = previousLine;
				
			} else {
				
				previousLine = null;

				newLines.push(line);
			};
		};
	};
	
	return newLines;
};

//*******************************************************
function processLists(lines){
	
	function outputListLines(lines, offset, newLines){
		var firstChar = getCharAt(lines[0],offset);
		
		if( '*' === firstChar ){
			newLines.push('<ul class="n2wiki">');
		} else {
			newLines.push('<ol class="n2wiki">');
		};

		var isOpened = false;
		
		for(var i=0,e=lines.length; i<e; ++i){
			var line = lines[i];

			var c2 = getCharAt(line, offset+1);
			
			if( '*' === c2 || '#' === c2 ){
				if( !isOpened ){
					newLines.push('<li class="n2wiki">');
				};

				var listLines = [];
				while( i<e ){
					line = lines[i];
					var c3 = getCharAt(line, offset+1);
					if( c3 !== c2 ){
						break;
					} else {
						listLines.push(line);
						++i;
					};
				};
				
				if( i<e ){
					--i;
				};
				
				outputListLines(listLines, offset+1, newLines);
				newLines.push('</li>');
				isOpened = false;
				
			} else {
				if( isOpened ){
					newLines.push('</li><li class="n2wiki">');
				} else {
					newLines.push('<li class="n2wiki">');
				};
				newLines.push( line.substr(offset+1) );
				isOpened = true;
			};
		};

		if( isOpened ){
			newLines.push('</li>');
		};

		if( '*' === firstChar ){
			newLines.push('</ul>');
		} else {
			newLines.push('</ol>');
		};
	};
	
	var newLines = [];
	
	for(var i=0,e=lines.length; i<e; ++i){
		var line = lines[i];
		
		var firstChar = getCharAt(line,0);

		if( '*' === firstChar 
		 || '#' === firstChar ){
			
			var listLines = [];
			
			while( i<e ){
				line = lines[i];

				var c1 = getCharAt(line, 0);
				
				if( c1 !== firstChar ){
					break;
				} else {
					listLines.push( line );
					++i;
				};
			};
			
			if( i<e ){
				--i;
			};
			
			outputListLines(listLines, 0, newLines);

		} else {
			newLines.push(line);
		};
	};
	
	return newLines;
};

//*******************************************************
var reTableStart = /^\{\|(.*)$/;
var reTableEnd = /^\|\}(.*)$/;
var reTableCaption = /^\|\+(.*)$/;
var reTableCell = /^(?:\||!)(.*)$/;
var reTableRow = /^\|-(.*)$/;
function processTables(lines){
	function startTable(tableOptions, caption, newLines){
		if( caption ){
			newLines.push('<div class="n2wiki n2wiki_tableCaption">');
			newLines.push(caption);
			newLines.push('</div>');
		};
		
		var tableLine = '<table class="n2wiki"';
		
		if( tableOptions ){
			tableLine += ' ';
			tableLine += tableOptions;
		};
		
		tableLine += '>';

		newLines.push(tableLine);
		newLines.push('<tr>');
	};

	function outputTableLines(lines, newLines){
		var tableStarted = false;
		var tableOptions = undefined;
		var caption = undefined;
		for(var i=0,e=lines.length; i<e; ++i){
			var line = lines[i];
			
			var mTableStart = reTableStart.exec(line);
			var mTableEnd = reTableEnd.exec(line);
			var mTableCaption = reTableCaption.exec(line);
			var mTableCell = reTableCell.exec(line);
			var mTableRow = reTableRow.exec(line);

			// Start table
			if( mTableStart ){
				var options = escapeOptions( mTableStart[1] );
				options = $n2.trim(options);
				if( options.length > 0 ){
					tableOptions = options;
				};
				
			} else if( mTableEnd ){
				// End table
				if( !tableStarted ) {
					startTable(tableOptions, caption, newLines);
					tableStarted = true;
				};
				newLines.push('</tr></table>');
			
			} else if( mTableCaption ){
				// Table Caption
				var cap = escapeCharacters( mTableCaption[1] );
				cap = $n2.trim(cap);
				if( cap.length > 0 ){
					caption = cap;
				};
				
			} else if( mTableRow ){
				// Table Row
				if( !tableStarted ) {
					startTable(tableOptions, caption, newLines);
					tableStarted = true;
				};
				
				var rowOptions = mTableRow[1];
				rowOptions = escapeOptions(rowOptions);
				rowOptions = $n2.trim(rowOptions);
				
				newLines.push('</tr>');
				
				var trLine = '<tr';
					
				if( rowOptions.length > 0 ){
					trLine += ' ';
					trLine += rowOptions;
				};

				trLine += '>';
				
				newLines.push(trLine);
				
			} else if( mTableCell ){
				// Table Cell
				if( !tableStarted ) {
					startTable(tableOptions, caption, newLines);
					tableStarted = true;
				};
				
				var isHeading = false;
				if( line[0] === '!' ){
					isHeading = true;
				};
				var cells = mTableCell[1].split('||');
				for(var j=0,k=cells.length; j<k; ++j){
					var cell = cells[j];
					var cellSplits = cell.split('|');
					var cellOptions = undefined;
					var cellContent = undefined;
					if( cellSplits.length > 1 ){
						cellOptions = cellSplits[0];
						cellContent = cellSplits[1];
					} else {
						cellContent = cellSplits[0];
					};
					
					var tdLine = '<td';
					if( isHeading ){
						tdLine = '<th';
					};
					
					if( cellOptions ){
						tdLine += ' ';
						tdLine += escapeOptions(cellOptions);
					};

					tdLine += '>';
					newLines.push( tdLine );

					newLines.push( escapeCharacters(cellContent) );

					if( isHeading ){
						newLines.push('</th>');
					} else {
						newLines.push('</td>');
					};
				};
			};
		};
	};

	var newLines = [];
	
	for(var i=0,e=lines.length; i<e; ++i){
		var line = lines[i];

		if( '{|' === line.substr(0,2) ){
			// Start of table
			
			var tableLines = [];
			
			while( i<e ){
				line = lines[i];

				if( '|}' === line.substr(0,2) ){
					// End of table
					tableLines.push( line );
					break;
				} else {
					tableLines.push( line );
					++i;
				};
			};
			
			outputTableLines(tableLines, newLines);

		} else {
			newLines.push(line);
		};
	};
	
	return newLines;
};

//*******************************************************
var reSectionOption = /^\s*([-_a-zA-Z][-_a-zA-Z0-9]*)\s*=\s*"(.*)"\s*$/;
function processSections(lines){

	var sections = [];
	var pendingSections = [];
	
	for(var i=0,e=lines.length; i<e; ++i){
		var line = lines[i];

		if( '{{' === line.substr(0,2) ){
			// Start of Section
			
			var section = {
				start: i
			};
			pendingSections.push(section);

		} else if( '}}' === line.substr(0,2) ){
			// End of Section
			if( pendingSections.length > 0 ){
				var section = pendingSections.pop();
				section.end = i;
				sections.push(section);
			};
		};
	};
	
	for(var i=0,e=sections.length; i<e; ++i){
		var section = sections[i];
		var startLine = lines[section.start];
		var replacementLine = getReplacementLine(startLine);
		
		if( replacementLine ){
			lines[section.start] = replacementLine;
			lines[section.end] = '</div>';
		};
	};
	
	return lines;
	
	function getReplacementLine(line){
		var line = line.substr(2);
		var options = line.split('|');
		var attributeMap = {};
		
		for(var i=0,e=options.length; i<e; ++i){
			var option = options[i];
			var matcher = reSectionOption.exec(option);
			if( matcher ){
				var name = matcher[1];
				var value = matcher[2];
				
				attributeMap[name] = value;
				
			} else {
				$n2.log('Invalid wiki section attribute: '+option);
			};
		};
		
		var html = [];
		
		html.push('<div');

		for(var name in attributeMap){
			var validAttribute = false;
			// Black list all scripts
			if( 'on' === name.substr(0,'on'.length) ){
				// Do not output "on" attributes
			} else if( 'nunaliit-' === name.substr(0,'nunaliit-'.length) ){
				// Allow nunaliit specific attributes
				validAttribute = true;
			} else if( $n2.html.isAttributeNameValid(name) ){
				validAttribute = true;
			};
			
			if( validAttribute ){
				var value = attributeMap[name];
				html.push(' ');
				html.push(name);
				html.push('="');
				html.push(value);
				html.push('"');
			};
		};

		html.push('>');
		
		return html.join('');
	};
};

//*******************************************************
var regexAttribute = /^\s*([-_a-zA-Z][-_a-zA-Z0-9]*)\s*=\s*"(.*)"\s*$/;
function insertShowService(links){
	var classNames = [];
	classNames.push( links.shift() );

	// Parse attributes
	var attributeValuesByName = {};
	for(var i=0,e=links.length; i<e; ++i){
		var link = links[i];
		var matcher = regexAttribute.exec(link);
		if( matcher ){
			var name = matcher[1];
			var value = matcher[2];
			
			if( 'class' === name ){
				classNames.push(value);
			} else {
				attributeValuesByName[name] = value;
			};
			
		} else {
			$n2.log('Invalid wiki nunaliit attribute: '+link);
		};
	};

	// Generate HTML
	var html = [];
	
	html.push('<div class="');

	for(var i=0,e=classNames.length; i<e; ++i){
		var className = classNames[i];
		if( i > 0 ){
			html.push(' ');
		};
		html.push(className);
	};
	html.push('"');
	
	for(var name in attributeValuesByName){
		var validAttribute = false;
		// Black list all scripts
		if( 'on' === name.substr(0,'on'.length) ){
			// Do not output "on" attributes
		} else if( 'nunaliit-' === name.substr(0,'nunaliit-'.length) ){
			// Allow nunaliit specific attributes
			validAttribute = true;
		} else if( $n2.html.isAttributeNameValid(name) ){
			validAttribute = true;
		};
		
		if( validAttribute ){
			var value = attributeValuesByName[name];
			html.push(' ');
			html.push(name);
			html.push('="');
			html.push(value);
			html.push('"');
		};
	};

	html.push('/>');
	
	return html.join('');
};

//*******************************************************
function computeLink(linkText){
	var links = linkText.split('|');
	
	var externalLink = false;
	var docLink = false;
	var url = links[0];
	var docId = undefined;
	if( 'http://' === url.substr(0,'http://'.length)
	 || 'https://' === url.substr(0,'https://'.length) 
	 || 'mailto:' === url.substr(0,'mailto:'.length)){
		externalLink = true;

	} else if( 'nunaliit:' === url.substr(0,'nunaliit:'.length) ){
		links[0] = url.substr('nunaliit:'.length);
		return insertShowService(links);

	} else {
		docLink = true;
		docId = url;
		url = '#';
	};

	var displayProvided = false;
	var display = url;
	if( links.length > 1 ){
		display = links[1];
		displayProvided = true;
	};
	display = escapeCharacters(display);
	
	var html = [];
	html.push('<a class="n2wiki');
	if( docLink ){
		html.push(' n2s_userEvents n2s_createDocOnClick');
		if( !displayProvided ){
			html.push(' n2s_briefDisplay');
		};
	};
	html.push('" href="');
	html.push(url);
	html.push('"');
	if( docLink ){
		html.push(' nunaliit-document="'+docId+'"');
	};
	html.push('>');
	html.push(display);
	html.push('</a>');
	
	return html.join('');
};

//*******************************************************
// Transform wiki markup to HTML
// Comments:
//    <!-- -->
//
// Special characters are escaped:
//    & -> &amp;
//    < -> &lt;
//    > -> &gt;
//
// Unordered list:
// * line
// * line
// ** line
// ** line
// * line
//
// Ordered list:
// # line
// # line
// ## line
// ## line
// # line
//
// Tables:
// {|                   Start table
// |+                   Table caption
// |-                   New row
// !                    Heading cell
// |                    Cell
// | options | content  Cell with options
// | cell1 || cell2     Multiple cells on one line
// |}                   End table
//
// Headings:
// = Heading1 =
// == Heading2 ==
// === Heading3 ===
// ==== Heading4 ====
// ===== Heading5 =====
// ====== Heading6 ======
// 
// Horizontal lines:
// ----
//
// Links:
// [[http://abc.com | description]]   		External link
// [[https://abc.com | description]]  		External link
// [[mailto:name@abc.com | description]]	External link
// [[docId | description]]            		Internal link
// [[nunaliit:class | option]]        		Show service insert
//
// Styling:
// ''italics''
// '''bold'''
//
// Sections:
// {{ attr1="value1" | attr2="value2"
// ...
// }}
function WikiToHtml(opts_){
	var opts = $n2.extend({
		wiki: null
	},opts_);
	
	var text = opts.wiki;
	if( typeof text !== 'string' ){
		throw new Error('Wiki text must be specified for WikiToHtml()');
	};

	var lines = text.split('\n');

	lines = removeComments(lines);
	
	// Character escaping
	for(var i=0,e=lines.length; i<e; ++i){
		var line = lines[i];
		lines[i] = escapeCharacters(line);
	};
	
	lines = mergeLines(lines);
	lines = processLists(lines);
	lines = processTables(lines);
	lines = processSections(lines);

	for(var i=0,e=lines.length; i<e; ++i){
		var line = lines[i];
		
		// Headings
		line = line.replace(/(?:^)([=]+)(.*)\1/g, function (m, l, t) {
	        return '<h' + l.length + ' class="n2wiki">' + t + '</h' + l.length + '>';
	    });
		
		// Horizontal Line
		line = line.replace(/(?:^|\n)([-]+)\s*/g, function (m, l) {
		    var minDashQuantity = 4;
		    if (l.length >= minDashQuantity) {
		        return '<hr class="n2wiki"/>';			
		    } else {
			return l;
		    };
	    });

		// Links
		line = line.replace(/\x5b\x5b([^\x5d]*)\x5d\x5d/g, function (m,l) {
	        return computeLink(l);
	    });

		// Bold
		line = line.replace(/'''([^']+)'''/g, function (m,t) {
	        return '<b>'+t+'</b>';
	    });

		// Italics
		line = line.replace(/''([^']+)''/g, function (m,t) {
	        return '<i>'+t+'</i>';
	    });
		
		if( isBlankLine(line) ){
			line = '<br/>';
		};
		
		
		lines[i] = line;
	};

	return lines.join('');
};

//*******************************************************
$n2.wiki = {
	WikiToHtml: WikiToHtml
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.tuioclient.js

;(function($,$n2){
	"use strict";

	var DH = 'n2.tuio';

	var MAX_SPRING_K = 160.0;
	var SPRING_LEN = 0.0000000000001;

	var usePhysics = true;

	// Time in ms to fade spring influence in or out
	var springFadeTime = 400.0;

	// Socket to tuioserver.js that emits TUIO events in JSON
	var socket = undefined;

	// Keep track if connection occurred
	var tuioConnected = false;

	// Keeps track if a service has been defined
	var g_tuioService = undefined;

	// Configuration
	var tuioConfiguration = undefined;

	// Number of escape keys pressed in the last while
	var escapeKeyCount = 0;

	// Speed factor for drag scrolling
	var scrollSpeed = 1.0;

	// Time in ms to wait until abandoning a draw and starting pinch/pan
	var moveDelay = 200.0;

	// Time in ms a cursor must be gone to be considered up
	var clickDelay = 1000;

	// Maximum cursor travel distance (in TUIO coordinates) for a click/press
	var clickDistance = 0.1;

	// Distance in pixels below which to consider two drawn points the same
	var pointDistance = 16.0;

	// Time in ms a cursor must be down and still for a long press
	var pressDelay = 1250;

	// Maximum distance to consider cursors to be on the same hand
	var handSpan = 0.25;

	// Next hand instance ID counter
	var nextHandIndex = 1;

	// True if currently drawing a zoom region
	var drawZooming = false;

	// Key for hand currently acting as the mouse, if any
	var mouseHand = undefined;

	// Key for cursor currently doing an exclusive long press, if any
	var pressCursor = undefined;

	// Number of cursors currently down
	var downCursors = 0;

	// Visual finger and hand feedback
	var showDots = false;
	var dotSize = 16.0;

	// Last scroll hand coordinates
	var scrollX = undefined;
	var scrollY = undefined;

	// Calibration
	var calibration = null;
	var calibrationDirty = false;

	// Pinch zoom parameters
	var lastPinchZoomDistance = undefined;
	var pinchZoomThreshold = 0.18;

	// Draw overlay canvas
	var overlay = undefined;

	// Time to wait until a finger draw is considered finished, in ms
	var drawDelay = 800.0;

	// Whether or not the pane is currently being rotated
	var paneRotating = false;

	// Visible rotation of the pane at the start of a rotation drag
	var paneRotateStartAngle = 0.0;
	var paneRotateAngle = 0.0;

	// Angle of initial mouse down point of a rotation drag
	var paneRotateMouseStartAngle = 0.0;

	// Maximum distance to consider points to be touching (pixels)
	var polyDistance = 30.0;

	var moduleDisplay = undefined;

	//==================================================================
	function IsTuioConnected() {
		return tuioConnected;
	};

	//==================================================================
	function IsTableModeOn() {
		var isTableModeOn = $('body').hasClass('nunaliit_tuio');
		return isTableModeOn;
	};

	//==================================================================
	function Vector(x, y) {
		this.x = x;
		this.y = y;
	}

	Vector.prototype.add = function(v) {
		return new Vector(this.x + v.x, this.y + v.y);
	}

	Vector.prototype.subtract = function(v) {
		return new Vector(this.x - v.x, this.y - v.y);
	}

	Vector.prototype.scale = function(s) {
		return new Vector(this.x * s, this.y * s);
	}

	Vector.prototype.magnitude = function(v) {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}

	Vector.prototype.distance = function(v) {
		var dx = this.x - v.x;
		var dy = this.y - v.y;

		return Math.sqrt((dx * dx) + (dy * dy));
	}

	//==================================================================

	/** Return the absolute distance between two points. */
	function distance(x1, y1, x2, y2) {
		return Math.abs(Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)));
	}

	/** Return the distance travelled along a line string.
	 *
	 * Returned distance is in the same unit used in the x and y fields of the
	 * input points (typicallly pixels).
	 */
	function lineStringDistance(points) {
		if (points.length < 2) {
			return 0.0;
		}

		var d = 0.0;
		for (var i = 0; i < points.length - 1; ++i) {
			var p = points[i];
			var q = points[i + 1];
			d += distance(p.x, p.y, q.x, q.y);
		}
		return d;
	}

	/** Return the area of a polygon specified by a set of points. */
	function area(points) {
		var area = 0;
		var j = points.length - 1;

		for (var i = 0; i < points.length; j = i++) {
			var pi = points[i];
			var pj = points[j];
			area += (pj.x + pi.x) * (pj.y - pi.y)
		}

		return area / 2;
	};

	/** Return the center of a set of points. */
	function centerPoint(points) {
		if (points.length == 1) {
			// Center of a single point is that point
			return points[0];
		} else if (points.length == 2) {
			// Center of a line is the midpoint of that line
			return new Vector((points[0].x + points[1].x) / 2,
			                  (points[0].y + points[1].y) / 2);
		}

		var minX = Infinity;
		var minY = Infinity;
		var maxX = 0;
		var maxY = 0;
		for (var i = 0; i < points.length; ++i) {
			minX = Math.min(minX, points[i].x);
			minY = Math.min(minY, points[i].y);
			maxX = Math.max(maxX, points[i].x);
			maxY = Math.max(maxY, points[i].y);
		}

		return new Vector(minX + (maxX - minX) / 2,
		                  minY + (maxY - minY) / 2);
	};

	/** Return the intersection between the line segments p0->p1 and p2->p3, or null.
	 *
	 * Based on algorithm from "Tricks of the Windows Game Programming Gurus" by Andre LeMothe
	 */
	function lineIntersection(p0, p1, p2, p3) {
		var s1 = p1.subtract(p0);
		var s2 = p3.subtract(p2);

		var s = (-s1.y * (p0.x - p2.x) + s1.x * (p0.y - p2.y)) / (-s2.x * s1.y + s1.x * s2.y);
		var t = ( s2.x * (p0.y - p2.y) - s2.y * (p0.x - p2.x)) / (-s2.x * s1.y + s1.x * s2.y);

		if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0) {
			return new Vector(p0.x + (t * s1.x), p0.y + (t * s1.y));
		}

		return null;
	}

	/** Return a simplified polygon based on the given line string, or null.
	 *
	 * The returned polygon is the given points up until the point where two
	 * segments intersect.  The intersecting segments are not included in the
	 * returned list of points, so the returned list does not intersect itself.
	 */
	function simplifyPolygon(points) {
		if (points.length < 4) {
			return null;
		}

		var slices = [];
		var bestSlice = null;
		var addPoint = null;
		function updateBestSlice(begin, end, intersection) {
			if (!bestSlice) {
				// First slice, so it's the best slice so far
				bestSlice = [begin, end];
				addPoint = intersection;
			} else {
				// Check if this slice overlaps a known intersecting slice
				var overlaps = false;
				for (var i = 0; i < slices.length; ++i) {
					if (begin <= slices[i][1] && slices[i][0] <= end) {
						overlaps = true;
						break;
					}
				}

				if (!overlaps && (end - begin) > bestSlice[1] - bestSlice[0]) {
					/* Does not contain a subslice with an intersection, and
					   contains more points than the best slice, so this is our
					   new best slice.  Using actual distance rather than
					   number of points may make more sense here, but this
					   seems to work well and is much less expensive. */
					bestSlice = [begin, end];
					addPoint = intersection;
				}
			}

			// Add to slices list for overlap checking next time around
			slices.push([begin, end]);
		}

		for (var i = 0; i < points.length - 3; ++i) {
			var p0 = points[i];
			var p1 = points[i + 1];

			var foundIntersection = false;
			for (var j = i + 2; j < points.length - 1 && !foundIntersection; ++j) {
				var p2 = points[j];
				var p3 = points[j + 1];

				// Check for an actual line intersection
				var intersection = lineIntersection(p0, p1, p2, p3);
				if (intersection) {
					updateBestSlice(i, j, intersection);
					foundIntersection = true;
				} else if (j > i + 4) {
					// Check if endpoints are close enough to be considered intersecting
					if (distance(p0.x, p0.y, p2.x, p2.y) <= polyDistance) {
						updateBestSlice(i, j, null);
						foundIntersection = true;
					} else if (distance(p1.x, p1.y, p2.x, p2.y) <= polyDistance) {
						updateBestSlice(i + 1, j, null);
						foundIntersection = true;
					} else if (distance(p0.x, p0.y, p3.x, p3.y) <= polyDistance) {
						updateBestSlice(i, j + 1, null);
						foundIntersection = true;
					} else if (distance(p1.x, p1.y, p3.x, p3.y) <= polyDistance) {
						updateBestSlice(i + 1, j + 1, null);
						foundIntersection = true;
					}
				}
			}

			if (foundIntersection) {
				// Found an intersection, so no point in checking overlapping intervals
				i = j;
				foundIntersection = false;
			}
		}

		if (bestSlice) {
			var poly = points.slice(bestSlice[0], bestSlice[1]);
			if (addPoint) {
				poly.push(addPoint);
			}
			return poly;
		}

		return null;
	}

	/** Return the force exerted by a spring between vectors p1 and p2. */
	function springForce(p1, p2, length, k) {
		var vec = p2.subtract(p1);
		var mag = vec.magnitude();
		var displacement = length - mag;

		if (mag < length) {
			return new Vector(0, 0);
		} else {
			return vec.scale(k * displacement * 0.5 / mag);
		}
	}

	//==================================================================
	/** A 2-D point with velocity, used for fingers (cursors) and hands. */
	function Body(x, y) {
		Vector.call(this, x, y);

		this.targetPos = new Vector(x, y);
		this.vel = new Vector(0, 0);
		this.div = undefined;
		this.dirty = false;
		this.alive = true;
		this.birthTime = Date.now();
		this.deathTime = undefined;
		this.distanceMoved = 0.0;
		this.lastTime = null;
	}

	Body.prototype = Object.create(Vector.prototype);

	Body.prototype.kill = function() {
		this.alive = false;
		this.deathTime = Date.now();
	}

	/** Set the target coordinate for the body to move towards. */
	Body.prototype.moveTo = function(x, y) {
		if (!isNaN(this.x) && !isNaN(this.y)) {
			this.distanceMoved += distance(this.x, this.y, x, y);
		}

		if (x != this.targetPos.x || y != this.targetPos.y) {
			this.targetPos = new Vector(x, y);
			if (isNaN(this.x) || isNaN(this.y)) {
				this.x = this.targetPos.x;
				this.y = this.targetPos.y;
			}
			this.dirty = true;
		}

		if (!usePhysics) {
			this.x = this.targetPos.x;
			this.y = this.targetPos.y;
		}

		return this.dirty;
	}

	/** Update position, moving towards the target if necessary. */
	Body.prototype.updatePosition = function(timestamp, energy) {
		if (!usePhysics) {
			this.x = this.targetPos.x;
			this.y = this.targetPos.y;
			return true;
		} else if (!this.lastTime) {
			// Initial call, but we need a time delta, wait for next tick
			this.lastTime = timestamp;
			return true;
		} else if (!this.dirty ||
				   (this.x == this.targetPos.x &&
					this.y == this.targetPos.y)) {
			// Nothing to do
			this.dirty = false;
			this.lastTime = timestamp;
			return false;
		}

		// Time since start in ms
		var elapsed = timestamp - this.lastTime;
		var dur = elapsed / 200;  // Arbitrary scale for in-universe time
		this.lastTime = timestamp;

		// Damp old velocity to avoid oscillation
		this.vel = this.vel.scale(0.1);

		// Calculate amount to move based on spring force
		var force = springForce(this.targetPos, this, SPRING_LEN, MAX_SPRING_K);
		var velocity = this.vel.add(force.scale(dur)).scale(energy);
		var dPos = velocity.scale(dur);

		// Calculate new position
		var newPos = this.add(dPos);
		this.x = newPos.x;
		this.y = newPos.y;
		this.vel = velocity;

		var snap = dPos.magnitude() < 0.0001;
		if (snap) {
			// New position is very close, snap to target
			this.x = this.targetPos.x;
			this.y = this.targetPos.y;
			this.vel = new Vector(0, 0);
		}

		// Clamp to valid coordinate space
		this.x = Math.min(Math.max(0.0, this.x), 1.0);
		this.y = Math.min(Math.max(0.0, this.y), 1.0);

		return true;
	}

	//==================================================================
	/** Construct a new cursor (finger). */
	function Cursor() {
		Body.call(this, Number.NaN, Number.NaN);

		this.down = false;
		this.downX = Number.NaN;
		this.downY = Number.NaN;
		this.index = Number.NaN;
		this.lastSeen = Date.now();
		this.hand = undefined;
		this.show = function() {
			if (!showDots) {
				return;
			} else if (this.div == undefined) {
				this.div = createDot(this.x, this.y, this.index);
			}

			this.div.style.left = ((this.x * window.innerWidth) - 10) + "px";
			this.div.style.top = ((this.y * window.innerHeight) - 10) + "px";
		}
	}

	Cursor.prototype = Object.create(Body.prototype);
	Cursor.prototype.constructor = Cursor;

	Cursor.prototype.kill = function() {
		Body.prototype.kill.call(this);
		if (this.hand != undefined && this.hand.numAliveCursors() == 0) {
			this.hand.kill();
		}
	}

	//==================================================================
	/** Construct a new tangible (block). */
	function Tangible() {
		this.id = new Number();
		this.x = new Number();
		this.y = new Number();
		this.angle = new Number();
		this.div = undefined;
	}

	//==================================================================
	/** Construct a new hand (grouping of cursors). */
	function Hand(x, y) {
		Body.call(this, x, y);

		this.cursors = [];
		this.index = nextHandIndex++;
		this.downX = x;
		this.downY = y;
	}

	Hand.prototype = Object.create(Body.prototype);
	Hand.prototype.constructor = Hand;

	/** Update the target position based on cursor positions. */
	Hand.prototype.updateTargetPosition = function() {
		if (this.cursors.length > 0) {
			var center = centerPoint(this.cursors);
			this.moveTo(center.x, center.y);
		}
	}

	Hand.prototype.updatePosition = function(timestamp, energy) {
		if (this.cursors.length < 1) {
			return;
		}

		if (!usePhysics) {
			var center = centerPoint(this.cursors);
			this.moveTo(center.x, center.y);
			return true;
		} else if (!this.lastTime) {
			// Initial call, but we need a time delta, wait for next tick
			this.lastTime = timestamp;
			return true;
		} else if (!this.dirty) {
			// Nothing to do
			this.dirty = false;
			this.lastTime = timestamp;
			return false;
		}

		// Time since start in ms
		var dur = (timestamp - this.lastTime) / 500;
		this.lastTime = timestamp;

		// Damp old velocity to avoid oscillation
		this.vel = this.vel.scale(0.1);

		var force = new Vector(0, 0);
		for (var c = 0; c < this.cursors.length; ++c) {
			var cursor = this.cursors[c];
			var spring_k = 0.0;
			if (cursor.alive) {
				var age = Date.now() - cursor.birthTime;
				spring_k = Math.min((age / springFadeTime) * MAX_SPRING_K, MAX_SPRING_K);
			} else {
				var rot = Date.now() - cursor.deathTime;
				spring_k = Math.min(((springFadeTime - rot) / springFadeTime) * MAX_SPRING_K, MAX_SPRING_K);
			}

			// Calculate and add force due to this cursor's spring
			var f = springForce(cursor, this, SPRING_LEN, spring_k);
			force = force.add(f);
		}

		var velocity = this.vel.add(force.scale(dur)).scale(energy);
		var dPos = velocity.scale(dur);

		// Calculate new position
		var newPos = this.add(dPos);
		this.x = newPos.x;
		this.y = newPos.y;
		this.vel = velocity;

		return true;
	}

	Hand.prototype.numAliveCursors = function() {
		var n = 0;
		for (var c = 0; c < this.cursors.length; ++c) {
			if (this.cursors[c].alive) {
				++n;
			}
		}
		return n;
	}

	Hand.prototype.removeCursor = function(cursor) {
		// Remove cursor from its associated hand's list
		for (var f = 0; f < this.cursors.length; ++f) {
			if (this.cursors[f] == cursor) {
				this.cursors.splice(f, 1);
				break;
			}
		}

		if (this.cursors.length == 0) {
			// Last finger removed from hand, delete hand
			onHandUp(this.index);
		} else {
			// Update position for hand feedback
			this.updateTargetPosition();
			this.show();
		}
	}

	/** Display a circle representing this hand for feedback. */
	Hand.prototype.show = function() {
		if (!showDots) {
			return;
		} else if (this.div == undefined) {
			this.div = createDot(this.x, this.y, "H" + this.index);
		}

		this.div.style.left = ((this.x * window.innerWidth) - 10) + "px";
		this.div.style.top = ((this.y * window.innerHeight) - 10) + "px";
		this.div.style.borderColor = "red";
	}

	/** Return the maximum distance a hand currently spans. */
	Hand.prototype.span = function() {
		var maxDistance = 0;
		for (var i = 0; i < this.cursors.length; ++i) {
			for (var j = 0; j < this.cursors.length; ++j) {
				if (i != j) {
					maxDistance = Math.max(
						maxDistance,
						distance(this.cursors[i].x, this.cursors[i].y,
						         this.cursors[j].x, this.cursors[j].y));
				}
			}
		}

		return maxDistance;
	}

	/** Remove any cursors that can not be a part of this hand.
	 *
	 * A list of the removed cursors is returned.  This is used to correct
	 * situations where the original cursor:hand association proves to be
	 * incorrect after some cursor movement.
	 */
	Hand.prototype.trimCursors = function() {
		var orphans = [];

		while (this.span() > handSpan) {
			// Find the point furthest from the center
			var maxDistance = 0;
			var furthest = undefined;
			for (var i = 0; i < this.cursors.length; ++i) {
				var cursor = this.cursors[i];
				var d = distance(cursor.x, cursor.y, this.x, this.y);
				if (d > maxDistance) {
					maxDistance = d;
					furthest = i;
				}
			}

			// Remove it
			if (furthest != undefined) {
				orphans.push(this.cursors[furthest]);
				this.removeCursor(this.cursors[furthest]);
			}
		}

		return orphans;
	}

	//==================================================================
	// Collections of currently alive things
	var cursors = new Object();
	var tangibles = new Object();
	var hands = new Object();

	/** Get the topmost DOM element at a TUIO position. */
	function getElementAtTablePoint(x, y) {
		if (isNaN(x) || isNaN(y)) {
			return null;
		}

		// Convert table coordinates to browser coordinates
		var winX = x * window.innerWidth;
		var winY = y * window.innerHeight;

		// Return the topmost DOM element at this position
		return document.elementFromPoint(winX, winY);
	}

	/** Dispatch a mouse event as a result of a cursor change.
	 * eventType: mousedown, mousemove, mouseup, or click
	 * x, y: 0..1 normalized TUIO cordinates
	 */
	function dispatchMouseEvent(eventType, x, y) {
		if (isNaN(x) || isNaN(y)) {
			return;
		}

		// Convert table coordinates to browser coordinates
		var winX = x * window.innerWidth;
		var winY = y * window.innerHeight;

		dispatchMouseEventWin(eventType, winX, winY);
	}

	/** Like dispatchMouseEvent but with window-relative coordinates. */
	function dispatchMouseEventWin(eventType, winX, winY)
	{
		// Get the topmost DOM element at this position
		var el = document.elementFromPoint(winX, winY);
		if (el == null) {
			return;
		}

		dispatchMouseEventTo(eventType, el, winX, winY);
	}

	/** Dispatch a mouse event to a specific DOM element. */
	function dispatchMouseEventTo(eventType, el, winX, winY)
	{
		// Create synthetic mouse event of the given type
		var event = new MouseEvent(eventType, {
			'view': window,
			'bubbles': true,
			'cancelable': true,
			'clientX': winX,
			'clientY': winY,
			'button': 0
		});

		// console.log("Dispatch " + eventType + " @ " + winX + "," + winY +
		// 			" => " + el + " #" + el.id + " ." + el.className);

		// Dispatch to element
		el.dispatchEvent(event);
	}

	function removeObject(dict, inst) {
		// Object is long dead and no longer influential, remove

		if (dict[inst].div != undefined) {
			// Remove calibration div
			document.body.removeChild(dict[inst].div);
		}

		if (dict[inst].hand != undefined) {
			dict[inst].hand.removeCursor(dict[inst]);
		}

		// Remove cursor from dictionary
		delete dict[inst];
	}

	/** Update the list of things that are alive.
	 * dict: Dictionary of cursors or tangibles.
	 * alive: Updated alive array.
	 */
	function updateAlive(dict, alive) {
		var aliveMap = {};
		for(var i=0,e=alive.length; i<e; ++i) {
			var id = alive[i];
			aliveMap[id] = true;
		};

		// Remove any dead objects
		for (var inst in dict) {
			if (!dict.hasOwnProperty(inst)) {
				continue; // Ignore prototypes
			}

			if (dict[inst].alive) {
				// Check if this instance is still alive
				if( !aliveMap[inst] ) {
					// No longer alive, flag as dead and schedule removal
					if (typeof dict[inst].kill === 'function') {
						dict[inst].kill();
					}

					// Issue cursor up immediately for responsive clicking
					if (dict == cursors) {
						onCursorUp(inst);
					}

					// Schedule full removal for when spring no longer has influence
					window.setTimeout(removeObject, springFadeTime, dict, inst);
				}
			}
		}

		// Add newly alive objects
		for (var i = alive.length - 1; i >= 0; i--) {
			if (!dict.hasOwnProperty(alive[i])) {
				var a = alive[i];
				if (dict == cursors) {
					/* This is a mousedown, but we do not have a position here.
					   Instead mousedown is dispatched on the initial position
					   update after a cursor becomes alive. */
					dict[a] = new Cursor();
					dict[a].index = a;
				} else if (dict == tangibles) {
					dict[a] = new Tangible();
				}
			}
		}
	}

	function numAliveHands() {
		var count = 0;
		for (var inst in hands) {
			if (hands.hasOwnProperty(inst) && hands[inst].alive) {
				++count;
			}
		}
		return count;
	}

	/** Update the visible calibration point for a cursor. */
	function createDot(x, y, content) {
		var div = document.createElement("div");
		div.className = "n2tuio_feedback_circle n2tuio_remove";
		div.style.width = dotSize + "px";
		div.style.height = dotSize + "px";
		div.style.left = ((x * window.innerWidth) - (dotSize / 2)) + "px";
		div.style.top = ((y * window.innerHeight) - (dotSize / 2)) + "px";
		div.innerHTML = content;
		document.body.appendChild(div);

		return div;
	}

	function createRing() {
		var $div = $('<div>')
			.addClass('n2tuio_edit_ring n2tuio_remove')
			.appendTo( $('#content') );
	}

	function displayError() {
		$('.n2tuio_edit_ring').css({
			'background-color': 'red'
		});
		window.setTimeout(function() {
			$('.n2tuio_edit_ring').css({
				'background-color': 'transparent'
			});
		}, 500);
	}

	/** Find the closest non-full hand to the given point. */
	function bestHand(x, y) {
		var bestDistance = Infinity;
		var hand = null;

		for (var h in hands) {
			if (hands.hasOwnProperty(h)) {
				var center = centerPoint(hands[h].cursors);
				var d = distance(x, y, center.x, center.y);
				if (d <= handSpan &&
					hands[h].numAliveCursors() < 5 &&
					d <= bestDistance) {
					hand = hands[h];
					bestDistance = d;
				}
			}
		}

		return hand;
	}

	/** Return true if the current cursor/hand association seems reasonable. */
	function handsAreSane(x, y) {
		// Check that individual hands are not too large
		for (var h in hands) {
			if (handSpan(hands[h]) > handSpan) {
				return false;
			}
		}

		// Check that distinct hands are not too close together
		var minDistance = Infinity;
		for (var i = 0; i < hand.cursors.length; ++i) {
			for (var j = 0; j < hand.cursors.length; ++j) {
				if (i != j) {
					maxDistance = Math.max(
						maxDistance,
						distance(hand.cursors[i].x, hand.cursors[i].y,
						         hand.cursors[j].x, hand.cursors[j].y));
				}
			}
		}

		return maxDistance;
	}

	/** Called on the initial position update after a cursor is down. */
	function onCursorDown(inst) {
		var cursor = cursors[inst];
		if (downCursors == 0 && pressCursor == undefined) {
			// First cursor down, start potential long press
			pressCursor = inst;
			if( overlay ){
				overlay.show();
			};
			drawZooming = true;
			dispatchMouseEvent('mousedown', cursor.x, cursor.y);
		}

		++downCursors;
	}

	/** Called when a down cursor is moved. */
	function onCursorMove(inst) {
		var cursor = cursors[inst];

		if (pressCursor == undefined && drawZooming) {
			// Had a press cursor, but this showed up before it went away,
			// so take over drawing duties
			if (overlay) {
				overlay.show();
			}
			dispatchMouseEvent('mousedown', cursor.x, cursor.y);
			pressCursor = inst;
		}

		if (inst == pressCursor) {
			if (drawZooming) {
				dispatchMouseEvent('mousemove', cursor.x, cursor.y);
			}

			var elapsed = Date.now() - cursor.birthTime;
			if (cursor.distanceMoved <= clickDistance && elapsed > pressDelay) {
				console.log("Long press!");
				// Hide overlay so it does not intercept mouse events
				if (overlay) {
					overlay.abortStroke();
				}

				// Dispatch click to select map element, if applicable
				dispatchMouseEvent('click', cursor.x, cursor.y);

				// Toggle information pane
				togglePane();

				pressCursor = undefined;
				drawZooming = false;
			}
		} else if (drawZooming && downCursors > 1 && Date.now() - cursor.birthTime > moveDelay) {
			// Multiple cursors have been down for a while, abort draw zoom
			if (overlay) {
				overlay.abortStroke();
			}
			pressCursor = undefined;
			drawZooming = false;
		}
	}

	/** Called when a cursor is released. */
	function onCursorUp(inst) {
		var cursor = cursors[inst];
		if (inst == pressCursor) {
			// Get the element (underneath the overlay) at the cursor position
			var wasSensitive = overlay.setSensitive(false);
			var el = getElementAtTablePoint(cursor.x, cursor.y);
			overlay.setSensitive(wasSensitive);

			// Check if this down/up sequence was fast enough to be a click
			var elapsed = Date.now() - cursor.birthTime;
			var isClick = cursor.distanceMoved <= clickDistance && elapsed < clickDelay;
			if (el && isClick &&
				((el.nodeName.toLowerCase() == "input" || el.nodeName.toLowerCase() == "textarea") &&
				 el.getAttribute("type") != "button")) {
				$(el).focus();  // Focus non-button input element before mouseup
			}

			dispatchMouseEvent('mouseup', cursor.x, cursor.y);

			if (el && isClick) {
				var winX = cursor.x * window.innerWidth;
				var winY = cursor.y * window.innerHeight;
				if (el.id.startsWith("OpenLayers")) {
					hidePane();
				}

				/* Re-sending the mousedown and mouseup events here immediately
				   before the click seems to be necessary to make OpenLayers
				   buttons work. */
				dispatchMouseEventTo('mousedown', el, winX, winY);
				dispatchMouseEventTo('mouseup', el, winX, winY);
				dispatchMouseEventTo('click', el, winX, winY);
			}
			pressCursor = undefined;
		}

		--downCursors;
	}

	/** Called on the initial position update after a hand is down. */
	function onHandDown(inst) {
		var hand = hands[inst];

		if (mouseHand == undefined) {
			/* No hand is down yet, start a mouse motion for map dragging. */
			// dispatchMouseEvent('mousedown', hand.x, hand.y);
			mouseHand = inst;
		} else {
			if (drawZooming) {
				// Multiple hands down, terminate draw zoom immediately
				pressCursor = undefined;
				if (overlay) {
					overlay.abortStroke();
				}
				drawZooming = false;
			}

			/* A hand was acting as the mouse cursor for map dragging, but now we
			   have several hands.  Stop drag since this no longer makes sense. */
			var oldMouseHand = hands[mouseHand];
			// dispatchMouseEvent('mouseup', oldMouseHand.x, oldMouseHand.y);
			mouseHand = undefined;
			scrollX = undefined;
			scrollY = undefined;
		}
	}

	/** Called when a down hand is moved. */
	function onHandMove(inst) {
		var hand = hands[inst];
		var nHands = numAliveHands();

		if (drawZooming) {
			return;
		} else if (mouseHand == undefined) {
			/* Mouse hand is no longer around, if this is the only remaining hand,
			   take over scrolling. */
			if (nHands == 1) {
				mouseHand = inst;
			}
		}

		if (nHands == 1 && inst == mouseHand && hand.cursors.length > 1) {
			// Hand is acting as mouse cursor, dispatch mouse move
			// dispatchMouseEvent('mousemove', hand.x, hand.y);

			if (scrollX == undefined && scrollY == undefined) {
				/* Initial scroll, jump hand position immediately to center.  This
				   avoids a jumpy scroll because the hand is still moving towards
				   the center points of the fingers, but we don't need this
				   smoothing until after scrolling starts. */
				hand.moveTo(centerPoint(hand.cursors));
				hand.x = hand.targetPos.x;
				hand.y = hand.targetPos.y;
			} else if (typeof(moduleDisplay) !== 'undefined') {
				// Scroll OpenLayers manually
				var dx = (scrollX - hand.x);
				var dy = (scrollY - hand.y);
				moduleDisplay.mapControl.map.pan(dx * window.innerWidth * scrollSpeed,
				                                 dy * window.innerHeight * scrollSpeed,
				                                 { animate: false, dragging: true });
			}
			scrollX = hand.x;
			scrollY = hand.y;
		} else {
			// Get the hands involved in the zoom gesture
			var zoomHands = [];
			for (var inst in hands) {
				if (hands.hasOwnProperty(inst) && hands[inst].alive) {
					zoomHands.push(hands[inst]);
				}
			}

			if (zoomHands.length < 2) {
				lastPinchZoomDistance = undefined;
				return;  // Not enough alive hands for pinch zooming
			}

			// Find the greatest distance between any two hands
			var d = 0.0;
			for (var i = 0; i < zoomHands.length - 1; ++i) {
				var dist = distance(zoomHands[i].x, zoomHands[i].y,
				                    zoomHands[i + 1].x, zoomHands[i + 1].y);
				if (dist > handSpan * 0.5 && dist > d) {
					d = dist;
				}
			}

			if (lastPinchZoomDistance != undefined) {
				var delta = lastPinchZoomDistance - d;
				var currentZoom = moduleDisplay.mapControl.map.getZoom();
				var nZoomLevels = moduleDisplay.mapControl.map.getNumZoomLevels();
				if (delta > pinchZoomThreshold) {
					if (currentZoom > 2) {
						moduleDisplay.mapControl.map.zoomOut();
					} else {
						displayError();
					}
					lastPinchZoomDistance = d;
				} else if (delta < -pinchZoomThreshold) {
					if (currentZoom < nZoomLevels - 1) {
						moduleDisplay.mapControl.map.zoomIn();
					} else {
						displayError();
					}
					lastPinchZoomDistance = d;
				}
			} else {
				lastPinchZoomDistance = d;
			}
		}
	}

	/** Called when a hand is released. */
	function onHandUp(inst) {
		var hand = hands[inst];

		if (hand.div != undefined) {
			// Remove calibration div
			document.body.removeChild(hand.div);
		}

		if (inst == mouseHand) {
			// Hand is acting as mouse cursor, dispatch mouse up
			// dispatchMouseEvent('mouseup', hand.x, hand.y);
			mouseHand = undefined;
			scrollX = undefined;
			scrollY = undefined;
		}

		lastPinchZoomDistance = undefined;

		delete hands[inst];
	}

	function onPathDraw(bounds, points) {
		// In edit mode, draw a new feature
		if( g_tuioService && g_tuioService.isEditing() ){
			var geometryCapture = new GeometryCapture({
				tuioService: g_tuioService
			});
			for(var i=0,e=points.length; i<e; ++i){
				geometryCapture.addPoint(points[i]);
			};
			geometryCapture.endDrawing();

		} else {
			drawZooming = false;
			var poly = simplifyPolygon(points);
			if (!poly) {
				return;  // Drawn shape doesn't enclose a region, do nothing
			}

			// Find bounding rectangle (in pixels)
			var left = Infinity;
			var bottom = 0;
			var right = 0;
			var top = Infinity;
			for (var i = 0; i < poly.length; ++i) {
				left = Math.min(left, poly[i].x);
				bottom = Math.max(bottom, poly[i].y);
				right = Math.max(right, poly[i].x);
				top = Math.min(top, poly[i].y);
			}

			var width = (right - left);
			var height = (bottom - top);
			if (width > 8 && height > 8) {
				// Bounds have reasonable size, convert to lon/lat
				var tl = moduleDisplay.mapControl.map.getLonLatFromPixel(
					new OpenLayers.Pixel(left, top));
				var br = moduleDisplay.mapControl.map.getLonLatFromPixel(
					new OpenLayers.Pixel(right, bottom));

				// Zoom/center map to/on bounding rectangle
				moduleDisplay.mapControl.map.zoomToExtent(
					[tl.lon, br.lat, br.lon, tl.lat]);
			}
		};
	}

	/** Associate a cursor with a hand, creating a new hand if necessary. */
	function addCursorToHand(cursor)
	{
		// Associate cursor with a hand
		var hand = bestHand(cursor.x, cursor.y);
		if (hand) {
			// Add to existing hand
			hand.cursors.push(cursor);
			hand.dirty = true;
			hand.alive = true;
		} else {
			// No existing hand is appropriate, create a new one
			hand = new Hand(cursor.x, cursor.y);
			hand.cursors = [cursor];
			hands[hand.index] = hand;
			onHandDown(hand.index);
		}

		cursor.hand = hand;

		return hand;
	}

	/** Update cursor coordinates according to a position update. */
	function updateCursors(set) {
		for (var inst in set) {
			if (!set.hasOwnProperty(inst)) {
				continue; // Ignore prototypes
			} else if (set[inst] == undefined || cursors[inst] == undefined) {
				continue; // Unknown cursor ID
			}

			var newX = (set[inst][0] - 0.5) * calibration.cursorXScale + 0.5 + calibration.cursorXOffset;
			var newY = (set[inst][1] - 0.5) * calibration.cursorYScale + 0.5 + calibration.cursorYOffset;
			if (isNaN(newX) || isNaN(newY)) {
				continue;
			}

			// Update stored cursor position
			cursors[inst].moveTo(newX, newY);
			dirty = true;

			if (!cursors[inst].down) {
				// Initial cursor position update (cursor down)
				cursors[inst].down = true;
				cursors[inst].birthTime = Date.now();
				cursors[inst].downX = newX;
				cursors[inst].downY = newY;

				addCursorToHand(cursors[inst]);
				onCursorDown(inst);

				energy = Math.min(1.0, energy + 1.0);
			} else {
				// Position update for down cursor (cursor move)
				onCursorMove(inst);

				// Increase energy for spring layout calculation
				var increase = Math.abs(
					distance(cursors[inst].x, cursors[inst].y,
					         newX, newY));
				energy = Math.min(1.0, energy + increase * 1000);
			}

			// Update cursor visual feedback
			if (!usePhysics) {
				cursors[inst].show();
			}

			if (cursors[inst].hand) {
				// Flag hand position as dirty for recalculation
				cursors[inst].hand.dirty = true;
			}
		}

		if (!usePhysics) {
			// Update the position of any hands that have changed
			for (var inst in hands) {
				var hand = hands[inst];
				hand.updateTargetPosition();

				// Check if any cursors have moved outside a reasonable hand span
				var orphans = hand.trimCursors();
				if (orphans.length > 0) {
					for (var i = 0; i < orphans.length; ++i) {
						addCursorToHand(orphans[i]);
					}
					cursorsMoved = true;
				}
			}

			// Show hand visual feedback
			for (var inst in hands) {
				var hand = hands[inst];
				// Re-calculate hand position based on cursors
				hand.updateTargetPosition();

				if (hand.dirty) {
					onHandMove(hand.index);
				}

				hand.show();
			}
		};

		if( g_tuioService ){
			g_tuioService._updateCursors(cursors, hands);
		};
	}

	function updateTangibles(set) {
		for (var inst in set) {
			if (!set.hasOwnProperty(inst)) {
				continue; // Ignore prototypes
			}

			if (set[inst] != undefined && tangibles[inst] != undefined) {
				tangibles[inst]['id'] = set[inst][0];
				tangibles[inst]['x'] = (set[inst][1] - 0.5) * calibration.cursorXScale + 0.5 + calibration.cursorXOffset;
				tangibles[inst]['y'] = (set[inst][2] - 0.5) * calibration.cursorYScale + 0.5 + calibration.cursorYOffset;
				tangibles[inst]['angle'] = set[inst][3];
				tangibles[inst]['alive'] = true;
			}
		}

		if( g_tuioService ){
			g_tuioService._updateTangibles(tangibles);
		};
	}

	function getPaneRotateAngle(e) {
		var pane = document.getElementsByClassName("n2_content_text")[0];
		var bounds = pane.getBoundingClientRect();
		var originX = bounds.left + (bounds.width / 2.0);
		var originY = bounds.top + (bounds.height / 2.0);
		return Math.atan2(e.pageY - originY, e.pageX - originX) * (180 / Math.PI);
	}

	function onRotateHandleDown(e) {
		var pane = document.getElementsByClassName("n2_content_text")[0];
		e.preventDefault();
		e.stopPropagation();
		paneRotating = true;
		paneRotateMouseStartAngle = getPaneRotateAngle(e);
		document.addEventListener("mousemove", onRotateHandleMove, true);
		document.addEventListener("mouseup", onRotateHandleUp, true);
	}

	function onRotateHandleMove(e) {
		if (paneRotating) {
			var pane = document.getElementsByClassName("n2_content_text")[0];
			var diff = getPaneRotateAngle(e) - paneRotateMouseStartAngle;
			e.preventDefault();
			e.stopPropagation();
			paneRotateAngle = paneRotateStartAngle + diff;
			pane.style.transform = 'rotate(' + paneRotateAngle + 'deg)';
		}
	}

	function onRotateHandleUp(e) {
		if (paneRotating) {
			e.preventDefault();
			e.stopPropagation();
			paneRotateStartAngle = paneRotateAngle;
			paneRotating = false;
			document.removeEventListener("mousemove", onRotateHandleMove);
			document.removeEventListener("mouseup", onRotateHandleUp);
		}
	}

	function createRotateHandle() {
		var handle = document.createElement('div');
		handle.className = "n2tuio_rotate_handle n2tuio_remove";
		handle.innerHTML = "&orarr;";
		handle.onmousedown = onRotateHandleDown;

		return handle;
	}

	function showPane() {
		var $pane = $('.n2_content_text');
		var pane = document.getElementsByClassName("n2_content_text")[0];

		$pane.addClass('n2tuio_showPane');

		pane.style.transform = 'rotate(' + paneRotateAngle + 'deg)';

		// Create left side rotation handle
		var lHandle = createRotateHandle();
		lHandle.id = "left_rotate_handle";
		lHandle.style.left = "-88px";
		lHandle.style.borderTopLeftRadius = "130px";
		lHandle.style.borderBottomLeftRadius = "130px";
		pane.appendChild(lHandle);

		// Create right side rotation handle
		var rHandle = createRotateHandle();
		rHandle.id = "right_rotate_handle";
		rHandle.style.left = "450px";
		rHandle.style.borderTopRightRadius = "130px";
		rHandle.style.borderBottomRightRadius = "130px";
		pane.appendChild(rHandle);
	}

	function hidePane() {
		var $pane = $('.n2_content_text');

		$pane.removeClass('n2tuio_showPane');
		$pane.removeAttr('style');
		$pane.children('.n2tuio_rotate_handle').remove();
	}

	function togglePane() {
		var $pane = $('.n2_content_text');
		var isPaneVisible = $pane.hasClass('n2tuio_showPane');
		if (!isPaneVisible) {
			showPane();
		} else {
			hidePane();
		}
	}

	var lastTime = null;
	var dirty = false;
	var energy = 1.0;

	function reschedule(callback) {
		var fps = 30;
		window.setTimeout(function() {
			window.requestAnimationFrame(callback);
		}, 1000 / fps);
	}

	function tick(timestamp) {
		if (!dirty || !lastTime) {
			// Nothing to do now, just schedule next tick
			lastTime = timestamp;
			reschedule(tick);
			return;
		}

		var interval = Math.min(timestamp - lastTime, 15.0);
		for (var t = lastTime + interval; dirty && t <= timestamp; t += interval) {
			subtick(t);
		}

		reschedule(tick);
	}

	function subtick(timestamp) {
		// Time since last tick in ms
		var dur = timestamp - lastTime;
		lastTime = timestamp;

		// Reduce overall energy to converge on stable positions
		energy = Math.max(0.0, Math.min(energy, energy - (dur / 1000.0)));

		// Update the position of each cursor
		var moving = false;
		for (var inst in cursors) {
			if (!cursors.hasOwnProperty(inst)) {
				continue; // Ignore prototypes
			}

			var cursor = cursors[inst];
			moving = cursor.updatePosition(timestamp, energy) || moving;
			cursor.show();
		}

		// Update the position of any hands that have changed
		var cursorsMoved = false;
		for (var inst in hands) {
			var hand = hands[inst];
			hand.updateTargetPosition();

			// Check if any cursors have moved outside a reasonable hand span
			var orphans = hand.trimCursors();
			if (orphans.length > 0) {
				for (var i = 0; i < orphans.length; ++i) {
					addCursorToHand(orphans[i]);
				}
				cursorsMoved = true;
			}
		}

		// Show hand visual feedback
		for (var inst in hands) {
			var hand = hands[inst];
			if (cursorsMoved) {
				// Cursors have moved hands, re-calculate target position
				hand.updateTargetPosition();
			}

			if (hand.dirty) {
				moving = hand.updatePosition(timestamp, energy) || moving;
				onHandMove(hand.index);
			}

			hand.show();
		}

		if (!moving) {
			dirty = false;
		}
	}

	//==================================================================
	function DrawOverlay(parent, width, height, pathCallback) {
		var self = this;

		this.parent = parent;
		this.drawing = false;
		this.isMouseDown = false;
		this.startTime = Date.now();
		this.points = [];
		this.pathCallback = pathCallback;

		this.canvas = document.createElement('canvas');
		this.canvas.className = "n2tuio_overlay n2tuio_remove";
		if( width ){
			this.canvas.width = width;
		};
		if( height ){
			this.canvas.height = height;
		};
		parent.appendChild(this.canvas);

		this.context = this.canvas.getContext('2d');

		this.getMousePosition = function (e) {
			var box = self.canvas.getBoundingClientRect();
			return { x: e.clientX - box.left,
			         y: e.clientY - box.top };
		}

		this.canvas.onmousedown = function (e) {
			var pos = self.getMousePosition(e);
			self.isMouseDown = true;
			self.startStroke(pos.x, pos.y);
		};

		this.canvas.onmousemove = function (e) {
			if (self.drawing) {
				var pos = self.getMousePosition(e);
				self.moveTo(pos.x, pos.y);
			}
		};

		this.canvas.onmouseup = function (e) {
			var pos = self.getMousePosition(e);
			self.moveTo(pos.x, pos.y);
			self.mouseUpTime = Date.now();
			self.isMouseDown = false;
			window.setTimeout(function() { self.endStroke(); }, drawDelay * 1.5);
		};
	}

	DrawOverlay.prototype.setSensitive = function (sensitive) {
		var wasSensitive = (this.canvas.style.pointerEvents != "none");
		if (sensitive) {
			this.canvas.style.pointerEvents = "auto";
		} else {
			this.canvas.style.pointerEvents = "none";
		}
		return wasSensitive;
	}

	DrawOverlay.prototype.show = function () {
		this.canvas.style.left = "0px";
		this.canvas.style.width = "100%";
		this.setSensitive(true);
	}

	DrawOverlay.prototype.hide = function () {
		this.canvas.style.left = "100%";
		this.canvas.style.width = "0";
		this.setSensitive(false);
	}

	DrawOverlay.prototype.startStroke = function (x, y) {
		this.context.lineCap = 'round';
		this.context.lineWidth = 2;
		if (g_tuioService && g_tuioService.isEditing()) {
			this.context.strokeStyle = '#FF0000';
		} else {
			this.context.strokeStyle = '#00FF00';
		}
		this.context.imageSmoothingEnabled = true;
		if (!this.drawing) {
			this.context.beginPath();
			this.context.moveTo(x, y);
			this.drawing = true;
		} else {
			this.context.lineTo(x, y);
		}

		this.points.push(new Vector(x, y));
	}

	DrawOverlay.prototype.moveTo = function (x, y) {
		if (!this.drawing) {
			return;
		} else if (this.points.length > 0 &&
		           this.points[this.points.length - 1].x == x &&
		           this.points[this.points.length - 1].y == y) {
			return;
		}

		this.context.lineTo(x, y);
		this.context.stroke();
		this.points.push(new Vector(x, y));
	}

	DrawOverlay.prototype.abortStroke = function () {
		if (this.drawing) {
			this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.hide();
			this.drawing = false;
			this.isMouseDown = false;
			this.points = [];
		}
	}

	DrawOverlay.prototype.endStroke = function () {
		if (!this.isMouseDown && Date.now() - this.mouseUpTime >= drawDelay) {
			// Save bounding box for passing to path callback
			var box = this.canvas.getBoundingClientRect();

			// Move canvas out of the way so path callback can dispatch events to
			// elements underneath it (like the map)
			this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.hide();

			if (this.points.length > 0) {
				this.pathCallback(box, this.points);
				this.points = [];
			}
			this.drawing = false;
		} else {
			/* The mouse went away, but came back, so reschedule an endStroke.
			   This should happen on the next mouseup event anyway, but if
			   events get funny/unreliable, we want to ensure the stroke is
			   ended, otherwise it will stay visible on the canvas and do
			   nothing. */
			var self = this;
			window.setTimeout(function() { self.endStroke(); }, drawDelay * 1.5);
		}
	}

	//==================================================================
	var TuioConfiguration = $n2.Class({

		initialize: function(opts_){
			var opts = $n2.extend({

			},opts_);
		},

		loadConfiguration: function(){
			var localStorage = $n2.storage.getLocalStorage();

			var tuioConfStr = localStorage.getItem('n2tuio_configuration');

			var tuioConf = undefined;
			if( tuioConfStr ){
				try {
					tuioConf = JSON.parse(tuioConfStr);
				} catch(e) {
					$n2.log('Unable to parse TUIO configuration:'+e);
				};
			};

			if( !tuioConf ){
				tuioConf = {};
			};

			return tuioConf;
		},

		saveConfiguration: function(tuioConf){
			var localStorage = $n2.storage.getLocalStorage();

			var tuioConfStr = JSON.stringify(tuioConf);
			localStorage.setItem('n2tuio_configuration',tuioConfStr);
		},

		deleteConfiguration: function(){
			var localStorage = $n2.storage.getLocalStorage();
			localStorage.removeItem('n2tuio_configuration');
		},

		isEnabled: function(){
			var tuioConf = this.loadConfiguration();
			return tuioConf.enabled;
		},

		setEnabled: function(flag){
			var tuioConf = this.loadConfiguration();
			tuioConf.enabled = flag;
			this.saveConfiguration(tuioConf);
		},

		isTableModeActive: function(){
			var tuioConf = this.loadConfiguration();
			return tuioConf.active;
		},

		setTableModeActive: function(flag){
			var tuioConf = this.loadConfiguration();
			tuioConf.active = flag;
			this.saveConfiguration(tuioConf);
		},

		getCalibration: function(){
			// Default calibration
			var calibration = {
				// Input calibration
				cursorXScale: 0.672
				,cursorYScale: 0.953
				,cursorXOffset: -0.04
				,cursorYOffset: 0.002
				// Map visual size and position
				,xMargin: 450
				,xOffset: -90
				,yMargin: 15
				,yOffset: 10
			};

			var tuioConf = this.loadConfiguration();

			if( tuioConf.calibration ){
				calibration = $n2.extend(calibration, tuioConf.calibration);
			};

			return calibration;
		},

		setCalibration: function(calibration){
			var tuioConf = this.loadConfiguration();
			tuioConf.calibration = calibration;
			this.saveConfiguration(tuioConf);
		}
	});


	//==================================================================
	/**
	 * Switch into table mode
	 */
	function startTableMode() {
		if( !IsTableModeOn() ){
			$('body').addClass('nunaliit_tuio');
			
			var $content = $('.nunaliit_content');

			$content.css({
				left: (calibration.xMargin + calibration.xOffset) + 'px'
				,right: (calibration.xMargin - calibration.xOffset) + 'px'
				,top: (calibration.yMargin + calibration.yOffset) + 'px'
				,bottom: (calibration.yMargin - calibration.yOffset) + 'px'
			});

			// Create draw overlay
			var $map = $('.n2_content_map');
			if ($map.length > 0) {
				var map = $map[0];
				overlay = new DrawOverlay(
					map, map.offsetWidth, map.offsetHeight, onPathDraw);
				drawZooming = true;
			}
			
			// Create reset extent button
			var $resetOuter = $('<div>')
				.addClass('n2tuio_resetExtent_outer n2tuio_remove')
				.appendTo( $('.nunaliit_content') );
			$('<a>')
				.addClass('n2tuio_resetExtent')
				.attr('href','#')
				.text( '#' )
				.appendTo( $resetOuter )
				.click(function(){
					if( g_tuioService ){
						g_tuioService.resetMapToInitialExtent();
					};
					return false;
				});

			// Create green/red edit ring
			createRing();
			
			// Remember that table mode is active
			if( tuioConfiguration ){
				tuioConfiguration.setTableModeActive(true);
			};
			
			// Disable map toggle
			g_tuioService.disableMapToggleClick();

			// Inform OpenLayers that map was resized
			if( moduleDisplay
				&& moduleDisplay.mapControl
				&& moduleDisplay.mapControl.map ){
				window.setTimeout(function(){
					moduleDisplay.mapControl.map.updateSize();
				},200);
			};
		};
	};

	//==================================================================
	/**
	 * Return to regular atlas mode
	 */
	function endTableMode() {
		
		if( IsTableModeOn() ){
			$('body').removeClass('nunaliit_tuio');
			
			var $content = $('.nunaliit_content');

			$content.removeAttr('style');
			$('.n2tuio_remove').remove();
			hidePane();
			
			// Remember that table mode is inactive
			if( tuioConfiguration ){
				tuioConfiguration.setTableModeActive(false);
			};
			
			// Restore map toggle
			g_tuioService.restoreMapToggleClick();

			// Inform OpenLayers that map was resized
			if( moduleDisplay
				&& moduleDisplay.mapControl
				&& moduleDisplay.mapControl.map ){
				window.setTimeout(function(){
					moduleDisplay.mapControl.map.updateSize();
				},200);
			};
		};
	};
	
	//==================================================================
	/**
	 * If in regular mode, switch to table mode.
	 * If in table mode, get out of it.
	 */
	function toggleTableMode() {
		if( !IsTableModeOn() ){
			startTableMode();
		} else {
			endTableMode();
		};
	};

	//==================================================================
	function Main(){
		// Configuration from local storage
		tuioConfiguration = new TuioConfiguration();

		if( tuioConfiguration.isEnabled()
			&& typeof io === 'function' ){
			socket = io('http://localhost:3000');

			if( socket ){
				socket.on('cursor update', function(update) {
					updateAlive(cursors, update.alive);
					updateCursors(update.set);
				});

				socket.on('tangibles update', function(update) {
					updateAlive(tangibles, update.alive);
					updateTangibles(update.set);
				});

				socket.on('welcome', function(update) {
					tuioConnected = true;
					$n2.log('tuio connected');
				});

				socket.emit('new client',{});
			};

			// Load saved calibration
			calibration = tuioConfiguration.getCalibration();

			// At regular intervals, attempt to save calibration data
			window.setInterval(function(){
				escapeKeyCount = 0;

				if( calibrationDirty ){
					if( $n2.storage
						&& $n2.storage.getLocalStorage
						&& typeof JSON !== 'undefined'
						&& JSON.stringify
						&& JSON.parse ){
						tuioConfiguration.setCalibration(calibration);
						calibrationDirty = false;
					};
				};
			},2000);

			window.onkeydown = function (e) {
				var code = e.keyCode ? e.keyCode : e.which;

				if (code === 27) {
					// Escape pressed, toggle non-map UI visibility
					++escapeKeyCount;
					if( escapeKeyCount >= 3 ){
						escapeKeyCount = 0;
						toggleTableMode();
					};
				};

				if( IsTableModeOn() ){
					var $content = $('.nunaliit_content');
					var content = $content[0];

					if (code == 70) {
						// f pressed, toggle visual feedback
						showDots = !showDots;
					} else if ( 67 === code && escapeKeyCount >= 2) {
						// <esc> <esc> c : calibrate
						if( g_tuioService ){
							g_tuioService.startCalibration();
						};
					} else if (code == 66) {
						// b, toggle border
						$('.n2tuio_edit_ring').toggleClass('n2tuio_hide');
					} else if (e.shiftKey) {
						// TUIO calibration
						if (code == 37) {
							if (e.altKey) {
								// Shift+Alt+left, offset TUIO left
								calibration.cursorXOffset -= 0.001;
							} else {
								// Shift+left, shrink TUIO horizontally
								calibration.cursorXScale -= 0.001;
							}
							calibrationDirty = true;
						} else if (code == 39) {
							if (e.altKey) {
								// Shift+Alt+right, offset TUIO right
								calibration.cursorXOffset += 0.001;
							} else {
								// Shift+right, expand TUIO horizontally
								calibration.cursorXScale += 0.001;
							}
							calibrationDirty = true;
						} else if (code == 40) {
							if (e.altKey) {
								// Shift+Alt+down, offset TUIO down
								calibration.cursorYOffset += 0.001;
							} else {
								// Shift+down, shrink TUIO vertically
								calibration.cursorYScale -= 0.001;
							}
							calibrationDirty = true;
						} else if (code == 38) {
							if (e.altKey) {
								// Shift+Alt+up, offset TUIO up
								calibration.cursorYOffset -= 0.001;
							} else {
								// Shift+up, grow TUIO vertically
								calibration.cursorYScale += 0.001;
							}
							calibrationDirty = true;
						}
					} else if (code == 37) {
						if (e.altKey) {
							// Alt+left, shrink horizontally
							calibration.xMargin += 2;
						} else {
							// Left, shift left
							calibration.xOffset -= 2;
						}

						content.style.left = (calibration.xMargin + calibration.xOffset) + "px";
						content.style.right = (calibration.xMargin - calibration.xOffset) + "px";
						calibrationDirty = true;
					} else if (code == 39) {
						if (e.altKey) {
							// Alt+right, grow horizontally
							calibration.xMargin -= 2;
						} else {
							// Right, shift right
							calibration.xOffset += 2;
						}

						content.style.left = (calibration.xMargin + calibration.xOffset) + "px";
						content.style.right = (calibration.xMargin - calibration.xOffset) + "px";
						calibrationDirty = true;
					} else if (code == 40) {
						if (e.altKey) {
							// Alt+down, shrink vertically
							calibration.yMargin += 2;
						} else {
							// Down, shift up
							calibration.yOffset += 2;
						}

						content.style.top = (calibration.yMargin + calibration.yOffset) + "px";
						content.style.bottom = (calibration.yMargin - calibration.yOffset) + "px";
						calibrationDirty = true;
					} else if (code == 38) {
						if (e.altKey) {
							// Alt+up, grow vertically
							calibration.yMargin -= 2;
						} else {
							// Up, shift down
							calibration.yOffset -= 2;
						}

						content.style.top = (calibration.yMargin + calibration.yOffset) + "px";
						content.style.bottom = (calibration.yMargin - calibration.yOffset) + "px";
						calibrationDirty = true;
					} else if (code == 80) {
						// P, show/hide pane
						togglePane();
					};
				};
			};

			if (usePhysics) {
				window.requestAnimationFrame(tick);
			};
			
			// Restore mode
			if( tuioConfiguration.isTableModeActive() ){
				startTableMode();
			};
		};
	};

	//==================================================================
	var CalibrationProcess = $n2.Class({

		intervalId: null,

		timeLeft: null,

		canvasId: null,

		canvasContext: null,

		// Canvas geometries

		width: null,

		height: null,

		initialize: function(opts_){
			var opts = $n2.extend({

			},opts_);

			var _this = this;

			// Timeout for abort
			this.timeLeft = 10;
			this.intervalId = window.setInterval(function(){
				_this.timeLeft = _this.timeLeft - 1;
				if( _this.timeLeft <= 0 ){
					$n2.log('CalibrationProcess aborting',this);
					_this._abortProcess();
				};
			},500);

			// Install canvas
			var $content = $('.nunaliit_content');
			this.width = $content.width();
			this.height = $content.height();
			this.canvasId = $n2.getUniqueId();
			var $canvas = $('<canvas>')
				.attr('id', this.canvasId)
				.attr('width',this.width)
				.attr('height',this.height)
				.css({
					position: 'absolute'
					,left: '0'
					,top: '0'
				})
				.appendTo($content);
			var canvasElem = $canvas[0];
			this.canvasContext = canvasElem.getContext('2d');
			canvasElem.onmousedown = function (e) {
				return _this._mouseDown(e);
			};
			this._startFirstStep();

			$n2.log('CalibrationProcess',this);
		},

		_mouseDown: function(e){
			var pos = this._getMousePosition(e);
			$n2.log('calibration mouse down',pos);

			if( 1 == this.step ){
				this.press1 = pos;
				this._clearCanvas();
				this._startSecondStep();

			} else if( 2 == this.step ){
				this.press2 = pos;
				this._clearCanvas();
				this._calibrate();
			};

			return false;
		},

		_calibrate: function(){
			this._abortProcess();
		},

		_clearCanvas: function(){
			this.canvasContext.clearRect(0,0,this.width,this.height);
		},

		_startFirstStep: function(){
			//this.canvasContext.fillStyle = 'rgba(255,0,0,64)';
			//this.canvasContext.fillRect(0,0,this.width,this.height);

			this.step = 1;
			this.step1 = {
				x: Math.floor(this.width / 2)
				,y: Math.floor(this.height / 2)
			};

			this._drawMarker(this.step1);
		},

		_startSecondStep: function(){
			this.step = 2;
			this.step2 = {
				x: this.step1.x + 250
				,y: this.step1.y + 250
			};

			this._drawMarker(this.step2);
		},

		_drawMarker: function(pos){
			this.canvasContext.fillStyle = '#000000';
			this.canvasContext.fillRect(pos.x-7,pos.y-7,14,14);

			this.canvasContext.fillStyle = '#ffff00';
			this.canvasContext.fillRect(pos.x-5,pos.y-5,10,10);

			this.canvasContext.fillStyle = '#000000';
			this.canvasContext.fillRect(pos.x-1,pos.y-1,2,2);
		},

		_getMousePosition: function(e) {
			var $canvas = $('#'+this.canvasId);
			var canvasElem = $canvas[0];
			var box = canvasElem.getBoundingClientRect();
			return { x: e.clientX - box.left,
			         y: e.clientY - box.top };
		},

		_abortProcess: function(){
			window.clearInterval(this.intervalId);

			$('#'+this.canvasId).remove();
			this.canvasContext = null;

			$n2.log('CalibrationProcess ended',this);
		}
	});

	//==================================================================
	var GeometryCapture = $n2.Class({

		tuioService: null,

		positions: null,

		initialize: function(opts_){
			var opts = $n2.extend({
				tuioService: null
			},opts_);

			this.positions = [];

			this.tuioService = opts.tuioService;
		},

		addPoint: function(pos){
			if (this.positions.length == 0 ||
				this.positions[this.positions.length - 1].x != pos.x ||
				this.positions[this.positions.length - 1].y != pos.y) {
				this.positions.push(pos);
			}
		},

		// Convert captured pixel positions to a list of OpenLayers Points
		positionsToPoints: function(positions){
			var points = [];

			for(var i = 0; i < positions.length; ++i) {
				var position = positions[i];
				var lonlat = this.tuioService.getMapPosition(position.x, position.y);
				if( lonlat ){
					var point = new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat);

					points.push(point);
				};
			};

			//$n2.log('points',points);

			return points;
		},

		// Get captured positions as an OpenLayers Geometry
		getGeometry: function(){
			if (this.positions.length == 0) {
				return null;
			}

			var first = this.positions[0];
			var last = this.positions[this.positions.length - 1];
			var poly = null;

			if (lineStringDistance(this.positions) <= pointDistance) {
				// Gesture didn't move very far, create a single point
				var pos = centerPoint(this.positions);
				var lonlat = this.tuioService.getMapPosition(pos.x, pos.y);
				if (lonlat) {
					return new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat);
				}
			} else if ((poly = simplifyPolygon(this.positions)) != null ||
					   distance(first.x, first.y, last.x, last.y) <= pointDistance) {
				// Start/end are close, or there is an intersection, create a polygon
				var points = (poly ? this.positionsToPoints(poly)
				                   : this.positionsToPoints(this.positions));
				var ring = new OpenLayers.Geometry.LinearRing();
				for (var i = 0; i < points.length; ++i) {
					ring.addPoint(points[i]);
				}
				return new OpenLayers.Geometry.Polygon([ring]);
			} else {
				// Doesn't seem to be a point or closed polygon, create a line string
				var points = this.positionsToPoints(this.positions);
				var geom = new OpenLayers.Geometry.LineString();
				for (var i = 0; i < points.length; ++i) {
					geom.addPoint(points[i]);
				}
				return geom;
			}

			return null;
		},

		endDrawing: function(){
			if( !this.tuioService.isEditing() ){
				return;
			};

			var geom = this.getGeometry();
			if (!geom) {
				return;
			}

			//$n2.log('geom',geom);

			var mapControl = this.tuioService.getMapControl();
			if( mapControl ){
				$n2.log('mapControl',mapControl);
				mapControl.initiateEditFromGeometry({
					geometry: geom
					,suppressCenter: true
				});

				// Save (empty) document for drawn geometry
				this.tuioService.dispatch({
					type: 'editTriggerSave'
				});
			};
		}
	});

	//==================================================================
	var TuioService = $n2.Class({

		dispatchService: null,

		tangibleState: null,

		unrecognizedTangibles: null,

		editing: null,

		mapEditing: null,

		moduleDisplay: null,
		
		originalMapToggleClick: null,

		initialize: function(opts_){
			var opts = $n2.extend({
				dispatchService: null
			},opts_);

			var _this = this;

			this.tangibleState = {};
			this.unrecognizedTangibles = {};
			this.editing = false;
			this.mapEditing = false;
			this.originalMapToggleClick = true;

			this.dispatchService = opts.dispatchService;

			if( this.dispatchService ){
				var f = function(m, addr, dispatcher){
					_this._handle(m, addr, dispatcher);
				};

				this.dispatchService.register(DH,'tuioGetState',f);
				this.dispatchService.register(DH,'reportModuleDisplay',f);
				this.dispatchService.register(DH,'editInitiate',f);
				this.dispatchService.register(DH,'mapReportMode',f);
				this.dispatchService.register(DH,'editClosed',f);
				this.dispatchService.register(DH,'start',f);
			};

			// Register with global variable
			g_tuioService = this;
		},

		startCalibration: function(){
			new CalibrationProcess();
		},

		getModuleDisplay: function(){
			return this.moduleDisplay;
		},

		isEditing: function(){
			if( this.editing ){
				return true;
			};

			if( this.mapEditing ){
				return true;
			};

			return false;
		},

		getMapControl: function(){
			var mapControl = undefined;

			if( this.moduleDisplay ){
				mapControl = this.moduleDisplay.mapControl;
			};

			return mapControl;
		},

		getOpenLayersMap: function(){
			var olMap = undefined;

			var mapControl = this.getMapControl();
			if( mapControl ){
				olMap = mapControl.map;
			};

			return olMap;
		},

		getMapPosition: function(x,y){
			var position = undefined;

			var olMap = this.getOpenLayersMap();
			if( olMap ){
				position = olMap.getLonLatFromPixel({
					x: x
					,y: y
				});
			};

			return position;
		},

		getMapProjection: function(){
			var proj = undefined;

			var olMap = this.getOpenLayersMap();
			if( olMap ){
				proj = olMap.getProjectionObject();
			};

			return proj;
		},
		
		resetMapToInitialExtent: function(){
			this.dispatch({
				type: 'mapResetExtent'
			});
		},
		
		disableMapToggleClick: function(){
			var mapControl = this.getMapControl();
			if( mapControl && mapControl.options ){
				mapControl.options.toggleClick = false;
			};
		},

		restoreMapToggleClick: function(){
			var mapControl = this.getMapControl();
			if( mapControl && mapControl.options ){
				mapControl.options.toggleClick = this.originalMapToggleClick;
			};
		},

		dispatch: function(m){
			if( this.dispatchService ){
				this.dispatchService.send(DH,m);
			};
		},

		_handle: function(m, addr, dispatcher){
			if( 'tuioGetState' === m.type ){
				// Synchronous call
				if( IsTuioConnected() ){
					m.connected = true;
				};

				if( IsTableModeOn() ){
					m.mode = 'table';
				} else {
					m.mode = 'regular';
				};

			} else if( 'reportModuleDisplay' === m.type ) {
				moduleDisplay = m.moduleDisplay;
				this.moduleDisplay = m.moduleDisplay;
				
				var mapControl = this.getMapControl();
				if( mapControl && mapControl.options ){
					this.originalMapToggleClick = mapControl.options.toggleClick;
				};

			} else if( 'editInitiate' === m.type ) {
				this.editing = true;

			} else if( 'editClosed' === m.type ) {
				this.editing = false;

			} else if( 'mapReportMode' === m.type ) {
				var mapControl = m.mapControl;
				if( mapControl
					&& mapControl.modes
					&& mapControl.modes.NAVIGATE ){
					if( m.mode === mapControl.modes.NAVIGATE.name ){
						this.mapEditing = false;
						$('body').removeClass('nunaliit_editing');
					} else {
						this.mapEditing = true;
						$('body').addClass('nunaliit_editing');
					};
				};

			} else if( 'start' === m.type ) {
				// Configuration is done. Begin operation
				Main();
			};
		},

		_updateTangibles: function(tangibles){
			for(var tangibleSeq in tangibles){
				var tangible = tangibles[tangibleSeq];
				var tangibleId = tangible.id;

				if( !tangible.service ){
					tangible.service = {};
				};

				// Process this tangible
				if( 0 === tangibleId ){
					if( tangible.alive
						&& !tangible.service.start ){
						tangible.service.start = true;
						this.dispatchService.send(DH,{
							type: 'loginShowForm'
						});
					} else if( !tangible.alive
					           && !tangible.service.end ){
						tangible.service.end = true;
						this.dispatchService.send(DH,{
							type: 'logout'
						});
					};

				} else if( 1 === tangibleId ){
					// Calibration
					if( !tangible.service.start ){
						tangible.service.start = true;
						this.startCalibration();
					};

				} else {
					// Tangible id not known. Report in log
					if( !this.unrecognizedTangibles[tangibleId] ){
						this.unrecognizedTangibles[tangibleId] = true;
						$n2.log('Tangible not recognized: '+tangibleId);
					};
				};
			};

			this.tangibleState.tangibles = tangibles;

			if( this.dispatchService ){
				this.dispatchService.send(DH,{
					type: 'tuioTangiblesUpdate'
					,tangibles: this.tangibleState
				});
			};
		},

		_updateCursors: function(cursors, hands){
			this.tangibleState.cursors = cursors;
			this.tangibleState.hands = hands;

			if( this.dispatchService ){
				this.dispatchService.send(DH,{
					type: 'tuioTangiblesUpdate'
					,tangibles: this.tangibleState
				});
			};
		}
	});

	$n2.tuioClient = {
		IsTuioConnected: IsTuioConnected
		,TuioService: TuioService
		,TuioConfiguration: TuioConfiguration
	};

})(jQuery, nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.utilities.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.utilities'
 ;

//--------------------------------------------------------------------------
var AssignLayerOnDocumentCreation = $n2.Class({
		
	layerId: null,
	
	onlyWithGeometries: null,

	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			layerId: null
			,onlyWithGeometries: false
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.layerId = opts.layerId;
		this.onlyWithGeometries = opts.onlyWithGeometries;
		this.dispatchService = opts.dispatchService;
			
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};

			this.dispatchService.register(DH,'preDocCreation',f);
		};
		
		$n2.log('AssignLayerOnDocumentCreation', this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'preDocCreation' === m.type ){
			var createdDoc = m.doc;
			
			var addLayer = true;
			if( this.onlyWithGeometries ){
				if( createdDoc.nunaliit_geom ){
					
				} else {
					addLayer = false;
				};
			};

			if( addLayer ){
				if( !createdDoc.nunaliit_layers ){
					createdDoc.nunaliit_layers = [];
				};
				
				if( this.layerId ){
					if( createdDoc.nunaliit_layers.indexOf(this.layerId) < 0 ){
						createdDoc.nunaliit_layers.push(this.layerId);
					};
				};
			};
		};
	}
});

//--------------------------------------------------------------------------
var SelectDocumentOnModuleIntroduction = $n2.Class({
		
	docIds: null,

	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			docId: null
			,docIds: null
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.docIds = [];
		
		this.moduleStarted = false;
		
		if( typeof opts.docId === 'string' ){
			this.docIds.push(opts.docId);
		};
		if( $n2.isArray(opts.docIds) ){
			for(var i=0,e=opts.docIds.length; i<e; ++i){
				var docId = opts.docIds[i];
				if( typeof docId === 'string' ){
					this.docIds.push(docId);
				};
			};
		};
			
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};

			this.dispatchService.register(DH,'modulePerformIntroduction',f);
		};
		
		$n2.log('SelectDocumentOnModuleIntroduction', this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modulePerformIntroduction' === m.type ){
			if( !m.performed ){
				if( this.docIds.length > 1 ){
					m.performed = true;
					this.dispatchService.send(DH,{
						type: 'selected'
						,docIds: this.docIds
					});
	
				} else if( this.docIds.length > 0 ){
					m.performed = true;
					this.dispatchService.send(DH,{
						type: 'selected'
						,docId: this.docIds[0]
					});
				};
			};
		};
	}
});

//--------------------------------------------------------------------------
// This utility performs a document selection when the current selection on a filter
// is changed. In this case, a filter refers to a document model of type 
// SelectableDocumentFilter. This utility is configured with a map of choices pointing
// to a document identifier. If the choices match, then the utility sends a
// selection on the associated document.
// The selection map is structured in such a way that the key is the identifier
// of the document to be selected. The values in the map can be a string or an 
// array of strings. These are the choices selected in the associated filter
// model.
// For example:
// {
//     "utilityType": "selectDocumentOnFilterChange"
//     ,"sourceModelId": "filterDocsByLayer"
//     ,"performSelectedEvent": false
//     ,"selectionMap": {
//    	  "123": "public"
//    	  ,"456": "approved"
//    	  ,"789": [ "public", "approved" ]
//     }
// }
var SelectDocumentOnFilterChange = $n2.Class('SelectDocumentOnFilterChange',{
		
	dispatchService: null,
	
	sourceModelId: null,
	
	selectionToDocId: null,
	
	/**
	 * Name of event used by source model to report changes in choices
	 */
	selectedChoicesChangeEventName: null,
	
	/**
	 * If set, send a 'selected' event instead of a 'userSelect' event.
	 */
	performSelectedEvent: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: undefined
			,sourceModelId: undefined
			,selectionMap: undefined
			,performSelectedEvent: undefined
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		if( typeof opts.sourceModelId === 'string' ){
			this.sourceModelId = opts.sourceModelId;
		} else {
			throw new Error('In configuration for SelectDocumentOnFilterChange, sourceModelId must be specified as a string');
		};
		
		this.selectionToDocId = {};
		if( opts.selectionMap && typeof opts.selectionMap === 'object' ){
			for(var docId in opts.selectionMap){
				var selection = opts.selectionMap[docId];
				var selectionString = this._selectionToString(selection);
				if( selectionString ){
					this.selectionToDocId[selectionString] = docId;
				};
			};
		};
		
		this.performSelectedEvent = false;
		if( opts.performSelectedEvent ){
			this.performSelectedEvent = true;
		};
		
		// Register to events
		if( this.dispatchService && this.sourceModelId ){
			var fn = function(m, addr, dispatcher){
				_this._handleFilterChange(m, addr, dispatcher);
			};
			
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters 
			 && sourceModelInfo.parameters.selectedChoices ){
				var paramInfo = sourceModelInfo.parameters.selectedChoices;
				this.selectedChoicesChangeEventName = paramInfo.changeEvent;
			};
			
			if( this.selectedChoicesChangeEventName ){
				this.dispatchService.register(DH, this.selectedChoicesChangeEventName, fn);
			};
		};
		
		$n2.log(this._classname, this);
	},
	
	_handleFilterChange: function(m, addr, dispatcher){
		if( this.selectedChoicesChangeEventName === m.type ){
			if( m.value ){
				var selection = m.value;
				var selectionString = this._selectionToString(selection);
				var docId = this.selectionToDocId[selectionString];
				if( docId ){
					var eventType = 'userSelect';
					if( this.performSelectedEvent ){
						eventType = 'selected';
					};

					this.dispatchService.send(DH, {
						type: eventType
						,docId: docId
					});
				};
			};
		};
	},
	
	/**
	 * Turns an array of selectors into a single string. First, sorts
	 * the items in array. Then, escapes each string. Finally, concatenate
	 * each string using a separator.
	 * 
	 * 'abc' -> 'abc'
	 * [ 'def', 'abc' ] -> 'abc|def'
	 * [ 'a|b', 'c|d' ] -> 'a||b|c||d'
	 */
	_selectionToString: function(selection){
		var _this = this;

		var selectionString = undefined;
		
		if( typeof selection === 'string' ){
			selectionString = this._escapeSelector(selection);

		} else if( $n2.isArray(selection) ){
			var effectiveSelection = [];
			selection.forEach(function(sel){
				if( typeof sel === 'string' ){
					effectiveSelection.push( _this._escapeSelector(sel) );
				};
			});

			effectiveSelection.sort();
			
			selectionString = effectiveSelection.join('|');
		};
		
		return selectionString;
	},
	
	_escapeSelector: function(sel){
		return sel.replace(/\|/g, 'oranges');
	}
});

//--------------------------------------------------------------------------
var Service = $n2.Class({
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH,'utilityCreate',f);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'utilityCreate' === m.type ){
			if( ! m.utilityType ){
				$n2.log('utilityType must be provided when creating a utility');
				return;
			};
			
			if( 'assignLayerOnDocumentCreation' === m.utilityType ){
				var options = {};
				
				if( typeof m.utilityOptions === 'object' ){
					for(var key in m.utilityOptions){
						var value = m.utilityOptions[key];
						options[key] = value;
					};
				};
				
				if( m.config ){
					if( m.config.directory ){
						options.dispatchService = m.config.directory.dispatchService;
					};
				};
				
		        new AssignLayerOnDocumentCreation(options);
		        
		        m.created = true;

			} else if( 'selectDocumentOnModuleIntroduction' === m.utilityType ){
				var options = {};
				
				if( typeof m.utilityOptions === 'object' ){
					for(var key in m.utilityOptions){
						var value = m.utilityOptions[key];
						options[key] = value;
					};
				};
				
				if( m.config ){
					if( m.config.directory ){
						options.dispatchService = m.config.directory.dispatchService;
					};
				};
				
		        new SelectDocumentOnModuleIntroduction(options);
		        
		        m.created = true;

			} else if( 'selectDocumentOnFilterChange' === m.utilityType ){
				var options = {};
				
				if( typeof m.utilityOptions === 'object' ){
					for(var key in m.utilityOptions){
						var value = m.utilityOptions[key];
						options[key] = value;
					};
				};
				
				if( m.config ){
					if( m.config.directory ){
						options.dispatchService = m.config.directory.dispatchService;
					};
				};
				
		        new SelectDocumentOnFilterChange(options);
		        
		        m.created = true;

			} else {
				if( $n2.mapUtilities 
				 && typeof $n2.mapUtilities.HandleUtilityCreateRequests === 'function' ){
					$n2.mapUtilities.HandleUtilityCreateRequests(m, addr, dispatcher);
				};

				if( $n2.utilitiesModel 
				 && typeof $n2.utilitiesModel.HandleUtilityCreateRequests === 'function' ){
					$n2.utilitiesModel.HandleUtilityCreateRequests(m, addr, dispatcher);
				};
				
				if( $n2.utilitiesChangeDetectors
					&& typeof $n2.utilitiesChangeDetectors.HandleUtilityCreateRequests === 'function' ){
					$n2.utilitiesChangeDetectors.HandleUtilityCreateRequests(m, addr, dispatcher);
				};
		    };
		};
	}
});

//--------------------------------------------------------------------------
$n2.utilities = {
	Service: Service
	,AssignLayerOnDocumentCreation: AssignLayerOnDocumentCreation
	,SelectDocumentOnModuleIntroduction: SelectDocumentOnModuleIntroduction
	,SelectDocumentOnFilterChange: SelectDocumentOnFilterChange
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.utilitiesModel.js

/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.utilitiesModel'
 ;

//--------------------------------------------------------------------------
var Action = $n2.Class({
	initialize: function(opts_){
		var opts = $n2.extend({
			
		},opts_);
	},
	
	execute: function(){
		throw new Exception('Action.execute() must be implemented by subclasses');
	}
});

//--------------------------------------------------------------------------
var SetFilterSelectionAction = $n2.Class('SetFilterSelectionAction', Action, {

	dispatchService: null,

	modelId: null,

	selection: null,
	
	selectAll: null,

	selectedChoicesSetEventName: null,

	allSelectedSetEventName: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: undefined
			,modelId: undefined
			,selection: undefined
			,selectAll: undefined
		},opts_);
		
		this.dispatchService = opts.dispatchService;
		this.modelId = opts.modelId;
		this.selection = opts.selection;
		this.selectAll = opts.selectAll;

		// Check modelId parameter
		if( typeof this.modelId !== 'string' ){
			throw new Error('modelId must be a string');
		};

		// Check selection parameter
		if( typeof this.selection === 'undefined' ){
			// OK
		} else if( $n2.isArray(this.selection) ){
			// If array is specified, it must be an array of strings
			this.selection.forEach(function(sel){
				if( typeof sel !== 'string' ){
					throw new Error('If parameter "selection" is specified, then it must be an array of strings');
				};
			});
		} else {
			throw new Error('If parameter "selection" is specified, then it must be an array of strings');
		};
		
		// Check selectAll parameter
		if( typeof this.selectAll === 'undefined' ){
			// OK
		} else if( typeof this.selectAll === 'boolean' ){
			// OK
		} else {
			throw new Error('If parameter "selectAll" is specified, it must be a boolean');
		};

		// Verify logic
		if( !this.selectAll && !this.selection ){
			throw new Error('At least one of the parameters "selectAll" or "selection" must be specified.');
		};
		
		// Get information from model
		if( this.dispatchService ){
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.modelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;
			
			if( sourceModelInfo 
			 && sourceModelInfo.parameters  ){
				if( sourceModelInfo.parameters.selectedChoices ){
					var paramInfo = sourceModelInfo.parameters.selectedChoices;
					this.selectedChoicesSetEventName = paramInfo.setEvent;
				};

				if( sourceModelInfo.parameters.allSelected ){
					var paramInfo = sourceModelInfo.parameters.allSelected;
					this.allSelectedSetEventName = paramInfo.setEvent;
				};
			};
		};
	},
	
	execute: function(){
		if( this.selectAll ){
			this.dispatchService.send(DH, {
				type: this.allSelectedSetEventName
				,value: true
			});
			
		} else if( this.selection ) {
			this.dispatchService.send(DH, {
				type: this.selectedChoicesSetEventName
				,value: this.selection
			});
		};
	}
});

//--------------------------------------------------------------------------
function createActionFromDefinition(dispatchService, definition){
	
	if( typeof definition != 'object' ){
		throw new Error('Unable to create an instance of Action since definition is not provided');
	};
	
	// Legacy actionType => type
	if( typeof definition.actionType === 'string' 
	 && typeof definition.type !== 'string' ){
		definition.type = definition.actionType;
	};
	
	// Create instance from definition
	var m = {
		type: 'instanceCreate'
		,instanceConfiguration: definition
		,instance: undefined
	};
	dispatchService.synchronousCall(DH,m);
	var instance = m.instance;
	
	if( !instance ){
		throw new Error('Unable to create an instance of type: '+definition.type);
	};
	
	if( typeof instance != 'object' ){
		throw new Error('Instance of type: '+definition.type+' is not an object');
	};
	
	if( typeof instance.execute != 'function' ){
		throw new Error('Instance of type: '+definition.type+' must implement execute() method');
	};
	
    return instance;
};

//--------------------------------------------------------------------------
var FilterMonitor = $n2.Class('FilterMonitor', {
		
	dispatchService: null,

	sourceModelId: null,

	allSelectedAction: null,

	notAllSelectedAction: null,

	selectedChoicesChangeEventName: null,

	allSelectedChangeEventName: null,

	allSelected: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: undefined
			,sourceModelId: undefined
			,onAllSelected: undefined
			,onNotAllSelected: undefined
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.sourceModelId = opts.sourceModelId;
		
		if( typeof opts.onAllSelected === 'object' ){
			this.allSelectedAction = createActionFromDefinition(this.dispatchService, opts.onAllSelected);
		};
		if( typeof opts.onNotAllSelected === 'object' ){
			this.notAllSelectedAction = createActionFromDefinition(this.dispatchService, opts.onNotAllSelected);
		};

		// Set up model listener
		if( this.dispatchService ){
			// Get model info
			var modelInfoRequest = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
				,modelInfo: null
			};
			this.dispatchService.synchronousCall(DH, modelInfoRequest);
			var sourceModelInfo = modelInfoRequest.modelInfo;

			if( sourceModelInfo 
			 && sourceModelInfo.parameters  ){
				if( sourceModelInfo.parameters.selectedChoices ){
					var paramInfo = sourceModelInfo.parameters.selectedChoices;
					this.selectedChoicesChangeEventName = paramInfo.changeEvent;
	
					if( paramInfo.value ){
						this.selectedChoices = paramInfo.value;
						
						this.selectedChoiceIdMap = {};
						this.selectedChoices.forEach(function(choiceId){
							_this.selectedChoiceIdMap[choiceId] = true;
						});
					};
				};

				if( sourceModelInfo.parameters.allSelected ){
					var paramInfo = sourceModelInfo.parameters.allSelected;
					this.allSelectedChangeEventName = paramInfo.changeEvent;
	
					if( typeof paramInfo.value === 'boolean' ){
						this.allSelected = paramInfo.value;
						
						if( this.allSelected ){
							if( this.allSelectedAction ){
								this.allSelectedAction.execute();
							};
						} else {
							if( this.notAllSelectedAction ){
								this.notAllSelectedAction.execute();
							};
						};
					};
				};
			};
			
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};

			if( this.selectedChoicesChangeEventName ){
				this.dispatchService.register(DH, this.selectedChoicesChangeEventName, fn);
			};

			if( this.allSelectedChangeEventName ){
				this.dispatchService.register(DH, this.allSelectedChangeEventName, fn);
			};
		};
		
		$n2.log(this._classname, this);
	},
	
	_handle: function(m, addr, dispatcher){
		if( this.allSelectedChangeEventName === m.type ){
			if( typeof m.value === 'boolean' ){
				if( this.allSelected && !m.value ){
					if( this.notAllSelectedAction ){
						this.notAllSelectedAction.execute();
					};
				} else if( !this.allSelected && m.value ){
					if( this.allSelectedAction ){
						this.allSelectedAction.execute();
					};
				};
				
				this.allSelected = m.value;
			};
		};
	}
});

//--------------------------------------------------------------------------
function HandleUtilityCreateRequests(m, addr, dispatcher){
	if( 'filterMonitor' === m.utilityType ){
		var options = {};
		
		if( typeof m.utilityOptions === 'object' ){
			for(var key in m.utilityOptions){
				var value = m.utilityOptions[key];
				options[key] = value;
			};
		};
		
		if( m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
        new FilterMonitor(options);
        
        m.created = true;
	};
};

//--------------------------------------------------------------------------
function getCurrentConfiguration(dispatcher){
	var config = undefined;
	
	if( dispatcher ){
		var m = {
			type: 'configurationGetCurrentSettings'
		};
		dispatcher.synchronousCall(DH,m);
		config = m.configuration;
	};

	return config;
};

//--------------------------------------------------------------------------
function handleInstanceCreate(m, addr, dispatcher){
	if( 'setFilterSelection' === m.instanceConfiguration.type ){
		var config = getCurrentConfiguration(dispatcher);
		
		var options = {};
		
		if( typeof m.instanceConfiguration === 'object' ){
			for(var key in m.instanceConfiguration){
				var value = m.instanceConfiguration[key];
				options[key] = value;
			};
		};
		
		
		if( config ){
			if( config.directory ){
				options.dispatchService = config.directory.dispatchService;
			};
		};
		
		m.instance = new SetFilterSelectionAction(options);
	};
};

//--------------------------------------------------------------------------
$n2.utilitiesModel = {
	HandleUtilityCreateRequests: HandleUtilityCreateRequests
	,handleInstanceCreate: handleInstanceCreate
	,FilterMonitor: FilterMonitor
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.utilitiesChangeDetectors.js

/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/



;(function($,$n2){
"use strict";

/* 
 * ------------------------------------------------------------------------------
 * Description: Atlas utility that detects if an input field value is empty or not.
 * When the input value is not empty, an n2_input_detected class is added to the element.
 * ------------------------------------------------------------------------------
 */
var InputChangeDetector = $n2.Class('InputChangeDetector', {
	
	disable: null, 
	
	initialize: function(opts_){

		var opts = $n2.extend({
			config: null
			,disable: false
			,options: null
		},opts_);
		
		var _this = this;
		
		if( opts.disable && typeof opts.disable === 'boolean' ){
			this.disable = opts.disable;
		};		
		
		if ( !this.disable ){
			$('body').addClass('n2_input_change_detector');
			this.startDetector();
		};
		
		$n2.log(this._classname, this);
	},
	
	startDetector: function(){
		
		$('body').change(function(){
			$(this).find('input').each(function(){
				var $input = $(this);
				var value = $input.val();

				if( value !== '' && !$input.hasClass('n2_input_detected') ){
					$input.addClass('n2_input_detected');
	
				} else if( value === '' && $input.hasClass('n2_input_detected') ){
					$input.removeClass('n2_input_detected');
				};
			});
		});
	}
});

//--------------------------------------------------------------------------
function HandleUtilityCreateRequests(m, addr, dispatcher){
	if( 'inputChangeDetector' === m.utilityType ){
		var options = {};
		
		if( typeof m.utilityOptions === 'object' ){
			for(var key in m.utilityOptions){
				var value = m.utilityOptions[key];
				options[key] = value;
			};
		};
		
		if( m.config ){
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
        new InputChangeDetector(options);
        
        m.created = true;
	};
};

//--------------------------------------------------------------------------
$n2.utilitiesChangeDetectors = {
	HandleUtilityCreateRequests: HandleUtilityCreateRequests
	,InputChangeDetector: InputChangeDetector
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couch.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

// This should be set to true if the server is being accessed being a bad proxy
var badProxy = false;

function httpJsonError(XMLHttpRequest, defaultStr) {
	// Need JSON
	if( !JSON || typeof(JSON.parse) !== 'function' ) {
		return $n2.error.fromString(defaultStr);
	};
	
	// Need a response text
	var text = XMLHttpRequest.responseText;
	if( !text ) return $n2.error.fromString(defaultStr);
	
	// Parse
	var error = JSON.parse(text);
	if( !error ) return $n2.error.fromString(defaultStr);
	
	var err = undefined;
	if( typeof error.reason === 'string' ) {
		err = $n2.error.fromString(error.reason);
	} else {
		err = $n2.error.fromString(defaultStr);
	};
	
	if( error.error ){
		var condition = 'couchDb_' + error.error;
		err.setCondition(condition);
	};
	
	return err;
};

// Fix name: no spaces, all lowercase
function fixUserName(userName) {
	return userName.toLowerCase().replace(' ','');
};

/*
 * This should be set if the client is run behind a bad proxy
 */
function isBadProxy(){
	return badProxy;
};
function setBadProxy(flag){
	if( flag ){
		badProxy = true;
	} else {
		badProxy = false;
	};
};

// =============================================
// Session
// =============================================

/*
 * Accepts two CouchDb session context objects and compares
 * them. If they are equivalent, returns true. Otherwise, false.
 */
function compareSessionContexts(s1, s2){
	// This takes care of same object and both objects null
	if( s1 === s2 ) {
		return true;
	};
	
	// Check that one of them is null or undefined
	if( !s1 ){
		return false;
	};
	if( !s2 ){
		return false;
	};
	
	if( s1.name !== s2.name ){
		return false;
	};

	// Compare roles
	var s1Roles = {};
	if( s1.roles ){
		for(var i=0,e=s1.roles.length; i<e; ++i){
			var role = s1.roles[i];
			s1Roles[role] = true;
		};
	};
	var s2Roles = {};
	if( s2.roles ){
		for(var i=0,e=s2.roles.length; i<e; ++i){
			var role = s2.roles[i];
			s2Roles[role] = true;
		};
	};
	for(var role in s1Roles){
		if( !s2Roles[role] ){
			return false;
		};
	};
	for(var role in s2Roles){
		if( !s1Roles[role] ){
			return false;
		};
	};
	
	return true;
};

var Session = $n2.Class('couch.Session',{
	
	server: null
	
	,pathToSession: null
	
	,changedContextListeners: null
	
	,lastSessionContext: null
	
	,initialize: function(server_, sessionInfo_){
	
		this.server = server_;
		
		this.changedContextListeners = [];
		this.lastSessionContext = null;
		
		if( sessionInfo_ ){
    		if( sessionInfo_.ok ) {
    			var context = sessionInfo_.userCtx;
    			this.changeContext(context);
    		};
		};
	}

	,getUrl: function() {
		return this.server.getSessionUrl();
	}
	
	,getContext: function() {
		return this.lastSessionContext;
	}

	,addChangedContextListener: function(listener){
		if( typeof(listener) === 'function' ) {
			this.changedContextListeners.push(listener);
			
			if( this.lastSessionContext ) {
				listener(this.lastSessionContext);
			};
		};
	}
	
	,changeContext: function(context) {
		this.lastSessionContext = context;
		if( this.lastSessionContext ) {
			for(var i=0,e=this.changedContextListeners.length; i<e; ++i) {
				var listener = this.changedContextListeners[i];
				try {
					listener(this.lastSessionContext);
				} catch(e) {};
			};
		};
	}
	
	,refreshContext: function(opts_) {
		var opts = $.extend({
				onSuccess: function(context) {}
				,onError: $n2.reportErrorForced
			}
			,opts_
		);
		
		var _this = this;
		var sessionUrl = this.getUrl();
		
		var data = {};
		
		// Always assume bad proxy on getting context. Force
		// obtaining a context that is up-to-date
		// if( badProxy ){
			data.r = Date.now();
		// };
		
		$.ajax({
			url: sessionUrl
			,type: 'get'
			,async: true
			,dataType: 'json'
			,data: data
			,success: function(res) {
				if( res.ok ) {
					var context = res.userCtx;
					_this.changeContext(context);
					opts.onSuccess(context);
				} else {
					opts.onError('Malformed context reported');
				};
			}
			,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				opts.onError('Error obtaining context: '+errStr);
			}
		});
	}
	
	,login: function(opts_) {
		var opts = $.extend({
				name: null
				,password: null
				,onSuccess: function(context) {}
				,onError: $n2.reportErrorForced
			}
			,opts_
		);

		var _this = this;
		var sessionUrl = this.getUrl();

		if( badProxy ){
			sessionUrl += '?r='+Date.now();
		};
		
		// Login does not happen often. Always assume bad proxy.
		//if( badProxy ){
			sessionUrl += '?r='+Date.now();
		//};
		
		// Fix name: no spaces, all lowercase
		if( opts.name ) {
			var name = fixUserName(opts.name);
		} else {
			opts.onError('A name must be supplied when logging in');
			return;
		};
		
		$.ajax({
	    	url: sessionUrl
    		,type: 'post'
    		,async: true
	    	,data: {
	    		name: name
	    		,password: opts.password
	    	}
	    	,contentType: 'application/x-www-form-urlencoded'
    		,dataType: 'json'
    		,success: function(info) {
	    		if( info && info.ok ) {
	    			_this.refreshContext({
	    				onSuccess: opts.onSuccess
	    				,onError: opts.onError
	    			});
	    		} else {
    				opts.onError('Unknown error during log in');
	    		};
	    	}
    		,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				opts.onError('Error during log in: '+errStr);
	    	}
		});
	}
	
	,logout: function(opts_) {
		var opts = $.extend({
				onSuccess: function(context) {}
				,onError: $n2.reportErrorForced
			}
			,opts_
		);

		var _this = this;
		var sessionUrl = this.getUrl();
		
		$.ajax({
	    	url: sessionUrl
    		,type: 'DELETE'
    		,async: true
    		,dataType: 'json'
    		,success: function(info) {
	    		if( info && info.ok ) {
	    			_this.refreshContext({
	    				onSuccess: opts.onSuccess
	    				,onError: opts.onError
	    			});
	    		} else {
    				opts.onError('Unknown error during log out');
	    		};
	    	}
    		,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				opts.onError('Error during log out: '+errStr);
	    	}
		});
	}
});

// =============================================
// Design Document
// =============================================

var designDoc = $n2.Class('couch.designDoc',{
	ddUrl: null,
	
	ddName: null,
	
	db: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			ddUrl: null
			,ddName: null
			,db: null
		},opts_);
		
		this.ddUrl = opts.ddUrl;
		this.ddName = opts.ddName;
		this.db = opts.db;
	},
	
	getDatabase: function(){
		return this.db;
	},
	
	getQueryUrl: function(opts_){
		var opts = $.extend(true, {
				viewName: null
				,listName: null
			}
			,opts_
		);
		
		if( opts.listName ) {
			return this.ddUrl + '_list/' + opts.listName + '/' + opts.viewName;
		} else {
			return this.ddUrl + '_view/' + opts.viewName;
		};
	},

	queryView: function(options_) {
		var opts = $.extend(true, {
				viewName: undefined
				,listName: undefined
				,viewUrl: undefined
				,startkey: undefined
				,endkey: undefined
				,keys: undefined
				,group: undefined
				,group_level: undefined
				,include_docs: undefined
				,limit: undefined
				,onlyRows: true
				,rawResponse: false
				,reduce: false
				,onSuccess: function(rows){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		if( JSON && JSON.stringify ) {
			// OK
		} else {
			opts.onError('json.js is required to query a view');
		};
		
		var viewUrl = opts.viewUrl;
		if( !viewUrl ) {
			if( opts.listName ) {
				viewUrl = this.ddUrl + '_list/' + opts.listName + '/' + opts.viewName;
			} else {
				viewUrl = this.ddUrl + '_view/' + opts.viewName;
			};
		};
		
		var mustBePost = false;
		var queryCount = 0;
		var query = {};
		var data = {};
		for(var k in opts) {
			if( k === 'viewName' 
			 || k === 'listName'
			 || k === 'viewUrl'
			 || k === 'onlyRows'
			 || k === 'rawResponse'
			 || k === 'onSuccess'
			 || k === 'onError'
			 || typeof(opts[k]) === 'undefined'
			 || opts[k] === null
			 ) { 
			 // Nothing to do
			} else if ( k === 'keys' ) {
				mustBePost = true;
				data[k] = opts[k];
			} else {
				++queryCount;
				query[k] = JSON.stringify( opts[k] );
			};
		};
		
		var dataType = 'json';
		if( opts.rawResponse ) {
			dataType = 'text';
		};
		
		if( mustBePost ) {
			var jsonData = JSON.stringify( data );
			
			var effectiveUrl = viewUrl;
			if( queryCount > 0 ){
				var params = $.param(query);
				effectiveUrl = viewUrl + '?' + params;
			};
			
			$.ajax({
		    	url: effectiveUrl
		    	,type: 'POST'
		    	,async: true
		    	,data: jsonData
		    	,contentType: 'application/json'
		    	,dataType: dataType
		    	,success: processResponse
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
					var errStr = httpJsonError(XMLHttpRequest, textStatus);
		    		opts.onError('Error during view query '+opts.viewName+': '+errStr);
		    	}
			});
			
		} else {
			if( badProxy ){
				query.r = Date.now();
			};

			$.ajax({
		    	url: viewUrl
		    	,type: 'GET'
		    	,async: true
		    	,cache: false
		    	,data: query
		    	,dataType: dataType
		    	,success: processResponse
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
					var errStr = httpJsonError(XMLHttpRequest, textStatus);
		    		opts.onError('Error during view query '+opts.viewName+': '+errStr);
		    	}
			});
		};
		
		function processResponse(queryResponse) {
			if( opts.onlyRows ) {
	    		if( queryResponse.rows ) {
	    			opts.onSuccess(queryResponse.rows);
	    		} else {
		    		opts.onError('Unexpected response during view query '+opts.view);
	    		};
    		} else {
    			// Send the whole response
    			opts.onSuccess(queryResponse);
    		};
		};
	}
});

// =============================================
// Change Notifier
// =============================================

var ChangeNotifier = $n2.Class('couch.ChangeNotifier',{

	changeUrl: null,
	
	include_docs: null,
	
	pollInterval: null,
	
	longPoll: null,
	
	timeout: null,
	
	style: null,
	
	db: null,
	
	listeners: null,
	
	lastSequence: null,

	currentRequest: null,
	
	currentWait: null,
	
	onError: function(err) { $n2.log(err); },

	initialized: null,
	
	initializationListeners: null,

	initialize: function(opts_) {
		var opts = $n2.extend({
			db: null
			,changeUrl: null
			,include_docs: false
			,pollInterval: 5000
			,longPoll: false
			,timeout: 20000
			,style: 'all_docs'
			,listeners: null
			,onSuccess: function(notifier){}
		},opts_);

		var _this = this;
		
		this.initialized = false;
		this.initializationListeners = [];
		this.listeners = [];

		this.db = opts.db;
		this.changeUrl = opts.changeUrl;
		this.include_docs = opts.include_docs;
		this.pollInterval = opts.pollInterval;
		this.longPoll = opts.longPoll;
		this.timeout = opts.timeout;
		this.style = opts.style;

		if( $n2.isArray(opts.listeners) ) {
			opts.listeners.forEach(function(listener){
				if( typeof listener === 'function' ){
					_this.listeners.push( listener );
				};
			});
		};

		if( typeof opts.onSuccess === 'function' ){
			this.initializationListeners.push(opts.onSuccess);
		};
		
		if( opts.doNotReset ) {
			finishInitialization();
		} else {
			this.resetLastSequence({
				onSuccess: finishInitialization
				,onError: function(err){
					$n2.logError('Error while obtaining database update sequence: '+err);
					finishInitialization();
				}
			});
		};
		
		function finishInitialization() {
			_this.reschedule();
			_this.requestChanges();
			
			_this.initialized = true;
			_this.initializationListeners.forEach(function(listener){
				listener(_this);
			});
			_this.initializationListeners = null;
		};
	},

	addListener: function(listener) {
		if( typeof(listener) === 'function' ) {
			this.listeners.push(listener);
			
			this.requestChanges();
		};
	},

	addInitializationListener: function(listener) {
		if( typeof listener === 'function' ) {
			if( this.initialized ){
				listener(this);
			} else {
				this.initializationListeners.push(listener);
			};
		};
	},
	
	/*
	 * This function does not report any changes. Instead, it
	 * updates the last sequence number to the current one. This
	 * means that the next request for changes will report only
	 * changes that have happened since 'now'.
	 */
	resetLastSequence: function(opt_) {
		
		var opt = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opt_);

		var _this = this;
		
		this.db.getChanges({
			limit: 1
			,descending: true
			,onSuccess: function(changes){
				if( changes
				 && changes.last_seq ){
					// In CouchDB 1.x, changes.last_seq is a number
					// In CouchDB 2.x, changes.last_seq is a string
					if( typeof changes.last_seq === 'string' ){
						_this.lastSequence = changes.last_seq;
						//$n2.log('changes.last_seq = '+changes.last_seq);
						//printDbUpdateSeq();
						opt.onSuccess();

					} else if( typeof changes.last_seq === 'number' ){
						_this.lastSequence = ''+changes.last_seq;
						//$n2.log('changes.last_seq = '+changes.last_seq);
						//printDbUpdateSeq();
						opt.onSuccess();

					} else {
						var err = new Error('Error with database change feed. Can not interpret last_seq: '+changes.last_seq);
						opt.onError(err);
					};
				} else {
					
				};
			}
			,onError: function(err){ 
				opt.onError('Error during a query of last update sequence: '+err);
			}
		});
		
//		function printDbUpdateSeq(){
//			_this.db.getInfo({
//		    	onSuccess: function(dbInfo) {
//					// In CouchDB 1.x, update_seq is a number
//					// In CouchDB 2.x, update_seq is a string
//					if( typeof dbInfo.update_seq === 'string' ){
//						$n2.log('dbInfo.update_seq = '+dbInfo.update_seq);
//
//					} else if( typeof dbInfo.update_seq === 'number' ){
//						$n2.log('dbInfo.update_seq = '+dbInfo.update_seq);
//
//					} else {
//						$n2.logError('Error with database information. Can not interpret update_seq: '+dbInfo.update_seq);
//					};
//		    	}
//		    	,onError: function(err) {
//					$n2.logError('Error during a query of current update sequence: '+err);
//		    	}
//			});
//		};
	},
	
	getLastSequence: function(){
		return this.lastSequence;
	},
	
	_reportChanges: function(changes) {
		
		if( typeof changes.last_seq === 'string' ) {
			this.lastSequence = changes.last_seq;
		} else if( typeof changes.last_seq === 'number' ) {
			this.lastSequence = ''+changes.last_seq;
		};
		
		if( changes.results && changes.results.length > 0 ) {
			for(var i=0,e=this.listeners.length; i<e; ++i) {
				this.listeners[i](changes);
			};
		};
	},
	
	/**
		Request the server for changes.
	 */
	requestChanges: function() {
		
		if( !this.listeners 
		 || this.listeners.length < 1 ) {
			// Nothing to do
			return;
		};
		if( this.currentRequest ) {
			// A request already in progress
			return;
		};
		if( this.currentWait ) {
			// Already scheduled
			return;
		};
	
		var req = {
			feed: 'normal'
			,style: this.style
		};
	
		if( this.lastSequence ) {
			req.since = this.lastSequence;
		};
		
		if( this.include_docs ) {
			req.include_docs = this.include_docs;
		};
		
		if( this.longPoll ) {
			req.feed = 'longpoll';
			req.timeout = this.timeout;
		};
		
		if( badProxy ){
			req.r = Date.now();
		};
		
		this.currentRequest = req;
		
		var _this = this;
		
		$.ajax({
	    	url: this.changeUrl
	    	,type: 'GET'
	    	,async: true
	    	,data: req
	    	,dataType: 'json'
	    	,success: function(changes) {
				_this.currentRequest = null;
				
	    		_this._reportChanges(changes);
	    		
	    		_this.reschedule();
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				_this.onError('Error during a server notifications: '+errStr);
	    		_this.reschedule();
	    	}
		});
	},
	
	/**
		Reschedule the next request for changes
	 */
	reschedule: function() {

		var now = $n2.utils.getCurrentTime();
		var expected = now + this.pollInterval;
		
		if( this.currentWait ) {
			// Already waiting
			if( this.currentWait.expected > expected ) {
				// We need to reschedule, earlier
				if( typeof(clearTimeout) === 'function' ) {
					clearTimeout(this.currentWait.timerId);
				}
				this.currentWait = null;
			} else {
				// There is already a timer sufficiently early to
				// handle the request
				return;
			}; 
		};

		// Start a new timeout	
		this.currentWait = {
			delayInMs: this.pollInterval
			,expected: expected
		};
		
		var _this = this;
		
		this.currentWait.timerId = setTimeout(function(){
				_this.currentWait = null;
				_this.requestChanges();
			}
			,this.currentWait.delayInMs
		);
	}
});

//=============================================
// Database Callbacks
//=============================================

var DatabaseCallbacks = $n2.Class('couch.DatabaseCallbacks',{
	
	onCreatedCallbacks: null
	
	,onUpdatedCallbacks: null
	
	,onDeletedCallbacks: null
	
	,initialize: function(){
		this.onCreatedCallbacks = [];
		this.onUpdatedCallbacks = [];
		this.onDeletedCallbacks = [];
	}

	,addOnCreatedCallback: function(f){
		if( typeof(f) === 'function' ) {
			this.onCreatedCallbacks.push(f);
		}
	}

	,addOnUpdatedCallback: function(f){
		if( typeof(f) === 'function' ) {
			this.onUpdatedCallbacks.push(f);
		}
	}

	,addOnDeletedCallback: function(f){
		if( typeof(f) === 'function' ) {
			this.onDeletedCallbacks.push(f);
		}
	}
	
	,_reportOnCreated: function(docInfo){
		for(var i=0,e=this.onCreatedCallbacks.length; i<e; ++i){
			var f = this.onCreatedCallbacks[i];
			f(docInfo);
		};
	}
	
	,_reportOnUpdated: function(docInfo){
		for(var i=0,e=this.onCreatedCallbacks.length; i<e; ++i){
			var f = this.onUpdatedCallbacks[i];
			f(docInfo);
		};
	}
	
	,_reportOnDeleted: function(docInfo){
		for(var i=0,e=this.onDeletedCallbacks.length; i<e; ++i){
			var f = this.onUpdatedCallbacks[i];
			f(docInfo);
		};
	}
});

// =============================================
// Database
// =============================================

var Database = $n2.Class('couch.Database',{
	
	dbUrl: null
	
	,dbName: null
	
	,server: null
	
	,callbacks: null
	
	,changeNotifier: null
	
	,changeNotifierRefreshIntervalInMs: null
	
	,initialize: function(opts_, server_) {
		var opts = $n2.extend({
			dbUrl: null
			,dbName: null
			,changeNotifierRefreshIntervalInMs: 5000
		},opts_);
	
		this.server = server_;
		
		this.dbUrl = opts.dbUrl;
		this.dbName = opts.dbName;
		this.changeNotifierRefreshIntervalInMs = opts.changeNotifierRefreshIntervalInMs;
		
		if( !this.dbUrl ) {
			var pathToServer = server_.getPathToServer();
			this.dbUrl = pathToServer + this.dbName + '/';
		};
		
		this.callbacks = new DatabaseCallbacks();
	}

	,getUrl: function(){
		return this.dbUrl;
	}
	
	,getServer: function(){
		return this.server;
	}
	
	,getDesignDoc: function(opts_) {
		var ddOpts = $.extend({
				ddUrl: null
				,ddName: null
			}
			,opts_
		);
		
		if( typeof ddOpts.ddUrl !== 'string' ) {
			if( typeof ddOpts.ddName !== 'string' ){
				throw new Error('Database.getDesignDoc() must specify ddName as a string if ddUrl is not');
			};
			ddOpts.ddUrl = this.dbUrl + '_design/' + ddOpts.ddName + '/';
		};
		
		ddOpts.db = this;
		
		return new designDoc(ddOpts);
	}
	
	,getChangeNotifier: function(opts_) {
		var opts = $n2.extend({
			onSuccess: function(notifier){}
		},opts_);
		
		if( !this.changeNotifier ){
			this.changeNotifier = new ChangeNotifier({
				db: this
				,changeUrl: this.dbUrl + '_changes'
				,pollInterval: this.changeNotifierRefreshIntervalInMs
				,onSuccess: opts.onSuccess
			});
		} else {
			this.changeNotifier.addInitializationListener(opts.onSuccess);
		};
			
		return this.changeNotifier;
	},
	
	/*
	 	What is returned looks like:
		{
		   "last_seq": "104-g1AAAAJjeJyd0ksKwjAQANBgBX8oFA-gJ5Am6ces7E10JmkpperKtd5Eb6I30ZvUfLpwUYSWwARmmAfDTEUIGReeIr48X2ShMKUs2QT60UqXBkBwVdd1WXiwPOrEKICcRlnY1vCHwbWOuGukhZVCJkQeYFcpNdK-kWZOyjAHuu0qHYx0baSplRjnDKXoKJ2GOpKb_jR2N9rEaoJzEUM_7eG0p9F8q9EwgwS6Tum0l9PeRpu7SZWkHKJe2sdpPxuImUKRtF5F-QUbHp8f",
		   "pending": 0,
		   "results": [
		      {
		         "seq": "1-g1AAAAF1eJzLYWBg4MhgTmEQTM4vTc5ISXIwNDLXMwBCwxygFFMiQ5L8____szKYExlzgQLsBolphqapJtg04DEmSQFIJtmDTEpkwKfOAaQunrC6BJC6eoLq8liAJEMDkAIqnU-M2gUQtfuJUXsAovY-MWofQNSC3JsFAMjHZqY",
		         "id": "module.map.label",
		         "changes": [
		            {
		               "rev": "1-6a63a7493382323b2db86a85ae4b518d"
		            }
		         ]
		      },
		      ...
		      {
		         "seq": "104-g1AAAAJjeJyd0ksKwjAQANBgBX8oFA-gJ5Am6ces7E10JmkpperKtd5Eb6I30ZvUfLpwUYSWwARmmAfDTEUIGReeIr48X2ShMKUs2QT60UqXBkBwVdd1WXiwPOrEKICcRlnY1vCHwbWOuGukhZVCJkQeYFcpNdK-kWZOyjAHuu0qHYx0baSplRjnDKXoKJ2GOpKb_jR2N9rEaoJzEUM_7eG0p9F8q9EwgwS6Tum0l9PeRpu7SZWkHKJe2sdpPxuImUKRtF5F-QUbHp8f",
		         "id": "org.nunaliit.css.body",
		         "deleted": true
		         "changes": [
		            {
		               "rev": "1-c6d43bc49dbc259ecc8a9f75d82119df"
		            }
		         ]
		      }
		   ]
		}
		
		In CouchDB 1.x, last_seq is a number
		In CouchDB 2.x, last_seq is a string
	 */
	getChanges: function(opt_) {
		var opt = $n2.extend({
			since: undefined
			,limit: undefined
			,descending: false
			,include_docs: false
			,onSuccess: function(changes){}
			,onError: function(msg){ $n2.reportErrorForced(msg); }
		},opt_);
		
		var req = {
			feed: 'normal'
		};
	
		if( opt.since ) {
			req.since = opt.since;
		};
		
		if( opt.limit ) {
			req.limit = opt.limit;
		};
		
		if( opt.descending ) {
			req.descending = opt.descending;
		};
		
		if( opt.include_docs ) {
			req.include_docs = opt.include_docs;
		};
		
		if( badProxy ){
			req.r = Date.now();
		};
		
		var changeUrl = this.dbUrl + '_changes';

		$.ajax({
	    	url: changeUrl
	    	,type: 'GET'
	    	,async: true
	    	,data: req
	    	,dataType: 'json'
	    	,success: opt.onSuccess
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				opt.onError('Error obtaining database changes: '+errStr);
	    	}
		});
	}

	,getDocumentUrl: function(doc) {
		
		if( typeof(doc) === 'string' ) {
			var docId = doc;
		} else {
			docId = doc._id;
		};
		
		return this.dbUrl + docId;
	}

	,getAttachmentUrl: function(doc,attName) {
		
		var docUrl = this.getDocumentUrl(doc);
		var url = docUrl + '/' + encodeURIComponent(attName);
		
		return url;
	}
	
	,getDocumentRevision: function(opts_) {
		var opts = $.extend({
				docId: null
				,onSuccess: function(info){}
				,onError: function(msg){ $n2.reportErrorForced(msg); }
			}
			,opts_
		);
		
		if( !opts.docId ) {
			opts.onError('No docId set. Can not retrieve document information');
			return;
		};
		
		var data = {
    		startkey: '"' + opts.docId + '"'
    		,endkey: '"' + opts.docId + '"'
    		,include_docs: false
    	};
		
		if( badProxy ){
			data.r = Date.now();
		};

	    $.ajax({
	    	url: this.dbUrl + '_all_docs'
	    	,type: 'get'
	    	,async: true
	    	,data: data
	    	,dataType: 'json'
	    	,success: function(res) {
	    		if( res.rows && res.rows[0] && res.rows[0].value && res.rows[0].value.rev ) {
	    			opts.onSuccess(res.rows[0].value.rev);
	    		} else {
					opts.onError('Malformed document revision for: '+opts.docId);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				opts.onError('Error obtaining document revision for '+opts.docId+': '+errStr);
	    	}
	    });
	}
	
	,getDocumentRevisions: function(opts_) {
		var opts = $.extend({
				docIds: null
				,onSuccess: function(info){}
				,onError: function(msg){ $n2.reportErrorForced(msg); }
			}
			,opts_
		);
		
		if( !opts.docIds ) {
			opts.onError('No docIds set. Can not retrieve document revisions');
			return;
		};
		if( !$n2.isArray(opts.docIds) ) {
			opts.onError('docIds must ba an array. Can not retrieve document revisions');
			return;
		};

		var data = {
			keys: opts.docIds
		};
		
	    $.ajax({
	    	url: this.dbUrl + '_all_docs?include_docs=false'
	    	,type: 'POST'
	    	,async: true
	    	,data: JSON.stringify(data)
	    	,contentType: 'application/json'
	    	,dataType: 'json'
	    	,success: function(res) {
	    		if( res.rows ) {
	    			var info = {};
    				for(var i=0,e=res.rows.length; i<e; ++i){
    					var row = res.rows[i];
    					if( row.id && row.value && row.value.rev ){
    						if( !row.value.deleted ) {
    							info[row.id] = row.value.rev;
    						};
    					};
    				};
	    			opts.onSuccess(info);
	    		} else {
					opts.onError('Malformed document revisions');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				opts.onError('Error obtaining document revision for '+opts.docId+': '+errStr);
	    	}
	    });
	}
	
	,buildUploadFileForm: function(jQuerySet, options_) {
		var _this = this;
		
		var opts = $.extend({
				docId: null
				,rev: null
				,doc: null
				,onSuccess: function(res){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		// Empty jQuerySet
		jQuerySet.empty();
		
		// This works only if jquery.form is available
		if( !$.fn.ajaxSubmit ) {
			opts.onError('Can not perform file uploads unless jquery.form.js is included');
		};
		
		if( null == opts.docId ) {
			if( opts.doc ) opts.docId = opts.doc._id;
		};
		if( null == opts.docId ) {
			opts.onError('Must specify document id when performing file uploads');
		};
		
		// Get revision for document
		if( null == opts.rev ) {
			if( opts.doc ) opts.rev = opts.doc._rev;
		};
		if( null == opts.rev ) {
			this.getDocumentRevision({
				docId: opts.docId
				,onSuccess: function(docRev){
					jQuerySet.each(function(i, elem){
						installForm(elem, opts.docId, docRev);
					});
				}
				,onError: opts.onError
			});
		} else {
			jQuerySet.each(function(i, elem){
				installForm(elem, opts.docId, opts.rev);
			});
		};
		
		function installForm(elem, docId, docRev) {
			var $elem = $(elem)
				,$form = $('<form method="post"></form>')
				,$button = $('<input class="n2CouchInputButton" type="button"/>')
				;
			$form.append( $('<input class="n2CouchInputFile" type="file" name="_attachments"/>') );
			$form.append( $('<input type="hidden" name="_rev" value="'+docRev+'"/>') );
			$button.val( _loc('Upload') );
			$form.append( $button );
			$elem.append($form);
			
			$button.click(function(){
				$form.ajaxSubmit({
					type: 'post'
					,url: _this.dbUrl + docId
					,dataType: 'json'
					,success: function(res) {
						$elem.find('*').removeAttr('disabled');
						if( res.error ) {
							opts.onError(_loc('Error while uploading: ')+res.error,options_);
						} else {
							opts.onSuccess(res,options_);
						}
					}
					,error: function(xhr, status, err) {
						$elem.find('*').removeAttr('disabled');
						opts.onError(_loc('Error while uploading: ')+err,options_);
					}
				});
				
				// Disable elements while file is uploading
				$elem.find('.n2CouchInputButton').attr('disabled','disabled');
			});
		};
	}
	
	,createDocument: function(options_) {
		var opts = $.extend(true, {
				data: {}
				,deviceId: undefined // custom for submissionDb
				,onSuccess: function(docInfo){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		if( JSON && JSON.stringify ) {
			// OK
		} else {
			opts.onError('json.js is required to create database documents');
		};
		
		var _s = this;
		
		// Device id for submission DB
		var deviceIdStr = '';
		if( opts.deviceId ){
			deviceIdStr = '?deviceId='+opts.deviceId;
		};
		
		var docId = opts.data._id;
		if( docId ) {
			// If _id was specified
			onUuid(docId);
		} else {
			this.server.getUniqueId({
				onSuccess: onUuid
				,onError: opts.onError
			});
		};
		
		function onUuid(docId){
			$.ajax({
		    	url: _s.dbUrl + docId + deviceIdStr
		    	,type: 'put'
		    	,async: true
		    	,data: JSON.stringify(opts.data)
		    	,contentType: 'application/json'
		    	,dataType: 'json'
		    	,success: function(docInfo) {
		    		_s.callbacks._reportOnCreated(docInfo);
		    		opts.onSuccess(docInfo);
		    	}
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
					var cause = httpJsonError(XMLHttpRequest, textStatus);
					var err = $n2.error.fromString(_loc('Error creating document'),cause);
		    		opts.onError(err);
		    	}
			});
		};
	}
	
	,updateDocument: function(options_) {
		var opts = $.extend(true, {
				data: null
				,deviceId: undefined // custom for submissionDb
				,onSuccess: function(docInfo){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		if( !JSON || typeof(JSON.stringify) !== 'function' ) {
			opts.onError('json.js is required to update database documents');
			return;
		};
		
		if( !opts.data || !opts.data._id || !opts.data._rev ) {
			opts.onError('On update, a valid document with _id and _rev attributes must be supplied');
			return;
		};
		
		// Device id for submission DB
		var deviceIdStr = '';
		if( opts.deviceId ){
			deviceIdStr = '?deviceId='+opts.deviceId;
		};
		
		var _s = this;
		
		$.ajax({
	    	url: _s.dbUrl + opts.data._id + deviceIdStr
	    	,type: 'PUT'
	    	,async: true
	    	,data: JSON.stringify(opts.data)
	    	,contentType: 'application/json'
	    	,dataType: 'json'
	    	,success: function(docInfo) {
	    		_s.callbacks._reportOnUpdated(docInfo);
	    		opts.onSuccess(docInfo);
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var cause = httpJsonError(XMLHttpRequest, textStatus);
				var err = $n2.error.fromString(_loc('Error updating document'),cause);
	    		opts.onError(err);
	    	}
		});
	}
	
	,deleteDocument: function(options_) {
		var opts = $.extend(true, {
				data: null
				,deviceId: undefined // custom for submissionDb
				,onSuccess: function(docInfo){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		if( !JSON || typeof(JSON.stringify) !== 'function' ) {
			opts.onError('json.js is required to delete database documents');
			return;
		};
		
		if( !opts.data || !opts.data._id || !opts.data._rev ) {
			opts.onError('On delete, a valid document with _id and _rev attributes must be supplied');
			return;
		};
		
		// Device id for submission DB
		var deviceIdStr = '';
		if( opts.deviceId ){
			deviceIdStr = '&deviceId='+opts.deviceId;
		};
		
		var _s = this;
		
		$.ajax({
	    	url: _s.dbUrl + opts.data._id + '?rev=' + opts.data._rev + deviceIdStr
	    	,type: 'DELETE'
	    	,async: true
	    	,dataType: 'json'
	    	,success: function(docInfo) {
	    		_s.callbacks._reportOnDeleted(docInfo);
	    		opts.onSuccess(docInfo);
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var cause = httpJsonError(XMLHttpRequest, textStatus);
				var err = $n2.error.fromString(_loc('Error deleting document'),cause);
	    		opts.onError(err);
	    	}
		});
	}
	
	/**
		Inserts and/or updates a number of documents
	 	@name bulkDocuments
	 	@function
	 	@memberOf nunaliit2.couch.Database
	 	@param {Array} documents Array of documents
	 	@param {Object} options_ Options associated with operations
	 
	 */
	,bulkDocuments: function(documents, options_) {
		var opts = $.extend(true, {
				onSuccess: function(docInfos){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		if( JSON && JSON.stringify ) {
			// OK
		} else {
			opts.onError('json.js is required to create database documents');
		};
		
		var data = JSON.stringify({ docs: documents });
		
		var _s = this;

		// Bulk documents operations use POST		
		$.ajax({
	    	url: _s.dbUrl + '_bulk_docs'
	    	,type: 'POST'
	    	,async: true
	    	,data: data
	    	,contentType: 'application/json'
	    	,dataType: 'json'
	    	,success: function(docInfos) {
	    		opts.onSuccess(docInfos);
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error on bulk document operation: '+errStr);
	    	}
		});
	}
	
	,getDocument: function(options_) {
		var opts = $.extend(true, {
				docId: null
				,rev: null
				,revs_info: false
				,revisions: false
				,conflicts: false
				,deleted_conflicts: false
				,onSuccess: function(doc){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		if( !opts.docId ) {
			opts.onError('No docId set. Can not retrieve document');
		};
		
		var data = {};
		
		if( opts.rev ) {
			data.rev = opts.rev;
		};
		
		if( opts.revs_info ) {
			data.revs_info = 'true';
		};
		
		if( opts.revisions ) {
			data.revs = 'true';
		};

		if( opts.conflicts ) {
			data.conflicts = 'true';
		};

		if( opts.deleted_conflicts ) {
			data.deleted_conflicts = 'true';
		};
		
		if( badProxy ){
			data.r = Date.now();
		}
		
		var url = this.dbUrl + opts.docId;
		
	    $.ajax({
	    	url: url
	    	,type: 'get'
	    	,async: true
	    	,data: data
	    	,dataType: 'json'
	    	,success: function(res) {
	    		opts.onSuccess(res);
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error obtaining document content for '+opts.docId+': '+errStr);
	    	}
	    });
	}

	,getDocuments: function(opts_) {
		var opts = $.extend(true, {
				docIds: null
				,onSuccess: function(docs){}
				,onError: function(errorMsg){ $n2.log(errorMsg); }
			}
			,opts_
		);
		
		if( JSON && JSON.stringify ) {
			// OK
		} else {
			opts.onError('json.js is required to query multiple documents');
			return;
		};
		
		if( !opts.docIds ) {
			opts.onError('No docIds set. Can not retrieve documents');
			return;
		};
		
		var viewUrl = this.dbUrl + '_all_docs?include_docs=true';
		
		var data = {
			keys: opts.docIds // requires POST
		};
		
		$.ajax({
	    	url: viewUrl
	    	,type: 'POST'
	    	,async: true
	    	,data: JSON.stringify(data)
	    	,contentType: 'application/json'
	    	,dataType: 'json'
	    	,success: function(queryResult) {
	    		if( queryResult.rows ) {
	    			var docs = [];
	    			for(var i=0,e=queryResult.rows.length; i<e; ++i) {
	    				var row = queryResult.rows[i];
	    				if( row && row.doc ) {
	    					docs.push(row.doc);
	    				}
	    			};
	    			opts.onSuccess(docs);
	    		} else {
		    		opts.onError('Unexpected response during query of multiple documents');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during query of multiple documents: '+errStr);
	    	}
		});
	}

	,listAllDocuments: function(opts_) {
		var opts = $.extend(true, {
				onSuccess: function(docIds){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,opts_
		);
		
		var viewUrl = this.dbUrl + '_all_docs?include_docs=false';
		
		if( badProxy ){
			viewUrl += '&r=' + Date.now();
		};
		
		$.ajax({
	    	url: viewUrl
	    	,type: 'GET'
	    	,async: true
	    	,dataType: 'json'
	    	,success: function(queryResult) {
	    		if( queryResult.rows ) {
	    			var docIds = [];
	    			for(var i=0,e=queryResult.rows.length; i<e; ++i) {
	    				var row = queryResult.rows[i];
	    				if( row && row.id ) {
	    					docIds.push(row.id);
	    				}
	    			};
	    			opts.onSuccess(docIds);
	    		} else {
		    		opts.onError('Unexpected response during listing of all documents');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during listing of all documents: '+errStr);
	    	}
		});
	}

	,getAllDocuments: function(opts_) {
		var opts = $.extend(true, {
				startkey: null
				,endkey: null
				,onSuccess: function(docs){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,opts_
		);

		if( JSON && JSON.stringify ) {
			// OK
		} else {
			opts.onError('json.js is required to query a view');
		};
		
		var data = {
			include_docs: true
		};
		for(var k in opts) {
			if( null === opts[k] ){
				// Ignore

			} else if( k === 'startkey' 
					|| k === 'endkey' ) { 
				data[k] = JSON.stringify( opts[k] );
			};
		};
		
		var viewUrl = this.dbUrl + '_all_docs';
		
		if( badProxy ){
			data.r = Date.now();
		};
		
		$.ajax({
	    	url: viewUrl
	    	,type: 'GET'
	    	,async: true
	    	,data: data
	    	,dataType: 'json'
	    	,success: function(queryResult) {
	    		if( queryResult.rows ) {
	    			var docs = [];
	    			for(var i=0,e=queryResult.rows.length; i<e; ++i) {
	    				var row = queryResult.rows[i];
	    				if( row && row.doc ) {
	    					docs.push(row.doc);
	    				};
	    			};
	    			opts.onSuccess(docs);
	    		} else {
		    		opts.onError('Unexpected response during retrieval of all documents');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during retrieval of all documents: '+errStr);
	    	}
		});
	}
	
	,getInfo: function(opts_) {
		var opts = $.extend(true, {
				onSuccess: function(dbInfo){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,opts_
		);
		
		var data = {};
		
		if( badProxy ){
			data.r = Date.now();
		};
		
		$.ajax({
	    	url: this.dbUrl
	    	,type: 'GET'
	    	,async: true
	    	,dataType: 'json'
	    	,data: data
	    	,success: function(dbInfo) {
	    		if( dbInfo.error ) {
		    		opts.onError(dbInfo.error);
	    		} else {
		    		opts.onSuccess(dbInfo);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during databse infro: '+errStr);
	    	}
		});
	}
	
	,queryTemporaryView: function(opts_){
		var opts = $n2.extend({
			map: null
			,reduce: null
			,onSuccess: function(rows){}
			,onError: $n2.reportErrorForced
		},opts_);

		if( !opts.map ) {
			opts.onError('"map" must be provided in temporary view');
		};
		
		var data = {
			map: opts.map
		};
		
		if( opts.reduce ) {
			data.reduce = opts.reduce;
		};
			
		var viewUrl = this.dbUrl + '_temp_view';
		
		$.ajax({
	    	url: viewUrl
	    	,type: 'post'
	    	,async: true
	    	,dataType: 'json'
	    	,data: JSON.stringify( data )
	    	,contentType: 'application/json'
	    	,success: function(queryResult) {
	    		if( queryResult.rows ) {
	    			opts.onSuccess(queryResult.rows);
	    		} else {
		    		opts.onError('Unexpected response during query of temporary view');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during query temporary view: '+errStr);
	    	}
		});
	}
});

//=============================================
// User DB
//=============================================

var UserDb = $n2.Class('couch.UserDb',Database,{
	
	initialize: function(server_,dbName_){
		if( !dbName_ ){
			dbName = '_users';
		};
		Database.prototype.initialize.call(this,{dbName:dbName_},server_);
	}
	
	,createUser: function(opts_) {
		var opts = $.extend({
				name: null
				,password: null
				,onSuccess: function(docInfo) {}
				,onError: $n2.reportErrorForced
			}
			,opts_
		);

		var userDbUrl = this.getUrl();

		// Check that JSON is installed
		if( !JSON || typeof(JSON.stringify) !== 'function' ) {
			opts.onError('json.js is required to create database documents');
			return;
		};
	
	    this.server.getUniqueId({
			onSuccess: onUuid
	    });
	    
	    function onUuid(uuid) {
			var id = 'org.couchdb.user:'+fixUserName(opts.name);
			var salt = uuid;
			var password_sha = $n2.crypto.hex_sha1(opts.password + salt);
		
			// Create user document
			var doc = {};
			for(var key in opts) {
				if( key !== 'name' 
				 && key !== 'password' 
				 && key !== 'onSuccess' 
				 && key !== 'onError' 
				 ) {
					doc[key] = opts[key];
				};
			};
			doc.type = "user";
			doc.name = fixUserName(opts.name);
			doc.password_sha = password_sha;
			doc.salt = salt;
			if( !$n2.isArray(doc.roles) ) {
				doc.roles = [];
			};
			
			$.ajax({
		    	url: userDbUrl + id
	    		,type: 'put'
	    		,async: true
		    	,data: JSON.stringify(doc)
		    	,contentType: 'application/json'
	    		,dataType: 'json'
	    		,success: opts.onSuccess
	    		,error: function(XMLHttpRequest, textStatus, errorThrown) {
					var errStr = httpJsonError(XMLHttpRequest, textStatus);
		    		opts.onError('Error during user creation: '+errStr);
		    	}
			});
		};
	}
	
	,updateUser: function(options_) {
		var opts = $.extend(true, {
				user: null
				,onSuccess: function(docInfo){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);

		var userDbUrl = this.getUrl();
		
		if( !JSON || typeof(JSON.stringify) !== 'function' ) {
			opts.onError('json.js is required to update user documents');
			return;
		};
		
		if( !opts.user || !opts.user._id ) {
			opts.onError('On update, a valid document with _id attribute must be supplied');
			return;
		};
		
		$.ajax({
	    	url: userDbUrl + opts.user._id
	    	,type: 'PUT'
	    	,async: true
	    	,data: JSON.stringify(opts.user)
	    	,contentType: 'application/json'
	    	,dataType: 'json'
	    	,success: function(docInfo) {
	    		opts.onSuccess(docInfo);
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error updating user: '+errStr);
	    	}
		});
	}

	,setUserPassword: function(options_) {
		var opts = $.extend(true, {
				user: null
				,password: null
				,onSuccess: function(docInfo){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);

		var userDbUrl = this.getUrl();

		if( !JSON || typeof(JSON.stringify) !== 'function' ) {
			opts.onError('json.js is required to set user password');
			return;
		};
		
		if( !opts.user || !opts.user._id || !opts.user._rev ) {
			opts.onError('On password change, a valid user document with _id and _rev attributes must be supplied');
			return;
		};
		
		if( !opts.password ) {
			opts.onError('On password change, a valid password must be supplied');
			return;
		};
		
		this.computeUserPassword({
			userDoc: opts.user
			,password: opts.password
			,onSuccess: function(userDoc){
				$.ajax({
			    	url: userDbUrl + opts.user._id
			    	,type: 'PUT'
			    	,async: true
			    	,data: JSON.stringify(userDoc)
			    	,contentType: 'application/json'
			    	,dataType: 'json'
			    	,success: function(docInfo) {
			    		opts.onSuccess(docInfo);
			    	}
			    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
						var errStr = httpJsonError(XMLHttpRequest, textStatus);
			    		opts.onError('Error changing user password: '+errStr);
			    	}
				});
			}
			,onError: opts.onError
		});
	}

	,computeUserPassword: function(options_) {
		var opts = $.extend({
				userDoc: null
				,password: null
				,onSuccess: function(userDoc){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);

		if( !JSON || typeof(JSON.stringify) !== 'function' ) {
			opts.onError('json.js is required to set user password');
			return;
		};
		
		if( !opts.userDoc ) {
			opts.onError('On setting password, a user document must be provided');
			return;
		};
		
		if( !opts.password ) {
			opts.onError('On setting change, a valid password must be supplied');
			return;
		};
		
	    this.server.getUniqueId({
			onSuccess: onUuid
	    });
	    
	    function onUuid(uuid) {
			var salt = uuid;
			var password_sha = $n2.crypto.hex_sha1(opts.password + salt);
			
			// Remove unwanted fields
			if( opts.userDoc.password ) delete opts.userDoc.password;
			if( opts.userDoc.password_scheme ) delete opts.userDoc.password_scheme;
			if( opts.userDoc.iterations ) delete opts.userDoc.iterations;
			if( opts.userDoc.derived_key ) delete opts.userDoc.derived_key;
			if( opts.userDoc.salt ) delete opts.userDoc.salt;
			if( opts.userDoc.password_sha ) delete opts.userDoc.password_sha;
		
			// Update user document
			opts.userDoc.password_sha = password_sha;
			opts.userDoc.salt = salt;

			opts.onSuccess(opts.userDoc);
		};
	}
	
	,deleteUser: function(opts_) {
		var opts = $.extend({
				user: null // a user document (do not need to specify id, rev)
				,id: null
				,rev: null
				,name: null
				,onSuccess: function(docInfo) {}
				,onError: $n2.reportErrorForced
			}
			,opts_
		);
		var userDbUrl = this.getUrl();

		var id = null;
		var rev = null;
		if( opts.user ) {
			id = opts.user._id;
			rev = opts.user._rev;
		}
		
		if( !id && opts.id ) {
			id = opts.id;
		}
		
		if( !id && opts.name ) {
			id = 'org.couchdb.user:'+fixUserName(opts.name);
		}
		if( !rev && opts.rev ) {
			rev = opts.rev;
		}
		
		$.ajax({
	    	url: userDbUrl + id + '?rev=' + rev 
 		,type: 'DELETE'
 		,async: true
 		,dataType: 'json'
 		,success: opts.onSuccess
 		,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during user deletion: '+errStr);
	    	}
		});
	}
	
	,getUser: function(options_) {
		var opts = $.extend(true, {
				name: null
				,id: null
				,onSuccess: function(user){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		var userDbUrl = this.getUrl();
		
		var id = opts.id;
		if( !id ) {
			id = 'org.couchdb.user:'+fixUserName(opts.name);
		};
		
		var data = {};
		
		if( badProxy ){
			data.r = Date.now();
		};
		
	    $.ajax({
	    	url: userDbUrl + id 
	    	,type: 'get'
	    	,async: true
	    	,dataType: 'json'
	    	,data: data
	    	,success: function(userDoc) {
	    		opts.onSuccess(userDoc);
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError( _loc('Error obtaining user document for {id}: {err}',{
	    			id: id
	    			,err: errStr
	    		}) );
	    	}
	    });
	}
	
	,getUsers: function(options_) {
		var opts = $.extend(true, {
				names: null
				,ids: null
				,onSuccess: function(users){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		var _this = this;
		
		var effectiveUrl = this.getUrl() + '_all_docs?include_docs=true';
		
		var ids = null;
		if( opts.ids && opts.ids.length ){
			ids = opts.ids.slice(0); // clone
		} else {
			ids = [];
		};
		if( opts.names && opts.names.length ) {
			for(var i=0,e=opts.names.length; i<e; ++i) {
				ids.push('org.couchdb.user:'+fixUserName(opts.names[i]));
			};
		};
		
		if( JSON && JSON.stringify ) {
			// OK
		} else {
			opts.onError('json.js is required to query multiple users');
			return;
		};
		
		var data = {
			keys: ids // requires POST
		};
		
		var users = [];
		var missingIds = {};
	    $.ajax({
	    	url: effectiveUrl
	    	,type: 'POST'
	    	,async: true
	    	,data: JSON.stringify(data)
	    	,contentType: 'application/json'
	    	,dataType: 'json'
	    	,success: function(res) {
	    		if( res.rows ) {
	    			var isMissing = false;
	    			for(var i=0,e=res.rows.length; i<e; ++i) {
	    				var row = res.rows[i];
	    				if( row && row.doc ) {
	    					if( row.doc._id ){
		    					users.push(row.doc);
	    					} else {
	    						// Work around for bug in CouchDB 1.4.0
	    						// https://issues.apache.org/jira/browse/COUCHDB-1888
	    						// Keep a list of dacuments returned without preperties and
	    						// try to retrieve them one at a time
	    						isMissing = true;
	    						missingIds[row.id] = true;
	    						retrieveUser(row.id);
	    					};
	    				}
	    			};
	    			if( !isMissing ){
	    				// All documents available. Simply return to caller
		    			opts.onSuccess(users);
	    			};
	    		} else {
		    		opts.onError('Unexpected response during query of multiple users');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during query of multiple users: '+errStr);
	    	}
	    });
		
		function retrieveUser(userId){
			_this.getUser({
				id: userId
				,onSuccess: function(user){
					if( user._id ){
						users.push(user);
					};
					delete missingIds[userId];
					returnUsers();
				}
				,onError: function(errorMsg){
					delete missingIds[userId];
					returnUsers();
				}
			});
		};
		
		function returnUsers(){
			for(var id in missingIds){
				// still waiting for some documents to be returned
				return id; // return id to remove warning
			};
			opts.onSuccess(users);
		};
	}

	,getAllUsers: function(opts_) {
		var opts = $.extend({
				onSuccess: function(users) {}
				,onError: $n2.reportErrorForced
			}
			,opts_
		);
		
		var _this = this;
		
		if( JSON && JSON.stringify ) {
			// OK
		} else {
			opts.onError('json.js is required to query a view');
			return;
		};
		
		var viewUrl = this.getUrl() + '_all_docs';
		
		var data = {
			startkey: JSON.stringify('org.couchdb.user:')
			,endkey: JSON.stringify('org.couchdb.user=')
			,include_docs: true
		};
		
		if( badProxy ){
			data.r = Date.now();
		};
		
		var users = [];
		var missingIds = {};
		$.ajax({
	    	url: viewUrl
	    	,type: 'get'
	    	,async: true
	    	,data: data
	    	,dataType: 'json'
	    	,success: function(queryResult) {
	    		if( queryResult.rows ) {
	    			var isMissing = false;
	    			for(var i=0,e=queryResult.rows.length; i<e; ++i) {
	    				var row = queryResult.rows[i];
	    				if( row && row.doc ) {
	    					if( row.doc._id ){
		    					users.push(row.doc);
	    					} else {
	    						// Work around for bug in CouchDB 1.4.0
	    						// https://issues.apache.org/jira/browse/COUCHDB-1888
	    						// Keep a list of dacuments returned without preperties and
	    						// try to retrieve them one at a time
	    						isMissing = true;
	    						missingIds[row.id] = true;
	    						retrieveUser(row.id);
	    					};
	    				}
	    			};
	    			if( !isMissing ){
	    				// All documents available. Simply return to caller
		    			opts.onSuccess(users);
	    			};
	    		} else {
		    		opts.onError('Unexpected response during query of all users');
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error during query of all users: '+errStr);
	    	}
		});
		
		function retrieveUser(userId){
			_this.getUser({
				id: userId
				,onSuccess: function(user){
					if( user._id ){
						users.push(user);
					};
					delete missingIds[userId];
					returnUsers();
				}
				,onError: function(errorMsg){
					delete missingIds[userId];
					returnUsers();
				}
			});
		};
		
		function returnUsers(){
			for(var id in missingIds){
				// still waiting for some documents to be returned
				return id; // return id to remove warning
			};
			opts.onSuccess(users);
		};
	}
});

// =============================================
// Server
// =============================================

var Server = $n2.Class('couch.Server',{
	
	options: null
	
	,isInitialized: false
	
	,uuids: null
	
	,userDbName: null
	
	,userDb: null
	
	,session: null
	
	,initListeners: null

	,initialize: function(options_, initListeners_){
		this.options = $n2.extend({
				pathToServer: '../'
				,pathToSession: null
				,pathToUserDb: null
				,pathToUuids: null
				,pathToReplicate: null
				,pathToActiveTasks: null
				,pathToAllDbs: null
				,version: null
				,skipSessionInitialization: false
				,userDbName: null
				,onSuccess: function(server){}
				,onError: function(err){}
			}
			,options_
		);
	
		this.isInitialized = false;
		this.uuids = [];
		this.userDbName = this.options.userDbName;
		this.userDb = null;
		this.session = null;
		this.initListeners = initListeners_;
		if( !this.initListeners ) {
			this.initListeners = [];
		};

		var _this = this;

		getServerVersion();
		
		function getServerVersion() {
			if( _this.options.version ) {
				// Do not need to get version, it was specified
				refreshContext();

			} else {
				var data = {};
				
				if( badProxy ){
					data.r = Date.now();
				};
				
				$.ajax({
			    	url: _this.options.pathToServer
			    	,type: 'get'
			    	,async: true
			    	,dataType: 'json'
			    	,data: data
			    	,success: function(res) {
			    		if( res.version ) {
			    			_this.options.version = res.version;
			    			
			    			// Now, refresh context
			    			getUserDbName();
			    			
			    		} else {
			    			errorInitialize('Malformed database welcome message.');
			    		};
			    	}
			    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
						var errStr = httpJsonError(XMLHttpRequest, textStatus);
						errorInitialize('Error obtaining database welcome: '+errStr);
			    	}
				});
			};
		};
		
		function getUserDbName(){
			if( null != _this.userDbName ){
				// User Db Name provided, no need to look for it
				refreshContext(null);
				
			} else {
				var sessionUrl = _this.getSessionUrl();
				
				var data = {};
				
				if( badProxy ){
					data.r = Date.now();
				};
				
				$.ajax({
			    	url: sessionUrl
			    	,type: 'get'
			    	,async: true
			    	,dataType: 'json'
			    	,data: data
			    	,success: function(res) {
			    		if( res.ok ) {
			    			// Retrieve user db, if available
			    			if( res && res.info && res.info.authentication_db ) {
			    				_this.userDbName = res.info.authentication_db;
			    			};

			    			refreshContext(res);
			    			
			    		} else {
			    			errorInitialize('Malformed session information message.');
			    		};
			    	}
			    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
						var errStr = httpJsonError(XMLHttpRequest, textStatus);
						errorInitialize('Error obtaining session information: '+errStr);
			    	}
				});
			};
		}
		
		function refreshContext(sessionInfo) {
			if( _this.options.skipSessionInitialization ) {
				finishInitialize();
				
			} else {
				_this.getSession().refreshContext({
					onSuccess: finishInitialize
					,onError: errorInitialize
				});
			};
		};
		
		function finishInitialize() {
			_this.isInitialized = true;
			
			// Call back all listeners
			for(var i=0,e=_this.initListeners; i<e; ++i) {
				var listener = _this.initListeners[i];
				try { listener(); } catch(e){}
			};
			_this.initListeners = [];
			
			_this.options.onSuccess(_this);
			
			// release callbacks
			delete _this.options['onSuccess'];
			delete _this.options['onError'];
		};
		
		function errorInitialize(err) {
			_this.options.onError(err);
			
			// release callbacks
			delete _this.options['onSuccess'];
			delete _this.options['onError'];
		};
	}

	,getPathToServer: function() {
		return this.options.pathToServer;
	}

	,getVersion: function() { return this.options.version; }
	
	,getReplicateUrl: function() {
		if( null == this.options.pathToReplicate ) {
			return this.options.pathToServer + '_replicate';
		}
		
		return this.options.pathToReplicate; 
	}
	
	,getActiveTasksUrl: function() {
		if( null == this.options.pathToActiveTasks ) {
			return this.options.pathToServer + '_active_tasks';
		}
		
		return this.options.pathToActiveTasks; 
	}
	
	,getSessionUrl: function() {
		var result = this.options.pathToSession;
		if( !result ) {
			result = this.options.pathToServer + '_session';
		};
		return result;
	}
	
	,getUniqueId: function(options_) {
		var opts = $.extend({
				onSuccess: function(uuid){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);
		
		var _this = this;
		
		if( this.uuids.length > 0 ) {
			var uuid = this.uuids.pop();
			opts.onSuccess(uuid);
			return;
		};
		
		var pathUUids = this.options.pathToUuids;
		if( !pathUUids ) {
			pathUUids = this.options.pathToServer + '_uuids';
		};
		
		var data = {
	    	count: 10
		};

		if( badProxy ){
			data.r = Date.now();
		};
		
		$.ajax({
	    	url: pathUUids
	    	,type: 'get'
	    	,async: true
	    	,data: data
	    	,dataType: 'json'
	    	,success: function(res) {
	    		if( res.uuids ) {
	    			for(var i=0,e=res.uuids.length; i<e; ++i) {
	    				var uuid = res.uuids[i];
	    				_this.uuids.push(uuid);
	    			};
					var uuid = _this.uuids.pop();
					opts.onSuccess(uuid);
					return;
	    		}
	    		opts.onError('Malformed uuids from database.');
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error obtaining new uuids from database: '+errStr);
	    	}
		});
	}
	
	,listDatabases: function(options_) {
		var opts = $.extend({
				onSuccess: function(dbNameArray){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,options_
		);

		var pathToAllDbs = this.options.pathToAllDbs;
		if( !pathToAllDbs ) {
			pathToAllDbs = this.options.pathToServer + '_all_dbs';
		};
		
		var data = {};

		if( badProxy ){
			data.r = Date.now();
		};

		$.ajax({
	    	url: pathToAllDbs
	    	,type: 'get'
	    	,async: true
	    	,dataType: 'json'
	    	,data: data
	    	,success: opts.onSuccess
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error obtaining list of databases: '+errStr);
	    	}
		});
	}

	,getUserDb: function() {
		if( !this.userDb ) {
			this.userDb = new UserDb(this,this.userDbName);
		};
		return this.userDb; 
	}

	,getSession: function(sessionInfo) {
		if( !this.session ) {
			this.session = new Session(this,sessionInfo);
		};
		
		return this.session;
	}
	
	,getDb: function(opts) {
		return new Database(opts, this);
	}
	
	,createDb: function(opts_) {
		var opts = $n2.extend({
			dbName: null
			,onSuccess: function(db){}
			,onError: $n2.reportErrorForced
		},opts_);
		
		if( !opts.dbName ) {
			opts.onError('"dbName" must be provided when creating a database');
			return;
		};

		var dbUrl = this.getPathToServer() + opts.dbName;
		
		var _s = this;
		
		$.ajax({
	    	url: dbUrl
	    	,type: 'put'
	    	,async: true
	    	,dataType: 'json'
	    	,success: function(creationInfo) {
	    		if( creationInfo.ok ) {
	    			var db = _s.getDb({dbUrl: dbUrl});
	    			opts.onSuccess(db);
	    		} else {
	    			opts.onError('Error occurred when creating database: '+creationInfo.error);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error creating database: '+errStr);
	    	}
		});
	}
	
	,deleteDb: function(opts_) {
		var opts = $n2.extend({
			dbName: null
			,onSuccess: function(){}
			,onError: $n2.reportErrorForced
		},opts_);
		
		if( !opts.dbName ) {
			opts.onError('"dbName" must be provided when deleting a database');
			return;
		};

		var dbUrl = this.getPathToServer() + opts.dbName;
		
		var _s = this;
		
		$.ajax({
	    	url: dbUrl
	    	,type: 'DELETE'
	    	,async: true
	    	,dataType: 'json'
	    	,success: function(info) {
	    		if( info.ok ) {
	    			opts.onSuccess();
	    		} else {
	    			opts.onError('Error occurred when deleting database: '+info.error);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
	    		opts.onError('Error deleting database: '+errStr);
	    	}
		});
	}
	
	,replicate: function(opts_){
		var opts = $n2.extend({
			source: null
			,target: null
			,filter: null
			,docIds: null
			,continuous: false
			,onSuccess: function(db){}
			,onError: $n2.reportErrorForced
		},opts_);

		if( !opts.source ) {
			opts.onError('"source" must be provided for replication');
			return;
		};
		if( !opts.target ) {
			opts.onError('"target" must be provided for replication');
			return;
		};
		
		var request = {
			source: opts.source
			,target: opts.target
		};
		if( opts.filter ) {
			request.filter = opts.filter;
		};
		if( opts.continuous ) {
			request.continuous = true;
		};
		if( opts.docIds ) {
			request.doc_ids = opts.docIds;
		};

		var serverPath = this.getReplicateUrl();

		$.ajax({
	    	url: serverPath
	    	,type: 'POST'
	    	,async: true
	    	,data: JSON.stringify(request)
	    	,contentType: 'application/json'
    		,dataType: 'json'
    		,success: function(res) {
	    		if( res.error ) {
	    			opts.onError('Error while initiating replication: '+res.error);
	    		} else {
	    			opts.onSuccess(res);
	    		};
    		}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
				var errStr = httpJsonError(XMLHttpRequest, textStatus);
				opts.onError('Error initiating replication: '+errStr);
    		}
		});
	}
	
	,addInitializedListener: function(listener) {
		if( typeof(listener) === 'function' ) {
			if( this.isInitialized ) {
				try { listener(); } catch(e) {}
			} else {
				this.initListeners.push(listener);
			};
		};
	}

});

//=============================================
// Utilities
//=============================================

function addAttachmentToDocument(opts_){
	var opts = $n2.extend({
		doc: null // Document to add attachment
		,data: null // The binary data in the attachment
		,attachmentName: null // name of attachment
		,contentType: 'application/binary'
	},opts_);
	
	if( !opts.doc || !opts.data || !opts.attachmentName ) {
		return 'Invalid parameters';
	};
	
	if( typeof($n2.Base64) == 'undefined' ) {
		return 'Base64 not included';
	};
	
	if( !opts.doc._attachments ) {
		opts.doc._attachments = {};
	};
	
	opts.doc._attachments[opts.attachmentName] = {};
	opts.doc._attachments[opts.attachmentName].content_type = opts.contentType;
	opts.doc._attachments[opts.attachmentName].data = $n2.Base64.encode(opts.data);
	
	return null;
};

//=============================================
// Couch Default
//=============================================

$n2.couch = $.extend({},{
	
	isBadProxy: isBadProxy

	,setBadProxy: setBadProxy
	
	,getServer: function(opt_) {
		return new Server(opt_);
	}
	
	/* Following deals with "default" server */
	,DefaultServer: null
	
	,defaultInitializeListeners: []
	
	,getPathToServer: function() {
		return $n2.couch.DefaultServer.getPathToServer();
	}
	
	,addInitializedListener: function(listener) {
		if( $n2.couch.DefaultServer ) {
			$n2.couch.DefaultServer.addInitializedListener(listener);
		} else {
			if( typeof(listener) === 'function' ) {
				$n2.couch.defaultInitializeListeners.push(listener);
			};
		};
	}
	
	,initialize: function(opts_) {
		$n2.couch.DefaultServer = new Server(opts_, $n2.couch.defaultInitializeListeners);
	}
	
	,getVersion: function() { 
		return $n2.couch.DefaultServer.getVersion(); 
	}
	
	,getSession: function() {
		return $n2.couch.DefaultServer.getSession(); 
	}

	,getUserDb: function() { 
		return $n2.couch.DefaultServer.getUserDb();
	}
	
	,getReplicateUrl: function() {
		return $n2.couch.DefaultServer.getReplicateUrl();
	}
	
	,getActiveTasksUrl: function() {
		return $n2.couch.DefaultServer.getActiveTasksUrl();
	}
	
	,getDb: function(opts) {
		return $n2.couch.DefaultServer.getDb(opts);
	}

	,getUniqueId: function(options_) {
		$n2.couch.DefaultServer.getUniqueId();
	}
	
	,addAttachmentToDocument: addAttachmentToDocument
	
	,compareSessionContexts: compareSessionContexts
});


$.fn.couchUploadFile = function(opts) {
	var db = $n2.couch.getDb(opts);
	db.buildUploadFileForm(this, opts);
	return this;
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couch.indexedDb.js

/*
Copyright (c) 2016, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
,DH = 'n2.couch.indexedDb'
;

// =============================================
// Design Document
// =============================================

var DesignDoc = $n2.Class('couchIndexedDb.DesignDoc',{

	couchDesignDoc: null,
	
	db: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			couchDesignDoc: null
			,db: null
		},opts_);
		
		this.couchDesignDoc = opts.couchDesignDoc;
		this.db = opts.db;
	},

	getDatabase: function(){
		return this.db;
	},
	
	getQueryUrl: function(opts_){
		return this.couchDesignDoc.getQueryUrl(opts_);
	},

	queryView: function(opts_) {
		var opts = $n2.extend({},opts_);
		
		var _this = this;
		
		// Figure out if documents were requested
		var include_docs = false;
		if( opts.include_docs ){
			include_docs = true;
			opts.include_docs = false;
		};
		
		// Intercept success
		var onSuccess = opts.onSuccess;
		opts.onSuccess = queryResult;
		
		this.couchDesignDoc.queryView(opts);
		
		function queryResult(results){
			if( opts.reduce ){
				// Reducing. No documents return
				onSuccess(results);
				
			} else if( include_docs ){
				// Need to fetch documents
				var docIds = [];
				var rowsByDocId = {};
				results.forEach(function(row){
					var docId = row.id;
					
					var rows = rowsByDocId[docId];
					if( !rows ){
						rows = [];
						rowsByDocId[docId] = rows;
						docIds.push(docId);
					};

					rows.push(row);
				});

				_this.db.getDocuments({
					docIds: docIds
					,onSuccess: function(docs){
						docs.forEach(function(doc){
							var docId = doc._id;
							var rows = rowsByDocId[docId];
							if( rows ){
								rows.forEach(function(row){
									row.doc = doc;
								});
							};
						});
						
						onSuccess(results);
					}
					,onError: function(cause){
						var err = $n2.error.fromString('Error obtaining documents returned by query',cause);
						opts.onError(err);
					}
				});
				
			} else {
				// Just return
				onSuccess(results);
			};
		};
	}
});

// =============================================
// Database
// =============================================

var Database = $n2.Class('couchIndexedDb.Database',{
	
	wrappedDb: null,
	
	documentCache: null,
	
	dbName: null,
	
	dbChangeNotifier: null,
	
	dispatchService: null,
	
	remoteDocumentCountLimit: null,
	
	remoteRevisionCountLimit: null,
	
	id: null,
	
	outstandingRevisionCount: null,

	isInitialized: null,
	
	initializeListeners: null,

	isCachingEnabled: null,
	
	fetchDocumentRequests: null,
	
	fetchDocumentRequestsByDocId: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			couchDb: null
			,documentCache: null
			,dispatchService: null
			,remoteDocumentCountLimit: null
			,remoteRevisionCountLimit: null
		},opts_);
		
		var _this = this;
	
		this.wrappedDb = opts.couchDb;
		this.documentCache = opts.documentCache;
		this.dispatchService = opts.dispatchService;
		this.remoteDocumentCountLimit = opts.remoteDocumentCountLimit;
		this.remoteRevisionCountLimit = opts.remoteRevisionCountLimit;
		
		this.id = $n2.getUniqueId();
		this.outstandingRevisionCount = 0;
		this.isInitialized = false;
		this.isCachingEnabled = false;
		this.initializeListeners = [];
		this.fetchDocumentRequests = null;
		this.fetchDocumentRequestsByDocId = null;

		// Get update notifier from database. This should give us
		// the ability to retrieve the current update sequence.
		// Do not start listening to the changes, yet.
		this.getChangeNotifier({
			onSuccess: function(notifier){
				// When we get here, we should be able to
				// query getLastSequence()
				_this.dbChangeNotifier = notifier;
				getDatabaseInfo();
			},
			onError: function(err){
				$n2.logError('Error while getting database change notifier: '+err);
				errorInitializing();
			}
		});
		
		function getDatabaseInfo() {
			// Get info about this database
			_this.getInfo({
				onSuccess: function receivedDbInfo(info){
					if( info 
					 && typeof info.db_name === 'string' ){
						_this.dbName = info.db_name;

						retrieveDocumentCacheSequence();

					} else {
						$n2.logError('Error with database information', info);
						errorInitializing();
					};
				}
				,onError: function(err){
					$n2.logError('Error while fetching database information: '+err);
					errorInitializing();
				}
			});
		};
		
		function retrieveDocumentCacheSequence(){
			_this.documentCache.getUpdateSequence({
				dbName: _this.dbName
				,onSuccess: function(cacheSequenceNumber){
					compareUpdateSequences(cacheSequenceNumber);
				}
				,onError: function(err){
					$n2.logError('Error while getting document cache sequence number: '+err);
					reInitializeDocumentCache();
				}
			});
		};
		
		function compareUpdateSequences(cacheSequenceNumber){
			var dbUpdateSequence = _this.dbChangeNotifier.getLastSequence();
			
			if( !cacheSequenceNumber ){
				// The cache has never been used. There is no document in cache.
				// Initialize cache with current update sequence
				_this.documentCache.initializeCache({
					dbName: _this.dbName
					,updateSequence: dbUpdateSequence
					,onSuccess: function(){
						$n2.log('Document cache: initialized ');
						listenToDbChangeFeed();
					}
					,onError: function(err){
						$n2.logError('Error while recording initializing document cache. '+err);
						errorInitializing();
					}
				});

			} else if( dbUpdateSequence === cacheSequenceNumber ){
				// The update sequence in the cache matches the one from the database.
				// This means that the cache is already up-to-date.
				$n2.log('Document cache: up-to-date');
				listenToDbChangeFeed();
				
			} else {
				// Check that we are on the correct database
				var changeLimit = 1000;
				_this.getChanges({
					since: cacheSequenceNumber
					,limit: changeLimit
					,onSuccess: function(changes){
						if( changes
						 && $n2.isArray(changes.results)
						 && changes.results.length < changeLimit ){
							// This is the correct database and we are able to process changes
							// since the last time we connected.
							_this._dbChanges(changes);
							$n2.log('Document cache: updating');
							listenToDbChangeFeed();

						} else {
							// Either this is not the right database or there has been a
							// very large number of changes since we last connected.
							// Re-initialize the cache
							reInitializeDocumentCache();
						};
					}
					,onError: function(err){
						// Error while getting the changes might mean that the "since"
						// parameter is not recognized. Re-initialize the cache
						reInitializeDocumentCache();
					}
				});
			};
		};
		
		function reInitializeDocumentCache() {
			var dbUpdateSequence = _this.dbChangeNotifier.getLastSequence();

			_this.documentCache.initializeCache({
				dbName: _this.dbName
				,updateSequence: dbUpdateSequence
				,onSuccess: function(){
					$n2.log('Document cache: re-initialized');
					listenToDbChangeFeed();
				}
				,onError: function(err){
					$n2.logError('Error while re-initializing document cache. '+err);
					errorInitializing();
				}
			});
		};
		
		function listenToDbChangeFeed(){
			// Install update notifier
			_this.dbChangeNotifier.addListener(function(changes){
				_this._dbChanges(changes);
			});
			
			done();
		};
		
		function done(){
			// At this point, the cache is initialized
			_this.isCachingEnabled = true;
			_this.isInitialized = true;
			
			// Call all listeners
			_this.initializeListeners.forEach(function(listener){
				listener();
			});
			
			_this.initializeListeners = [];
		};
		
		function errorInitializing(){
			$n2.logError('Document cache: disabled');
			_this.isCachingEnabled = false;
			_this.isInitialized = true;
		};
	},

	getUrl: function(){
		return this.wrappedDb.getUrl();
	},

	getServer: function(){
		return this.wrappedDb.getServer();
	},
	
	getDesignDoc: function(opts_) {
		var couchDesignDoc = this.wrappedDb.getDesignDoc(opts_);

		var designDoc = new DesignDoc({
			couchDesignDoc: couchDesignDoc
			,db: this
		});

		return designDoc;
	},
	
	getChangeNotifier: function(opts_) {
		return this.wrappedDb.getChangeNotifier(opts_);
	},
	
	getChanges: function(opts_) {
		this.wrappedDb.getChanges(opts_);
	},

	getDocumentUrl: function(doc) {
		return this.wrappedDb.getDocumentUrl(doc);
	},

	getAttachmentUrl: function(doc,attName) {
		return this.wrappedDb.getAttachmentUrl(doc,attName);
	},
	
	getDocumentRevision: function(opts_) {
		this.wrappedDb.getDocumentRevision(opts_);
	},
	
	getDocumentRevisions: function(opts_) {
		var _this = this;
		
		if( typeof this.remoteRevisionCountLimit === 'number' ){
			// Break up requests in chunks of appropriate size, re-assemble
			// response
			var docIds = opts_.docIds.slice(); // clone
			var info = {};
			var outstandingCount = docIds.length;
			
			this._updateOutstandingRevisionCount(outstandingCount);
			
			var opts = $n2.extend({
				onSuccess: function(info){}
				,onError: function(err){}
			},opts_);
			
			fetchChunk();
			
		} else {
			// No limit. Make complete request
			this.wrappedDb.getDocumentRevisions(opts_);
		};
		
		function fetchChunk(){
			if( docIds.length <= 0 ){
				// Call complete
				_this._updateOutstandingRevisionCount(0 - outstandingCount);
				opts.onSuccess(info);

			} else {
				var requestDocIds = docIds.splice(0,_this.remoteRevisionCountLimit);
				_this.wrappedDb.getDocumentRevisions({
					docIds: requestDocIds
					,onSuccess: function(requestInfo){
						_this._updateOutstandingRevisionCount(0 - requestDocIds.length);
						outstandingCount = outstandingCount - requestDocIds.length;
						
						// Accumulate revisions in one response
						for(var docId in requestInfo){
							var rev = requestInfo[docId];
							info[docId] = rev;
						};
						
						// Fetch next chunk
						fetchChunk();
					}
					,onError: function(err){
						_this._updateOutstandingRevisionCount(0 - outstandingCount);
						opts.onError(err);
					}
				});
			};
		};
	},
	
	buildUploadFileForm: function(jQuerySet, options_) {
		this.wrappedDb.buildUploadFileForm(jQuerySet, options_);
	},
	
	createDocument: function(opts_) {
		var _this = this;

		// This request is dependent on the cache.
		// Do not performed until initialized
		if( !this.isInitialized ){
			this.initializeListeners.push(function(){
				_this.createDocument(opts_);
			});
			return;
		};

		// Modifies request
		var opts = $n2.extend({},opts_,{
			onSuccess: storeDocument
		});

		this.wrappedDb.createDocument(opts);
		
		function storeDocument(docInfo){
			if( _this.isCachingEnabled ){
				var doc = $n2.extend({},opts_.data);
				doc._id = docInfo.id;
				doc._rev = docInfo.rev;
				var changes = [];
				changes.push({
					dbName: _this.dbName
					,id: doc._id
					,rev: doc._rev
					,doc: doc
				});
				_this.documentCache.performChanges(changes);
			};
			opts_.onSuccess(docInfo);
		};
	},
	
	updateDocument: function(opts_) {
		var _this = this;

		// This request is dependent on the cache.
		// Do not performed until initialized
		if( !this.isInitialized ){
			this.initializeListeners.push(function(){
				_this.updateDocument(opts_);
			});
			return;
		};
		
		// Modifies request
		var opts = $n2.extend({},opts_,{
			onSuccess: storeDocument
		});

		this.wrappedDb.updateDocument(opts);
		
		function storeDocument(docInfo){
			if( _this.isCachingEnabled ){
				var doc = $n2.extend({},opts_.data);
				doc._id = docInfo.id;
				doc._rev = docInfo.rev;
				var changes = [];
				changes.push({
					dbName: _this.dbName
					,id: doc._id
					,rev: doc._rev
					,doc: doc
				});
				_this.documentCache.performChanges(changes);
			};
			opts_.onSuccess(docInfo);
		};
	},
	
	deleteDocument: function(opts_) {
		var _this = this;

		// This request is dependent on the cache.
		// Do not performed until initialized
		if( !this.isInitialized ){
			this.initializeListeners.push(function(){
				_this.deleteDocument(opts_);
			});
			return;
		};
		
		// Modifies request
		var opts = $n2.extend({},opts_,{
			onSuccess: deleteDocument
		});

		this.wrappedDb.deleteDocument(opts);
		
		function deleteDocument(docInfo){
			if( _this.isCachingEnabled ){
				var changes = [];
				changes.push({
					dbName: _this.dbName
					,id: opts_.data._id
					,rev: docInfo.rev
					,deleted: true
				});
				_this.documentCache.performChanges(changes);
			};
			opts_.onSuccess(docInfo);
		};
	},
	
	bulkDocuments: function(documents, options_) {
		this.wrappedDb.bulkDocuments(documents, options_);
	},
	
	getDocument: function(opts_) {
		var _this = this;

		// This request is dependent on the cache.
		// Do not performed until initialized
		if( !this.isInitialized ){
			this.initializeListeners.push(function(){
				_this.getDocument(opts_);
			});
			return;
		};
		
		var skipCache = false;
		var skipStore = false;
		if( opts_.rev ){
			// Asking for a specific revision
			skipCache = true;
			skipStore = true;
		};
		if( opts_.revs_info ){
			// Asking for a revision information
			skipCache = true;
			skipStore = true;
		};
		if( opts_.revisions ){
			// Asking for a revision information
			skipCache = true;
			skipStore = true;
		};
		if( opts_.conflicts ){
			// Asking for a conflict information
			skipCache = true;
			skipStore = true;
		};
		if( opts_.deleted_conflicts ){
			// Asking for a conflict information
			skipCache = true;
			skipStore = true;
		};
		if( opts_.skipCache ){
			// Specifically asking to skip cache
			skipCache = true;
		};
		
		if( skipCache ){
			performNative();
		} else {
			this._validateDocumentCache({
				onSuccess: function(){
					_this.documentCache.getDocument({
						dbName: _this.dbName
						,docId: opts_.docId
						,onSuccess: checkDocument
						,onError: performNative
					});
				}
				,onError: performNative
			});
		};
		
		function checkDocument(doc){
			if( doc ) {
				opts_.onSuccess(doc);
			} else {
				performNative();
			};
		};
		
		function performNative(){
			// Get document from CouchDb
			var opts = $n2.extend({},opts_,{
				onSuccess: storeDocument
			});

			_this.wrappedDb.getDocument(opts);
		};
		
		function storeDocument(doc){
			// Attempt caching
			if( _this.isCachingEnabled && !skipStore ){
				var changes = [];
				changes.push({
					dbName: _this.dbName
					,id: doc._id
					,rev: doc._rev
					,doc: doc
				});
				_this.documentCache.performChanges(changes);
			};

			// Return document to client
			opts_.onSuccess(doc);
		};
	},

	getDocuments: function(opts_) {
		var _this = this;

		// This request is dependent on the cache.
		// Do not performed until initialized
		if( !this.isInitialized ){
			this.initializeListeners.push(function(){
				_this.getDocuments(opts_);
			});
			return;
		};

		var opts = $.extend(true, {
			docIds: null
			,skipCache: undefined
			,onSuccess: function(docs){}
			,onError: function(errorMsg){ $n2.log(errorMsg); }
		},opts_);
		
		if( !$n2.isArray(opts.docIds) ){
			throw new Error('Database.getDocuments() docIds must be an array');
		};
		opts.docIds.forEach(function(docId){
			if( typeof docId !== 'string' ){
				throw new Error('Database.getDocuments() docIds[*] must be a string');
			};
		});

		if( opts.skipCache ){
			performRemoteRequest();
		} else {
			this._validateDocumentCache({
				onSuccess: function(){
					_this._performDocumentFetchRequest({
					    docIds: opts.docIds
					    ,onSuccess: opts.onSuccess
					    ,onError: opts.onError
					});
				}
				,onError: performRemoteRequest
			});
		};

		function performRemoteRequest(){
			var remoteOpts = $n2.extend({},opts,{
				onSuccess: function(docs){
					if( _this.isCachingEnabled ){
						var changes = [];

						docs.forEach(function(doc){
							changes.push({
								dbName: _this.dbName
								,id: doc._id
								,rev: doc._rev
								,doc: doc
							});
						});

						_this.documentCache.performChanges(changes);
					};
					
					opts.onSuccess(docs);
				}
			});
			
			_this.wrappedDb.getDocuments(remoteOpts);
		};
	},

	listAllDocuments: function(opts_) {
		this.wrappedDb.listAllDocuments(opts_);
	},

	getAllDocuments: function(opts_) {
		this.wrappedDb.getAllDocuments(opts_);
	},
	
	getInfo: function(opts_) {
		this.wrappedDb.getInfo(opts_);
	},
	
	queryTemporaryView: function(opts_){
		this.wrappedDb.queryTemporaryView(opts_);
	},
	
	_dbChanges: function(changes){
		// changes:
		// {
		//    "last_seq": "104-g1AAAAJjeJyd0ksKwjAQANBgBX8oFA-gJ5Am6ces7E10JmkpperKtd5Eb6I30ZvUfLpwUYSWwARmmAfDTEUIGReeIr48X2ShMKUs2QT60UqXBkBwVdd1WXiwPOrEKICcRlnY1vCHwbWOuGukhZVCJkQeYFcpNdK-kWZOyjAHuu0qHYx0baSplRjnDKXoKJ2GOpKb_jR2N9rEaoJzEUM_7eG0p9F8q9EwgwS6Tum0l9PeRpu7SZWkHKJe2sdpPxuImUKRtF5F-QUbHp8f",
		//    "pending": 0,
		//    "results": [
		//       {
		//          "seq": "1-g1AAAAF1eJzLYWBg4MhgTmEQTM4vTc5ISXIwNDLXMwBCwxygFFMiQ5L8____szKYExlzgQLsBolphqapJtg04DEmSQFIJtmDTEpkwKfOAaQunrC6BJC6eoLq8liAJEMDkAIqnU-M2gUQtfuJUXsAovY-MWofQNSC3JsFAMjHZqY",
		//          "id": "module.map.label",
		//          "changes": [
		//             {
		//                "rev": "1-6a63a7493382323b2db86a85ae4b518d"
		//             }
		//          ]
		//       },
		//       ...
		//       {
		//          "seq": "104-g1AAAAJjeJyd0ksKwjAQANBgBX8oFA-gJ5Am6ces7E10JmkpperKtd5Eb6I30ZvUfLpwUYSWwARmmAfDTEUIGReeIr48X2ShMKUs2QT60UqXBkBwVdd1WXiwPOrEKICcRlnY1vCHwbWOuGukhZVCJkQeYFcpNdK-kWZOyjAHuu0qHYx0baSplRjnDKXoKJ2GOpKb_jR2N9rEaoJzEUM_7eG0p9F8q9EwgwS6Tum0l9PeRpu7SZWkHKJe2sdpPxuImUKRtF5F-QUbHp8f",
		//          "id": "org.nunaliit.css.body",
		//          "deleted": true
		//          "changes": [
		//             {
		//                "rev": "1-c6d43bc49dbc259ecc8a9f75d82119df"
		//             }
		//          ]
		//       }
		//    ]
		// }
		var _this = this;
		
		var lastSeq = undefined;
		if( typeof changes.last_seq === 'string' ){
			lastSeq = changes.last_seq;
		} else if( typeof changes.last_seq === 'number' ) {
			lastSeq = ''+changes.last_seq;
		} else {
			$n2.logError('Unable to handle last_seq: '+changes.last_seq);
		};

		var results = changes.results.slice(); // clone so we can reverse
		
		// Reverse results so we see the latest changes first, taking
		// precedence over older ones
		results.reverse();
		
		// Keep track of which document we have already seen
		var seenByDocId = {};
		
		// Keep track of changes to apply to cache
		var cacheChanges = [];
		
		results.forEach(function(updateRecord){
			var docId = updateRecord.id;

			// Do not process a document twice
			if( !seenByDocId[docId] ){
				var latestNumber;
				var latestRev;
				if( $n2.isArray(updateRecord.changes) ) {
					updateRecord.changes.forEach(function(change){
						var number = getNumberFromRevision(change.rev);
						
						if( latestNumber === undefined ){
							latestNumber = number;
							latestRev = change.rev;
						} else if( number > latestNumber ){
							latestNumber = number;
							latestRev = change.rev;
						};
					});
				};
				
				if( updateRecord.deleted 
				 && typeof latestRev === 'string' ){
					// Inform cache of deletion
					var cacheChange = {
						dbName: _this.dbName
						,id: docId
						,rev: latestRev
						,deleted: true
					};
					cacheChanges.push(cacheChange);
					seenByDocId[docId] = cacheChange;
					
				} else if( typeof latestRev === 'string' ){
					// Inform cache of update
					var cacheChange = {
						dbName: _this.dbName
						,id: docId
						,rev: latestRev
					};
					cacheChanges.push(cacheChange);
					seenByDocId[docId] = cacheChange;
				};
			};
		});

		// Update sequence
		cacheChanges.push({
			dbName: _this.dbName
			,updateSequence: lastSeq
		});
		
		// Record how far we have processed the change feed
		this.documentCache.performChanges(cacheChanges);

		function getNumberFromRevision(revision){
			var splits = revision.split('-');
			var number = 1 * splits[0];
			return number;
		};
	},
	
	_validateDocumentCache: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		
		if( !this.isCachingEnabled ){
			opts.onError('Caching is not enabled');
		};
		
		this.documentCache.getUpdateSequence({
			dbName: _this.dbName
			,onSuccess: cacheSequenceNumber
			,onError: function(err){
				$n2.log('Error while validating cache (retrieve cache sequence number). '+err);
				opts.onError(err);
			}
		});
		
		function cacheSequenceNumber(cacheSequenceNumber){
			_this.wrappedDb.getChanges({
				since: cacheSequenceNumber
				,onSuccess: applyChanges
				,onError: function(err){ 
					$n2.log('Error while validating cache (get changes). '+err);
					opts.onError(err);
				}
			});
		};
		
		function applyChanges(changes){
			_this._dbChanges(changes);
			opts.onSuccess();
		};
	},
	
	_updateOutstandingDocumentCount: function(count){
		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'waitReport'
				,requester: this.id
				,name: 'fetchDocuments'
				,label: _loc('Retrieving documents')
				,count: count
			});
		};
	},
	
	_updateOutstandingRevisionCount: function(delta){
		this.outstandingRevisionCount += delta;
		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'waitReport'
				,requester: this.id
				,name: 'fetchRevisions'
				,label: _loc('Verifying revisions')
				,count: this.outstandingRevisionCount
			});
		};
	},
	
	/**
	 * Serialize all document fetch requests and prevent fetching the
	 * same document multiple times. This function checks the cache first
	 * and then fetches documents remotely.
	 */
	_performDocumentFetchRequest: function(request){
		var _this = this;
		
		// Validate the request
		// {
		//    docIds: []
		//    ,onSuccess: function(docs){}
		//    ,onError: function(err){}
		// }
		if( typeof request !== 'object' ){
			throw new Error('Database._performDocumentFetchRequest() request must be an object');
		};
		if( !$n2.isArray(request.docIds) ){
			throw new Error('Database._performDocumentFetchRequest() request.docId must be an array');
		};
		request.docIds.forEach(function(docId){
			if( typeof docId !== 'string' ){
				throw new Error('Database._performDocumentFetchRequest() request.docId[*] must be a string');
			};
		});
		if( typeof request.onSuccess !== 'function' ){
			throw new Error('Database._performDocumentFetchRequest() request.onSuccess must be a function');
		};
		if( typeof request.onError !== 'function' ){
			throw new Error('Database._performDocumentFetchRequest() request.onError must be a function');
		};
		
		// Augment request to keep track of progress
		request.docsById = {};
		request.outsdandingDocumentCount = request.docIds.length;
		
		// Special case: nothing requested
		if( request.docIds.length <= 0 ){
			request.onSuccess([]);
			return;
		};

		// Check if we need to set up a new thread
		var startThread = false;
		if( !this.fetchDocumentRequests ){
			startThread = true;
			this.fetchDocumentRequests = [];
			this.fetchDocumentRequestsByDocId = {};
		};
		
		// Break up the request into fetch requests for each document identifier
		request.docIds.forEach(function(docId){
			var fetchRequest = _this.fetchDocumentRequestsByDocId[docId];
			if( !fetchRequest ){
				fetchRequest = {
					docId: docId
					,requests: []
				};
				_this.fetchDocumentRequestsByDocId[docId] = fetchRequest;
				_this.fetchDocumentRequests.push(fetchRequest);
			};
			
			fetchRequest.requests.push(request);
		});

		this._updateOutstandingDocumentCount(this.fetchDocumentRequests.length);

		var remoteDocIds = [];
		var finishedRequests = [];
		if( startThread ){
			runThread();
		};
		
		function runThread(){
			if( _this.fetchDocumentRequests.length <= 0 ){
				// We are done. Stop thread
				_this.fetchDocumentRequests = null;
				_this.fetchDocumentRequestsByDocId = null;
				
				_this._updateOutstandingDocumentCount(0);
				
			} else {
				_this._updateOutstandingDocumentCount(_this.fetchDocumentRequests.length);

				// Continue, we have more work to do.
				remoteDocIds = [];
				checkCache();
			};
		};

		function checkCache(){
			if( _this.fetchDocumentRequests.length <= 0 ){
				// No more requests. Fetch remotely
				fetchRemotely();

			} else if( typeof _this.remoteDocumentCountLimit === 'number' 
			 && remoteDocIds.length >= _this.remoteDocumentCountLimit ){
				// We have accumulated enough doc ids to fetch remotely
				fetchRemotely();
			
			} else {
				var fetchRequest = _this.fetchDocumentRequests.shift();
				
				if( _this.isCachingEnabled ){
					// Attempt to get from cache
					_this.documentCache.getDocument({
						dbName: _this.dbName
						,docId: fetchRequest.docId
						,onSuccess: function(doc){
							if( doc ){
								receivedDocument(doc);
								checkCache();
							} else {
								// Do not have document in cache. Get document remotely
								remoteDocIds.push(fetchRequest.docId);
								checkCache();
							};
						}
						,onError: function(err){
							// Error on cache. Get document remotely
							remoteDocIds.push(fetchRequest.docId);
							checkCache();
						}
					});
				} else {
					// Cache is not available. Fetch all documents remotely
					remoteDocIds.push(fetchRequest.docId);
					while( _this.fetchDocumentRequests.length > 0 ){
						fetchRequest = _this.fetchDocumentRequests.shift();
						remoteDocIds.push(fetchRequest.docId);
					};

					fetchRemotely();
				};
			};
		};
		
		function fetchRemotely(){

			if( remoteDocIds.length > 0 ){
				// Make a map of remotely requested document to figure out
				// which one we got
				var docsById = {};
				remoteDocIds.forEach(function(docId){
					docsById[docId] = null;
				});

				_this.wrappedDb.getDocuments({
					docIds: remoteDocIds
					,onSuccess: function(docs){
						// Update map
						docs.forEach(function(doc){
							docsById[doc._id] = doc;
						});
						
						// For each requested document, report the outcome
						for(var docId in docsById){
							var doc = docsById[docId];
							if( doc ){
								receivedDocument(doc);
							} else {
								documentNotAvailable(docId);
							};
						};
						
						// Cache the document received remotely
						if( _this.isCachingEnabled ){
							var changes = [];
							docs.forEach(function(doc){
								changes.push({
									dbName: _this.dbName
									,id: doc._id
									,rev: doc._rev
									,doc: doc
								});
							});
							_this.documentCache.performChanges(changes);
						};
						
						sendFinishedResults();
						runThread();
					}
					,onError: function(err){ 
						// For each requested document, report error
						for(var docId in docsById){
							errorReceived(docId, err);
						};
						sendFinishedResults();
						runThread();
					}
				});
				
				// While we are waiting for remot server, send what we have accumulated
				// so far from cache
				sendFinishedResults();

			} else {
				// Nothing to fetch remotely
				sendFinishedResults();
				runThread();
			};
		};
		
		function sendFinishedResults(){
			var requests = finishedRequests;
			finishedRequests = [];
			
			requests.forEach(function(finishedRequest){
				if( finishedRequest.error ){
					finishedRequest.onError(finishedRequest.error);
				} else {
					// Gather the documents
					var docs = [];
					for(var docId in finishedRequest.docsById){
						var doc = finishedRequest.docsById[docId];
						docs.push(doc);
					};
					finishedRequest.onSuccess(docs);
				};
			});
		};
		
		function receivedDocument(doc){
//			fetchRequest = {
//				docId: docId
//				,requests: [
//				{
//					docIds: []
//					,onSuccess: function(docs){}
//					,onError: function(err){}
//					,outsdandingDocumentCount: <number>
//					,docsById: {}
//				}
//	            ]
//			};

			var fetchRequest = _this.fetchDocumentRequestsByDocId[doc._id];
			if( fetchRequest ){
				fetchRequest.requests.forEach(function(request){
					if( !request.docsById[doc._id] ){
						request.docsById[doc._id] = doc;
						--request.outsdandingDocumentCount;
						
						if( request.outsdandingDocumentCount <= 0 ){
							finishedRequests.push(request);
						};
					};
				});
				
				delete _this.fetchDocumentRequestsByDocId[doc._id];
			};
		};

		function documentNotAvailable(docId){
			var fetchRequest = _this.fetchDocumentRequestsByDocId[docId];
			if( fetchRequest ){
				fetchRequest.requests.forEach(function(request){
					--request.outsdandingDocumentCount;
						
					if( request.outsdandingDocumentCount <= 0 ){
						finishedRequests.push(request);
					};
				});
				
				delete _this.fetchDocumentRequestsByDocId[docId];
			};
		};

		function errorReceived(docId,err){
			var fetchRequest = _this.fetchDocumentRequestsByDocId[docId];
			if( fetchRequest ){
				fetchRequest.requests.forEach(function(request){
					if( !request.error ){
						request.error = err;
						
						finishedRequests.push(request);
					};
				});
				
				delete _this.fetchDocumentRequestsByDocId[docId];
			};
		};
	}
});

// =============================================
// Server
// =============================================

var Server = $n2.Class('couchIndexedDb.Server',{
	
	wrappedServer: null,
	
	indexedDbService: null,
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			couchServer: null
			,indexedDbService: null
			,dispatchService: null
		},opts_);
		
		this.wrappedServer = opts.couchServer;
		this.indexedDbService = opts.indexedDbService;
		this.dispatchService = opts.dispatchService;
	},

	getPathToServer: function() {
		return this.wrappedServer.getPathToServer();
	},

	getVersion: function() { 
		return this.wrappedServer.getVersion(); 
	},
	
	getReplicateUrl: function() {
		return this.wrappedServer.getReplicateUrl(); 
	},
	
	getActiveTasksUrl: function() {
		return this.wrappedServer.getActiveTasksUrl(); 
	},
	
	getSessionUrl: function() {
		return this.wrappedServer.getSessionUrl(); 
	},
	
	getUniqueId: function(opts_) {
		this.wrappedServer.getUniqueId(opts_);
	},
	
	listDatabases: function(opts_) {
		this.wrappedServer.listDatabases(opts_);
	},

	getUserDb: function() {
		return this.wrappedServer.getUserDb();
	},

	getSession: function(sessionInfo) {
		return this.wrappedServer.getSession(sessionInfo);
	},
	
	getDb: function(opts_) {
		var couchDatabase = this.wrappedServer.getDb(opts_);
		if( opts_.allowCaching ){
			var documentCache = this.indexedDbService.getDocumentCache();
			return new Database({
				couchDb: couchDatabase
				,documentCache: documentCache
				,dispatchService: this.dispatchService
				,remoteDocumentCountLimit: opts_.remoteDocumentCountLimit
				,remoteRevisionCountLimit: opts_.remoteRevisionCountLimit
			});
		} else {
			return couchDatabase;
		};
	},
	
	createDb: function(opts_) {
		var opts = $n2.extend({
			dbName: null
			,onSuccess: function(db){}
			,onError: $n2.reportErrorForced
		},opts_);
		
		var _this = this;
		
		this.wrappedServer.createDb({
			dbName: opts.dbName
			,onSuccess: function(couchDb){
				var db = new Database({
					couchDb: couchDb
				});
				opts.onSuccess(db);
			}
			,onError: opts.onError
		});
	},
	
	deleteDb: function(opts_) {
		this.wrappedServer.deleteDb(opts_);
	},
	
	replicate: function(opts_){
		this.wrappedServer.replicate(opts_);
	},
	
	addInitializedListener: function(listener) {
		this.wrappedServer.addInitializedListener(listener);
	}
});

//=============================================
function getServer(opts_) {
	var opts = $n2.extend({
		couchServer: null
		,indexedDbService: null
		,dispatchService: null
		,onSuccess: function(couchServer){}
		,onError: function(err){}
	},opts_);
	
	var server = new Server({
		couchServer: opts.couchServer
		,dispatchService: opts.dispatchService
		,indexedDbService: opts.indexedDbService
	});
	
	opts.onSuccess(server);
};

//=============================================

$n2.couchIndexedDb = {
	getServer: getServer
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchUtils.js

"use strict";
var n2utils = {

	isArray: function(o) {
		if( null === o ) return false;
		if( typeof(o) !== 'object' ) return false;
		if( typeof(o.length) !== 'number' ) return false;
		if( typeof(o.push) !== 'function' ) return false;
		if( typeof(o.pop) !== 'function' ) return false;
		if( typeof(o.concat) !== 'function' ) return false;
		if( typeof(o.join) !== 'function' ) return false;
		if( typeof(o.slice) !== 'function' ) return false;
		if( typeof(o.reverse) !== 'function' ) return false;
		if( typeof(o.splice) !== 'function' ) return false;
		if( typeof(o.sort) !== 'function' ) return false;
		
		return true;
	}
	
	,isArrayOfStrings: function(o) {
		if( !n2utils.isArray(o) ) return false;
		
		for(var i=0,e=o.length; i<e; ++i){
			if( typeof o[i] !== 'string' ) return false;
		};
		
		return true;
	}
	
	,isValidBounds: function(b) {
		if( false == n2utils.isArray(b) ) return false;
		if( b.length != 4 ) return false;
		var minx = b[0]
			,miny = b[1]
			,maxx = b[2]
			,maxy = b[3]
			;
		if( typeof(minx) !== 'number' ) return false;
		if( typeof(miny) !== 'number' ) return false;
		if( typeof(maxx) !== 'number' ) return false;
		if( typeof(maxy) !== 'number' ) return false;
		
		return true;
	}

	,isValidWkt: function(str) {
		function getChar(stream){
			if(stream.index < stream.str.length){
				return stream.str[stream.index];
			};
			return undefined;
		};
		
		function isSpace(c){
			if( ' ' === c 
			 || '\n' === c 
			 || '\r' === c ){
				return true;
			};
			return false;
		};

		function skipSpaces(stream){
			while(stream.index < stream.str.length){
				var c = stream.str[stream.index];
				if( isSpace(c) ){
					++stream.index;
				} else {
					break;
				};
			};
		};

		// number := \d+ ( '.' \d* )?
		function isValidNumber(stream){
			var isValid = false;
			
			var c = getChar(stream);
			if( '-' === c ){
				++stream.index;
				c = getChar(stream);
			};
			
			if( '0' <= c && '9' >= c ){
				isValid = true;
				
				while( '0' <= c && '9' >= c ){
					++stream.index;
					c = getChar(stream);
				};
				
				if( '.' === c ){
					// Floating point
					++stream.index;
					c = getChar(stream);
					while( '0' <= c && '9' >= c ){
						++stream.index;
						c = getChar(stream);
					};
				};
			};
			
			return isValid;
		};

		// location := <number> \s+ <number>
		function isValidLocation(stream){
			if( !isValidNumber(stream) ) return false;
			
			var c = getChar(stream);
			if( !isSpace(c) ) return false;
			skipSpaces(stream);

			if( !isValidNumber(stream) ) return false;

			// At this point, this is a valid location
			
			// Test for third position (z)
			var streamPosition = stream.index;
			skipSpaces(stream);
			if( !isValidNumber(stream) ) {
				// There is not a third position. Reset stream
				stream.index = streamPosition;
			};
			
			return true;
		};

		// point := '(' \s* <location> \s* ')'
		function isValidPoint(stream){
			if( '(' !== getChar(stream) ) return false;
			++stream.index;

			skipSpaces(stream);
			
			if( !isValidLocation(stream) ) return false;

			skipSpaces(stream);
			
			if( ')' !== getChar(stream) ) return false;
			++stream.index;
			
			return true;
		};
			
		// linestring := '(' \s* <location> \s* (',' \s* <location> \s*)+ ')'
		function isValidLineString(stream){
			if( '(' !== getChar(stream) ) return false;
			++stream.index;

			skipSpaces(stream);
			
			if( !isValidLocation(stream) ) return false;

			skipSpaces(stream);
			
			var count = 1;
			while( ',' === getChar(stream) ){
				++stream.index;
				
				++count;

				skipSpaces(stream);
				
				if( !isValidLocation(stream) ) return false;

				skipSpaces(stream);
			};
			
			if( ')' !== getChar(stream) ) return false;
			++stream.index;
			
			if( count < 2 ){
				return false;
			};
			
			return true;
		};
		
		// polygon := '(' \s* <linestring> \s* (',' \s* <linestring> \s*)* ')'
		function isValidPolygon(stream){
			if( '(' !== getChar(stream) ) return false;
			++stream.index;

			skipSpaces(stream);
			
			if( !isValidLineString(stream) ) return false;

			skipSpaces(stream);
			
			while( ',' === getChar(stream) ){
				++stream.index;
				
				skipSpaces(stream);
				
				if( !isValidLineString(stream) ) return false;

				skipSpaces(stream);
			};
			
			if( ')' !== getChar(stream) ) return false;
			++stream.index;
			
			return true;
		};
			
		function isValidGeometry(stream){
			if( 'point' === stream.str.substr(stream.index,'point'.length).toLowerCase() ){
				stream.index += 'point'.length;

				skipSpaces(stream);
				
				if( !isValidPoint(stream) ) return false;
				return true;
				
			} else if( 'linestring' === stream.str.substr(stream.index,'linestring'.length).toLowerCase() ){
				stream.index += 'linestring'.length;

				skipSpaces(stream);
				
				if( !isValidLineString(stream) ) return false;
				return true;
				
			} else if( 'polygon' === stream.str.substr(stream.index,'polygon'.length).toLowerCase() ){
				stream.index += 'polygon'.length;
				
				skipSpaces(stream);

				if( !isValidPolygon(stream) ) return false;
				return true;

			} else if( 'multipoint' === stream.str.substr(stream.index,'multipoint'.length).toLowerCase() ){
				stream.index += 'multipoint'.length;

				skipSpaces(stream);
				
				if( '(' !== getChar(stream) ) return false;
				++stream.index;

				skipSpaces(stream);
				
				if( !isValidPoint(stream) ) return false;

				skipSpaces(stream);

				while( ',' === getChar(stream) ){
					++stream.index;
					
					skipSpaces(stream);
					
					if( !isValidPoint(stream) ) return false;

					skipSpaces(stream);
				};

				if( ')' !== getChar(stream) ) return false;
				++stream.index;
				
				return true;

			} else if( 'multilinestring' === stream.str.substr(stream.index,'multilinestring'.length).toLowerCase() ){
				stream.index += 'multilinestring'.length;

				skipSpaces(stream);
				
				if( '(' !== getChar(stream) ) return false;
				++stream.index;

				skipSpaces(stream);
				
				if( !isValidLineString(stream) ) return false;

				skipSpaces(stream);

				while( ',' === getChar(stream) ){
					++stream.index;
					
					skipSpaces(stream);
					
					if( !isValidLineString(stream) ) return false;

					skipSpaces(stream);
				};

				if( ')' !== getChar(stream) ) return false;
				++stream.index;
				
				return true;

			} else if( 'multipolygon' === stream.str.substr(stream.index,'multipolygon'.length).toLowerCase() ){
				stream.index += 'multipolygon'.length;

				skipSpaces(stream);
				
				if( '(' !== getChar(stream) ) return false;
				++stream.index;

				skipSpaces(stream);
				
				if( !isValidPolygon(stream) ) return false;

				skipSpaces(stream);

				while( ',' === getChar(stream) ){
					++stream.index;
					
					skipSpaces(stream);
					
					if( !isValidPolygon(stream) ) return false;

					skipSpaces(stream);
				};

				if( ')' !== getChar(stream) ) return false;
				++stream.index;
				
				return true;

			} else if( 'geometrycollection' === stream.str.substr(stream.index,'geometrycollection'.length).toLowerCase() ){
				stream.index += 'geometrycollection'.length;

				skipSpaces(stream);
				
				if( '(' !== getChar(stream) ) return false;
				++stream.index;

				skipSpaces(stream);
				
				if( !isValidGeometry(stream) ) return false;

				skipSpaces(stream);

				while( ',' === getChar(stream) ){
					++stream.index;
					
					skipSpaces(stream);
					
					if( !isValidGeometry(stream) ) return false;

					skipSpaces(stream);
				};

				if( ')' !== getChar(stream) ) return false;
				++stream.index;
				
				return true;
			};
			
			return false;
		};
		
		var stream = {
			str: str
			,index: 0
		};
		
		skipSpaces(stream);

		if( !isValidGeometry(stream) ) return false;
		
		skipSpaces(stream);
		
		if( stream.str.length !== stream.index ) return false;
		
		return true;
	}

	,isValidGeom: function(o) {
		function countChar(str,c){
			return str.split(c).length - 1;
		};

		if( typeof(o) !== 'object' ) return false;

		if( typeof(o.nunaliit_type) !== 'string' ) return false;
		if( o.nunaliit_type !== 'geometry' ) return false;

		if( o.bbox ) {
			if( false == n2utils.isValidBounds(o.bbox) ) return false;
		} else {
			return false;
		};

		if( typeof(o.wkt) !== 'string' ) return false;
		if( !n2utils.isValidWkt(o.wkt) ) return false;

		return true;
	}

	,geomSize: function(o) {
		if( typeof(o) !== 'object' ) return 0;

		if( typeof(o.wkt) === 'string' ) {
			return o.wkt.length;
		};
		
		return 0;
	}

	,extractLayers: function(doc) {
		var result = null;
		
		if( doc.nunaliit_layers
		 && n2utils.isArray(doc.nunaliit_layers) ) {
			var layerMap = {};
			
			for(var i=0,e=doc.nunaliit_layers.length; i<e; ++i) {
				var l = doc.nunaliit_layers[i];
				if( typeof(l) === 'string' ) {
					layerMap[l] = true;
				};
			};
			
			for(var layerId in layerMap) {
				if( !result ) result = [];
				result.push(layerId);
			};
		};
		
		return result;
	}
	
	,excludedSearchTerms: [
		'a'
		,'the'
		,'of'
		,'an'
		,'and'
		,'or'
		,'by'
		,'in'
		,'to'
	]

	,extractSearchTerms: function(doc, indexing) {
		// Returns a map of words with associated usage.
		// The keys in the map are words and the associated
		// values are objects. The value objects contain an
		// attribute 'count' that contains the number of times
		// a word is encountered. It also contains an attribute 
		// 'index' which is the earlier reference of a word in
		// a found string.
	
		var strings = [];
		n2utils.extractStrings(doc,strings,null,n2utils.excludedSearchAttributes);
		
		var map = {};
		for(var i=0,e=strings.length;i<e;++i){
			n2utils.extractWordsFromString(strings[i],map,indexing);
		};
		
		return map;
	}
	
	,excludedSearchAttributes: [
		'_rev'
		,'nunaliit_geom'
		,'nunaliit_import.geometry'
	]
	
	,reWordSplit: /[\x00-\x26\x28-\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\x7f]+/ 

	,addWordToMap: function(word, index, map) {
		// Save each word in a map, with the number of times
		// the word is encountered (count) and the index of the word in 
		// the string it is found, favouring earlier indices.
		
		var word = word.toLowerCase();
		word = n2utils.removeApostrophe(word);
		if( word && word !== '' ) {
			if( map[word] ) {
				map[word].count++;
				if( index < map[word].index ) {
					map[word].index = index;
				};
			} else {
				var folded = n2utils.foldWord(word);
				map[word] = {
					index: index
					,count: 1
					,folded: folded
				};
			};
		};
	}

	,extractWordsFromString: function(str, map, indexing) {
		// For the string element, split up in words.
		// Save each word in a map of words, that keeps track
		// of number of times a word is encountered and the earliest
		// index it is found
		
		var words = str.split( n2utils.reWordSplit );
		for(var i=0,e=words.length; i<e; ++i) {
			n2utils.addWordToMap(words[i],i,map);
			
			if( indexing ) {
				var fragments = words[i].split('_');
				if( fragments.length > 1 ){
					for(var j=0,k=fragments.length; j<k; ++j){
						if( fragments[j].length > 0 ) {
							n2utils.addWordToMap(fragments[j],i,map);
						};
					};
				};
			};
		};
	}

	,extractStrings: function(obj, strings, currentPath, excludedPaths) {
		// Traverses an object to find all string elements.
		// Accumulate strings in the given array
		// Skip excluded paths

		for(var i=0,e=excludedPaths.length; i<e; ++i){
			// this path is excluded
			if( excludedPaths[i] === currentPath ) return;
		};
		
		if( null === obj ) {
			// Nothing to do
			
		} else if( typeof(obj) === 'string' ) {
			strings.push(obj);
			
		} else if( n2utils.isArray(obj) ) {
			for(var i=0,e=obj.length; i<e; ++i) {
				var p = currentPath ? currentPath+'.'+i : ''+i;
				n2utils.extractStrings(obj[i],strings,p,excludedPaths);
			};

		} else if( typeof(obj) === 'object' ) {
			for(var key in obj) {
				var p = currentPath ? currentPath+'.'+key : ''+key;
				n2utils.extractStrings(obj[key],strings,p,excludedPaths);
			};
		};
	}
	
	,foldedChars: {
0x60: 0x27
,0xc0: 0x61
,0xc1: 0x61
,0xc2: 0x61
,0xc3: 0x61
,0xc4: 0x61
,0xc7: 0x63
,0xc8: 0x65
,0xc9: 0x65
,0xca: 0x65
,0xcb: 0x65
,0xcc: 0x69
,0xcd: 0x69
,0xce: 0x69
,0xcf: 0x69
,0xd1: 0x6e
,0xd2: 0x6f
,0xd3: 0x6f
,0xd4: 0x6f
,0xd5: 0x6f
,0xd6: 0x6f
,0xd8: 0x6f
,0xd9: 0x75
,0xda: 0x75
,0xdb: 0x75
,0xdc: 0x75
,0xdd: 0x79
,0xe0: 0x61
,0xe1: 0x61
,0xe2: 0x61
,0xe3: 0x61
,0xe4: 0x61
,0xe7: 0x63
,0xe8: 0x65
,0xe9: 0x65
,0xea: 0x65
,0xeb: 0x65
,0xec: 0x69
,0xed: 0x69
,0xee: 0x69
,0xef: 0x69
,0xf1: 0x6e
,0xf2: 0x6f
,0xf3: 0x6f
,0xf4: 0x6f
,0xf5: 0x6f
,0xf6: 0x6f
,0xf8: 0x6f
,0xf9: 0x75
,0xfa: 0x75
,0xfb: 0x75
,0xfc: 0x75
,0xfd: 0x79
,0xff: 0x79
,0x0100: 0x61
,0x0101: 0x61
,0x0102: 0x61
,0x0103: 0x61
,0x0104: 0x61
,0x0105: 0x61
,0x0106: 0x63
,0x0107: 0x63
,0x0108: 0x63
,0x0109: 0x63
,0x010a: 0x63
,0x010b: 0x63
,0x010c: 0x63
,0x010d: 0x63
,0x010e: 0x64
,0x010f: 0x64
,0x0110: 0x64
,0x0111: 0x64
,0x0112: 0x65
,0x0113: 0x65
,0x0114: 0x65
,0x0115: 0x65
,0x0116: 0x65
,0x0117: 0x65
,0x0118: 0x65
,0x0119: 0x65
,0x011a: 0x65
,0x011b: 0x65
,0x011c: 0x67
,0x011d: 0x67
,0x011e: 0x67
,0x011f: 0x67
,0x0120: 0x67
,0x0121: 0x67
,0x0122: 0x67
,0x0123: 0x67
,0x0124: 0x68
,0x0125: 0x68
,0x0126: 0x68
,0x0127: 0x68
,0x0128: 0x69
,0x0129: 0x69
,0x012a: 0x69
,0x012b: 0x69
,0x012c: 0x69
,0x012d: 0x69
,0x012e: 0x69
,0x012f: 0x69
,0x0130: 0x69
,0x0131: 0x69
,0x0134: 0x6a
,0x0135: 0x6a
,0x0136: 0x6b
,0x0137: 0x6b
,0x0138: 0x6b
,0x0139: 0x6c
,0x013a: 0x6c
,0x013b: 0x6c
,0x013c: 0x6c
,0x013d: 0x6c
,0x013e: 0x6c
,0x013f: 0x6c
,0x0140: 0x6c
,0x0141: 0x6c
,0x0142: 0x6c
,0x0143: 0x6e
,0x0144: 0x6e
,0x0145: 0x6e
,0x0146: 0x6e
,0x0147: 0x6e
,0x0148: 0x6e
,0x0149: 0x6e
,0x014a: 0x6e
,0x014b: 0x6e
,0x014c: 0x6f
,0x014d: 0x6f
,0x014e: 0x6f
,0x014f: 0x6f
,0x0150: 0x6f
,0x0151: 0x6f
,0x0154: 0x72
,0x0155: 0x72
,0x0156: 0x72
,0x0157: 0x72
,0x0158: 0x72
,0x0159: 0x72
,0x015a: 0x73
,0x015b: 0x73
,0x015c: 0x73
,0x015d: 0x73
,0x015e: 0x73
,0x015f: 0x73
,0x0160: 0x73
,0x0161: 0x73
,0x0162: 0x74
,0x0163: 0x74
,0x0164: 0x74
,0x0165: 0x74
,0x0166: 0x74
,0x0167: 0x74
,0x0168: 0x75
,0x0169: 0x75
,0x016a: 0x75
,0x016b: 0x75
,0x016c: 0x75
,0x016d: 0x75
,0x016e: 0x75
,0x016f: 0x75
,0x0170: 0x75
,0x0171: 0x75
,0x0172: 0x75
,0x0173: 0x75
,0x0174: 0x77
,0x0175: 0x77
,0x0176: 0x79
,0x0177: 0x79
,0x0178: 0x79
,0x0179: 0x7a
,0x017a: 0x7a
,0x017b: 0x7a
,0x017c: 0x7a
,0x017d: 0x7a
,0x017e: 0x7a
,0x2018: 0x27
,0x2019: 0x27
,0x201b: 0x27
,0x2032: 0x27
,0x2035: 0x27
	}
	
	,foldWord: function(word) {
		var r = [];
		word = word.toLowerCase();
		for(var i=0,e=word.length;i<e;++i){
			var c = word.charCodeAt(i);
			if( c === c ) {
				// Is not NaN
				var s = n2utils.foldedChars[c];
				if( s ) {
					r.push( String.fromCharCode(s) );
				} else {
					r.push( String.fromCharCode(c) );
				};
			};
		};
		return r.join('');
	}
	
	,removeApostrophe: function(word){
		if( word.length > 1 && n2utils.isApostropheCodeChar(word.charCodeAt(0)) ) {
			word = word.substr(1,word.length-1);
		};
		if( word.length > 1 && n2utils.isApostropheCodeChar(word.charCodeAt(word.length-1)) ) {
			word = word.substr(0,word.length-1);
		};
		if( word.length > 2 && word[word.length-1] === 's' 
			&& n2utils.isApostropheCodeChar(word.charCodeAt(word.length-2)) ) {
			word = word.substr(0,word.length-2);
		};
		return word;
	}
	
	,isApostropheCodeChar: function(code){
		return (code === 0x27 || code === 0x60 
			|| code === 0x2018 || code === 0x2019 || code === 0x201b
			|| code === 0x2032 || code === 0x2035
			);
	}

	,extractTypes: function(obj, result, ancestors) {
		// Traverses an object to find all structure types.
		
		ancestors = ancestors ? ancestors : [];
		
		if( ancestors.indexOf(obj) >= 0 ) {
			// already visited
			return;
		};
		
		ancestors.push(obj);
		
		if( null === obj ) {
			// Nothing to do
			
		} else if( n2utils.isArray(obj) ) {
			for(var i=0,e=obj.length; i<e; ++i) {
				n2utils.extractTypes(obj[i],result,ancestors);
			};

		} else if( typeof(obj) === 'object' ) {
			if( obj.nunaliit_type ) {
				// This is a type
				result[obj.nunaliit_type] = 1;
			};
			
			// Continue traversing
			for(var key in obj) {
				var value = obj[key];
				
				n2utils.extractTypes(value,result,ancestors);
			};
		};

		ancestors.pop();
	}

	,extractSpecificType: function(obj, type, result, ancestors) {
		// Traverses an object to find all components of a
		// given type.
		
		ancestors = ancestors ? ancestors : [];
		
		if( ancestors.indexOf(obj) >= 0 ) {
			// already visited
			return;
		};
		
		ancestors.push(obj);
		
		if( null === obj ) {
			// Nothing to do
			
		} else if( n2utils.isArray(obj) ) {
			for(var i=0,e=obj.length; i<e; ++i) {
				n2utils.extractSpecificType(obj[i],type,result,ancestors);
			};

		} else if( typeof(obj) === 'object' ) {
			if( obj.nunaliit_type && obj.nunaliit_type === type ) {
				// This is an object of interest
				result.push(obj);
			} else {
				// This is not what we are looking for. Continue searching.
				for(var key in obj) {
					if( '__n2Source' === key ) continue;
					
					var value = obj[key];
					
					n2utils.extractSpecificType(value,type,result,ancestors);
				};
			};
		};
		
		ancestors.pop();
	}

	,extractLinks: function(obj, links) {
		// Traverses an object to find all link elements.
		// Return all link elements in a list.

		n2utils.extractSpecificType(obj, 'reference', links);
	}

	,extractGeometries: function(obj, geometries) {
		// Traverses an object to find all geometry elements.

		n2utils.extractSpecificType(obj, 'geometry', geometries);
	}
	
	,getAtlasRole: function(n2Atlas, role){
		if( !n2Atlas ) {
			return role;
		} else if( typeof(n2Atlas.name) === 'string' ) {
			return n2Atlas.name + '_' + role;
		};
		return role;
	}
	
	,validateDocumentStructure: function(doc, errorFn){
		
		// Ensure all nunaliit_type entries are strings
		n2utils.validateTypes(doc,errorFn);
		
		// Verify schema
		if( doc.nunaliit_schema 
		 && typeof doc.nunaliit_schema !== 'string' ){
			errorFn('If nunaliit_schema is specified, it must be a string');
		};
		
		// Verify geometries
		var geometries = [];
		n2utils.extractGeometries(doc, geometries);
		for(var i=0,e=geometries.length; i<e; ++i) {
			var geometry = geometries[i];
			
			if( !n2utils.isValidGeom(geometry) ) {
				errorFn('Invalid geometry');
			}
		};

		// Verify nunaliit_created
		if( doc.nunaliit_created ){
			if( typeof doc.nunaliit_created !== 'object' ) {
				errorFn('Field "nunaliit_created" must be an object');
			};
			if( doc.nunaliit_created.nunaliit_type !== 'actionstamp' ) {
				errorFn('"nunaliit_created" must be of type "actionstamp"');
			};
			if( typeof doc.nunaliit_created.time !== 'number' ) {
				errorFn('"nunaliit_created.time" must be a number');
			};
			if( doc.nunaliit_created.action !== 'created' ) {
				errorFn('"nunaliit_created.action" must be a "created"');
			};
		};

		// Verify nunaliit_last_updated
		if( doc.nunaliit_last_updated ){
			if( typeof doc.nunaliit_last_updated !== 'object' ) {
				errorFn('Field "nunaliit_last_updated" must be an object');
			};
			if( doc.nunaliit_last_updated.nunaliit_type !== 'actionstamp' ) {
				errorFn('"nunaliit_last_updated" must be of type "actionstamp"');
			};
			if( typeof doc.nunaliit_last_updated.time !== 'number' ) {
				errorFn('"nunaliit_last_updated.time" must be a number');
			};
			if( doc.nunaliit_last_updated.action !== 'updated' ) {
				errorFn('"nunaliit_last_updated.action" must be a "updated"');
			};
		};
		
		// Verify action stamps
		var actionStamps = [];
		n2utils.extractSpecificType(doc, 'actionstamp', actionStamps);
		for(var i=0,e=actionStamps.length; i<e; ++i) {
			var as = actionStamps[i];
			
			if( typeof as.name !== 'string' ){
				errorFn('Action stamps must have a string field named: "name"');
			};
			if( typeof as.time !== 'number' ) {
				errorFn('Action stamps must have a number field named: "time"');
			};
		};

		// Verify layers
		if( doc.nunaliit_layers ) {
			if( !n2utils.isArrayOfStrings(doc.nunaliit_layers) ) {
				errorFn('nunaliit_layers must be an array of strings');
			};
		};

		// Verify l10n request
		if( 'translationRequest' === doc.nunaliit_type ) {
			if( typeof doc.str !== 'string' ) {
				errorFn('Translation requests must have a string "str"');
			}
			if( typeof doc.lang !== 'string' ) {
				errorFn('Translation requests must have a string "lang"');
			}
			if( doc.trans ) {
				if( typeof doc.trans !== 'string' ) {
					errorFn('Translation requests providing "trans" field must be string');
				}
			}
		};
	
		// Verify CSS
		if( doc.nunaliit_css ) {
			if( typeof doc.nunaliit_css !== 'object' ){
				errorFn('CSS fragments must have an object structure');
			};
			if( doc.nunaliit_css.nunaliit_type !== 'css' ){
				errorFn('CSS fragments must have a type of "css"');
			};
			if( typeof(doc.nunaliit_css.name) !== 'string' ) {
				errorFn('CSS fragments must have a string "name" property.');
			};
			if( typeof(doc.nunaliit_css.css) !== 'undefined'
			 && typeof(doc.nunaliit_css.css) !== 'string' ) {
				errorFn('CSS fragments must have a string "css" property.');
			};
		};

		// Verify submission
		if( doc.nunaliit_submission ) {
			if( typeof doc.nunaliit_submission !== 'object' ){
				errorFn('Submission documents must have an object structure');
			};
			if( typeof doc.nunaliit_submission.state !== 'string' ){
				errorFn('Submission documents must include a state');
			};
			if( typeof doc.nunaliit_submission.submitter_name !== 'string' ){
				errorFn('Submission documents must include the name of the submitter');
			};
			if( false == n2utils.isArrayOfStrings(doc.nunaliit_submission.submitter_roles) ){
				errorFn('Submission documents must include the roles of the submitter');
			};
			if( doc.nunaliit_submission.original_reserved ) {
				if( typeof doc.nunaliit_submission.original_reserved !== 'object' ){
					errorFn('Submission documents must have an object for field "original_reserved"');
				};
				if( typeof doc.nunaliit_submission.original_reserved.id !== 'string' ){
					errorFn('Submission documents must include the original identifier');
				};
			};
			if( typeof doc.nunaliit_submission.original_doc !== 'object' 
			 && typeof doc.nunaliit_submission.original_doc !== 'undefined' ){
				errorFn('In a submission document, if specified, "original_doc" must be an object');
			};
			if( typeof doc.nunaliit_submission.submitted_reserved !== 'object' 
			 && typeof doc.nunaliit_submission.submitted_reserved !== 'undefined' ){
				errorFn('In a submission document, if specified, "submitted_reserved" must be an object');
			};
			if( typeof doc.nunaliit_submission.submitted_doc !== 'object' 
			 && typeof doc.nunaliit_submission.submitted_doc !== 'undefined' ){
				errorFn('In a submission document, if specified, "submitted_doc" must be an object');
			};
			if( typeof doc.nunaliit_submission.deletion !== 'boolean' 
			 && typeof doc.nunaliit_submission.deletion !== 'undefined' ){
				errorFn('In a submission document, if specified, "deletion" must be a boolean');
			};
			if( !doc.nunaliit_submission.deletion ){
				if( !doc.nunaliit_submission.submitted_reserved ){
					errorFn('In a submission document, if not a deletion, then "submitted_reserved" must be specified');
				};
			};
			if( !doc.nunaliit_submission.submitted_reserved 
			 && !doc.nunaliit_submission.original_reserved ){
				errorFn('In a submission document, one of "submitted_reserved" or "original_reserved" must be specified');
			};
		};
		
		// Verify attachment descriptors
		if( doc.nunaliit_attachments ){
			if( typeof doc.nunaliit_attachments !== 'object' ){
				errorFn('"nunaliit_attachments" must be an object structure');
			};
			if( doc.nunaliit_attachments.nunaliit_type !== 'attachment_descriptions' ){
				errorFn('"nunaliit_attachments" must be of type "attachment_descriptions"');
			};
			if( typeof doc.nunaliit_attachments.files !== 'object' ){
				errorFn('"nunaliit_attachments" must have an object structure named "files"');
			};
			for(var attName in doc.nunaliit_attachments.files) {
				var att = doc.nunaliit_attachments.files[attName];
				
				if( typeof att !== 'object' ){
					errorFn('Attachment descriptors must be of type "object"');
				};
				if( att.attachmentName !== attName ){
					errorFn('Attachment descriptors must have a duplicate name in "attachmentName"');
				};
				if( typeof att.status !== 'string' ){
					errorFn('Attachment descriptors must have a "status" string');
				};
			};
		};
	}

	,validateTypes: function(obj, errorFn) {
		// Traverses an object to validate all fields
		// named: "nunaliit_type"
		
		if( null === obj ) {
			// Nothing to do
			
		} else if( n2utils.isArray(obj) ) {
			for(var i=0,e=obj.length; i<e; ++i) {
				if( n2utils.validateTypes(obj[i],errorFn) ){
					return true;
				};
			};

		} else if( typeof(obj) === 'object' ) {
			if( obj.nunaliit_type ) {
				if( typeof obj.nunaliit_type !== 'string' ){
					errorFn('Fields named "nunaliit_type" must be strings');
					return true;
				};
			};
			
			// Continue traversing
			for(var key in obj) {
				var value = obj[key];
				
				if( n2utils.validateTypes(value,errorFn) ){
					return true;
				};
			};
		};
		
		return false;
	}
};

if( typeof exports === 'object' ) {
	exports.isArray = n2utils.isArray;
	exports.isArrayOfStrings = n2utils.isArrayOfStrings;
	exports.isValidBounds = n2utils.isValidBounds;
	exports.isValidWkt = n2utils.isValidWkt;
	exports.isValidGeom = n2utils.isValidGeom;
	exports.extractLayers = n2utils.extractLayers;
	exports.extractLinks = n2utils.extractLinks;
	exports.extractSearchTerms = n2utils.extractSearchTerms;
	exports.addWordToMap = n2utils.addWordToMap;
	exports.extractStrings = n2utils.extractStrings;
	exports.foldWord = n2utils.foldWord;
	exports.removeApostrophe = n2utils.removeApostrophe;
	exports.isApostropheCodeChar = n2utils.isApostropheCodeChar;
	exports.extractTypes = n2utils.extractTypes;
	exports.extractSpecificType = n2utils.extractSpecificType;
	exports.extractGeometries = n2utils.extractGeometries;
	exports.getAtlasRole = n2utils.getAtlasRole;
	exports.validateDocumentStructure = n2utils.validateDocumentStructure;
	exports.validateTypes = n2utils.validateTypes;
};

if( typeof nunaliit2 === 'function' ) {
	nunaliit2.couchUtils = {};
	nunaliit2.couchUtils.isArray = n2utils.isArray;
	nunaliit2.couchUtils.isArrayOfStrings = n2utils.isArrayOfStrings;
	nunaliit2.couchUtils.isValidBounds = n2utils.isValidBounds;
	nunaliit2.couchUtils.isValidWkt = n2utils.isValidWkt;
	nunaliit2.couchUtils.isValidGeom = n2utils.isValidGeom;
	nunaliit2.couchUtils.extractLayers = n2utils.extractLayers;
	nunaliit2.couchUtils.extractLinks = n2utils.extractLinks;
	nunaliit2.couchUtils.extractSearchTerms = n2utils.extractSearchTerms;
	nunaliit2.couchUtils.addWordToMap = n2utils.addWordToMap;
	nunaliit2.couchUtils.extractStrings = n2utils.extractStrings;
	nunaliit2.couchUtils.foldWord = n2utils.foldWord;
	nunaliit2.couchUtils.removeApostrophe = n2utils.removeApostrophe;
	nunaliit2.couchUtils.isApostropheCodeChar = n2utils.isApostropheCodeChar;
	nunaliit2.couchUtils.extractTypes = n2utils.extractTypes;
	nunaliit2.couchUtils.extractSpecificType = n2utils.extractSpecificType;
	nunaliit2.couchUtils.extractGeometries = n2utils.extractGeometries;
	nunaliit2.couchUtils.getAtlasRole = n2utils.getAtlasRole;
	nunaliit2.couchUtils.validateDocumentStructure = n2utils.validateDocumentStructure;
	nunaliit2.couchUtils.validateTypes = n2utils.validateTypes;
};


// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchTiles.js

"use strict";
var n2tiles = {

	format4326_65K: null
	,format4326_200: null
	,format4326_25M: null

	,makeFormat: function(minx,miny,maxx,maxy,resx,resy) {
		var tilesX = (maxx - minx) * resx;
		var tilesY = (maxy - miny) * resy;
		var tiles = tilesX * tilesY;
		
		var incx = (maxx - minx) / tilesX;
		var incy = (maxy - miny) / tilesY;
	
		return {
			minx: minx
			,miny: miny
			,maxx: maxx
			,maxy: maxy
			,resx: resx
			,resy: resy
			,tiles: tiles
			,nx: tilesX
			,ny: tilesY
			,incx: incx
			,incy: incy
		};
	}
	
	,getBoundsFromTile: function(format, tileNumber) {
		var coordX = tileNumber % format.nx;
		var coordY = (tileNumber - coordX) / format.nx;
		
		var minx = ((coordX * format.incx) + format.minx);
		var miny = ((coordY * format.incy) + format.miny);
		
		return {
			minx: minx
			,miny: miny
			,maxx: (minx + format.incx)
			,maxy: (miny + format.incy)
		};
	}
	
	,getTileFromPosition: function(format, x, y) {
		return (y * format.nx) + x;
	}
	
	,getTilePositionFromCoords: function(format, x, y) {
		var coordX = Math.floor((x - format.minx) / format.incx);
		var coordY = Math.floor((y - format.miny) / format.incy);
		
		if( coordX < 0 ) coordX = 0;
		if( coordX >= format.nx ) coordX = format.nx - 1;
		if( coordY < 0 ) coordY = 0;
		if( coordY >= format.ny ) coordY = format.ny - 1;
		
		return {
			x: coordX
			,y: coordY
			,tile: n2tiles.getTileFromPosition(format, coordX, coordY)
		};
	}
	
	,getTileFromCoords: function(format, x, y) {
		var coordX = Math.floor((x - format.minx) / format.incx);
		var coordY = Math.floor((y - format.miny) / format.incy);
		
		if( coordX < 0 ) coordX = 0;
		if( coordX >= format.nx ) coordX = format.nx - 1;
		if( coordY < 0 ) coordY = 0;
		if( coordY >= format.ny ) coordY = format.ny - 1;
		
		return n2tiles.getTileFromPosition(format, coordX, coordY);
	}
	
	,getTilesFromBounds: function(format, minx, miny, maxx, maxy, maxTiles) {
		
		var blTilePosition = n2tiles.getTilePositionFromCoords(format, minx, miny);
		var trTilePosition = n2tiles.getTilePositionFromCoords(format, maxx, maxy);
		
		var leftX = blTilePosition.x;
		var rightX = trTilePosition.x;
		var trTile = trTilePosition.tile;
		
		if( minx > maxx // wrap around situation
		 && leftX === rightX // end up on same tile
		 ){
			--rightX;
			if( rightX < 0 ){
				rightX = format.nx - 1;
			};
		};
		
//$n2.log('leftX',leftX);
//$n2.log('rightX',rightX);
//$n2.log('trTile',trTile);

		var result = [];
		
//var count = 0;		
		var done = 0;
		var x = blTilePosition.x;
		var y = blTilePosition.y;
		var tile = n2tiles.getTileFromPosition(format, x, y);
		while(!done) {
			result.push(tile);
//$n2.log('tile',tile);

			if( tile == trTile ) {
				done = 1;
				
			} else if( x == rightX ) {
				x = leftX;
				y = y + 1;
				while( y >= format.ny ){
					y = y - format.ny;
				};
				
			} else {
				x = x + 1;
				while( x >= format.nx ){
					x = x - format.nx;
				};
			}

			tile = n2tiles.getTileFromPosition(format, x, y);
//++count;
//if(count>10) return result;
			if(result.length>format.tiles) return []; // error			
			if( maxTiles && result.length>maxTiles) return []; // max reached
		};
		
		return result;
	}
	
	,getApproxTilesForBounds: function(format, minx, miny, maxx, maxy) {
		var cX = (maxx>minx) ? ((maxx - minx) / format.incx) :
			(((format.maxx - maxx) + (minx - format.minx)) / format.incx);
		var cY = (maxy>miny) ? ((maxy - miny) / format.incy) :
			(((format.maxy - maxy) + (miny - format.miny)) / format.incy);
		
		return (Math.floor(cX)+1) * (Math.floor(cY) + 1);
	}
};

//n2tiles.format4326_65K = n2tiles.makeFormat(-180,-90,180,90,1,1);
n2tiles.format4326_200 = {
minx: -180
,miny: -90
,maxx: 180
,maxy: 90
,resx: 0.05
,resy: 0.05
,tiles: 162
,nx: 18
,ny: 9
,incx: 20
,incy: 20
};

//n2tiles.format4326_200 = n2tiles.makeFormat(-180,-90,180,90,0.05,0.05);
n2tiles.format4326_65K = {
minx: -180
,miny: -90
,maxx: 180
,maxy: 90
,resx: 1
,resy: 1
,tiles: 64800
,nx: 360
,ny: 180
,incx: 1
,incy: 1
};

//n2tiles.format4326_25M = n2tiles.makeFormat(-180,-90,180,90,20,20);
n2tiles.format4326_25M = {
minx: -180
,miny: -90
,maxx: 180
,maxy: 90
,resx: 20
,resy: 20
,tiles: 25920000
,nx: 7200
,ny: 3600
,incx: 0.05
,incy: 0.05
};

if( typeof exports === 'object' ) {
	exports.makeFormat = n2tiles.makeFormat;
	exports.getBoundsFromTile = n2tiles.getBoundsFromTile;
	exports.getTileFromCoords = n2tiles.getTileFromCoords;
	exports.getTilesFromBounds = n2tiles.getTilesFromBounds;
	exports.getApproxTilesForBounds = n2tiles.getApproxTilesForBounds;
	exports.format4326_65K = n2tiles.format4326_65K;
	exports.format4326_200 = n2tiles.format4326_200;
	exports.format4326_25M = n2tiles.format4326_25M;
};
if( typeof nunaliit2 === 'function' ) {
	nunaliit2.tiles = {};
	nunaliit2.tiles.makeFormat = n2tiles.makeFormat;
	nunaliit2.tiles.getBoundsFromTile = n2tiles.getBoundsFromTile;
	nunaliit2.tiles.getTilePositionFromCoords = n2tiles.getTilePositionFromCoords;
	nunaliit2.tiles.getTileFromCoords = n2tiles.getTileFromCoords;
	nunaliit2.tiles.getTilesFromBounds = n2tiles.getTilesFromBounds;
	nunaliit2.tiles.getApproxTilesForBounds = n2tiles.getApproxTilesForBounds;
	nunaliit2.tiles.format4326_65K = n2tiles.format4326_65K;
	nunaliit2.tiles.format4326_200 = n2tiles.format4326_200;
	nunaliit2.tiles.format4326_25M = n2tiles.format4326_25M;
};
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchSchema.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

var CouchSchemaRepository = $n2.Class($n2.schema.SchemaRepository,{
	
	couchOptions: null
	
	,initialize: function(opts_){
		$n2.schema.SchemaRepository.prototype.initialize.apply(this);
		
		this.couchOptions = $n2.extend({
			db: null
			,designDoc: null
			,viewNameSchemas: 'schemas'
			,viewNameRootSchemas: 'schemas-root'
			,dispatchService: null
			,preload: false
			,preloadedCallback: function(){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		this.loadSchemasFn = function(o){
			_this._loadSchemas(o);
		};

		var dispatcher = this._getDispatcher();
		if( dispatcher ){
			var dispatcherHandle = dispatcher.getHandle('n2.couchSchema');
			
			var f = function(m){
				_this._handle(m);
			};
			
			dispatcher.register(dispatcherHandle, 'documentContentCreated', f);
			dispatcher.register(dispatcherHandle, 'documentContentUpdated', f);
		};
		
		if( this.couchOptions.preload ){
			this._preload();
		};
	}
	
	,_loadSchemas: function(opt_){
		var opt = $n2.extend({
			names: null
			,rootSchemas: false
			,onSuccess: function(schemaDefinitions){}
			,onError: function(err){ $n2.reportError(err); }
		},opt_);
		
		var viewRequest = {
			viewName: this.couchOptions.viewNameSchemas
			,include_docs: true
			,onSuccess: function(rows){
				var defs = [];
				for(var i=0,e=rows.length; i<e; ++i) {
					defs.push(rows[i].doc);
				};
				opt.onSuccess(defs);
			}
			,onError: opt.onError
		};
		
		if( opt.names ) {
			viewRequest.keys = opt.names;
		};
		
		if( opt.rootSchemas ) {
			viewRequest.viewName = this.couchOptions.viewNameRootSchemas;
		};
		
		// Query view
		this.couchOptions.designDoc.queryView(viewRequest);
	}
	
	,_handle: function(m){
		if( 'documentContentCreated' === m.type
		 || 'documentContentUpdated' === m.type ) {
			var doc = m.doc;
			
			if( doc.nunaliit_type === 'schema' ) {
				this.addSchemas({
					schemas: [doc]
					,onError: function(err){
						$n2.log('Error adding created/updated schema ('+doc._id+') to repository: '+err);
					}
				});
			};
		};
	}
	
	,_getDispatcher: function(){
		return this.couchOptions.dispatchService;
	}

	,_preload: function(){

		var _this = this;
		
		this.couchOptions.designDoc.queryView({
			viewName: this.couchOptions.viewNameSchemas
			,include_docs: true
			,onSuccess: function(rows){
				var defs = [];
				for(var i=0,e=rows.length; i<e; ++i) {
					defs.push(rows[i].doc);
				};
				_this.addSchemas({
					schemas: defs
				});
				_this.rootSchemasQueried = true;
				_this.couchOptions.preloadedCallback();
			}
			,onError: function(err){
				_this.couchOptions.onError( _loc('Unable to preload schemas: {err}',{err:err}) );
			}
		});
	}
});


//============================================================
// Exports
$n2.couchSchema = {
	CouchSchemaRepository: CouchSchemaRepository
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchImportData.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
;(function($,$n2){
"use strict";

	// Localization
	var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch-import',args); };

	var StatusLogger = $n2.Class({
		divId: null
		
		,initialize: function(opts_){
			var opts = $n2.extend({
				div: null
			},opts_);
			
			if( opts.div ){
				var $div = $(opts.div);
				var id = $div.attr('id');
				if( !id ){
					id = $n2.getUniqueId();
					$div.attr('id',id);
				};
				this.divId = id;
			};
		}
	
		,log: function(text){
			var $log = this._getLog();
			var id = $n2.getUniqueId();
			$('<div class="data_import_status"></div>')
				.attr('id',id)
				.text(text)
				.appendTo( $log );
			return id;
		}
		
		,error: function(text){
			var $log = this._getLog();
			var id = $n2.getUniqueId();
			$('<div class="data_import_status data_import_error"></div>')
				.attr('id',id)
				.text('Error: '+text)
				.appendTo( $log );
			return id;
		}
		
		,empty: function(){
			var $log = this._getLog();
			$log.empty();
		}
		
		,_getLog: function(){
			return $('#'+this.divId);
		}
	});

	/**
	 * Base class for data importers.  Instantiate one that includes
	 * a data loading method (e.g. $.getJSON) below or instantiate 
	 * this with a hard coded data array (this.options.dataArray)
	 * 
	 * In each case, an input JSON object is converted to be used as one 
	 * or more documents
	 * in the underlying atlas data according to atlas application requirements.
	 * The reason to do this would be because the input entry is logically
	 * composed of multiple records which in the couchdb application make
	 * more sense as a group of linked documents (i.e., documents refer 
	 * to each other using their _id fields).
	 * 
	 * To accomplish this using asynchronous document updates to push each
	 * portion of the original information to the database requires that 
	 * each piece be uploaded, then fetched to find the allocated ID, using
	 * that ID to update the related records referring to the original
	 * information portion, and then uploading the piece.
	 * 
	 * The process will support a 1:N conversion, defined as:
	 * 
	 * convertJsonForUpload: A function that takes a single
	 *                       object as input and returns an array, A, containing
	 *                       1 object ready for upload and N-1 interim objects 
	 *                       that at least potentially may be further updated
	 *                       before upload.  A[0] will be uploaded as returned
	 *                       by this function.  
	 *              
	 * incrementalUpdateFns: An array of N-1 incremental update functions, each called
	 *                       after a data portion, originally created by convertJsonForUpload,
	 *                       is uploaded to the database.
	 *                       Entry k is called after A[k] has been uploaded to update
	 *                       entries A[k+1 ... N-1] given A[k]'s doc ID.
	 *                       If when ready for upload, A[k] is
	 *                       null or undefined, it is skipped (useful for optional
	 *                       data portions).
	 *                       
	 * viewNames[]: an array of N viewNames that will be used in conjunction with 
	 *              an array of N key value functions to determine whether or not
	 *              the component objects to be uploaded already exist in the
	 *              database.  A null entry in either the viewNames array or in the
	 *              key values array means that the existence of that subcomponent
	 *              record is not checked.  This is valid if the record is only 
	 *              potentially unique in its generated document ID used to reference
	 *              it from the other information components.
	 *              
	 * keyValueFns[]: see description of viewNames above.  viewNames[k] and keyValueFns[k]
	 *                correspond to each other.
	 *                
	 * containsGeometry[]: N element array of boolean flags defining whether or not each
	 *                     output information component contains a geometry field.  Normally
	 *                     at most only one of the output records would contain geometry but
	 *                     depending on the data relationships between information components
	 *                     there's no way to know which record would contain the geometry.
	 *                     
	 * descriptiveLabels[]: an array of data type descriptive labels used in error and status
	 *                      message displays, corresponding to each information component
	 *                      created during conversion.
	 * 
	 * +------+          +--------+
	 * |  IN  |  -+-->   | OUT 1  | <----+
	 * +------+   |      +--------+      |
	 *            |                      |
	 *            |      +--------+      |
	 *            +-->   | OUT 2  |      |
	 *            |      +--------+      |
	 * conversion |                      | (example reference; later upload references earlier)
	 *  process   |                      |
	 *            |         ...          |
	 *            |                      |
	 *            |                      |
	 *            |      +--------+      |
	 *            +-->   | OUT N  | -----+
	 *                   +--------+
	 * 
	 */
	$n2.OneToManyDataImporter = $n2.Class(
		'$n2.OneToManyDataImporter',
		{
			options: {
				db: null,
				designDoc: null,
				atlasDesign: null,
				dataArray: [], // array of json objects to be converted
				statusDiv: null, // for output messages (legacy)
				logger: null,
				eraseStatusDiv: true,
				
				/*
				 * need to pause for tiling updates, per output info portion
				 */
				containsGeometry: [ false ],
				
				/*
				 * descriptive labels describing data type of each output info portion
				 * created by the conversion function.  Used in output status messages.
				 */
				descriptiveLabels: [ '' ],
				
				/*
				 * couchdb viewnames array, each of which can be used to find a 
				 * single document with a key generated from the corresponding entry 
				 * in the keyValueFns array (below).
				 */
				viewNames: [ '' ],
				
				/**
				 * Take an entry to be added and generate the key for it.  Note
				 * that each of these functions is always called on the pre-converted
				 * record (see  below).
				 * 
				 * function signature: function(entry) {}
				 * @param enrty pre-conversion data entry to be added to database.
				 * @return key value (possibly complex)
				 */
				keyValueFns: [ function(entry) { return null; } ],
				
				/**
				 * Verify that a record to be converted and added contains the required fields
				 * @param enrty pre-conversion data entry to be added to database.
				 */
				jsonPropertiesVerifyFn: function(entry) {
					return true;
				},
				
				/**
				 * convert the imported entry for adding to the database according
				 * to the current system's templates.
				 * @param entry pre-conversion data entry to be added to database.
				 * @return array of converted javascript object.
				 */
				convertJsonForUpload: function(entry) {
					return [ entry ];
				},
				
				/**
				 * incrementally update the remaining data portions for upload using
				 * the input document ID to update necessary inter-document references.
				 * @param docId database document ID
				 * @param uploadArray array of remaining document objects to be updated
				 */
				incrementalUpdateFns: [ function(docId, uploadArray) { return; } ]
			},
			
			statusId: 1, // for naming status message divs
		
			initialize: function(opts_) {
				this.options = $n2.extend({}, this.options, opts_);
				
				if( this.options.logger ){
					this.logger = this.options.logger;
					
				} else if( this.options.statusDiv ){
					this.logger = new StatusLogger({div:this.options.statusDiv});
				};
				
				if( this.options.eraseStatusDiv && this.logger ) {
					this.logger.empty();
				};
			},
			
			/**
			 * @param aIndex index of entry in data array at which to start loading.
			 */
			loadEntry: function(aIndex) {
				if (aIndex >= this.options.dataArray.length) {
					this.postStatusMsgImmediate(_loc('Done'));
					return;
				};

				var entry = this.options.dataArray[aIndex];
				var designDoc = this.options.designDoc;
				
				/*
				 * make modifiable copies of option arrays.
				 */
				var _t_viewNames = this.options.viewNames.slice(0);
				var _t_keyValueFns = this.options.keyValueFns.slice(0);
				var _t_descriptiveLabels = this.options.descriptiveLabels.slice(0);
				
				var entryStatusId = this.allocateStatusMsgSpace();
			
				confirmDocumentsDoNotExist(this, entry, function(caller) {
					/*
					 * Once all documents that need to be unique have been
					 * confirmed to not exist, begin the uploads.
					 */
					caller.createEntry(aIndex, entry);
				});				

				function confirmDocumentsDoNotExist(caller, entry, doNotExistFn) {
					if (_t_viewNames.length <= 0  ||
							_t_keyValueFns.length <= 0 ||
							_t_descriptiveLabels.length <= 0) {
						doNotExistFn(caller); // did not find an existing record in the list
						return;
					};
					
					var currKeyValFn = _t_keyValueFns.shift();
					var currViewName = _t_viewNames.shift();
					var currDescriptiveLabel = _t_descriptiveLabels.shift();

					if (! $n2.isDefined(currKeyValFn) ||
							! $n2.isDefined(currViewName)) {
						confirmDocumentsDoNotExist(caller, entry, doNotExistFn);
						return;
					};
					
					var keyVal = currKeyValFn(entry);
					if (null === keyVal) { // signal from application key value routine to skip this entry
						caller.loadEntry(aIndex+1); // skip to next entry
						return;
					};

					// Check if it exists
					designDoc.queryView({
						viewName: currViewName,
						startkey: keyVal,
						endkey: keyVal,
						onSuccess: function(rows) {
							if( rows.length > 0 ) { // already exist
								var locStr = _loc('{label} definition ({key}) already exists - not loaded or updated',{
									label: _loc(currDescriptiveLabel)
									,key: keyVal
								});
								caller.updateStatusMsgAsynch(locStr,entryStatusId);
								caller.loadEntry(aIndex+1); // skip to next entry
							} else {
								confirmDocumentsDoNotExist(caller, entry, doNotExistFn);
							};
						},
						onError: function(errorMsg){ 
							var locStr = _loc('Error: query error while verifying {label} definition ({key})',{
								label: _loc(currDescriptiveLabel)
								,key: keyVal
							});
							caller.updateStatusMsgAsynch(locStr,entryStatusId);
							caller.loadEntry(aIndex+1); // skip to next entry
						}
					});
				};				
			},
			
			/**
			 * @param aIndex index of current entry in this.options.dataArray
			 * @param entry the current json data entry
			 */
			createEntry: function(aIndex, entry) {
				var uploadDataArray = [];
				var db = this.options.db;
				var atlasDesign = this.options.atlasDesign;

				if (this.options.jsonPropertiesVerifyFn(entry)) {
					
					/*
					 * Convert input, creating possibly multiple outputs.
					 * Array of outputs returned.
					 */
					uploadDataArray = this.options.convertJsonForUpload(entry);
					
					/*
					 * The interface for the simple data importer advertises the 
					 * convertJsonForUpload fn 
					 * as simply returning a struct, not an array of structures.  Catch
					 * that case and adapt it.....
					 */
					if (! $n2.isArray(uploadDataArray)) {
						uploadDataArray = [ uploadDataArray ];
					};
					
					/*
					 * make modifiable copies of option arrays.
					 */
					var _t_descriptiveLabels = this.options.descriptiveLabels.slice(0);
					var _t_incrementalUpdateFns = this.options.incrementalUpdateFns.slice(0);
					var _t_containsGeometry = this.options.containsGeometry.slice(0);
					
					/*
					 * NOTE: one-pass update.  Data portions created as documents
					 * later can only refer to ones created earlier.
					 * 
					 * 1) upload uploadDataArray[0]
					 * 2) for each subsequent element of uploadDataArray, k:
					 *    2a) update uploadDataArray elements [k ... N-1]
					 *    2b) upload uploadDataArray[k]
					 *    2c) if uploadDataArray[k] contains geometry, query 
					 *        the database tiling views to allow the server
					 *        to keep up.
					 */
					createEntryUpdateSubsequentEntries(this);

					
				} else {
					this.postStatusMsgImmediate(_loc('Required fields missing for ') +
							this.options.descriptiveLabels[0] + _loc(' definition: ') + aIndex);
					next(this);
				};
				
				function next(caller) {
					if (uploadDataArray.length > 0) {
						createEntryUpdateSubsequentEntries(caller);
					} else {
						caller.loadEntry(aIndex+1);
					};
				};
				
				function createEntryUpdateSubsequentEntries(caller) {
					if (uploadDataArray.length <= 0) { // done - no more entries to upload
						return;
					};
					
					/*
					 * Generate asynch status div, even though it may not be used.  This
					 * keeps asynch and immediate messages in a consistent order, aligning with
					 * the order of elements in the uploadDataArray.
					 */
					var entryStatusId = caller.allocateStatusMsgSpace();

					var nextUpload = uploadDataArray.shift();
					var currDescriptiveLabel = _t_descriptiveLabels.shift();
					var currContainsGeometry = _t_containsGeometry.shift();
					var currIncrementalUpdateFn = null;
					if (uploadDataArray.length >= 1) { // at least one subsequent record, so should be an incremental update fn
						currIncrementalUpdateFn = _t_incrementalUpdateFns.shift();
					};
					
					if (! $n2.isDefined(nextUpload)) { // move to next data portion or next record.
						caller.postStatusMsgImmediate(currDescriptiveLabel + _loc(' definition null and skipped.'));
						next(caller);
						return;
					};

					$n2.couchDocument.adjustDocument(nextUpload);

					db.createDocument({
						data: nextUpload,
						onSuccess: function(docInfo) { // @param docInfo JSON object {ok: <bool>, id: <id>, rev: <rev> }
							caller.updateStatusMsgAsynch(
								currDescriptiveLabel + _loc(' definition (') + docInfo.id + ')', 
								entryStatusId);
							
							if ($n2.isDefined(currIncrementalUpdateFn)) {
								var uploadedDoc = $n2.extend({},nextUpload,{
									_id: docInfo.id
									,_rev: docInfo.rev
								});
								currIncrementalUpdateFn(docInfo.id, uploadDataArray,uploadedDoc);
							};
							
							/*
							 *  this will initiate next record's upload, after delaying to
							 *  allow the server to perform geometry indexing if required.
							 */
							queryViews(atlasDesign, caller, currContainsGeometry, next);
						},
						onError: function(err) {
							$n2.log('Error creating document: '+err, nextUpload);
							caller.updateStatusMsgAsynch(
								_loc('Error creating ') + currDescriptiveLabel + 
									_loc(' definition (index: ') + aIndex + _loc('). STOPPING: ') + err, 
								entryStatusId);
						}
					});
					
				};
			},
			
			/**
			 * set the input data array
			 * @param data array of JSON objects
			 */
			setDataArray: function(data) {
				this.options.dataArray = data;
			},
			
			/**
			 * post a synchronous status message
			 */
			postStatusMsgImmediate: function(msg) {
				if( this.logger ){
					return this.logger.log(msg);
				};
				return null;
			},
			
			/**
			 * allocate a spot for an asynchronous message, return the 
			 * allocated div ID for use later updating
			 */
			allocateStatusMsgSpace: function() {
				if( this.logger ){
					return this.logger.log('');
				};
				return null;
			},
			
			/**
			 * Update an asynchronously allocated status space
			 */
			updateStatusMsgAsynch: function(msg, id) {
				if( id ) $('#'+id).text(msg);
			}
		});
		
	/**
	 * Simple data importer - without 1:n data splitting.
	 * 
	 * Encapsulates an above one-to-many instance.  Note that, as opposed to
	 * the 1:n converter above, some of the options for this class are expected to be
	 * singleton values rather than arrays of values.  See comments and usage in
	 * this.initialize.
	 */
	$n2.DataImporter = $n2.Class(
		'$n2.DataImporter',
		{
			options: {
				db: null,
				designDoc: null,
				atlasDesign: null,
				dataArray: [], // array of json objects
				containsGeometry: false, // need to pause for tiling updates?
				statusDiv: null, // for output messages (legacy)
				logger: null,
				descriptiveLabel: '', // for output messages

				/*
				 * couchdb viewName array used to find a 
				 * single document with a key
				 * generated using the keyValueFn (below).
				 */
				viewName: '',

				/**
				 * Take an entry to be added and generate the key for it.  Note
				 * that this function is always called on the pre-converted
				 * record (see convertJsonForUpload below).
				 * 
				 * function signature: function(entry) {}
				 * @param enrty pre-conversion data entry to be added to database.
				 * @return key value (possibly complex)
				 */
				keyValueFn: function(entry) { return null; },

				/**
				 * Verify that a record to be added contains the required fields
				 * @param enrty pre-conversion data entry to be added to database.
				 */
				jsonPropertiesVerifyFn: function(entry) {
					return true;
				},

				/**
				 * convert the imported entry for adding to the database according
				 * to the current system's templates.
				 * @param enrty pre-conversion data entry to be added to database.
				 * @return convert javascript object.
				 */
				convertJsonForUpload: function(entry) {
					return entry;
				}
			},
			
			/*
			 * encapsulated importer
			 */
			importer: null,

			initialize: function(opts_) {
				this.options = $n2.extend({}, this.options, opts_);
				
				this.importer = new $n2.OneToManyDataImporter({
					db: this.options.db,
					designDoc: this.options.designDoc,
					atlasDesign: this.options.atlasDesign,
					dataArray: this.options.dataArray,
					containsGeometry: [ this.options.containsGeometry ],
					statusDiv: this.options.statusDiv,
					logger: this.options.logger,
					descriptiveLabels: [ this.options.descriptiveLabel ],
					viewNames: [ this.options.viewName ],
					keyValueFns: [ this.options.keyValueFn ],
					jsonPropertiesVerifyFn: this.options.jsonPropertiesVerifyFn,
					convertJsonForUpload: this.options.convertJsonForUpload,
					incrementalUpdateFns: [] // n-1 entries (see comments)
				});
			},
			
			loadEntry: function(aIndex) {
				this.importer.loadEntry(aIndex);
			},
			
			/**
			 * set the input data array
			 * @param data array of JSON objects
			 */
			setDataArray: function(data) {
				this.options.dataArray = data;
				this.importer.setDataArray(data);
			}
		});
	
	/*
	 * Input plug-ins.  Add input handling, resulting in the definition of the
	 * DataImporter's dataArray option and finally the calling of the importer's
	 * loadEntry function.
	 * 
	 * Required of dataImporter:
	 * - setDataArray fn
	 * - loadEntry fn
	 */
	$n2.JSONInputPlugInForDataImport = $n2.Class(
		'$n2.JSONInputPlugInForDataImport',
		{
			options: {
				jsonFile: '',
				importer: null,
				entriesFromData: function(data){
					return data;
				}
			},
			
			initialize: function(opts_) {
				this.options = $n2.extend({}, this.options, opts_);
			},
			
			loadJson: function() {
				var this_ = this;
				$.getJSON(
					this.options.jsonFile, 
					function(data, textStatus) {
						var entries = null;
						if( data ){
							entries = this_.options.entriesFromData(data);
						};
						if( entries && $n2.isArray(entries) ) {
							this_.options.importer.setDataArray(entries);
							this_.options.importer.loadEntry(0);
						};
					});
			}

		});

	$n2.GeoJSONInputPlugInForDataImport = $n2.Class(
		'$n2.GeoJSONInputPlugInForDataImport',
		{
			options: {
				jsonFile: '',
				importer: null,
				
				 /* 
				  * convertJsonForUpload fn probably wants to use the crs for each GeoJson.
				  */
				crs: 'EPSG:4326'
			},
			
			geojsonParser: null,

			initialize: function(opts_) {
				this.options = $n2.extend({}, this.options, opts_);
				this.geojsonParser = new OpenLayers.Format.GeoJSON();
			},

			loadGeoJson: function() {
				var this_ = this;
				$.getJSON(
					this.options.jsonFile, 
					function(data, textStatus) {
						if ($n2.isDefined(data) &&
								$n2.isDefined(data.crs) &&
								$n2.isDefined(data.crs.type) &&
								'name' === data.crs.type &&
								$n2.isDefined(data.crs.properties) &&
								$n2.isDefined(data.crs.properties.name)) {
							this_.options.crs = data.crs.properties.name;
						};

						if ($n2.isDefined(data) &&
								$n2.isDefined(data.type) && 
								'featurecollection' === data.type.toLowerCase() &&
								$n2.isDefined(data.features) && 
								$n2.isArray(data.features)) {

							var dataArray = [];

							for (var i=0, len=data.features.length; i < len; i++) {

								var olVector = this_.geojsonParser.read(
										data.features[i], 
										"Feature", 
										null);
								dataArray.push(olVector);

							};
							
							this_.options.importer.setDataArray(dataArray);
							this_.options.importer.loadEntry(0);
						};

				});
			},
			
			/**
			 * Convert an openlayers vector object, created by parsing the 
			 * geojson, to Well Known Text structured as a JS object
			 * containing a nunaliit_geom.
			 * 
			 * Although this is a locally scoped function within the class, it actually
			 * needs to be called (most likely) from the context of a convertJsonForUpload
			 * function in code using these importer classes.  Because this function is
			 * really stateless, it could simply be invoked through the object prototype:
			 * 
			 * 	var geom_obj = $n2.GeoJSONInputPlugInForDataImport.prototype.convertGeomToWkt.call(this, olVector);
			 * 
			 * @param entry openlayers vector object
			 */
			convertGeomToWkt: function(olVector) {
                var wkt = olVector.geometry.toString();
                var bounds = olVector.geometry.getBounds();
                var xmin = bounds.left;
                var xmax = bounds.right;
                var ymin = bounds.bottom;
                var ymax = bounds.top;

				return {
                	nunaliit_geom: {
                		nunaliit_type: "geometry",
                		wkt: wkt,
                		bbox: [ xmin, ymin, xmax, ymax ]
                	}
				};
			}
		});

	/*
	 * helper functions
	 */
	
	/**
	 * @param containsGeometry true if this data type contains geometry
	 * @param doNextEntryFn fn to call when view checking is done and it is 
	 *                      time to load the next entry
	 */
	function queryViews(atlasDesign, caller, containsGeometry, doNextEntryFn) {
		var viewsToQuery;

		function doViewCheck(firstCall) {
			if (firstCall) {
				tilingViews = [
				                'geom-layer-tile200',
				                'geom-layer-tile25m',
				                'geom-layer-tile65k',
				                'geom-tile200',
				                'geom-tile25m',
				                'geom-tile65k'
				                ];
			};
			
			/*
			 * only query tiling views for data that contains geometry
			 */
			if (!containsGeometry || tilingViews.length < 1) {
				doNextEntryFn(caller);
			} else {
				var viewName = tilingViews.pop();
				atlasDesign.queryView({
					viewName: viewName,
					limit: 1,
					onSuccess: function() { doViewCheck(false); }, // query next
					onError: function(err) {
						$('#status').append( 
								$('<div>' + 
								_loc('STOPPING: Failed verifying view ') +
								viewName + 
								' ('+err+')' ));
					}
				});
			};
		};
		doViewCheck(true);
	};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchConfiguration.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
,DH = 'n2.couchConfiguration';

//===========================================================

var ConfigService = $n2.Class('ConfigurationService',{

	serverUrl: null,
	
	dispatchService: null,
	
	configuration: null,
	
	serverVersion: null,

	serverBuild: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			url: null
			,dispatchService: null
			,configuration: null
		},opts_);
		
		var _this = this;
		
		this.serverUrl = opts.url;
		this.dispatchService = opts.dispatchService;
		this.configuration = opts.configuration;
		
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			
			this.dispatchService.register(DH, 'configurationGetCurrentSettings', f);
		};
	},
	
	getNunaliitServerRoles: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(roles){}
			,onError: function(err){}
		},opts_);

		$.ajax({
			url: this.serverUrl+'getServerRoles'
			,type: 'GET'
			,dataType: 'json'
			,success: function(data, textStatus, jqXHR){
				if( data && data.roles ) {
					opts.onSuccess(data.roles);
				} else {
					opts.onError( _loc('Invalid server response') );
				};
			}
			,error: function(jqXHR, textStatus, errorThrown){
				var err = $n2.utils.parseHttpJsonError(jqXHR, textStatus);
				opts.onError(err);
			}
		});
	},
	
	getAtlasRoles: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(roles){}
			,onError: function(err){}
		},opts_);

		$.ajax({
			url: this.serverUrl+'getAtlasRoles'
			,type: 'GET'
			,dataType: 'json'
			,success: function(data, textStatus, jqXHR){
				if( data && data.roles ) {
					opts.onSuccess(data.roles);
				} else {
					opts.onError( _loc('Invalid server response') );
				};
			}
			,error: function(jqXHR, textStatus, errorThrown){
				var err = $n2.utils.parseHttpJsonError(jqXHR, textStatus);
				opts.onError(err);
			}
		});
	},
	

	_handle: function(m, addr, dispatcher){
		if( 'configurationGetCurrentSettings' === m.type ){
			// Synchronous call to retrieve current configuration
			m.configuration = this.configuration;
		};
	},

	testConnection: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(isBadProxy){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var connectionInfo = {
			badProxy: false // Assume that there is no bad proxy
			,speed: 0 // assume fast
		};

		// Get two random strings from server. The server always return
		// a new string. If two responses are the same, then there exists
		// a proxy badly configured between client and server.
		var randomStr1;
		var randomStr2;
		var startTime = Date.now();
		var endTime;
		this._getChannelRandom({
			onSuccess: firstRandomReceived
			,onError: testFailed
		});
		
		function firstRandomReceived(str){
			randomStr1 = str;
			_this._getChannelRandom({
				onSuccess: secondRandomReceived
				,onError: testFailed
			});
		};

		function secondRandomReceived(str){
			endTime = Date.now();
			randomStr2 = str;
			
			if( randomStr1 && randomStr1 === randomStr2 ){
				connectionInfo.badProxy = true;
			};
			
			connectionInfo.testDurationInMs = endTime - startTime;
			if( connectionInfo.testDurationInMs > 1500 ){
				connectionInfo.speed = 1; // slow
			};
			
			done();
		};
		
		function testFailed(err){
			$n2.log('Problem testing for bad proxy',err);
			done();
		};
		
		function done(){
			_this.connectionInfo = connectionInfo;
			opts.onSuccess(connectionInfo);
		};
	},
	
	_getChannelRandom: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(randomString){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;

		$.ajax({
			url: this.serverUrl+'testChannel'
			,type: 'GET'
			,dataType: 'json'
			,success: function(data, textStatus, jqXHR){
				if( data ){
					var serverVersion = data.version;
					var serverBuild = data.build;
					
					_this._reportServerVersion(serverVersion, serverBuild);
				};

				if( data && data.random ) {
					opts.onSuccess(data.random);
				} else {
					opts.onError( 'Did not receive random from server' );
				};
			}
			,error: function(jqXHR, textStatus, errorThrown){
				var err = $n2.utils.parseHttpJsonError(jqXHR, textStatus);
				opts.onError(err);
			}
		});
	},
	
	_reportServerVersion: function(version, build){
		if( !this.serverVersion ){
			this.serverVersion = version;
			this.serverBuild = build;

			if( this.configuration ){
				this.configuration.serverVersion = version;
				this.configuration.serverBuild = build;
			};
			
			if( n2atlas ){
				if( this.serverVersion !== n2atlas.version ){
					$n2.logError('Version mismatch. Client: '+n2atlas.version+' Server: '+this.serverVersion);
				};
				if( this.serverBuild !== n2atlas.build ){
					$n2.logError('Build mismatch. Client: '+n2atlas.build+' Server: '+this.serverBuild);
				};
			};
		};
	}
});

// ===========================================================
function Configure(options_){
	
	var options = $n2.extend({
		rootPath: null // string
		,couchServerUrl: null // string
		,atlasDbUrl: null // string
		,atlasDesignName: 'atlas'
		,siteDesignName: 'site'
		,progressServerUrl: null // string
		,mediaUrl: null // string
		,uploadServerUrl: null // string
		,exportServerUrl: null // string
		,configServerUrl: null // string
		,userServerUrl: null // string
		,submissionDbUrl: null // string
		,submissionServerUrl: null // string
		,dateServerUrl: null // string
		,simplifiedGeometryServerUrl: null // string
		,mailServerUrl: null // string
		,onSuccess: function(config){}
	},options_);

	var configuration = {
		directory: {}
		,rootPath: options.rootPath
	};
	var isSlowConnection = false;
	var couchDbCachingEnabled = false;
	var debugConfiguration;
	
	loadLibraries();
	
	function loadLibraries(){
		if( n2atlas 
		 && n2atlas.googleMapApiKey ){
			$n2.scripts.loadGoogleMapApi({
				googleMapApiKey: n2atlas.googleMapApiKey
				,onLoaded: librariesLoaded
				,onError: function(err){
					$n2.logError('Error while loading Google Map API: '+err);
					librariesLoaded();
				}
			});
		} else {
			librariesLoaded();
		};
	};
	
	function librariesLoaded(){
		// Start function
		configuration.start = function(){
			if( configuration.directory.dispatchService ){
				configuration.directory.dispatchService.send('n2.couchConfiguration',{type:'start'});
			};
		};
		
		// Custom Service
		configuration.directory.customService = new $n2.custom.CustomService({
			directory: configuration.directory
		});
		
		// Adjust configuration based on custom service
		if( configuration.directory.customService.getOption('couchDbCachingEnabled',false) ){
			couchDbCachingEnabled = true;
		};
		if( configuration.directory.customService.getOption('couchDbCachingDisabled',false) ){
			couchDbCachingEnabled = false;
		};

		// Adjust configuration based on local storage
		debugConfiguration = new $n2.debug.DebugConfiguration();
		if( debugConfiguration.isBadProxyEnabled() ){
			$n2.couch.setBadProxy(true);
		};
		if( debugConfiguration.isCouchDbCachingEnabled() ){
			couchDbCachingEnabled = true;
		};
		if( debugConfiguration.isCouchDbCachingDisabled() ){
			couchDbCachingEnabled = false;
		};
	
		// Dispatcher
		var dispatchLogging = false;
		if( debugConfiguration.isEventLoggingEnabled() ){
			dispatchLogging = true;
		};
		configuration.directory.dispatchService = new $n2.dispatch.Dispatcher({
			logging: dispatchLogging
		});

		$n2.couchMap.Configure({
			dispatchService: configuration.directory.dispatchService
		});
	
		// History monitoring
		configuration.directory.historyMonitor = new $n2.history.Monitor({
			directory: configuration.directory
		});
		configuration.directory.historyTracker = new $n2.history.Tracker({
			dispatchService: configuration.directory.dispatchService
		});
		configuration.directory.history = new $n2.history.History({
			dispatchService: configuration.directory.dispatchService
		});
	
		// Event translation
		configuration.directory.eventService = new $n2.couchEvents.EventSupport({
			directory: configuration.directory
		});
	
		// Analytics Service
		configuration.directory.analyticsService = new $n2.analytics.AnalyticsService({
			dispatchService: configuration.directory.dispatchService
		});
	
		// Intent Service
		configuration.directory.userIntentService = new $n2.userIntentView.IntentService({
			dispatchService: configuration.directory.dispatchService
		});
	
		// Turn off cometd
	 	$.cometd = {
	 		init: function(){}
	 		,subscribe: function(){}
	 		,publish: function(){}
	 	};
	
		// Configuration
		configuration.directory.configService = new ConfigService({
			url: options.configServerUrl
			,dispatchService: configuration.directory.dispatchService
			,configuration: configuration
		});
		
		// Test to see if sitting behind a bad proxy
		if( debugConfiguration.forceSlowConnectionHandling() ){
			isSlowConnection = true;
		};
		configuration.directory.configService.testConnection({
			onSuccess: function(connectionInfo){
				$n2.log('Connection speed:'+ connectionInfo.speed +' elapsed:'+connectionInfo.testDurationInMs+'ms');
				if( connectionInfo.badProxy ){
					$n2.couch.setBadProxy(true);
					$n2.log('Detected bad proxy in communication channel');
				};
				if( connectionInfo.speed > 0 ){
					isSlowConnection = true;
					$n2.log('Detected slow connection');
				} else {
					
				};
				communicationsTested();
			}
			,onError: communicationsTested // continue
		});
	};
	
	function communicationsTested(){
		if( isSlowConnection ){
			$n2.log('Slow connection handling requested');
		};
		if( $n2.couch.isBadProxy() ){
			$n2.log('Bad proxy circumvention requested');
		};
		
		// Open Indexed DB
		$n2.indexedDb.openIndexedDb({
			dispatchService: configuration.directory.dispatchService
			,onSuccess: function(indexedDbService){
				configuration.directory.indexedDbService = indexedDbService;
				indexedDbInitialized();
			}
			,onError: indexedDbInitialized
		});
	};

	function indexedDbInitialized(){

		// Initialize CouchDB
		if( couchDbCachingEnabled
		 && configuration.directory.indexedDbService ){
	 	 	$n2.couch.initialize({
	 	    	pathToServer: options.couchServerUrl
	 	    	,onSuccess: function(couchServer){
	 				$n2.couchIndexedDb.getServer({
	 					couchServer: couchServer
	 					,dispatchService: configuration.directory.dispatchService
	 					,indexedDbService: configuration.directory.indexedDbService
	 					,onSuccess: couchInitialized
	 					,onError: function(err){
	 				 		$n2.log('Error while initializing cached server.',err);
	 				 		couchInitialized(couchServer);
	 					}
	 				});
	 	    	}
	 	 		,onError: couchInitError
	 	 	});
	 	} else {
	 	 	$n2.couch.initialize({
	 	    	pathToServer: options.couchServerUrl
	 	    	,onSuccess: couchInitialized
	 	    	,onError: couchInitError
	 	 	});
	 	};
	 	
	 	function couchInitError(err){
	 		$n2.log('Unable to initialize with CouchDb server.',err);
	 	};
	};
	
	function couchInitialized(couchServer) {
		
		configuration.couchServer = couchServer;
		configuration.directory.couchServer = couchServer;
		
		var remoteDocumentCountLimit = undefined;
		var remoteRevisionCountLimit = undefined;
		var changeNotifierRefreshIntervalInMs = undefined;
		if( isSlowConnection ){
			remoteDocumentCountLimit = 100;
			remoteRevisionCountLimit = 1000;
			changeNotifierRefreshIntervalInMs = 15000;
		};
		configuration.atlasDb = configuration.couchServer.getDb({
			dbUrl:options.atlasDbUrl
			,allowCaching: true
			,remoteDocumentCountLimit: remoteDocumentCountLimit
			,remoteRevisionCountLimit: remoteRevisionCountLimit
			,changeNotifierRefreshIntervalInMs: changeNotifierRefreshIntervalInMs
		});
		configuration.atlasDesign = configuration.atlasDb.getDesignDoc({ddName:options.atlasDesignName});
		configuration.siteDesign = configuration.atlasDb.getDesignDoc({ddName:options.siteDesignName});

		configuration.atlasDb.getInfo({
			onSuccess: function(dbInfo){
				configuration.atlasDbName = dbInfo.db_name;
				atlasDbInfoRetrieved();
			}
			,onError: atlasDbInfoRetrieved
		});
	};
	
	function atlasDbInfoRetrieved() {

		configuration.directory.attachmentService = new $n2.couchAttachment.AttachmentService({
			mediaRelativePath: options.mediaUrl
			,dispatchService: configuration.directory.dispatchService
		});
		
		if( options.submissionDbUrl ){
			configuration.submissionDb = configuration.couchServer.getDb({dbUrl:options.submissionDbUrl});
		};
		
		configuration.dataSources = [];
		
		var couchDbDs = null;
		if( configuration.submissionDb ){
			couchDbDs = new $n2.couchDocument.CouchDocumentSourceWithSubmissionDb({
				id: 'main'
				,db: configuration.atlasDb
				,submissionDb: configuration.submissionDb
				,submissionServerUrl: options.submissionServerUrl
				,dispatchService: configuration.directory.dispatchService
				,attachmentService: configuration.directory.attachmentService
				,isDefaultDocumentSource: true
			});
		} else {
			couchDbDs = new $n2.couchDocument.CouchDocumentSource({
				id: 'main'
				,db: configuration.atlasDb
				,dispatchService: configuration.directory.dispatchService
				,attachmentService: configuration.directory.attachmentService
				,isDefaultDocumentSource: true
			});
		};
		configuration.dataSources.push(couchDbDs);
		configuration.documentSource = couchDbDs;

		// Check browser compliance
		if( $n2.couchHelp 
		 && $n2.couchHelp.CheckBrowserCompliance ){
			$n2.couchHelp.CheckBrowserCompliance({
				db: configuration.atlasDb
			});
		};
		configuration.directory.schemaRepository = new $n2.couchSchema.CouchSchemaRepository({
			db: configuration.atlasDb
			,designDoc: configuration.atlasDesign
			,dispatchService: configuration.directory.dispatchService
			,preload: true
			,preloadedCallback: schemasPreloaded 
		});
	};
	
	function schemasPreloaded() {
		var refreshIntervalInSec = undefined; // do not change default
		if( isSlowConnection ){
			refreshIntervalInSec = 10;
		};
		configuration.directory.authService = new $n2.couchAuth.AuthService({
			onSuccess: authInitialized
			,atlasDb: configuration.atlasDb
			,schemaRepository: configuration.directory.schemaRepository
			,directory: configuration.directory
			,userServerUrl: options.userServerUrl
			,refreshIntervalInSec: refreshIntervalInSec
		});
	};
	
	function authInitialized() {

		configuration.directory.localizationService = new $n2.couchL10n.LocalizationService({
			db: configuration.atlasDb
	 		,designDoc: configuration.atlasDesign
	 		,dispatchService: configuration.directory.dispatchService
	 	});

	 	configuration.directory.progressService = new $n2.progress.ProgressServer({
			url: options.progressServerUrl
		});

	 	configuration.directory.uploadService = new $n2.upload.Upload({
			url: options.uploadServerUrl
			,progressServer: configuration.directory.progressService
		});

	 	configuration.directory.mailService = new $n2.mail.MailService({
			url: options.mailServerUrl
			,dispatchService: configuration.directory.dispatchService
			,customService: configuration.directory.customService
		});

		configuration.directory.exportService = new $n2.couchExport.ExportService({
			url: options.exportServerUrl
			,atlasDb: configuration.atlasDb
			,atlasDesign: configuration.atlasDesign
			,config: configuration
		});

		configuration.directory.dateService = new $n2.dateService.DateService({
			url: options.dateServerUrl
		});
		
	 	configuration.directory.searchService = new $n2.couchSearch.SearchServer({
			designDoc: configuration.atlasDesign
			,db: configuration.atlasDb
			,dispatchService: configuration.directory.dispatchService
			,customService: configuration.directory.customService
			,dateService: configuration.directory.dateService
		});
		
	 	configuration.mediaRelativePath = options.mediaUrl;

	 	configuration.directory.requestService = new $n2.couchRequests({
			documentSource: configuration.documentSource
			,userDb: $n2.couch.getUserDb()
			,dispatchService: configuration.directory.dispatchService
			,userServerUrl: options.userServerUrl
		});

		configuration.directory.dispatchSupport = new $n2.couchDispatchSupport.DispatchSupport({
			dispatchService: configuration.directory.dispatchService
		});

		configuration.directory.languageService = new $n2.languageSupport.LanguageService({
			directory: configuration.directory
		});
		
		configuration.directory.displayImageSourceFactory = new $n2.couchDisplayBox.DisplayImageSourceFactory({
			dispatchService: configuration.directory.dispatchService
		});
		
		configuration.directory.showService = new $n2.couchShow.Show({
			db: configuration.atlasDb
			,documentSource: configuration.documentSource
			,requestService: configuration.directory.requestService
			,dispatchService: configuration.directory.dispatchService
			,schemaRepository: configuration.directory.schemaRepository
			,customService: configuration.directory.customService
			,attachmentService: configuration.directory.attachmentService
			,displayImageSourceFactory: configuration.directory.displayImageSourceFactory
		});
		
		// Navigation Service
		configuration.directory.navigationService = new $n2.couchNavigation.NavigationService({
			dispatchService: configuration.directory.dispatchService
			,showService: configuration.directory.showService
			,documentSource: configuration.documentSource
		});

		configuration.directory.dialogService = new $n2.couchDialogs.DialogService({
			dispatchService: configuration.directory.dispatchService
			,documentSource: configuration.documentSource
			,searchService: configuration.directory.searchService
			,showService: configuration.directory.showService
			,schemaRepository: configuration.directory.schemaRepository
			,atlasDesign: configuration.atlasDesign
		});
		
		configuration.directory.createDocProcess = new $n2.couchRelatedDoc.CreateRelatedDocProcess({
			documentSource: configuration.documentSource
			,schemaRepository: configuration.directory.schemaRepository
			,uploadService: configuration.directory.uploadService
			,showService: configuration.directory.showService
			,authService: configuration.directory.authService
			,dialogService: configuration.directory.dialogService
			,dispatchService: configuration.directory.dispatchService
		});
		
	 	configuration.directory.commentService = new $n2.comment.Service({
			documentSource: configuration.documentSource
			,showService: configuration.directory.showService
			,createDocProcess: configuration.directory.createDocProcess
			,dispatchService: configuration.directory.dispatchService
			,customService: configuration.directory.customService
		});
		
	 	configuration.directory.schemaEditorService = new $n2.couchEdit.SchemaEditorService({
			documentSource: configuration.documentSource
			,showService: configuration.directory.showService
			,searchService: configuration.directory.searchService
			,dispatchService: configuration.directory.dispatchService
			,dialogService: configuration.directory.dialogService
		});
		
	 	configuration.directory.editService = new $n2.couchEdit.EditService({
			documentSource: configuration.documentSource
			,schemaRepository: configuration.directory.schemaRepository
			,uploadService: configuration.directory.uploadService
			,showService: configuration.directory.showService
			,authService: configuration.directory.authService
			,dispatchService: configuration.directory.dispatchService
			,searchService: configuration.directory.searchService
			,schemaEditorService: configuration.directory.schemaEditorService
			,customService: configuration.directory.customService
			,dialogService: configuration.directory.dialogService
			,createDocProcess: configuration.directory.createDocProcess
		});
	 	configuration.couchEditor = configuration.directory.editService; // legacy
		
	 	configuration.directory.userService = new $n2.couchUser.UserService({
			userDb: $n2.couch.getUserDb()
			,configService: configuration.directory.configService
			,schemaRepository: configuration.directory.schemaRepository
			,schemaEditorService: configuration.directory.schemaEditorService
			,userServerUrl: options.userServerUrl
			,customService: configuration.directory.customService
		});
		
	 	configuration.directory.modelService = new $n2.model.Service({
			dispatchService: configuration.directory.dispatchService
		});
		
	 	configuration.directory.utilityService = new $n2.utilities.Service({
			dispatchService: configuration.directory.dispatchService
		});
		
	 	configuration.directory.instanceService = new $n2.instance.Service({
			dispatchService: configuration.directory.dispatchService
		});
		
	 	configuration.directory.canvasService = new $n2.canvas.Service({
			dispatchService: configuration.directory.dispatchService
		});
		
	 	configuration.directory.displayService = new $n2.display.Service({
			dispatchService: configuration.directory.dispatchService
		});
		
	 	configuration.directory.widgetService = new $n2.widgetBasic.Service({
	 		config: configuration
		});
	 	
	 	$n2.mapAndControls.DefaultPopupHtmlFunction = function(opt_){
	 		var feature = opt_.feature;
	 		
	 		if( feature.cluster && feature.cluster.length === 1 ){
	 			feature = feature.cluster[0];
	 		};
	 		
	 		if( feature.cluster ){
	 			var clusterSize = feature.cluster.length;
	 			if( feature.attributes && feature.attributes.count ){
		 			clusterSize = feature.attributes.count;
	 			};
	 			
				var $tmp = $('<span class="n2_popup"></span>');
				$tmp.text( _loc('This cluster contains {count} features',{
					count: clusterSize
				}) );

		 		var $wrapper = $('<div></div>');
		 		$wrapper.append($tmp);
		 		var html = $wrapper.html();
		 		
		 		opt_.onSuccess(html);

	 		} else {
		 		var doc = opt_.feature.data;
		 		
		 		var $tmp = $('<span class="n2_popup"></span>');
		 		configuration.directory.showService.displayBriefDescription($tmp,{},doc);
		 		
		 		var $wrapper = $('<div></div>');
		 		$wrapper.append($tmp);
		 		var html = $wrapper.html();
		 		
		 		opt_.onSuccess(html);
	 		};
	 	};

	 	// Set up hover sound
	 	configuration.directory.hoverSoundService = new $n2.couchSound.HoverSoundService({
			db: configuration.atlasDb
			,dispatchService: configuration.directory.dispatchService
			,requestService: configuration.directory.requestService
			,customService: configuration.directory.customService
	 	});
		
		// Set up GeoNames service
		var geoNamesOptions = {};
		if( window.nunaliit_custom
		 && window.nunaliit_custom.geoNames ){
			if( window.nunaliit_custom.geoNames.username ){
				geoNamesOptions.username = window.nunaliit_custom.geoNames.username;
			};
		};
		configuration.directory.geoNamesService = new $n2.GeoNames.Service(geoNamesOptions);

		configuration.directory.importProfileService = new $n2.couchImportProfile.ImportProfileService({
			atlasDb: configuration.atlasDb
			,atlasDesign: configuration.atlasDesign
			,schemaRepository: configuration.directory.schemaRepository
			,dispatchService: configuration.directory.dispatchService
		});

		configuration.directory.documentListService = new $n2.couchDocumentList.DocumentListService({
			atlasDesign: configuration.atlasDesign
			,dispatchService: configuration.directory.dispatchService
		});

		configuration.directory.simplifiedGeometryService = new $n2.couchSimplifiedGeometries.Service({
			url: options.simplifiedGeometryServerUrl
			,atlasDb: configuration.atlasDb
			,dispatchService: configuration.directory.dispatchService
			,customService: configuration.directory.customService
			,indexedDbService: couchDbCachingEnabled ? configuration.directory.indexedDbService : null
			,dbName: configuration.atlasDbName
		});

		if( $n2.tuioClient ){
			configuration.directory.tuioService = new $n2.tuioClient.TuioService({
				dispatchService: configuration.directory.dispatchService
			});
		};
		
		// Load help files
		if( configuration.atlasDb ){
			$n2.couchHelp.InstallHelpDocument({
				db: configuration.atlasDb
				,id: 'help.dates'
				,key: 'dates'
			});

			$n2.couchHelp.InstallHelpDocument({
				db: configuration.atlasDb
				,id: 'help.wiki'
				,key: 'wiki'
			});
		};
		
		callCustomConfiguration();
	};
	
	function callCustomConfiguration(){
		if( !$n2.scripts.areAllCustomScriptsLoaded() ){
			// More scripts needed to load
			window.setTimeout(callCustomConfiguration, 100);
			return;
		};

		if( window 
		 && window.nunaliit_custom 
		 && typeof(window.nunaliit_custom.configuration) === 'function' ){
			window.nunaliit_custom.configuration(configuration, configurationDone);
		} else {
			configurationDone();
		};
	};
	
	function configurationDone(){
		// Fix HTML from page
		if( configuration.directory.showService ){
			configuration.directory.showService.fixElementAndChildren( $('body') );
		};
		
		$n2.log('nunaliit configuration',configuration);
		options.onSuccess(configuration);
	};
};

$n2.couchConfiguration = {
	Configure: Configure
	,ConfigService: ConfigService
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchGeom.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

// @ requires n2.utils.js

;(function($n2){
"use strict";

/*
 * Returns a geometry object used in CouchDb given
 * a geometry obtained from OpenLayers.
 */
function getCouchGeometry(geom) {

	var bounds = geom.getBounds();
	var wkt = geom.toString();
	
	return {
		nunaliit_type: 'geometry'
		,wkt: wkt
		,bbox: [
			bounds.left
			,bounds.bottom
			,bounds.right
			,bounds.top
		]
	};
};

function updateDocumentWithWktGeometry(opts_) {
	var opts = $n2.extend({
		doc: null
		,wkt: null
	},opts_);
	
	if( !opts.doc ) {
		throw 'Attribute "doc" not provided while updating a geometry document';
	}
	if( !opts.wkt ) {
		throw 'Attribute "wkt" not provided while updating a geometry document';
	}
	
	if( OpenLayers && OpenLayers.Geometry && OpenLayers.Geometry.fromWKT ) {
		var olGeom = OpenLayers.Geometry.fromWKT(opts.wkt);
	} else { 
		opts.onError('OpenLayers must be installed to update document geometries');
		return;
	};		

	if( olGeom ){
		var couchGeom = getCouchGeometry(olGeom);
		
		// Install geometry
		opts.doc.nunaliit_geom = couchGeom;
	};
};

/*
 * Given a couch geometry, fixes the bbox
 */
function updatedGeometry(couchGeom) {

	if( OpenLayers 
	 && OpenLayers.Geometry 
	 && OpenLayers.Geometry.fromWKT ) {
		var olGeom = OpenLayers.Geometry.fromWKT(couchGeom.wkt);
		if( olGeom ){
			var bounds = olGeom.getBounds();
			couchGeom.bbox = [
				bounds.left
				,bounds.bottom
				,bounds.right
				,bounds.top
			];
		};
	};
	
	if( couchGeom.simplified ){
		delete couchGeom.simplified;
	};
};

/*
 * Returns a geometry object used in OpenLayers given
 * a geometry obtained from a Couch document.
 */
function getOpenLayersGeometry(opts_) {
	var opts = $n2.extend({
		doc: null
		,couchGeom: null
		,wkt: null
	},opts_);
	
	var wkt = opts.wkt;
	
	if( !wkt 
	 && opts.couchGeom ){
		wkt = opts.couchGeom.wkt;
	};
	
	if( !wkt 
	 && opts.doc 
	 && opts.doc.nunaliit_geom ){
		wkt = opts.doc.nunaliit_geom.wkt;
	};
	
	if( wkt ){
		if( OpenLayers && OpenLayers.Geometry && OpenLayers.Geometry.fromWKT ) {
			var olGeom = OpenLayers.Geometry.fromWKT(wkt);
			return olGeom;
		} else { 
			throw 'OpenLayers must be installed to update document geometries';
		};
	};

	return undefined;
};

/*
 * Selects a tile layer from a bounding box. If a tile
 * layer is selected, then its name is set in the
 * 'viewName' attribute if the view options and the
 * tile identifiers are saved as an array in the 'keys'
 * property.
 * If an appropriate tile layer is found, true is returned.
 * Otherwise, false is returned.
 */	
function selectTileViewFromBounds(viewOptions, bb, layer, fids) {
	
	var views = [
		{
			tile:$n2.tiles.format4326_25M
			,name: 'geom-tile25m'
			,list: 'noduplicate'
			,layer: false
			,fid: false
		}
		,{
			tile:$n2.tiles.format4326_25M
			,name: 'geom-layer-tile25m'
			,list: 'noduplicate'
			,layer: true
			,fid: false
		}
		,{
			tile:$n2.tiles.format4326_65K
			,name: 'geom-tile65k'
			,list: 'noduplicate'
			,layer: false
			,fid: false
		}
		,{
			tile:$n2.tiles.format4326_65K
			,name: 'geom-layer-tile65k'
			,list: 'noduplicate'
			,layer: true
			,fid: false
		}
		,{
			tile:$n2.tiles.format4326_200
			,name: 'geom-tile200'
			,list: 'noduplicate'
			,layer: false
			,fid: false
		}
		,{
			tile:$n2.tiles.format4326_200
			,name: 'geom-layer-tile200'
			,list: 'noduplicate'
			,layer: true
			,fid: false
		}
		,{
			tile:null
			,name: 'geom-layer-fid'
			,layer: true
			,fid: true
		}
		,{
			tile:null
			,name: 'geom-layer'
			,layer: true
			,fid: false
		}
		,{
			tile:null
			,name: 'geom'
			,layer: false
			,fid: true
		}
	];
	
	// bbox and fids are mutually exclusive
	if( bb && fids ) bb = null;
	
	for(var i=0,e=views.length; i<e; ++i) {
		var v = views[i];

		if( bb && v.tile && layer && v.layer ) {
			// This view support tiles and layer
			if( $n2.tiles.getApproxTilesForBounds(
				v.tile
				,bb[0],bb[1]
				,bb[2],bb[3] ) < 500 ) {
				
				viewOptions.viewName = v.name;
				
				var tiles = $n2.tiles.getTilesFromBounds(
					v.tile
					,bb[0],bb[1]
					,bb[2],bb[3]
					);
					
				viewOptions.keys = [];
				for(var j=0,k=tiles.length; j<k; ++j) {
					viewOptions.keys.push( [layer,tiles[j]] );
				};
				
				if( v.list ) viewOptions.listName = v.list;
				
				return true;
			};
			
		} else if( bb && v.tile && !layer && !v.layer ) {
			// This view support tiles only
			if( $n2.tiles.getApproxTilesForBounds(
				v.tile
				,bb[0],bb[1]
				,bb[2],bb[3] ) < 500 ) {
				
				viewOptions.viewName = v.name;
				
				viewOptions.keys = $n2.tiles.getTilesFromBounds(
					v.tile
					,bb[0],bb[1]
					,bb[2],bb[3]
					);

				if( v.list ) viewOptions.listName = v.list;
				
				return true;
			};
			
		} else if( fids && v.fid && layer && v.layer ) {
			// This view supports layer and fid
			viewOptions.viewName = v.name;
			
			viewOptions.keys = [];
			for(var j=0,k=fids.length; j<k; ++j) {
				viewOptions.keys.push( [layer,fids[j]] );
			};

			if( v.list ) viewOptions.listName = v.list;
				
			return true;
			
		} else if( fids && v.fid && !layer && !v.layer ) {
			// This view supports fid
			viewOptions.viewName = v.name;
			
			viewOptions.keys = fids;

			if( v.list ) viewOptions.listName = v.list;
				
			return true;
			
		} else if( !fids && !v.fid && layer && v.layer ) {
			// This view supports fid
			viewOptions.viewName = v.name;
			
			viewOptions.keys = [layer];

			if( v.list ) viewOptions.listName = v.list;
				
			return true;
			
		} else if( !bb && !fids && !layer && !v.fid && !v.layer && !v.tile ) {
			// This view supports fid
			viewOptions.viewName = v.name;

			if( v.list ) viewOptions.listName = v.list;
				
			return true;
		};
	};
	
	return false;
};

function queryGeometries(atlasDesignDoc, viewOptions) {

	var bounds = null;
	
	// Rebuild view options
	var data = {};

	// Install default view
	data.viewName = 'geom';
	data.listName = 'noduplicate';
	
	// Copy over client request
	for(var key in viewOptions) {
		if( key === 'bounds' ) {
			bounds = viewOptions[key];
		} else {
			data[key] = viewOptions[key];
		};
	};
	
	// Select proper tile layer
	if( bounds ) {
		// Switch view name and add keys for bounds
		selectTileViewFromBounds(data, bounds);
	};
	
	// Make request
	atlasDesignDoc.queryView(data);
};

$n2.couchGeom = {
	getCouchGeometry: getCouchGeometry
	,updateDocumentWithWktGeometry: updateDocumentWithWktGeometry
	,updatedGeometry: updatedGeometry
	,getOpenLayersGeometry: getOpenLayersGeometry
	,selectTileViewFromBounds: selectTileViewFromBounds
	,queryGeometries: queryGeometries
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchShow.js

/*
Copyright (c) 2011, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); },
 DH = 'n2.couchShow',
 couchUserPrefix = 'org.couchdb.user:',
 suppressLeaveConfirmation = false;

function noop(){};

var reUrl = /(^|\s)(https?:\/\/[^\s]*)(\s|$)/;

//*******************************************************

/**
 * This function iterates over all the descendants of a
 * DOM node, calling the specified function for each
 * element.
 * @param element Node where search should start from
 * @param fn Function to be called for each descendant element
 */
function iterateOverChildElements(element, fn){
	var childElements = [];
	var nodeList = element.childNodes;
	for(var i=0;i<nodeList.length;++i){
		var childNode = nodeList.item(i);
		if( childNode 
		 && childNode.nodeType === 1 ){ // element
			childElements.push(childNode);
		};
	};
	
	childElements.forEach(function(childElement){
		fn(childElement);
		iterateOverChildElements(childElement, fn)
	});
};

function getChildElements(element){
	var childElements = [];
	addDescendants(element, childElements);
	return childElements;
	
	function addDescendants(node, arr){
		var nodeList = node.childNodes;
		for(var i=0;i<nodeList.length;++i){
			var childNode = nodeList.item(i);
			if( childNode 
			 && childNode.nodeType === 1 ){ // element
				arr.push(childNode);
				addDescendants(childNode, arr);
			};
		};
	};
};

function replaceClassName(element, sourceClassName, targetClassName){
	var classes = element.className;
	if( classes ){
		var classNames = classes.split(' ');
		var newClassNames = [];
		classNames.forEach(function(className){
			if( className === sourceClassName ){
				newClassNames.push(targetClassName);
			} else {
				newClassNames.push(className);
			};
		});
		var newClasses = newClassNames.join(' ');
		element.className = newClasses;
	};
};


// *******************************************************
var DomStyler = $n2.Class({
	
	db: null,
	
	documentSource: null,

	showService: null,
	
	displayFunction: null,
	
	editFunction: null,
	
	deleteFunction: null,
	
	viewLayerFunction: null,
	
	changes: null,

	changesWithContext: null,

	observerChangeMap: null,

	mutationObserver: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			db: null
			,documentSource: null
			,showService: null
			,displayFunction: null
			,editFunction: null
			,deleteFunction: null
			,viewLayerFunction: null
		},opts_);
		
		this.db = opts.db;
		this.documentSource = opts.documentSource;
		this.showService = opts.showService;
		this.displayFunction = opts.displayFunction;
		this.editFunction = opts.editFunction;
		this.deleteFunction = opts.deleteFunction;
		this.viewLayerFunction = opts.viewLayerFunction;
		
		var _this = this;
		
		// This is a list of all DOM changes performed by
		// the show service:
		// - source : String. Class name to find element to change
		// - target : String. Class name to switch element to after change
		// - fn : Function. Function to call to perform change
		// - acceptsContextDocument : Boolean. If true, specify the context
		//                            document
		this.changes = [
			{
				source: 'n2s_localize'
				,target: 'n2s_localized'
				,fn: this._localize
				,acceptsContextDocument: false
			},
			{
				source: 'n2_localize'
				,target: 'n2_localized'
				,fn: this._localize
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_briefDisplay'
				,target: 'n2s_briefDisplayed'
				,fn: this._briefDisplay
				,acceptsContextDocument: true
			},
			{
				source: 'n2_briefDisplay'
				,target: 'n2_briefDisplayed'
				,fn: this._briefDisplay
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_fullDisplay'
				,target: 'n2s_fullDisplayed'
				,fn: this._fullDisplay
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_referenceLink'
				,target: 'n2s_insertedReferenceLink'
				,fn: this._insertReferenceLink
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_insertTime'
				,target: 'n2s_insertedTime'
				,fn: this._insertTime
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_insertUserName'
				,target: 'n2s_insertedUserName'
				,fn: this._insertUserName
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_insertLayerName'
				,target: 'n2s_insertedLayerName'
				,fn: this._insertLayerName
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_insertMediaView'
				,target: 'n2s_insertedMediaView'
				,fn: this._insertMediaView
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_insertMediaPlayer'
				,target: 'n2s_insertedMediaPlayer'
				,fn: this._insertMediaPlayer
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_insertModuleName'
				,target: 'n2s_insertedModuleName'
				,fn: this._insertModuleName
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_insertFirstThumbnail'
				,target: 'n2s_insertedFirstThumbnail'
				,fn: this._insertFirstThumbnail
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_insertHoverSoundIcon'
				,target: 'n2s_insertedHoverSoundIcon'
				,fn: this._insertHoverSoundIcon
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_externalMediaLink'
				,target: 'n2s_adjustedExternalMediaLink'
				,fn: this._adjustExternalMediaLink
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_insertExternalMediaLink'
				,target: 'n2s_insertedExternalMediaLink'
				,fn: this._insertExternalMediaLink
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_convertTextUrlToLink'
				,target: 'n2s_convertedTextUrlToLink'
				,fn: this._convertTextUrlToLink
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_clickFindGeometryOnMap'
				,target: 'n2s_findGeometryOnMap'
				,fn: this._clickFindGeometryOnMap
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_clickAddLayerFromDefinition'
				,target: 'n2s_addLayerFromDefinition'
				,fn: this._clickAddLayerFromDefinition
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_clickEdit'
				,target: 'n2s_edit'
				,fn: this._clickEdit
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_clickDelete'
				,target: 'n2s_delete'
				,fn: this._clickDelete
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_handleHover'
				,target: 'n2s_handledHover'
				,fn: this._handleHover
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_installMaxHeight'
				,target: 'n2s_installedMaxHeight'
				,fn: this._installMaxHeight
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_clickLogin'
				,target: 'n2s_login'
				,fn: this._clickLogin
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_clickMapEdit'
				,target: 'n2s_mapEdit'
				,fn: this._clickMapEdit
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_preserveSpaces'
				,target: 'n2s_preservedSpaces'
				,fn: this._preserveSpaces
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_insertDocumentList'
				,target: 'n2s_insertedDocumentList'
				,fn: this._insertDocumentList
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_select'
				,target: 'n2s_selected'
				,fn: this._select
				,acceptsContextDocument: false
			},
			{
				source: 'n2s_installTiledImageClick'
				,target: 'n2s_installedTiledImageClick'
				,fn: this._installTiledImageClick
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_custom'
				,target: 'n2s_customed'
				,fn: this._custom
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_userEvents'
				,target: 'n2s_userEvents_installed'
				,fn: this._userEvents
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_wikiTransform'
				,target: 'n2s_wikiTransformed'
				,fn: this._wikiTransform
				,acceptsContextDocument: true
			},
			{
				source: 'n2s_showFindAvailable'
				,target: 'n2s_showedFindAvailable'
				,fn: this._showFindAvailable
				,acceptsContextDocument: true
			}
		];
	
		// Make an array of changes that accepts a context document
		this.changesWithContext = [];
		this.changes.forEach(function(change){
			if( change.acceptsContextDocument ){
				_this.changesWithContext.push(change);
			};
		});
		
		// Make a maps of changes for V3 processing
		this.changesMap = {};
		this.changes.forEach(function(change){
			_this.changesMap[change.source] = change;
		});
		
		// The mutation observer can make changes that do not require a context.
		// The mutation observer observes all changes on a document.
		this.mutationObserver = null;
//		if( typeof MutationObserver == 'function' ){
//			// Create a dictionary of changes to support observer
//			this.observerChangeMap = {};
//			this.changes.forEach(function(change){
//				if( !change.acceptsContextDocument ){
//					_this.observerChangeMap[change.source] = change;
//				};
//			});
//
//			this.mutationObserver = new MutationObserver(function(mutations, observer){
//				_this._observeMutations(mutations);
//			});
//			
//			this.mutationObserver.observe($('body')[0], {
//				childList: true
//				,subtree: true
//				,attributes: true
//				,attributeFilter: ['class']
//			});
//		};
	},

	fixElementAndChildren: function($elem, opt, contextDoc){
//		if( typeof performance !== 'undefined' ){
//			var _this = this;
//			var start = performance.now();
//		};
		
		this._fixElementAndChildrenV3($elem, opt, contextDoc);

//		if( typeof performance !== 'undefined' ){
//			var end = performance.now();
//			var elapsed = end-start;
//			if( this.maxElapsed === undefined ){
//				this.maxElapsed = elapsed;
//			} else if( elapsed > this.maxElapsed ){
//				this.maxElapsed = elapsed;
//			};
//			if( this.totalElapsed === undefined ){
//				this.totalElapsed = elapsed;
//			} else {
//				this.totalElapsed += elapsed;
//			};
//			if( !this.performanceInstalled ){
//				this.performanceInstalled = true;
//				$('<a>')
//					.attr('href','#')
//					.text( _loc('Log Perf') )
//					.css({
//						'text-decoration': 'none',
//				    	'color': '#fff'
//					})
//					.appendTo( $('.nunaliit_footer') )
//					.click(function(){
//						$n2.log('total: '+_this.totalElapsed+' max: '+_this.maxElapsed);
//						return false;
//					});
//				$('<a>')
//					.attr('href','#')
//					.text( _loc('Reset Perf') )
//					.css({
//						'text-decoration': 'none',
//				    	'color': '#fff'
//					})
//					.appendTo( $('.nunaliit_footer') )
//					.click(function(){
//						_this.totalElapsed = 0;
//						_this.maxElapsed = 0;
//						return false;
//					});
//			};
//		};
	},

	// V3 is 24% faster than V2 and 31% faster than V1
	_fixElementAndChildrenV3: function($elem, opt, contextDoc){
		var _this = this;
		
		// Call custom code to modify element
		var dispatchService = this.showService.dispatchService;
		if( dispatchService ) {
			dispatchService.synchronousCall(DH, {
				type:'showPreprocessElement'
				,elem: $elem
				,doc: contextDoc
				,showService: this.showService
			});
		};
		
		$elem.each(function(){
			modifyElement(this);
//				var childElems = getChildElements(this);
//				childElems.forEach(function(node){
//					modifyElement(node);
//				});
			iterateOverChildElements(this, modifyElement);
		});
		
		function modifyContextedElement(element){
			var classes = element.className;
			if( typeof classes === 'string' ){
				var classNames = classes.split(' ');
				classNames.forEach(function(className){
					var changes = _this.changesWithContext[className];
					if( changes 
					 && typeof changes.target === 'string' 
					 && typeof changes.fn === 'function' ){
						try {
							replaceClassName(element, className, changes.target);
							changes.fn.call(_this, $(element), contextDoc, opt);
						} catch(e) {
							console.log('Error applying change: '+className,e);
						};
					};
				});
			};
		};
		
		function modifyElement(element){
			var classes = element.className;
			if( typeof classes === 'string' ){
				var classNames = classes.split(' ');
				classNames.forEach(function(className){
					var changes = _this.changesMap[className];
					if( changes 
					 && typeof changes.target === 'string' 
					 && typeof changes.fn === 'function' ){
						try {
							replaceClassName(element, className, changes.target);
							changes.fn.call(_this, $(element), contextDoc, opt);
						} catch(e) {
							console.log('Error applying change: '+className,e);
						};
					};
				});
			};
		};
	},

	// V2 is 9% faster than V1
	_fixElementAndChildrenV2: function($elem, opt, contextDoc){
		var _this = this;
		
		// Call custom code to modify element
		var dispatchService = this.showService.dispatchService;
		if( dispatchService ) {
			dispatchService.synchronousCall(DH, {
				type:'showPreprocessElement'
				,elem: $elem
				,doc: contextDoc
				,showService: this.showService
			});
		};
		
		
		var $set = $elem;
		
		if( this.mutationObserver ){
			// Perform all changes based on context, leaving the changes that
			// do not require a context to the mutation observer
			this.changesWithContext.forEach(function(change){
				var sourceClassName = change.source;
				var targetClassName = change.target;
				var fn = change.fn;
				
				findAndExecute($set, sourceClassName, targetClassName, fn);
			});

		} else {
			// There is no mutation observer. Perform all changes
			this.changes.forEach(function(change){
				var sourceClassName = change.source;
				var targetClassName = change.target;
				var fn = change.fn;
				
				findAndExecute($set, sourceClassName, targetClassName, fn);
			});
		};
		
		
		function findAndExecute($set, sourceClass, targetClass, fn){
			if( $set.hasClass(sourceClass) ){
				execute($set, sourceClass, targetClass, fn);
			};
			$set.find('.'+sourceClass).each(function(){
				execute($(this), sourceClass, targetClass, fn);
			});
		};
		
		function execute($set, sourceClass, targetClass, fn){
			$set
				.removeClass(sourceClass)
				.addClass(targetClass);
			fn.call(_this, $set, contextDoc, opt);
		};
	},
	
	_fixElementAndChildrenV1: function($elem, opt, contextDoc){
		var _this = this;
		
		// Call custom code to modify element
		var dispatchService = this.showService.dispatchService;
		if( dispatchService ) {
			dispatchService.synchronousCall(DH, {
				type:'showPreprocessElement'
				,elem: $elem
				,doc: contextDoc
				,showService: this.showService
			});
		};
		
		
		var $set = $elem.find('*').addBack();

		// Perform all changes
		this.changes.forEach(function(change){
			var sourceClassName = change.source;
			var targetClassName = change.target;
			var fn = change.fn;
			
			$set.filter('.'+sourceClassName).each(function(){
				var $jq = $(this);
				$jq.removeClass(sourceClassName).addClass(targetClassName);
				fn.call(_this, $jq, contextDoc, opt);
			});
		});
	},
	
	_observeMutations: function(mutations){
		var _this = this;

		mutations.forEach(function(mutation) {
			if( mutation.type === 'attributes' ){
				if( mutation.target 
				 && mutation.target.nodeType === 1 /* element */ ){
					fixElement(mutation.target);
				};

			} else if( mutation.type === 'childList' ){
				if( mutation.addedNodes 
				 && mutation.addedNodes.length ){
					for(var i=0; i<mutation.addedNodes.length; ++i){
						var node = mutation.addedNodes.item(i);
						if( node && node.nodeType === 1 /*element*/ ){
							fixElement(node);
						};
					};
				};

			} else {
				console.log('mutation: '+mutation.type,mutation);
			};
		});
		
		function fixElement(element){
			var classes = element.className;
			if( typeof classes === 'string' ){
				var classNames = classes.split(' ');
				classNames.forEach(function(className){
					var changes = _this.observerChangeMap[className];
					if( changes 
					 && typeof changes.target === 'string' 
					 && typeof changes.fn === 'function' ){
						try {
							replaceClassName(element, className, changes.target);
							changes.fn.call(_this, $(element));
						} catch(e) {
							console.log('Error applying change: '+className,e);
						};
					};
				});
			};
		};
	},
	
	_receivedDocumentContent: function(doc){
		var _this = this;
		
		var docId = undefined;
		if( doc ){
			docId = doc._id;
		};
		
		var contentClass = undefined;
		if( docId ){
			contentClass = 'n2show_documentContent_' + $n2.utils.stringToHtmlId(docId);
		};
		
		if( contentClass ){
			$('.'+contentClass).each(function(){
				var $jq = $(this);

				_this._refreshElementWithDocument($jq, doc);

				var isContinuous = $jq.attr('data-content-continuous');
				
				// Content was received. No longer waiting for it.
				if( !isContinuous ){
					$jq.removeClass(contentClass);
				};
			});
		};
		
		// Handle layer definitions
		if( doc 
		 && doc.nunaliit_layer_definition ){
			var layerId = doc.nunaliit_layer_definition.id;
			if( !layerId ){
				layerId = doc._id;
			};

			if( layerId ){
				contentClass = 'n2show_layerContent_' + $n2.utils.stringToHtmlId(layerId);

				$('.'+contentClass).each(function(){
					var $jq = $(this);
					
					// No longer waiting for layer. Update with
					// document
					$jq.removeClass(contentClass);
					_this._associateDocumentToElement(doc, $jq);

					_this._refreshElementWithDocument($jq, doc);
				});
			};
		};
	},

	_receivedDocumentUpdate: function(doc){
		var _this = this;
		
		var docId = undefined;
		if( doc ){
			docId = doc._id;
		};
		
		var updateClass = undefined;
		if( docId ){
			updateClass = 'n2show_documentUpdate_' + $n2.utils.stringToHtmlId(docId);
		};
		
		if( updateClass ){
			$('.'+updateClass).each(function(){
				var $jq = $(this);

				_this._refreshElementWithDocument($jq, doc);
			});
		};
		
		// On update, it is possible that a list is affected.
		$('.n2show_documentList').each(function(){
			var $jq = $(this);

			_this._insertDocumentList($jq);
		});
	},

	_refreshElementWithDocument: function($jq, doc){
		var dispatchService = this.showService.dispatchService;
		if( dispatchService ) {
			dispatchService.synchronousCall(DH, {
				type:'showPreprocessElement'
				,elem: $jq
				,doc: doc
				,showService: this.showService
			});
		};

		if( $jq.hasClass('n2s_insertedMediaView') ){
			this._insertMediaView($jq, doc);
		};

		if( $jq.hasClass('n2s_insertedMediaPlayer') ){
			this._insertMediaPlayer($jq, doc);
		};
		
		if( $jq.hasClass('n2s_insertedFirstThumbnail') ){
			this._insertFirstThumbnail($jq, doc);
		};
		
		if( $jq.hasClass('n2s_customed') ){
			this._custom($jq, doc);
		};
		
		if( $jq.hasClass('n2s_userEvents_installed') ){
			this._userEvents($jq, doc);
		};

		if( $jq.hasClass('n2s_briefDisplayed') ){
			this._briefDisplay($jq, doc);
		};

		if( $jq.hasClass('n2s_fullDisplayed') ){
			this._fullDisplay($jq, doc);
		};

		if( $jq.hasClass('n2s_insertedLayerName') ){
			this._insertLayerName($jq, doc);
		};

		if( $jq.hasClass('n2s_insertedModuleName') ){
			this._insertModuleName($jq, doc);
		};

		if( $jq.hasClass('n2s_showedFindAvailable') ){
			this._showFindAvailable($jq, doc);
		};
	},

	_localize: function($jq) {
		var text = $jq.text();
		var locText = undefined;
		if( $n2.l10n 
		 && $n2.l10n.lookupDictionaryTranslation ){
			locText = $n2.l10n.lookupDictionaryTranslation(text, 'nunaliit2-couch');
		};
		if( typeof locText === 'string' ) {
			$jq.text(locText);
		} else {
			$jq.addClass('n2s_waiting_for_localization');
		};
	},
	
	_preserveSpaces: function($jq) {
		$jq.each(function(){
			performPreserveSpace(this);
		});
		
		function performPreserveSpace(parent){
			var node = parent.firstChild;
			while(node){
				if( node.nodeType === 3 ){ // text node
					$(node.parentNode).css('white-space','pre-wrap');
					node = node.nextSibling;
				} else {
					performPreserveSpace(node);
					node = node.nextSibling;
				};
			};
		};
	},
	
	_insertDocumentList: function($jq){
		var listType = $jq.attr('nunaliit-list-type');
		if( typeof listType === 'undefined' ){
			listType = $jq.attr('n2-list-type');
			if( listType ){
				$jq.attr('nunaliit-list-type',listType);
			};
		};
		var listName = $jq.attr('nunaliit-list-name');
		if( typeof listName === 'undefined' ){
			listName = $jq.attr('n2-list-name');
			if( listName ){
				$jq.attr('nunaliit-list-name',listName);
			};
		};
		
		$jq
			.addClass('n2show_documentList n2show_documentList_wait')
			.empty();
		
		var dispatchService = this.showService.dispatchService;
		if( dispatchService ) {
			dispatchService.send(DH, {
				type:'documentListQuery'
				,listType: listType
				,listName: listName
			});
		};
	},

	_select: function($jq){
		var choiceName = $jq.attr('n2-choice');
		
		var found = false;
		$jq.find('.n2s_choice').each(function(){
			var $choice = $(this);
			var name = $choice.attr('n2-choice');
			if( name === choiceName ){
				found = true;
			} else {
				$choice.remove();
			};
		});

		if( found ){
			$jq.find('.n2s_choiceDefault').remove();
		};
	},
	
	_briefDisplay: function($jq, data) {
		var docId = $jq.attr('nunaliit-document');
		if( !docId ){
			docId = $jq.text();
			$jq.attr('nunaliit-document',docId);
		};

		var docId = this._associateDocumentToElement(data, $jq);
		
		if( data && data._id === docId ){
			this.showService._displayDocumentBrief($jq, data);
		};
	},
	
	_fullDisplay: function($jq, data, opt_) {
		var docId = this._associateDocumentToElement(data, $jq);
		
		if( data && data._id === docId ){
			this.showService._displayDocumentFull($jq, data, opt_);
		};
	},
	
	_insertReferenceLink: function($jq) {
		var _this = this;

		var docId = $jq.attr('nunaliit-document');
		if( !docId ){
			docId = $jq.text();
			$jq.attr('nunaliit-document',docId);
		};

		this.showService.printBriefDescription($jq, docId);
		$jq.click(function(){
			var dispatchService = _this.showService.dispatchService;
			if( dispatchService ) {
				dispatchService.send(DH, {type:'userSelect',docId:docId});
			};

			if( _this.displayFunction ) {
				_this.displayFunction(docId,opt_);
			};

			return false;
		});
	},
	
	_insertTime: function($jq) {
		var time = 1 * $jq.text();
		var timeStr = (new Date(time)).toString();
		$jq.text(timeStr);
	},
	
	_insertUserName: function($elem) {
		var userName = $elem.attr('nunaliit-user');
		if( !userName ){
			userName = $elem.text();
		};
		
		this.showService.printUserName(
			$elem
			,userName
			,{showHandle:true}
			);
	},
	
	_insertLayerName: function($elem, data) {
		var layerIdentifier = $elem.attr('nunaliit-layer');
		var docId = $elem.attr('nunaliit-document');
		
		// Legacy: layer id used to be specified as text
		if( !layerIdentifier && !docId ){
			layerIdentifier = $elem.text();
			$elem.attr('nunaliit-layer',layerIdentifier);
		};
		
		// Compute inline layer definition
		var inlineDefinition = undefined;
		if( data 
		 && data.nunaliit_layer_definition ){
			inlineDefinition = data.nunaliit_layer_definition;
			if( !inlineDefinition.id ){
				// Legacy: layer definition uses doc id
				inlineDefinition.id = data._id;
			};
		};

		// Associated by layer id?
		var doc = undefined;
		if( layerIdentifier ){
			if( inlineDefinition 
			 && inlineDefinition.id === layerIdentifier ){
				// No need to make a request. We already have the document.
				doc = data;
			} else {
				var associated = $elem.hasClass('n2show_layerAssociated');
				if( !associated ){
					// Must request this layer definition
					$elem.addClass('n2show_layerAssociated');
					var contentClass = 'n2show_layerContent_' + $n2.utils.stringToHtmlId(layerIdentifier);
					$elem.addClass(contentClass);

					// Request this document
					this.showService._requestLayerDefinition(layerIdentifier);
				};
			};
			
		} else if( docId ) {
			// Associated by docId?
			if( data && data._id === docId ){
				// No need to make a request. We already have the document
				doc = data;
			};
			this._associateDocumentToElement(data, $elem);
			
		} else if( inlineDefinition ){
			// Associated with inline-document?
			doc = data;
			this._associateDocumentToElement(data, $elem);
		};

		
		if( doc 
		 && doc.nunaliit_layer_definition ){
			var layerId = doc.nunaliit_layer_definition.id;
			if( !layerId ){
				layerId = doc._id;
			};
			
			if( layerId === layerIdentifier ){
				if( doc.nunaliit_layer_definition.name ){
					var name = _loc(doc.nunaliit_layer_definition.name);
					
					$elem.text(name);
				};
			};
		};
	},

	_insertMediaView: function($insertView, data) {
		var _this = this;
		
		var docId = this._associateDocumentToElement(data, $insertView);
		
		var attachmentName = $insertView.attr('nunaliit-attachment');
		if( !attachmentName ) {
			attachmentName = $insertView.text();
			$insertView.attr('nunaliit-attachment', attachmentName);
		};

		$insertView.empty();

		// Do we have document?
		if( data && data._id === docId ){
			var attachment = null;
			if( data._attachments 
			 && data._attachments[attachmentName] ){
				attachment = data._attachments[attachmentName];
			};

			var attDesc = null;
			if( data 
			 && data.nunaliit_attachments 
			 && data.nunaliit_attachments.files ) {
				attDesc = data.nunaliit_attachments.files[attachmentName];
			};
			
			if( attDesc
			 && attDesc.status === 'attached'
			 && attachment ) {
				
				var attUrl = this.db.getAttachmentUrl(data,attachmentName);

				// An attachment was uploaded for this file
				var linkDiv = null;
				if( attDesc.thumbnail
				 && data._attachments[attDesc.thumbnail]
				 ) {
					var thumbUrl = this.db.getAttachmentUrl(data,attDesc.thumbnail);
					linkDiv = $('<div class="n2Show_thumb_wrapper"><img src="'+thumbUrl+'"/></div>');

				} else if( attDesc.fileClass === 'image' ) {
					linkDiv = $('<div class="n2Show_icon_wrapper"><div class="n2Show_icon_image"></div></div>');
				
				} else if( attDesc.fileClass === 'audio' ) {
					linkDiv = $('<div class="n2Show_icon_wrapper"><div class="n2Show_icon_audio"></div></div>');
				
				} else if( attDesc.fileClass === 'video' ) {
					linkDiv = $('<div class="n2Show_icon_wrapper"><div class="n2Show_icon_video"></div></div>');
					
				} else {
					linkDiv = $('<div class="n2Show_icon_wrapper"><div class="n2Show_icon_file"></div></div>');
				};
				
				if( null != linkDiv ) {
					$insertView.append(linkDiv);
					var cb = createMediaCallback(
							attDesc.fileClass
							,attUrl
							,data
							,attachmentName
						);
					linkDiv.click(cb);
				};
			};

		} else {
			// Do not have document
			var label = _loc('Media({docId},{attName})',{
				docId: docId
				,attName: attachmentName
			});
			$('<span>')
				.addClass('n2s_insertMediaView_wait')
				.text(label)
				.appendTo($insertView);
		};
		
		function createMediaCallback(uploadType, attachmentUrl, doc, attachmentName) {
			
			return function(evt) {
				var mediaOptions = {
					url: attachmentUrl
					,suppressLeaveConfirmation: suppressLeaveConfirmation
				};
				
				// Mime type
				var attachment = null;
				if( doc._attachments && doc._attachments[attachmentName] ){
					attachment = doc._attachments[attachmentName];
				};
				if( attachment ) {
					mediaOptions.mimeType = attachment.content_type;
				};
				
				var attDesc = doc.nunaliit_attachments.files[attachmentName];
				// Title
				if( attDesc
				 && attDesc.data
				 && attDesc.data.title ) {
					mediaOptions.title = attDesc.data.title;
				};
				
				// Height and width
				if( attDesc ){
					if(attDesc.width){
						mediaOptions.width = attDesc.width;
					};

					if(attDesc.height){
						mediaOptions.height = attDesc.height;
					};

					if( 'image' === uploadType 
					 && attDesc.photosphere
					 && attDesc.photosphere.type === 'panorama' ) {
						uploadType = 'photosphere';
					};
				};
				
				if( 'image' === uploadType || 'photosphere' === uploadType ){
					_this.showService.displayImageSourceFactory.getImageSourceForDoc({
						doc: doc
						,attName: attachmentName
						,showService: _this.showService
						,onSuccess: function(imageSource, doc, startIndex){
							new nunaliit2.displayBox.DisplayBox({
								imageSource: imageSource
								,startIndex: startIndex
							});
						}
						,onError: function(err){
							$n2.log('Error while creating image source factory', err);
						}
					});
					
				} else {
					// Generate brief HTML
					var $temp = $('<div></div>');
					_this.showService._displayDocumentBrief($temp,doc,{
						onDisplayed:function(){
							var html = $temp.html();
							mediaOptions.metaDataHtml = html;
								
							// Display media
							mediaOptions.type = uploadType;
							$n2.mediaDisplay.displayMedia(mediaOptions);
						}
					});
				};
				
				return false;
			};
		};
	},


	_insertMediaPlayer: function($insertView, data) {
		var _this = this;

		var docId = this._associateDocumentToElement(data, $insertView);

		var attachmentName = $insertView.attr('nunaliit-attachment');
		if( !attachmentName ){
			attachmentName = $insertView.text();
			$insertView.attr('nunaliit-attachment', attachmentName);
		};

		$insertView.empty();

		if( data && data._id === docId ){
			var attachment = null;
			if( data._attachments 
				&& data._attachments[attachmentName] ){
				attachment = data._attachments[attachmentName];
			};

			var attDesc = null;
			if( data 
				&& data.nunaliit_attachments 
				&& data.nunaliit_attachments.files ) {
				attDesc = data.nunaliit_attachments.files[attachmentName];
			};

			var thumbnailURL = null;
			if( attDesc && attDesc.thumbnail ){
				thumbnailURL = this.db.getAttachmentUrl(data,attDesc.thumbnail);
			};

			if( attDesc
				&& attDesc.status === 'attached'
				&& attachment ) {

				var attUrl = this.db.getAttachmentUrl(data,attachmentName);
				var mediaDivId = $n2.getUniqueId();
				var mediaId = $n2.getUniqueId();
				var audioWidth = 300;

				if( attDesc.fileClass === 'audio' && attUrl ){

					var $mediaDiv = $('<div>')
						.attr('id', mediaDivId)
						.appendTo($insertView);

					var $audio = $('<audio>')
						.attr('id', mediaId)
						.attr('controls', 'controls')
						.attr('width', audioWidth)
						.appendTo($mediaDiv);

					var $audioSource = $('<source>')
						.attr('src', attUrl)
						.appendTo($audio);

					if( attDesc.mimeType ){
						$audioSource.attr('type', attDesc.mimeType);
					};

					$('#'+mediaId).mediaelementplayer({
						features: ['playpause','progress','volume','sourcechooser']
					});

				} else if( attDesc.fileClass === 'video' && attUrl ){

					var $mediaDiv = $('<div>')
						.attr('id', mediaDivId)
						.appendTo($insertView);

					var $video = $('<video>')
						.attr('id', mediaId)
						.attr('controls', 'controls')
						.attr('width', attDesc.width)
						.attr('height', attDesc.height)
						.appendTo($mediaDiv);

					var $videoSource = $('<source>')
						.attr('src', attUrl)
						.appendTo($video);

					if( attDesc.mimeType ){
						$videoSource.attr('type', attDesc.mimeType);
					};

					$('#'+mediaId).mediaelementplayer({
						poster: thumbnailURL
						,features: ['playpause','progress','volume','sourcechooser','fullscreen']
					});
				};

				var $docBrief = $('<span>')
					.addClass('n2s_briefDisplay')
					.attr('nunaliit-document',data._id)
					.appendTo($insertView);
		
				_this.fixElementAndChildren($docBrief, {}, null);
			};

		} else {
			// Do not have playable media document
			var label = _loc('Media({docId},{attName})',{
				docId: docId
				,attName: attachmentName
			});
			$('<span>')
				.addClass('n2s_insertMediaPlayer_wait')
				.text(label)
				.appendTo($insertView);
		};
	},

	_insertModuleName: function($jq, data) {
		var docId = this._associateDocumentToElement(data, $jq);
		
		if( data 
		 && data._id === docId 
		 && data.nunaliit_module
		 && data.nunaliit_module.title ){
			var title = _loc(data.nunaliit_module.title);
			$jq.text(title);
		};
	},
	
	_insertFirstThumbnail: function($insertElem, doc){

		var docId = this._associateDocumentToElement(doc, $insertElem);

		$insertElem.empty();

		var attachmentService = null;
		if( this.showService ){
			attachmentService = this.showService.attachmentService;
		};

		if( doc && doc._id === docId ){
			// Select first thumbnail
			var attachment = null;
			if( attachmentService ){
				var attachments = attachmentService.getAttachments(doc);
				for(var i=0,e=attachments.length; i<e; ++i){
					var att = attachments[i];
					if( att.isSource  ){
						var thumbnailAtt = att.getThumbnailAttachment();
						if( thumbnailAtt 
						 && thumbnailAtt.isAttached() ){
							attachment = thumbnailAtt;
							break;
						};
					};
				};
			};
			
			if( attachment ){
				$('<img>')
					.attr('src',attachment.computeUrl())
					.appendTo($insertElem);
			};
		};
	},
	
	_insertHoverSoundIcon: function($insertHoverSoundIcon, data){
		var _this = this;
		var playSound = false;

		if( $n2.couchSound
		 && $n2.couchSound.DocumentContainsHoverSound
		 && $n2.couchSound.DocumentContainsHoverSound(data) ) {
			var $wrapper = $('<div>')
				.addClass('n2Show_icon_wrapper')
				.appendTo($insertHoverSoundIcon);
			$('<div>')
				.addClass('n2Show_icon_speaker')
				.appendTo($wrapper)
				.click(function(){
					toggleHoverSound();
					return false;
				});
		};
		
		function toggleHoverSound(){
			var dispatchService = _this.showService.dispatchService;
			if( dispatchService ) {
				if( !playSound ) {
					dispatchService.send(DH, {type:'playHoverSoundOn',doc:data});
					playSound = true;
				} else {
					dispatchService.send(DH, {type:'playHoverSoundOff',doc:data});
					playSound = false;
				};
			};
		};
	},
	
	_adjustExternalMediaLink: function($externalLink, data) {
		var attachmentName = $externalLink.attr('href');
		
		var attachment = null;
		if( data._attachments 
		 && data._attachments[attachmentName] ) {
			attachment = data._attachments[attachmentName];
		};
		
		var attDesc = null;
		if( data 
		 && data.nunaliit_attachments 
		 && data.nunaliit_attachments.files ) {
			attDesc = data.nunaliit_attachments.files[attachmentName];
		};
		
		if( attDesc
		 && attDesc.status === 'attached' 
		 && attachment ) {
			
			var attUrl = this.db.getAttachmentUrl(data,attachmentName);

			$externalLink.attr('href',attUrl);
			$externalLink.click(function(e){
				if( suppressLeaveConfirmation ){
					return true;
				};

				if( confirm( _loc('You are about to leave this page. Do you wish to continue?') ) ) {
					return true;
				};
				return false;
			});
			
		} else {
			// At this point, we have a link that leads nowhere. Simply report
			// error to user.
			$externalLink.click(function(e){
				alert( _loc('File is not currently available') );
				return false;
			});
		};
	},
	
	_insertExternalMediaLink: function($div, data) {
		var attachmentName = $div.attr('nunaliit-attachment');
		
		$div.empty();
		
		var attachment = null;
		if( data 
		 && data._attachments 
		 && data._attachments[attachmentName] ) {
			attachment = data._attachments[attachmentName];
		};
		
		var attDesc = null;
		if( data 
		 && data.nunaliit_attachments 
		 && data.nunaliit_attachments.files ) {
			attDesc = data.nunaliit_attachments.files[attachmentName];
		};
		
		if( attDesc
		 && attDesc.status === 'attached' 
		 && attachment ) {
			var attUrl = this.db.getAttachmentUrl(data,attachmentName);
			
			// Check if original is available
			if( attDesc.originalAttachment
			 && data._attachments[attDesc.originalAttachment] ) {
				// Use original attachment, instead
				attUrl = this.db.getAttachmentUrl(data,attDesc.originalAttachment);
			};

			// <a class="n2s_externalMediaLink" href="{{.}}">
			//   <span class="n2s_externalMediaLinkName">({{../originalName}})</span>
			// </a>

			var $a = $('<a></a>')
				.addClass('n2s_adjustedExternalMediaLink')
				.attr('href',attUrl)
				.click(function(e){
					if( suppressLeaveConfirmation ){
						return true;
					};

					if( confirm( _loc('You are about to leave this page. Do you wish to continue?') ) ) {
						return true;
					};
					return false;
				})
				.appendTo($div);

			var name = attDesc.originalName;
			if( !name ){
				name = attachmentName;
			};
			
			$('<span></span>')
				.addClass('n2s_externalMediaLinkName')
				.text(name)
				.appendTo($a);
		};
	},
	
	_convertTextUrlToLink: function($jq) {
		$jq.each(function(){
			performTextUrlToLink(this);
		});
		
		function performTextUrlToLink(parent){
			var node = parent.firstChild;
			while(node){
				if( node.nodeType === 3 ){ // text node
					var nextSibling = node.nextSibling;
					convertTextElement(parent, node);
					node = nextSibling;
				} else {
					performTextUrlToLink(node);
					node = node.nextSibling;
				};
			};
		};
		
		function convertTextElement(parent, textNode){
			var text = textNode.nodeValue;
			
			var removeTextNode = false;
			var m = reUrl.exec(text);
			var after = null;
			while(m){
				removeTextNode = true;
				
				after = m[3] + text.substr(m.index + m[0].length);
				var before = text.substr(0, m.index) + m[1];
				
				if( before.length > 0 ){
					var t2 = parent.ownerDocument.createTextNode(before);
					parent.insertBefore(t2,textNode);
				};
				
				// Create link
				var aNode = parent.ownerDocument.createElement('a');
				aNode.setAttribute('href',m[2]);
				aNode.setAttribute('class','n2s_convertedUrl');
				var t1 = parent.ownerDocument.createTextNode(m[2]);
				aNode.appendChild(t1);
				parent.insertBefore(aNode,textNode);
				
				// Continue search
				text = after;
				m = reUrl.exec(text);
			};
			
			if( after ){
				var t3 = parent.ownerDocument.createTextNode(after);
				parent.insertBefore(t3,textNode);
			};

			if( removeTextNode ) {
				parent.removeChild(textNode);
			};
		};
	},
	
	_clickFindGeometryOnMap: function($jq, data){
		var dispatcher = this.showService.dispatchService;

		if( data 
		 && data.nunaliit_geom 
		 && dispatcher
		 && dispatcher.isEventTypeRegistered('find')
		 ) {

			$jq.click(function(){
				dispatcher.send(
					DH
					,{
						type: 'find'
						,docId: data._id
						,doc: data
					}
				);
				return false;
			});
		} else {
			$jq.remove();
		};
	},
	
	_clickAddLayerFromDefinition: function($jq, contextDoc){
		var _this = this;

		var viewLayerFunction = this.viewLayerFunction;
		var dispatchService = _this.showService.dispatchService;
		
		if( viewLayerFunction || dispatchService ) {
			if( contextDoc
			 && contextDoc.nunaliit_layer_definition ) {
				$jq.click(function(){
					var layerDefinition = contextDoc.nunaliit_layer_definition;
					
					if( viewLayerFunction ) {
						viewLayerFunction(contextDoc);
					};
					
					if( dispatchService ) {
						var layerId = layerDefinition.id;
						if( !layerId ){
							layerId = contextDoc._id;
						};
						var layerDef = {
							name: layerDefinition.name
							,type: 'couchdb'
							,options: {
								layerName: layerId
								,documentSource: _this.documentSource
							}
						};
						
						dispatchService.send(
							DH
							,{
								type: 'addLayerToMap'
								,layer: layerDef
								,options: {
									setExtent: {
										bounds: layerDefinition.bbox
										,crs: 'EPSG:4326'
									}
								}
							}
						);
					};
					
					return false;
				});
			} else {
				$jq.remove();
			};
		} else {
			$jq.remove();
		};
	},
	
	_clickEdit: function($jq, contextDoc, opt){
		var _this = this;

		if( this.editFunction ) {
			$jq.click(function(){
				_this.editFunction(contextDoc,opt);
				return false;
			});
		} else {
			$jq.empty();
		};
	},
	
	_clickDelete: function($jq, contextDoc, opt){
		var _this = this;

		if( this.deleteFunction ) {
			$jq.click(function(){
				_this.deleteFunction(contextDoc,opt);
				return false;
			});
		} else {
			$jq.empty();
		};
	},
	
	_clickLogin: function($jq){
		var _this = this;

		$jq.click(function(){
			var dispatchService = _this.showService.dispatchService;
			if( dispatchService ) {
				dispatchService.send(DH, {
					type:'loginShowForm'
				});
			};
			return false;
		});
	},
	
	_clickMapEdit: function($jq){
		var _this = this;

		$jq.click(function(){
			var dispatchService = _this.showService.dispatchService;
			if( dispatchService ) {
				dispatchService.send(DH, {
					type:'mapSwitchToEditMode'
				});
			};
			return false;
		});
	},
	
	_installMaxHeight: function($jq){
		var maxHeight = $jq.attr('_maxheight');
		
		if( !maxHeight ) {
			$jq.attr('n2s_error','Attribute _maxheight not found');
			$n2.log('n2Show installMaxHeight: Attribute _maxHeight not found');
		} else if( $jq.height() > maxHeight ) {
			var showText = _loc('More');
			var hideText = _loc('Less');
			
			var id = $n2.getUniqueId();
			var $children = $jq.contents();
			var $content = $('<div class="n2show_maxHeightContent n2show_maxHeight_truncated"></div>')
				.attr('id',id);
			
			$jq.append($content);
			
			$children.each(function(){
				$(this).appendTo($content);
			});
			
			$content.css({
				overflow: 'hidden'
				,height: maxHeight + 'px'
			});
			
			var $link = $('<a href="#" class="n2show_maxHeightLink"></a>')
				.text(showText)
				.click(function(e) {
					e.preventDefault();

					var $link = $(this);
					var $content = $('#'+id);
					if ($content.height() > maxHeight) {
						$link.text(showText);
						$content
							.css('height', maxHeight + 'px')
							.addClass('n2show_maxHeight_truncated')
							.removeClass('n2show_maxHeight_full');
					} else {
						$link.text(hideText);
						$content
							.css('height', 'auto')
							.addClass('n2show_maxHeight_full')
							.removeClass('n2show_maxHeight_truncated');
					};
					
					return false;
				});

			$('<div class="n2show_maxHeightLinkContainer"></div>')
				.append($link)
				.appendTo($jq);
		};
	},
	
	_handleHover: function($jq, contextDoc){

        var dispatchService = this.showService.dispatchService;
        var docId = this._getDocumentIdentifier(contextDoc, $jq);

        if( dispatchService ) {
            $jq.hover(
                function(){ // in
                    dispatchService.send(DH, {
                        type:'userFocusOn'
                        ,docId:docId
                    });
                }
                ,function(){ // out
                    dispatchService.send(DH, {
                        type:'userFocusOff'
                        ,docId:docId
                    });
                }
            );
        };
    },

	_installTiledImageClick: function($elem, doc){
		var _this = this;
		
		var docId = this._getDocumentIdentifier(doc, $elem);
		var attName = $elem.attr('nunaliit-attachment');
		
		if( !docId ){
			$elem.attr('nunaliit-error','No document specified');
		} else if( !attName ){
			$elem.attr('nunaliit-error','No attachment specified');
		} else {
			// docId and attName are specified
			// Get URL
			var url = this.db.getAttachmentUrl({_id:docId},attName);
			
			$elem
				.css('cursor','pointer')
				.click(function(){
					new $n2.displayTiledImage.DisplayTiledImage({
						url: url
						,tileMapResourceName: 'tilemapresource.xml'
						,docId: docId
						,showService: _this.showService
					});
					return false;
				});
		};
	},

	_custom: function($elem, doc){
		var _this = this;
		
		var docId = this._associateDocumentToElement(doc, $elem);
		var customType = $elem.attr('nunaliit-custom');
		
		if( !customType ){
			$elem.attr('nunaliit-error','No custom type specified');
		} else if( doc ){
			// We have a document and a custom type

			// Get selector
			var selectorStr = $elem.attr('nunaliit-selector');
			var selector = undefined;
			if( selectorStr ){
				selector = $n2.objectSelector.decodeFromDomAttribute(selectorStr);
			};

			// Call dispatcher
			var dispatchService = this.showService.dispatchService;
			if( dispatchService ) {
				dispatchService.synchronousCall(DH, {
					type:'showCustom'
					,elem: $elem
					,doc: doc
					,customType: customType
					,selector: selector
					,showService: this.showService
				});
			};
		} else {
			// We have only a custom type

			// Call dispatcher
			var dispatchService = this.showService.dispatchService;
			if( dispatchService ) {
				dispatchService.synchronousCall(DH, {
					type:'showCustom'
					,elem: $elem
					,customType: customType
					,showService: this.showService
				});
			};
		};
	},
	
	_userEvents: function($elem, doc){
		var _this = this;
		
		var docId = this._getDocumentIdentifier(doc, $elem);
		
		var disableClick = false;
		var disableClickAttr = $elem.attr('nunaliit-disable-click');
		if( 'true' == disableClickAttr ){
			disableClick = true;
		};
		
		var disableHover = false;
		var disableHoverAttr = $elem.attr('nunaliit-disable-hover');
		if( 'true' == disableHoverAttr ){
			disableHover = true;
		};
		
		if( docId ){
			// We have a document identifier
			var eventClass = 'n2s_userEvents_doc_' + $n2.utils.stringToHtmlId(docId);
			$elem.addClass(eventClass);

			// Get current intent from user intent service
			var dispatchService = this.showService.dispatchService;
			if( dispatchService ) {
				// Update classes
				var msg = {
					type:'userIntentGetCurrent'
					,intentMap: null
				};
				dispatchService.synchronousCall(DH, msg);
				if( msg.intentMap ){
					// Is there a state for this node?
					var docState = msg.intentMap[docId];
					if( docState ){
						if( docState.n2_selected ){
							$elem.addClass('nunaliit_selected');
						};
						if( docState.n2_hovered ){
							$elem.addClass('nunaliit_hovered');
						};
						if( docState.n2_find ){
							$elem.addClass('nunaliit_found');
						};
					};
				};
				
				// Install events
				if( !disableClick ){
					$elem.click(function(){
						var $elem = $(this);
						
						var createSchema = $elem.attr('nunaliit-create-schema');
						if( createSchema ){
							_this.showService._createDocIfInexistant(docId, createSchema);
						} else {
							dispatchService.send(DH,{
								type:'userSelect'
								,docId: docId
							});
						};

						return false;
					});
				};

				if( !disableHover ){
					$elem.mouseover(function(e){
	 		 			dispatchService.send(DH,{
	 		 				type: 'userFocusOn'
	 		 				,docId: docId
	 		 			});
	 				})
					.mouseout(function(e){
	 		 			dispatchService.send(DH,{
	 		 				type: 'userFocusOff'
	 		 				,docId: docId
	 		 			});
	 				});
				};
			};
		};
	},
	
	_wikiTransform: function($elem, contextDoc){
		var _this = this;
		
		var text = $elem.text();

		if( $n2.wiki ){
			var html = $n2.wiki.WikiToHtml({
				wiki: text
			});

			$elem.html(html);
			
			$elem.find('.n2s_createDocOnClick').each(function(){
				var $node = $(this);
				if( contextDoc 
				 && contextDoc.nunaliit_schema ){
					$node.attr('nunaliit-create-schema',contextDoc.nunaliit_schema);
				};
			});
			
			$elem.children().each(function(){
				_this.fixElementAndChildren($(this), {}, contextDoc);
			});
		};
	},
	
	/*
	 * Keep track of a document's availability for the 'find' event. Adjust
	 * classes on the element depending on status: 'n2show_findAvailable' or 
	 * 'n2show_findNotAvailable'
	 */
	_showFindAvailable: function($elem, doc){
		var _this = this;
		
		var docId = this._associateDocumentToElement(doc, $elem);
		
		// "find is available" is special. It should be recomputed for every
		// received document content.
		var contentClass = 'n2show_documentContent_' + $n2.utils.stringToHtmlId(docId);
		$elem
			.addClass(contentClass)
			.attr('data-content-continuous','true');

		if( doc && doc._id === docId ){
			var findAvailable = false;
			
			var dispatchService = this.showService.dispatchService;
			if( dispatchService ) {
				var msg = {
					type: 'findIsAvailable'
					,docId: docId
					,doc: doc
					,isAvailable: false
				};
				dispatchService.synchronousCall(DH,msg);
				if( msg.isAvailable ){
					findAvailable = true;
				};
			};
			
			if( findAvailable ){
				$elem
					.removeClass('n2show_findNotAvailable')
					.addClass('n2show_findAvailable');
			} else {
				$elem
					.removeClass('n2show_findAvailable')
					.addClass('n2show_findNotAvailable');
			};
		};
	},
	
	_getDocumentIdentifier: function(doc, $elem){
		var docId = $elem.attr('nunaliit-document');

		if( !docId && doc ){
			docId = doc._id;
		};
		
		return docId;
	},
	
	_associateDocumentToElement: function(doc, $elem){
		var docId = this._getDocumentIdentifier(doc, $elem);

		var associated = $elem.hasClass('n2show_documentAssociated');
		
		if( docId && !associated ){
			$elem.attr('nunaliit-document', docId);
			$elem.addClass('n2show_documentAssociated');

			// Ready to receive updates
			var updateClass = 'n2show_documentUpdate_' + $n2.utils.stringToHtmlId(docId);
			$elem.addClass(updateClass);
			
			if( doc && doc._id === docId ){
				// Already have document
			} else {
				// Ready to receive content
				var contentClass = 'n2show_documentContent_' + $n2.utils.stringToHtmlId(docId);
				$elem.addClass(contentClass);

				// Request this document
				this.showService._requestDocument(docId);
			};
		};
		
		return docId;
	}
});

//*******************************************************
var Show = $n2.Class({

	options: null,
	
	db: null,
	
	documentSource: null,
	
	requestService: null,
	
	dispatchService: null,
	
	schemaRepository: null,
	
	customService: null,
	
	attachmentService: null,
	
	displayImageSourceFactory: null,
	
	defaultSchema: null,
	
	displayFunction: null,
	
	editFunction: null,
	
	deleteFunction: null,
	
	viewLayerFunction: null,
	
	preprocessDocument: null,
	
	eliminateDeniedMedia: null,
	
	eliminateNonApprovedMedia: null,
	
	domStyler: null,
	
	postProcessDisplayFns: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			db: null
			,documentSource: null
			,requestService: null
			,dispatchService: null
			,schemaRepository: null
			,customService: null
			,attachmentService: null
			,displayImageSourceFactory: null
			,defaultSchema: null
			,displayFunction: null
			,editFunction: null
			,deleteFunction: null
			,viewLayerFunction: null
			,preprocessDocument: null
			,eliminateDeniedMedia: false
			,eliminateNonApprovedMedia: false
		},opts_);
		
		var _this = this;
		
		// Legacy
		this.options = {};
		
		this.db = opts.db;
		this.documentSource = opts.documentSource;
		this.requestService = opts.requestService;
		this.dispatchService = opts.dispatchService;
		this.schemaRepository = opts.schemaRepository;
		this.customService = opts.customService;
		this.attachmentService = opts.attachmentService;
		this.displayImageSourceFactory = opts.displayImageSourceFactory;
		this.defaultSchema = opts.defaultSchema;
		this.displayFunction = opts.displayFunction;
		this.editFunction = opts.editFunction;
		this.deleteFunction = opts.deleteFunction;
		this.viewLayerFunction = opts.viewLayerFunction;
		this.options.preprocessDocument = opts.preprocessDocument;
		this.eliminateDeniedMedia = opts.eliminateDeniedMedia;
		this.eliminateNonApprovedMedia = opts.eliminateNonApprovedMedia;
		this.postProcessDisplayFns = [];
		
		this.domStyler = new DomStyler({
			db: this.db
			,documentSource: this.documentSource
			,showService: this
			,displayFunction: this.displayFunction
			,editFunction: this.editFunction
			,deleteFunction: this.deleteFunction
			,viewLayerFunction: this.viewLayerFunction
		});

		var requestService = this.requestService;
		if( requestService ){
			requestService.addUserListener(function(userDoc){
				_this._displayUserDocument(userDoc);
			});
		};
		
		var dispatchService = this.dispatchService;
		if( dispatchService ){
			var f = function(msg, address, dispatchService){
				_this._handleDispatch(msg, address, dispatchService);
			};
			dispatchService.register(DH, 'start', f);
			dispatchService.register(DH, 'documentListResults', f);
			dispatchService.register(DH, 'documentContent', f);
			dispatchService.register(DH, 'documentDeleted', f);
			dispatchService.register(DH, 'documentContentCreated', f);
			dispatchService.register(DH, 'documentContentUpdated', f);
			dispatchService.register(DH, 'userIntentChanged', f);
			dispatchService.register(DH, 'findAvailabilityChanged', f);
		};
	},

	addPostProcessDisplayFunction: function(fn){
		if( typeof(fn) === 'function' ){
			this.postProcessDisplayFns.push(fn);
		};
	},

	fixElementAndChildren: function($elem, opt, contextDoc){
		this.domStyler.fixElementAndChildren($elem, opt, contextDoc);
	},
	
	displayBriefDescription: function($elem, opt_, doc){
		var opt = $n2.extend({
			onDisplayed: null // function($elem, doc, opt_){}
			,schemaName: null
		},opt_);

		if( doc && doc._id ) {
			$elem.addClass('n2s_briefDisplayed');
			$elem.attr('nunaliit-document',doc._id);

			this.domStyler._associateDocumentToElement(doc, $elem);
			
			this._displayDocumentBrief($elem, doc, opt);
		};
	},
	
	displayDocument: function($elem, opt_, doc){
		var opt = $n2.extend({
			onDisplayed: null // function($elem, doc, opt_){}
			,schemaName: null
		},opt_);

		if( doc && doc._id ) {
			$elem.addClass('n2s_fullDisplayed');
			$elem.attr('nunaliit-document',doc._id);

			this.domStyler._associateDocumentToElement(doc, $elem);

			this._displayDocumentFull($elem, doc, opt);
		};
	},
	
	printUserName: function($elem, userName, opts){
		$elem.addClass('n2ShowUser_'+$n2.utils.stringToHtmlId(userName));
		if( opts && opts.showHandle ) {
			$elem.addClass('n2ShowUserDisplayAndHandle');
		} else {
			$elem.addClass('n2ShowUserDisplay');
		};

		this._adjustUserNameNode($elem, userName, undefined);

		this._requestUser(userName); // fetch document
	},
	
	printBriefDescription: function($elem, docId){
		$elem.addClass('n2s_briefDisplayed');
		$elem.addClass('n2Show_docNotFound');
		$elem.attr('nunaliit-document',docId);

		this.domStyler._briefDisplay($elem);
	},
	
	printDocument: function($elem, docId){
		$elem.addClass('n2s_fullDisplayed');
		$elem.addClass('n2Show_docNotFound');
		$elem.attr('nunaliit-document',docId);
		
		this.domStyler._fullDisplay($elem);
	},
	
	printLayerName: function($elem, layerIdentifier){
		$elem.addClass('n2s_insertedLayerName');
		$elem.attr('nunaliit-layer',layerIdentifier);

		$elem.text(layerIdentifier);
		
		this.domStyler._insertLayerName($elem);
	},
	
	installUserEvents: function(opts_){
		var opts = $n2.extend({
			doc: null
			,elem: null
			,disableClick: false
			,disableHover: false
		},opts_);
		
		var $elem = $(opts.elem);
		
		if( opts.disableClick ){
			$elem.attr('nunaliit-disable-click','true');
		};
		if( opts.disableHover ){
			$elem.attr('nunaliit-disable-hover','true');
		};
		
		this.domStyler._userEvents($elem, opts.doc);
	},
	
	showFindAvailable: function(opts_){
		var opts = $n2.extend({
			doc: null
			,docId: null
			,elem: null
		},opts_);
		
		var doc = opts.doc;
		var docId = opts.docId;

		if( !docId && doc ){
			docId = doc._id;
		};

		var $elem = null;
		if( opts.elem ){
			$elem = $(opts.elem);
		};

		if( docId && $elem && $elem.length > 0 ){
			$elem.addClass('n2s_showedFindAvailable');
			$elem.attr('nunaliit-document',docId);
			
			this.domStyler._showFindAvailable($elem, doc);
		};
	},

	_displayUserDocument: function(userDoc){
		var _this = this;

		var id = userDoc._id;
		
		// Get display name
		var displayName = userDoc.display;
		
		// Get short name
		var userName = null;
		if( id.substr(0,couchUserPrefix.length) === couchUserPrefix ) {
			userName = id.substr(couchUserPrefix.length);
		};

		if( userName ) {
			$('.n2ShowUser_'+$n2.utils.stringToHtmlId(userName)).each(function(){
				var $elem = $(this);
				
				_this._adjustUserNameNode($elem, userName, displayName);
			});
		};
	},
	
	_adjustUserNameNode: function($elem, userName, displayName){
		var showHandle = true;
		if( $elem.hasClass('n2ShowUserDisplay') ) {
			showHandle = false;
		} else if( $elem.hasClass('n2ShowUserDisplayAndHandle') ){
			showHandle = true; // redundant
		};

		$elem
			.empty()
			.removeClass('n2ShowInsertedUserDisplayName');

		// Defaults to display name
		if( displayName ) {
			$('<span>')
				.addClass('n2Show_userDisplayName')
				.text(displayName)
				.appendTo($elem);
			$elem.addClass('n2ShowInsertedUserDisplayName');
		};

		if( showHandle ){
			$('<span>')
				.addClass('n2Show_userName')
				.text(userName)
				.appendTo($elem);
		}
	},
	
	_displayDocumentBrief: function($elem, doc, opt_){
		
		var opt = $n2.extend({
			onDisplayed: null // function($elem, doc, opt_){}
			,schemaName: null
		},opt_);

		var _this = this;

		// Perform pre-processing, allowing client to
		// augment document prior to display
		doc = this._preprocessDocument(doc);

		if( opt.schemaName ) {
			_this.schemaRepository.getSchema({
				name: opt.schemaName
				,onSuccess: function(schema_) {
					printBrief($elem,schema_);
				}
				,onError: function(){
					displayError($elem);
				}
			});
			
		} else if( doc.nunaliit_schema ) {
			_this.schemaRepository.getSchema({
				name: doc.nunaliit_schema
				,onSuccess: function(schema_) {
					printBrief($elem,schema_);
				}
				,onError: function(){
					displayError($elem);
				}
			});
			
		} else if( _this.defaultSchema ) {
			printBrief($elem, _this.defaultSchema);
			
		} else {
			displayError($elem);
		};
		
		function printBrief($elem, schema){
			$elem.removeClass('n2Show_docNotFound');
			schema.brief(doc,$elem);
			_this.fixElementAndChildren($elem, {}, doc);
			_this._postProcessDisplay($elem, doc);

			if( typeof opt.onDisplayed === 'function' ){
				opt.onDisplayed($elem, doc, schema, opt_);
			};
		};
		
		function displayError($elem){
			$elem.text( _loc('Unable to display brief description') );

			if( typeof opt.onDisplayed === 'function' ){
				opt.onDisplayed($elem, doc, null, opt_);
			};
		};
	},
	
	_displayDocumentFull: function($elem, doc, opt_){
		
		var opt = $n2.extend({
			onDisplayed: null // function($elem, doc, opt_){}
			,schemaName: null
		},opt_);
		
		var _this = this;
		
		// Peform pre-processing, allowing client to
		// augment document prior to display
		doc = this._preprocessDocument(doc);
		
		if( opt.schemaName ) {
			_this.schemaRepository.getSchema({
				name: opt.schemaName
				,onSuccess: function(schema){
					displaySchema($elem, schema);
				}
				,onError: function(){
					displayError($elem);
				}
			});
			
		} else if( doc.nunaliit_schema ) {
			_this.schemaRepository.getSchema({
				name: doc.nunaliit_schema
				,onSuccess: function(schema){
					displaySchema($elem, schema);
				}
				,onError: function(){
					displayError($elem);
				}
			});
			
		} else if( _this.defaultSchema ) {
			displaySchema($elem, _this.defaultSchema);
			
		} else {
			displayError($elem);
		};
		
		function displaySchema($elem,schema){
			$elem.removeClass('n2Show_docNotFound');
			schema.display(doc,$elem);
			_this.fixElementAndChildren($elem, {}, doc);
			_this._postProcessDisplay($elem, doc);

			if( typeof opt.onDisplayed === 'function' ){
				opt.onDisplayed($elem, doc, schema, opt_);
			};
		};
		
		function displayError($elem){
			$elem.text( _loc('Unable to display document') );
		};
	},
	
	_preprocessDocument: function(doc_){
		var doc = doc_;
		
		if( this.options 
		 && this.options.preprocessDocument ){
			doc = this.options.preprocessDocument(doc);
		};
		
		return doc;
	},

	_postProcessDisplay: function($sElem, data){
		// Perform post-process function 
		for(var i=0,e=this.postProcessDisplayFns.length; i<e; ++i){
			var fn = this.postProcessDisplayFns[i];
			fn(data, $sElem);
		};
	},
	
	_requestUser: function(userName){
		var requestService = this.requestService;
		if( requestService ){
			requestService.requestUser(userName); // fetch document
		};
	},

	_requestDocument: function(docId,cbFn){
		var requestService = this.requestService;
		if( requestService ){
			requestService.requestDocument(docId,cbFn); // fetch document
		};
	},

	_requestLayerDefinition: function(layerId){
		var requestService = this.requestService;
		if( requestService ){
			requestService.requestLayerDefinition(layerId); // fetch document
		};
	},
	
	_handleDocumentListResults: function(m){
		var _this = this;
		
		$('.n2show_documentList_wait').each(function(){
			var $elem = $(this);
			
			var listType = $elem.attr('nunaliit-list-type');
			if( typeof listType === 'undefined'){
				listType = $elem.attr('n2-list-type');
			};
			var listName = $elem.attr('nunaliit-list-name');
			if( typeof listName === 'undefined'){
				listName = $elem.attr('n2-list-name');
			};
			var listLive = $elem.attr('nunaliit-list-live');
			if( listLive === 'false'){
				listLive = undefined;
			};
			
			if( listType === m.listType 
			 && listName === m.listName ){
				$elem.removeClass('n2show_documentList_empty');

				if( !listLive ) {
					// If not live, do not wait for any more updates
					$elem.removeClass('n2show_documentList_wait');
				};
				
				$elem.empty();

				// Are documents provided?
				if( m.docs && m.docs.length > 0 ){
					for(var i=0,e=m.docs.length; i<e; ++i){
						var doc = m.docs[i];
						var docId = doc._id;
						
						var $doc = $('<div>')
							.addClass('n2show_documentList_item')
							.addClass('n2s_userEvents')
							.attr('nunaliit-document',docId)
							.appendTo($elem);
						
						var $a = $('<a>')
							.attr('href','#')
							.appendTo($doc);
	
						_this._displayDocumentBrief($a, doc);
					};

					_this.fixElementAndChildren($elem, {}, null);
					
				// If documents are not provided, docIds are compulsory
				} else if( m.docIds && m.docIds.length > 0 ){
					for(var i=0,e=m.docIds.length; i<e; ++i){
						var docId = m.docIds[i];
						
						var $doc = $('<div>')
							.addClass('n2show_documentList_item')
							.addClass('n2s_userEvents')
							.attr('nunaliit-document',docId)
							.appendTo($elem);
						
						var $a = $('<a>')
							.attr('href','#')
							.addClass('n2s_briefDisplay')
							.attr('nunaliit-document',docId)
							.text(docId)
							.appendTo($doc);
					};
					
					_this.fixElementAndChildren($elem, {}, null);
					
				// If empty, set class to report it
				} else {
					$elem.addClass('n2show_documentList_empty');
				};
			};
		});
	},
	
	_handleDocumentContent: function(doc){
		if( doc ){
			this.domStyler._receivedDocumentContent(doc);
		};
	},

	_handleDocumentUpdate: function(doc){
		if( doc ){
			this.domStyler._receivedDocumentUpdate(doc);
		};
	},
	
	_handleUserIntentChanged: function(changes){
		if( changes && changes.length > 0 ){
			for(var i=0,e=changes.length; i<e; ++i){
				var change = changes[i];
				var docId = change.n2_id;
				var eventClass = 'n2s_userEvents_doc_' + $n2.utils.stringToHtmlId(docId);
				$('.'+eventClass).each(function(){
					var $elem = $(this);

					if( change.n2_selected ){
						$elem.addClass('nunaliit_selected');
					} else {
						$elem.removeClass('nunaliit_selected');
					};

					if( change.n2_hovered ){
						$elem.addClass('nunaliit_hovered');
					} else {
						$elem.removeClass('nunaliit_hovered');
					};

					if( change.n2_find ){
						$elem.addClass('nunaliit_found');
					} else {
						$elem.removeClass('nunaliit_found');
					};
				});
			};
		};
	},
	
	_handleDispatch: function(m, address, dispatchService){
		if( 'start' === m.type ){
			// Accept Post-process display functions that are
			// set during configuration
			var customService = this.customService;
			if( customService ){
				var postProcessFns = customService.getOption('displayPostProcessFunctions');
				if( postProcessFns ){
					for(var i=0,e=postProcessFns.length;i<e;++i){
						var fn = postProcessFns[i];
						this.addPostProcessDisplayFunction(fn);
					};
				};
				
				suppressLeaveConfirmation = 
					customService.getOption('displaySuppressLeaveConfirmation',false);
			};
			
		} else if( 'documentListResults' === m.type ) {
			this._handleDocumentListResults(m);
			
		} else if( 'documentDeleted' === m.type ) {
			var docId = m.docId;
			
			if( docId ){
				var escaped = $n2.utils.stringToHtmlId(docId);
				$('.n2show_documentUpdate_'+escaped).remove();
			};

		} else if( 'documentContentCreated' === m.type ) {
			var doc = m.doc;
			if( doc ){
				this._handleDocumentUpdate(doc);
			};

		} else if( 'documentContentUpdated' === m.type ) {
			var doc = m.doc;
			if( doc ){
				this._handleDocumentUpdate(doc);
			};

		} else if( 'documentContent' === m.type ) {
			this._handleDocumentContent(m.doc);
			
		} else if( 'userIntentChanged' === m.type ) {
			if( m.changes ){
				this._handleUserIntentChanged(m.changes);
			};
			
		} else if( 'findAvailabilityChanged' === m.type ) {
			// A canvas is reporting a different set of documents
			// available for 'find'. Compile all docIds related to
			// 'find'
			var docIdMap = {};
			$('.n2s_showedFindAvailable').each(function(){
				var $elem = $(this);
				var docId = $elem.attr('nunaliit-document');
				if( docId ){
					docIdMap[docId] = true;
				};
			});
			
			// Get the content of the documents, since 'findIsAvailable' synchronous
			// call requires the document content. When receiving document content,
			// all elements with class 'n2s_showedFindAvailable' are updated accordingly
			for(var docId in docIdMap){
				this._requestDocument(docId);
			};
		};
	},
	
	_createDocIfInexistant: function(docId, schemaName){
		var _this = this;
		
		this.documentSource.getDocumentInfoFromIds({
			docIds: [ docId ]
			,onSuccess: function(docInfos){
				var docInfosById = {};
				for(var i=0,e=docInfos.length; i<e; ++i){
					var info = docInfos[i];
					docInfosById[info.id] = info;
				};
				
				if( docInfosById[docId] ){
					// Exists. Select
					_this.dispatchService.send(DH,{
						type:'userSelect'
						,docId: docId
					});
				} else {
					// Does not exist. Create
					_this.schemaRepository.getSchema({
						name: schemaName
						,onSuccess: function(schema) {
							var doc = schema.createObject({
								_id: docId
							});
							_this.dispatchService.send(DH,{
								type:'editInitiate'
								,doc: doc
							});
						}
					});
				};
			}
		});
	}
});

//*******************************************************
$n2.couchShow = {
	Show: Show	
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchEdit.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2) {
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
,DH = 'n2.couchEdit'
;

function getDefaultCouchProjection(){
	var defaultCouchProj = null;
	if( typeof(OpenLayers) !== 'undefined' 
	 && OpenLayers.Projection ) {
		defaultCouchProj = new OpenLayers.Projection('EPSG:4326');
	};
	return defaultCouchProj;
};

//++++++++++++++++++++++++++++++++++++++++++++++


function isKeyEditingAllowed(obj, selectors, data) {
	
	if( !selectors ) return false;
	
	if( selectors[0] === '_id' ) return false;
	if( selectors[0] === '_rev' ) return false;
	if( selectors[0] === '__n2Source' ) return false;
	
	return true;
}

function isValueEditingAllowed(obj, selectors, data) {
	
	if( !selectors ) return false;

	if( selectors[0] === '_id' ) return false;
	if( selectors[0] === '_rev' ) return false;
	if( selectors[0] === '__n2Source' ) return false;
	
	return true;
};

function isKeyDeletionAllowed(obj, selectors, data) {
	
	if( !selectors ) return false;

	if( selectors[0] === '_id' ) return false;
	if( selectors[0] === '_rev' ) return false;
	if( selectors[0] === '__n2Source' ) return false;
	
	return true;
};

function searchForDocumentId(options_){

	var options = $n2.extend({
		searchServer: null
		,showService: null
		,onSelected: function(docId){}
		,onReset: function(){}
	},options_);
	
	var shouldReset = true;
	
	var dialogId = $n2.getUniqueId();
	var inputId = $n2.getUniqueId();
	var searchButtonId = $n2.getUniqueId();
	var displayId = $n2.getUniqueId();
	var $dialog = $('<div id="'+dialogId+'" class="editorSelectDocumentDialog">'
			+'<div><label for="'+inputId+'">'+_loc('Search:')+'</label>'
			+'<input id="'+inputId+'" type="text"/>'
			+'<button id="'+searchButtonId+'">'+_loc('Search')+'</button></div>'
			+'<div  class="editorSelectDocumentDialogResults" id="'+displayId+'"></div>'
			+'<div><button class="cancel">'+_loc('Cancel')+'</button></div>'
			+'</div>');
	
	$dialog.find('button.cancel')
			.button({icons:{primary:'ui-icon-cancel'}})
			.click(function(){
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			})
		;
	
	var dialogOptions = {
		autoOpen: true
		,title: _loc('Select Document')
		,modal: true
		,width: 370
		,close: function(event, ui){
			var diag = $(event.target);
			diag.dialog('destroy');
			diag.remove();
			if( shouldReset ) {
				options.onReset();
			};
		}
	};
	$dialog.dialog(dialogOptions);

	options.searchServer.installSearch({
		textInput: $('#'+inputId)
		,searchButton: $('#'+searchButtonId)
		,displayFn: displaySearch
		,onlyFinalResults: true
	});
	
	function displaySearch(displayData) {
		if( !displayData ) {
			reportError('Invalid search results returned');

		} else if( 'wait' === displayData.type ) {
			$('#'+displayId).empty();

		} else if( 'results' === displayData.type ) {
			var $table = $('<table></table>');
			$('#'+displayId).empty().append($table);
		
			for(var i=0,e=displayData.list.length; i<e; ++i) {
				var docId = displayData.list[i].id;
				var $tr = $('<tr></tr>');

				$table.append($tr);
				
				$td = $('<td class="n2_search_result olkitSearchMod2_'+(i%2)+'">'
					+'<a href="#'+docId+'" alt="'+docId+'"></a></td>');
				$tr.append($td);
				if( options.showService ) {
					options.showService.printBriefDescription($td.find('a'),docId);
				} else {
					$td.find('a').text(docId);
				};
				$td.find('a').click( createClickHandler(docId) );
			};
			
		} else {
			reportError('Invalid search results returned');
		};
	};
	
	function createClickHandler(docId) {
		return function(e){
			options.onSelected(docId);
			shouldReset = false;
			var $dialog = $('#'+dialogId);
			$dialog.dialog('close');
			return false;
		};
	};
};


//++++++++++++++++++++++++++++++++++++++++++++++

var CouchSimpleDocumentEditor = $n2.Class({

	elemId: null

	,editedDocument: null
	
	,schema: null
	
	,defaultEditSchema: null

	,schemaRepository: null
	
	,schemaEditorService: null
	
	,dispatchService: null
	
	,editors: null
	
	,couchProj: null
	
	,treeEditor: null
	
	,slideEditor: null
	
	,isInsert: null
	
	,editorsContainerId: null
	
	,initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,elemId: null
			,doc: null
			,schema: null // schema name, array of schema name or special option
			,defaultEditSchema: null
			,schemaRepository: null
			,schemaEditorService: null
			,dispatchService: null
			,editors: null
			,couchProj: null
		},opts_);
		
		this.elemId = opts.elemId;
		if( opts.elem ){
			var $elem = $(opts.elem);
			this.elemId = $elem.attr('id');
			if( !this.elemId ){
				this.elemId = $n2.getUniqueId();
				$elem.attr('id',this.elemId);
			};
		};
		
		this.schema = opts.schema;
		this.defaultEditSchema = opts.defaultEditSchema;
		this.schemaRepository = opts.schemaRepository;
		this.schemaEditorService = opts.schemaEditorService;
		this.dispatchService = opts.dispatchService;
		this.editors = opts.editors;
		this.couchProj = opts.couchProj;

		this.editedDocument = {};
		var clonedDoc = $n2.extend(true,{},opts.doc); // deep copy
		for(var key in clonedDoc){
			if( '__n2Source' === key ){
				// Drop information about document source so it does not
				// appear in the editor
			} else {
				this.editedDocument[key] = clonedDoc[key];
			};
		};
		
		// Obtain documentSource
		this.editedDocumentSource = undefined;
		if( this.dispatchService ){
			var m = {
				type: 'documentSourceFromDocument'
				,doc: opts.doc
			};
			this.dispatchService.synchronousCall(DH,m);
			this.editedDocumentSource = m.documentSource;
		};
		
		this.isInsert = false;
		
		if( !this.couchProj ){
			this.couchProj = getDefaultCouchProjection();
		};
		
		if( this.dispatchService ){
			var f = function(m){ _this._handle(m); };
			this.dispatchService.register(DH, 'editGeometryModified', f);
			this.dispatchService.register(DH, 'mapGeometryAdded', f);
		};
		
		if( !this.editors ){
			// Default
			this.editors = [
				$n2.couchEdit.Constants.FORM_EDITOR
				,$n2.couchEdit.Constants.TREE_EDITOR
				,$n2.couchEdit.Constants.SLIDE_EDITOR
				,$n2.couchEdit.Constants.RELATION_EDITOR
			];
		};
		
		this._edit();
	}

	,getDocument: function(){
		return this.editedDocument;
	}

	,_getDiv: function(){
		return $('#'+this.elemId);
	}

	,_edit: function(){
		var _this = this;
		
		this.isInsert = (typeof this.editedDocument._rev === 'undefined' 
			|| this.editedDocument._rev === null);
	
		this._selectSchema(schemaSelected);
		
		function schemaSelected(schema) {
			if( _this.isInsert ) {
				// Create original object by augmenting current one with template
				if( schema ) {
					var template = schema.createObject({});
					$n2.extend(true, _this.editedDocument, template);
				};
			};
			
			_this._displayEditor(schema);
		};
	}
	
	,_displayEditor: function(selectedSchema) {
		var _this = this;
		
		var data = this.editedDocument;
		
		// Give an opportunity to adjust document before edit
		this._synchronousCall({
			type: 'editorStartDocumentEdit'
			,doc: data
		});

		// Update feature data with user info
		$n2.couchDocument.adjustDocument(data);
		
		// Figure out if accordion is needed
		var accordionNeeded = false;
		var relationEditorNeeded = false;
		var editorCount = 0;
		for(var i=0,e=this.editors.length;i<e;++i){
			var editorDesc = this.editors[i];
			if( $n2.couchEdit.Constants.FORM_EDITOR === editorDesc ){
				if( selectedSchema && this.schemaEditorService ){
					++editorCount;
				};
			} else if( $n2.couchEdit.Constants.TREE_EDITOR === editorDesc ){
				++editorCount;
			} else if( $n2.couchEdit.Constants.SLIDE_EDITOR === editorDesc ){
				++editorCount;
			} else if( $n2.couchEdit.Constants.RELATION_EDITOR === editorDesc ){
				relationEditorNeeded = true;
			};
		};
		if( editorCount > 1 ){
			accordionNeeded = true;
		};

		var $div = this._getDiv();
		$div.empty();
		
		this.editorsContainerId = $n2.getUniqueId();
		var $editorsContainer = $('<div id="'+this.editorsContainerId+'" class="n2CouchEditor_container"></div>');
		$div.append($editorsContainer);

		for(var i=0,e=this.editors.length;i<e;++i){
			var editorDesc = this.editors[i];
			
			if( $n2.couchEdit.Constants.FORM_EDITOR === editorDesc
			 && selectedSchema 
			 && this.schemaEditorService ) {
				// Accordion Header
				if( accordionNeeded ) {
					var $schemaHeader = $('<h3>')
						.appendTo($editorsContainer);
					$('<a>')
						.attr('href','#')
						.text( _loc('Form View') )
						.appendTo($schemaHeader);
				};
				
				var $schemaContainer = $('<div class="n2CouchEditor_schema"></div>')
					.addClass('n2CouchEditor_schema')
					.appendTo($editorsContainer);
				
				this.schemaEditor = this.schemaEditorService.editDocument({
					doc: data
					,schema: selectedSchema
					,$div: $schemaContainer
					,onChanged: function(){
						_this._adjustInternalValues(_this.editedDocument);
						if( _this.treeEditor ) {
							_this.treeEditor.refresh();
						};
						if( _this.slideEditor ) {
							_this.slideEditor.refresh();
						};
						_this._refreshRelations(data);
						_this._onEditorObjectChanged(data);
					}
				});
				
			} else if( $n2.couchEdit.Constants.TREE_EDITOR === editorDesc ) {
				// Accordion Header for Tree
				if( accordionNeeded ) {
					var $treeHeader = $('<h3>')
						.appendTo($editorsContainer);
					$('<a>')
						.attr('href','#')
						.text( _loc('Tree View') )
						.appendTo($treeHeader);
				};
		
				// Tree container
				var $treeContainer = $('<div>')
					.addClass('n2CouchEditor_tree')
					.appendTo($editorsContainer);
				var editorOptions = {
					onObjectChanged: function() {
						_this._adjustInternalValues(_this.editedDocument);
						if( _this.slideEditor ) {
							_this.slideEditor.refresh();
						};
						if( _this.schemaEditor ) {
							_this.schemaEditor.refresh();
						};
						_this._refreshRelations(data);
						_this._onEditorObjectChanged(data);
					}
					,isKeyEditingAllowed: isKeyEditingAllowed
					,isValueEditingAllowed: isValueEditingAllowed
					,isKeyDeletionAllowed: isKeyDeletionAllowed
				};
				var objectTree = new $n2.tree.ObjectTree($treeContainer, data, editorOptions);
				this.treeEditor = new $n2.tree.ObjectTreeEditor(objectTree, data, editorOptions);
			
			} else if( $n2.couchEdit.Constants.SLIDE_EDITOR === editorDesc ) {
				// Accordion Header for slide editor
				if( accordionNeeded ) {
					var $slideHeader = $('<h3>')
						.appendTo($editorsContainer);
					$('<a>')
						.attr('href','#')
						.text( _loc('Editor View') )
						.appendTo($slideHeader);
				};
	
				// Content for slide editor
				var $slideContainer = $('<div>')
					.addClass('n2CouchEditor_slide')
					.appendTo($editorsContainer);
				var slideEditorOptions = {
					onObjectChanged: function() {
						_this._adjustInternalValues(_this.editedDocument);
						if( _this.treeEditor ) {
							_this.treeEditor.refresh();
						};
						if( _this.schemaEditor ) {
							_this.schemaEditor.refresh();
						};
						_this._refreshRelations(data);
						_this._onEditorObjectChanged(data);
					}
					,isKeyEditingAllowed: isKeyEditingAllowed
					,isValueEditingAllowed: isValueEditingAllowed
					,isKeyDeletionAllowed: isKeyDeletionAllowed
				};
				this.slideEditor = new $n2.slideEditor.Editor($slideContainer, data, slideEditorOptions);
			};
		};
		
		if( accordionNeeded ) {
			$editorsContainer.accordion({ collapsible: true });
		};
		
		// Report relations
		if( relationEditorNeeded ) {
			var $displayRelationsDiv = $('<div class="editorDisplayRelations"></div>');
			$editorsContainer.append( $displayRelationsDiv );
			this._refreshRelations(data);
		};
	}

	,_selectSchema: function(callbackFn) {
		var _this = this;

		// Check hint from document
		if( this.editedDocument.nunaliit_schema ) {
			this.schemaRepository.getSchema({
				name: this.editedDocument.nunaliit_schema
				,onSuccess: function(schema){
					callbackFn(schema);
				}
				,onError: function(err){
					$n2.log('Error fetching schema: '+_this.editedDocument.nunaliit_schema,err);
					callbackFn(null);
				}
			});
			
		} else if( this.schema && this.isInsert ) {
			if( $n2.couchEdit.Constants.ALL_SCHEMAS === this.schema ) {
				// Must select a schema from all root schemas
				this.schemaRepository.getRootSchemas({
					onSuccess: function(schemas){
						selectFromSchemas(schemas);
					}
					,onError: function(err){
						$n2.log('Error fetching root schemas',err);
						callbackFn(null);
					}
				});
				
			} else if( $n2.isArray(this.schema) ) {
				// Must select a schema
				selectFromSchemas(this.schema);
				
			} else {
				// Only one schema to select from
				callbackFn(this.schema);
			};
			
		} else if( this.defaultEditSchema && !this.isInsert ) {
			// If the object does not specify a schema, use default schema
			// if specified
			callbackFn(this.defaultEditSchema);
			
		} else {
			// No schema specified, go directly to displaying editor
			callbackFn(null);
		};
		
		function selectFromSchemas(schemas) {
			// shortcuts
			if( schemas.length < 1 ) {
				callbackFn(null);
				return;
				
			} else if( schemas.length == 1 ) {
				callbackFn(schemas[0]);
				return;
			};
			
			var dialogId = $n2.getUniqueId();
			var selectId = $n2.getUniqueId();
			var $dialog = $('<div id="'+dialogId+'" class="editorSelectSchemaDialog">'
					+'<label for="'+selectId+'">'+_loc('Select a schema:')+'</label>'
					+'<select id="'+selectId+'"></select>'
					+'<div><button>'+_loc('OK')+'</button><button>'+_loc('Cancel')+'</button></div>'
					+'</div>');
			
			var $select = $dialog.find('select');
			for(var i=0,e=schemas.length; i<e; ++i) {
				$select.append( $('<option>'+schemas[i].name+'</option>') );
			}
			
			var cancelOnClose = true;
			
			$dialog.find('button')
				.first()
					.button({icons:{primary:'ui-icon-check'}})
					.click(function(){
						var $dialog = $('#'+dialogId);
						var $select = $dialog.find('select');
						var schemaName = $select.val();

						$n2.log('schemaName',schemaName);
						_this.schemaRepository.getSchema({
							name: schemaName
							,onSuccess: function(schema){
								callbackFn(schema);
							}
							,onError: function(err){
								reportError('Unable to get selected schema: '+err);
								_this._cancelEdit();
							}
						});
				
						cancelOnClose = false;
						$dialog.dialog('close');
						return false;
					})
				.next()
					.button({icons:{primary:'ui-icon-cancel'}})
					.click(function(){
						var $dialog = $('#'+dialogId);
						$dialog.dialog('close');
						return false;
					})
				;
			
			var dialogOptions = {
				autoOpen: true
				,title: _loc('Select Document Schema')
				,modal: true
				,close: function(event, ui){
					var diag = $(event.target);
					diag.dialog('destroy');
					diag.remove();
					
					if( cancelOnClose ){
						_this._cancelEdit();
					};
				}
			};
			$dialog.dialog(dialogOptions);
		};
	}

	,_dispatch: function(m){
		if( this.dispatchService ){
			this.dispatchService.send(DH,m);
		};
	}

	,_synchronousCall: function(m){
		if( this.dispatchService ){
			this.dispatchService.send(DH,m);
		};
	}

	,_handle: function(m, address, dispatcher){
		// Check that we are still alive
		var $div = this._getDiv();
		if( $div.length < 1 ){
			// No longer in use, de-register from dispatcher
			dispatcher.deregister(address);
		};
		
		if( m.type === 'editGeometryModified' ){
			if( m._origin !== this ){
				this._geometryModified(m.docId, m.geom, m.proj);
			};
		} else if( m.type === 'mapGeometryAdded' ){
			this._addGeometry(m.geometry, m.projection);
		};
	}

	,_adjustInternalValues: function(obj) {
		// BBOX
		if( typeof(OpenLayers) !== 'undefined' ) {
			var geomData = obj.nunaliit_geom;
			if( geomData ) {
				// Check if editor has changed the geometry's WKT
				if( this.currentGeometryWkt != geomData.wkt ) {
					$n2.couchGeom.updatedGeometry(geomData);
				};
			};
		};
	}

	,_refreshRelations: function(data){
		var _this = this;
		var $div = this._getDiv();
		var $displayRelationsDiv = $div.find('.editorDisplayRelations');
		if( $displayRelationsDiv.length < 1 ) return;

		var showService = this.showService;
		if( !showService ) return;

		// Compute relations
		var docIdMap = {};
		if( data 
		 && data.nunaliit_relations
		 && data.nunaliit_relations.length ){
			for(var i=0,e=data.nunaliit_relations.length; i<e; ++i){
				var ref = data.nunaliit_relations[i];
				if( ref.doc ) {
					docIdMap[ref.doc] = true;
				};
			};
		};
		if( data 
		 && data.nunaliit_source
		 && data.nunaliit_source.doc ){
			docIdMap[data.nunaliit_source.doc] = true;
		};
		
		// Remove displayed relations that are no longer valid
		$displayRelationsDiv.find('.editorDisplayRelation').each(function(){
			var $display = $(this);
			var relDocId = $display.attr('nunaliitRelationDocId');
			if( !docIdMap[relDocId] ){
				$display.remove();
			} else {
				// This relDocId is already displayed. Remove from map.
				delete docIdMap[relDocId];
			};
		});
		
		// Function to delete a relation
		var removeRelationFn = function(e){
			var $btn = $(this);
			var $removeRelationDiv = $btn.parents('.editorDisplayRelation');
			if( $removeRelationDiv.length > 0 ){
				var relDocId = $removeRelationDiv.attr('nunaliitRelationDocId');
				_this._removeRelation(relDocId);
				$removeRelationDiv.remove();
			};
			
			return false;
		};
		
		// Add missing relations. At this point, docIdMap contains
		// only missing relations
		for(var relDocId in docIdMap){
			var $displayRelationDiv = $('<div class="editorDisplayRelation"></div>');
			$displayRelationsDiv.append($displayRelationDiv);
			$displayRelationDiv.attr('nunaliitRelationDocId',relDocId);

			$('<span></span>')
				.text( _loc('Relation: '))
				.appendTo($displayRelationDiv);
			
			var $brief = $('<span></span>')
				.text(relDocId)
				.appendTo($displayRelationDiv);
			if( showService ){
				showService.printBriefDescription($brief, relDocId);
			};
			
			$('<button class="editorDisplayRelationButton"></button>')
				.text( _loc('Remove') )
				.appendTo($displayRelationDiv)
				.button({icons:{primary:'ui-icon-trash'}})
				.click(removeRelationFn)
				;
		};
	}
	
	,_onEditorObjectChanged: function(obj) {
		var geomData = obj.nunaliit_geom;
		
		if( !geomData ) return; // avoid errors
		if( typeof(OpenLayers) === 'undefined' ) return;
			
		// Check if editor has changed the geometry's WKT
		if( this.currentGeometryWkt !== geomData.wkt ) {
		
			this.currentGeometryWkt = geomData.wkt;

			var olGeom = $n2.couchGeom.getOpenLayersGeometry({couchGeom:geomData});
			
			this._dispatch({
				type: 'editGeometryModified'
				,docId: obj._id
				,geom: olGeom
				,proj: this.couchProj
				,_origin: this
			});
		};
	}

	,_geometryModified: function(docId, geom, proj) {

		if( proj.getCode() != this.couchProj.getCode() ) {
			// Need to convert
			geom = geom.clone();
			geom.transform(proj,this.options.couchProj);
		};
    	
		var geomData = this.editedDocument.nunaliit_geom;
		geomData.wkt = geom.toString();
		$n2.couchGeom.updatedGeometry(geomData);
		this.currentGeometryWkt = geomData.wkt;
		if( this.schemaEditor ) {
			this.schemaEditor.refresh();
		};
		if( this.treeEditor ) {
			this.treeEditor.refresh();
		};
		if( this.slideEditor ) {
			this.slideEditor.refresh();
		};
	}
	
	,_addGeometry: function(geom, proj) {
		if( proj.getCode() != this.couchProj.getCode() ) {
			// Need to convert
			geom = geom.clone();
			geom.transform(proj,this.couchProj);
		};
		
		var geomData = this.editedDocument.nunaliit_geom;
		if( !geomData ){
			geomData = {
				nunaliit_type: 'geometry'
			};
			this.editedDocument.nunaliit_geom = geomData;
		};
		geomData.wkt = geom.toString();
		$n2.couchGeom.updatedGeometry(geomData);
		this.currentGeometryWkt = geomData.wkt;
		if( this.schemaEditor ) {
			this.schemaEditor.refresh();
		};
		if( this.treeEditor ) {
			this.treeEditor.refresh();
		};
		if( this.slideEditor ) {
			this.slideEditor.refresh();
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++

var CouchDocumentEditor = $n2.Class({
	
	panelName: null,
	uploadService: null,
	searchService: null,
	showService: null,
	schemaEditorService: null,
	schemaRepository: null,
	customService: null,
	dispatchService: null,
	dialogService: null,
	initialLayers: null,
	schema: null,
	defaultEditSchema: null,
	documentSource: null,
	couchProj: null,
	onCancelFn: null,
	onCloseFn: null,
	moduleEditInfo: null,
	relatedDocProcess: null,
	schemaEditor: null,
	treeEditor: null,
	slideEditor: null,
	attachmentEditor: null,
	originalDocument: null,
	editedDocument: null,
	editedDocumentSchema: null,
	currentGeometryWkt: null,
	editorContainerId: null,
	isInsert: null,
	userButtons: null,
	editorSuppressSlideView: null,
	editorSuppressTreeView: null,
	editorSuppressFormView: null,
	onRefreshFunctions: null,
	enableAddFile: null,
	
	initialize: function(
		opts_
		) {
		
		var opts = $n2.extend({
			panelName: null
			,uploadService: null
			,searchService: null
			,showService: null
			,schemaEditorService: null
			,schemaRepository: null
			,customService: null
			,dispatchService: null
			,dialogService: null
			,initialLayers: []
			,schema: null
			,defaultEditSchema: null
			,documentSource: null
			,couchProj: null
			,onCancelFn: function(doc){}
			,onCloseFn: function(){}
			,moduleEditInfo: null
			,relatedDocProcess: null
			
			// buttonX....
		}, opts_);
		
		var _this = this;
		
		this.panelName = opts.panelName;
		this.uploadService = opts.uploadService;
		this.searchService = opts.searchService;
		this.showService = opts.showService;
		this.schemaEditorService = opts.schemaEditorService;
		this.schemaRepository = opts.schemaRepository;
		this.customService = opts.customService;
		this.dispatchService = opts.dispatchService;
		this.dialogService = opts.dialogService;
		this.initialLayers = opts.initialLayers;
		this.schema = opts.schema;
		this.defaultEditSchema = opts.defaultEditSchema;
		this.documentSource = opts.documentSource;
		this.couchProj = opts.couchProj;
		this.onCancelFn = opts.onCancelFn;
		this.onCloseFn = opts.onCloseFn;
		this.moduleEditInfo = opts.moduleEditInfo;
		this.relatedDocProcess = opts.relatedDocProcess;
		
		this.userButtons = [];
		var label = 'button';
		for(var key in opts) {
			if( key.substr(0,label.length) === label ) {
				this.userButtons.push(opts[key]);
			};
		};

		this.editorSuppressSlideView = false;
		this.editorSuppressTreeView = false;
		this.editorSuppressFormView = false;
		this.enableAddFile = false;
		this.onRefreshFunctions = [];
		var cs = this.customService;
		if( cs ){
			this.editorSuppressSlideView = cs.getOption('editorSuppressSlideView',false);
			this.editorSuppressTreeView = cs.getOption('editorSuppressTreeView',false);
			this.editorSuppressFormView = cs.getOption('editorSuppressFormView',false);
			
			var flag = cs.getOption('editorEnableAddFile',false);
			if( flag ){
				this.enableAddFile = true;
			};
			
			var onRefreshFunctions = cs.getOption('editorOnRefreshFunctions',[]);
			onRefreshFunctions.forEach(function(onRefresh){
				if( typeof onRefresh === 'function' ){
					_this.onRefreshFunctions.push(onRefresh);
				};
			});
		};
		if( this.moduleEditInfo ){
			if( this.moduleEditInfo.enableAddFile ){
				this.enableAddFile = true;
			};
		};
	},
	
	isEditing: function(){
		if( this.editedDocument ){
			return true;
		};
		return false;
	},

	startEditingFromGeometry: function(olGeom, olProj) {
		
		var _this = this;
	
		this.editedDocument = {};
		this.editedDocumentSchema = null;
	
		this.currentGeometryWkt = undefined;
		
		this.isInsert = true;

		this._selectSchema(schemaSelected);
		
		function schemaSelected() {
			// Create original object by augmenting current one with template
			if( _this.editedDocumentSchema ) {
				var template = _this.editedDocumentSchema.createObject({});
				$n2.extend(true, _this.editedDocument, template);
			};

			// Geometry
			if( olProj.getCode() != _this.couchProj.getCode() ) {
				// Need to convert
				var geom = olGeom.clone();
				geom.transform(olProj,_this.couchProj);
				olGeom = geom;
			};
			var g = $n2.couchGeom.getCouchGeometry(olGeom);
			_this.editedDocument.nunaliit_geom = g;
			_this.currentGeometryWkt = g.wkt;
			
			// Add default layers?
			if( _this.initialLayers 
			 && _this.initialLayers.length > 0 ) {
				_this.editedDocument.nunaliit_layers = _this.initialLayers;
			};

			// Give a chance to external processes to modify document
			_this.dispatchService.synchronousCall(DH,{
				type: 'preDocCreation'
				,doc: _this.editedDocument
			});
			
			_this._prepareDocument();
		};
	},

	startDocumentEditing: function(doc_) {

		var _this = this;
		
		this.editedDocument = {};
		this.editedDocumentSchema = null;
		var clonedDoc = $n2.extend(true,{},doc_); // deep copy
		for(var key in clonedDoc){
			if( '__n2Source' === key ) {
				// Drop information about document source so it does not
				// appear in the editor
			} else {
				this.editedDocument[key] = clonedDoc[key];
			};
		};

		// Obtain documentSource
		this.editedDocumentSource = undefined;
		if( this.dispatchService ){
			var m = {
				type: 'documentSourceFromDocument'
				,doc: doc_
			};
			this.dispatchService.synchronousCall(DH,m);
			this.editedDocumentSource = m.documentSource;
		};
	
		this.currentGeometryWkt = undefined;
		if( this.editedDocument 
		 && this.editedDocument.nunaliit_geom ) {
			this.currentGeometryWkt = this.editedDocument.nunaliit_geom.wkt;
		};
		
		this.isInsert = (typeof(this.editedDocument._rev) === 'undefined' || this.editedDocument._rev === null);

		this._selectSchema(schemaSelected);
		
		function schemaSelected() {
			if( _this.isInsert ) {
				// Create original object by augmenting current one with template
				if( _this.editedDocumentSchema ) {
					var template = _this.editedDocumentSchema.createObject({});
					$n2.extend(true, template, _this.editedDocument);
					_this.editedDocument = template;
				};
				
				// Give a chance to external processes to modify document
				_this.dispatchService.synchronousCall(DH,{
					type: 'preDocCreation'
					,doc: _this.editedDocument
				});
			};
			
			_this._prepareDocument();
		};
	},

	_prepareDocument: function() {

		var _this = this;

		// Retrieve original geometry
		var editedDoc = _this.editedDocument;
		var nunaliit_geom = editedDoc.nunaliit_geom;
		
		if( nunaliit_geom 
		 && nunaliit_geom.simplified
		 && nunaliit_geom.simplified.original ) {
			// Must reload original geometry
			var attName = nunaliit_geom.simplified.original;
			
			// Check that attachment is available
			if( editedDoc._attachments 
			 && editedDoc._attachments[attName]
			 && this.editedDocumentSource ){
				var url = this.editedDocumentSource.getDocumentAttachmentUrl(editedDoc, attName);
				$.ajax({
					url: url
					,type: 'get'
					,async: true
					,dataType: 'text'
					,success: function(wkt) {
						$n2.couchGeom.updateDocumentWithWktGeometry({
							doc: editedDoc
							,wkt: wkt
						});
						startEditor();
					}
					,error: function(XMLHttpRequest, textStatus, errorThrown) {
						$n2.log('Unable to retrieve original geometry',editedDoc);
						startEditor();
					}
				});
				
			} else {
				startEditor();
			};
		} else {
			startEditor();
		};
		
		function startEditor(){
			_this.originalDocument = $n2.extend(true,{},editedDoc);
			
			var olGeom = $n2.couchGeom.getOpenLayersGeometry({
				doc: editedDoc
			});

			_this._dispatch({
				type: 'editReportOriginalDocument'
				,docId: editedDoc._id
				,doc: editedDoc
				,geometry: olGeom
				,projection: _this.couchProj
				,_origin: _this
			});
			
			_this._displayEditor();
		};
	},
	
	_selectSchema: function(callbackFn) {
		var _this = this;

		this.editedDocumentSchema = null;
		
		// Check hint from document
		if( this.editedDocument.nunaliit_schema ) {
			this.schemaRepository.getSchema({
				name: this.editedDocument.nunaliit_schema
				,onSuccess: function(schema){
					_this.editedDocumentSchema = schema;
					callbackFn(schema);
				}
				,onError: function(err){
					$n2.log('Error fetching schema: '+_this.editedDocument.nunaliit_schema,err);
					callbackFn(null);
				}
			});
			
		} else if( this.schema && this.isInsert ) {
			if( $n2.couchEdit.Constants.ALL_SCHEMAS === this.schema ) {
				// Must select a schema from all root schemas
				this.dialogService.selectSchema({
					onSelected: function(schema){
						_this.editedDocumentSchema = schema;
						callbackFn(schema);
					}
					,onReset: function(){
						_this._cancelEdit();
					}
				});
				
			} else if( $n2.isArray(this.schema) ) {
				// Must select a schema
				this.dialogService.selectSchema({
					schemas: this.schema
					,onSelected: function(schema){
						_this.editedDocumentSchema = schema;
						callbackFn(schema);
					}
					,onReset: function(){
						_this._cancelEdit();
					}
				});
				
			} else {
				// Only one schema to select from
				this.editedDocumentSchema = this.schema;
				callbackFn(this.schema);
			};
			
		} else if( this.defaultEditSchema && !this.isInsert ) {
			// If the object does not specify a schema, use default schema
			// if specified
			this.editedDocumentSchema = this.defaultEditSchema;
			callbackFn(this.defaultEditSchema);
			
		} else {
			// No schema specified, go directly to displaying editor
			callbackFn(null);
		};
	},

	_displayEditor: function() {
		var _this = this;
		
		var selectedSchema = this.editedDocumentSchema;
		
		$('body').addClass('nunaliit_editing');
		$('.n2_disable_on_edit')
			.attr('disabled','disabled');

		var data = this.editedDocument;

		// Give an opportunity to adjust document before edit
		this._synchronousCall({
			type: 'editorStartDocumentEdit'
			,doc: data
		});

		// Update feature data with user info
		$n2.couchDocument.adjustDocument(data);

		// Compute which views to show
		var showFormView = false;
		var showTreeView = false;
		var showSlideView = false;
		var viewCount = 0;
		var showAccordion = false;
		var schemaEditorService = this.schemaEditorService;
		if( !this.editorSuppressFormView 
		 && selectedSchema 
		 && schemaEditorService ){
			showFormView = true;
			++viewCount;
		};
		if( !this.editorSuppressTreeView ){
			showTreeView = true;
			++viewCount;
		};
		if( !this.editorSuppressTreeView ){
			showSlideView = true;
			++viewCount;
		};
		if( viewCount > 1 ){
			showAccordion = true;
		};

		var attributeDialog = $('#'+this.panelName);
		attributeDialog.empty();
		
		this.editorContainerId = $n2.getUniqueId();
		var $editorContainer = $('<div id="'+this.editorContainerId+'" class="n2CouchEditor_container"></div>');
		attributeDialog.append($editorContainer);

		if( showFormView ) {
			if( showAccordion ) {
				var $schemaHeader = $('<h3>').appendTo($editorContainer);
				$('<a>')
					.attr('href','#')
					.text( _loc('Form View') )
					.appendTo($schemaHeader);
			};

			var $schemaContainer = $('<div>')
				.addClass('n2CouchEditor_schema')
				.appendTo($editorContainer);
			
			this.schemaEditor = schemaEditorService.editDocument({
				doc: data
				,schema: selectedSchema
				,$div: $schemaContainer
				,onChanged: function(){
					_this._adjustInternalValues(_this.editedDocument);
					if( _this.treeEditor ) {
						_this.treeEditor.refresh();
					};
					if( _this.slideEditor ) {
						_this.slideEditor.refresh();
					};
					if( _this.attachmentEditor ) {
						_this.attachmentEditor.refresh();
					};
					_this._refreshRelations(data);
					_this.onEditorObjectChanged(data);
				}
			});
		};

		if( showTreeView ) {
			if( showAccordion ) {
				var $treeHeader = $('<h3>').appendTo($editorContainer);
				$('<a>')
					.attr('href','#')
					.text( _loc('Tree View') )
					.appendTo($treeHeader);
			};
			
			var $treeContainer = $('<div>')
				.addClass('n2CouchEditor_tree')
				.appendTo($editorContainer);
			var editorOptions = {
				onObjectChanged: function() {
					_this._adjustInternalValues(_this.editedDocument);
					if( _this.slideEditor ) {
						_this.slideEditor.refresh();
					};
					if( _this.schemaEditor ) {
						_this.schemaEditor.refresh();
					};
					if( _this.attachmentEditor ) {
						_this.attachmentEditor.refresh();
					};
					_this._refreshRelations(data);
					_this.onEditorObjectChanged(data);
				}
				,isKeyEditingAllowed: isKeyEditingAllowed
				,isValueEditingAllowed: isValueEditingAllowed
				,isKeyDeletionAllowed: isKeyDeletionAllowed
			};
			var objectTree = new $n2.tree.ObjectTree($treeContainer, data, editorOptions);
			this.treeEditor = new $n2.tree.ObjectTreeEditor(objectTree, data, editorOptions);
		};
		
		if( showSlideView ) {
			if( showAccordion ) {
				var $slideHeader = $('<h3>').appendTo($editorContainer);
				$('<a>')
					.attr('href','#')
					.text( _loc('Editor View') )
					.appendTo($slideHeader);
			};
			
			var $slideContainer = $('<div>')
				.addClass('n2CouchEditor_slide')
				.appendTo($editorContainer);
			var slideEditorOptions = {
				onObjectChanged: function() {
					_this._adjustInternalValues(_this.editedDocument);
					if( _this.treeEditor ) {
						_this.treeEditor.refresh();
					};
					if( _this.schemaEditor ) {
						_this.schemaEditor.refresh();
					};
					if( _this.attachmentEditor ) {
						_this.attachmentEditor.refresh();
					};
					_this._refreshRelations(data);
					_this.onEditorObjectChanged(data);
				}
				,isKeyEditingAllowed: isKeyEditingAllowed
				,isValueEditingAllowed: isValueEditingAllowed
				,isKeyDeletionAllowed: isKeyDeletionAllowed
			};
			this.slideEditor = new $n2.slideEditor.Editor($slideContainer, data, slideEditorOptions);
		};
		
		if( showAccordion ) {
			$editorContainer.accordion({ collapsible: true });
		};
		
		// Report relations
		$('<div>')
			.addClass('editorDisplayRelations')
			.appendTo($editorContainer);
		this._refreshRelations(data);
		
		// Attachment editor
		{
			var disableAttachmentEditorButtons = ! this.enableAddFile;
			var $attachmentsDiv = $('<div>')
				.addClass('editorAttachments')
				.appendTo($editorContainer);
			this.attachmentEditor = new AttachmentEditor({
				doc: data
				,elem: $attachmentsDiv
				,documentSource: this.documentSource
				,uploadService: this.uploadService
				,disableAddFile: disableAttachmentEditorButtons
				,disableRemoveFile: disableAttachmentEditorButtons
				,moduleEditInfo: this.moduleEditInfo
				,onChangedFn: function(){
					_this._adjustInternalValues(_this.editedDocument);
					if( _this.schemaEditor ) {
						_this.schemaEditor.refresh();
					};
					if( _this.treeEditor ) {
						_this.treeEditor.refresh();
					};
					if( _this.slideEditor ) {
						_this.slideEditor.refresh();
					};
					_this._refreshRelations(data);
					_this.onEditorObjectChanged(data);
				}
			});
		};

		if (window.cordova) {
			var $currentLocationToggle = $('<label>')
				.addClass('cordova-btn cordova-icon cordova-location-toggle width-200')
				.appendTo($editorContainer)
				.text(_loc('Current Location'))
				.click(function(event) {
					event.preventDefault();
					_this.attachmentEditor.cordovaLocation = !_this.attachmentEditor.cordovaLocation;
					if (!!_this.attachmentEditor.cordovaLocation) {
						$(this).removeClass('icon-unchecked');
						$(this).addClass('icon-checked');
					} else {
						$(this).removeClass('icon-checked');
						$(this).addClass('icon-unchecked');
					}
				});
			if (!!_this.attachmentEditor.cordovaLocation) {
				$currentLocationToggle.removeClass('icon-unchecked');
				$currentLocationToggle.addClass('icon-checked');
			} else {
				$currentLocationToggle.removeClass('icon-checked');
				$currentLocationToggle.addClass('icon-unchecked');
			}
		}

		var formButtons = $('<div class="editorButtons"></div>');
		$editorContainer.append(formButtons);

		var saveBtn = $('<button class="save">'+_loc('Save')+'</button>');
		formButtons.append(saveBtn);
		saveBtn.button({icons:{primary:'ui-icon-check'}});
		saveBtn.click(function(){
			_this._save();
			return false;
		});

		if( !this.isInsert
		 && $n2.couchMap.canDeleteDoc(data)
			) {
			var deleteBtn = $('<button class="delete">'+_loc('Delete')+'</button>');
			formButtons.append(deleteBtn);
			deleteBtn.button({icons:{primary:'ui-icon-trash'}});
			deleteBtn.click(function(evt){
				if( confirm( _loc('Do you really want to delete this feature?') ) ) {
					deletion(data);
				};
				return false;
			});
		};
		
		if( this.attachmentEditor ){
			this.attachmentEditor.printButtons({
				elem: formButtons
			});
		};

		var addRelationBtn = $('<button class="relation">'+_loc('Add Relation')+'</button>');
		formButtons.append(addRelationBtn);
		addRelationBtn.button({icons:{primary:'ui-icon-plusthick'}});
		addRelationBtn.click(function(){ _this._addRelationDialog(); return false; });

		var layersBtn = $('<button class="layers">'+_loc('Layers')+'</button>');
		formButtons.append(layersBtn);
		layersBtn.button({icons:{primary:'ui-icon-link'}});
		layersBtn.click(function(){ _this._manageLayersDialog(); return false; });

		var cancelBtn = $('<button class="cancel">'+_loc('Cancel')+'</button>');
		formButtons.append(cancelBtn);
		cancelBtn.button({icons:{primary:'ui-icon-cancel'}});
		cancelBtn.click(function(){ 
			_this._cancelEdit();
			return false;
		});
		
		// Add user buttons
		for(var i=0,e=this.userButtons.length; i<e; ++i) {
			var userButton = this.userButtons[i];
			
			var $uBtn = $('<button>'+_loc(''+userButton.label)+'</button>');
			if( userButton.buttonClass ) {
				$uBtn.addClass(userButton.buttonClass);
			};
			if( userButton.before ) {
				var $anchor = formButtons.find('button.'+userButton.before);
				$anchor.before($uBtn);
			} else if( userButton.after ) {
				var $anchor = formButtons.find('button.'+userButton.after);
				$anchor.after($uBtn);
			} else {
				formButtons.append($uBtn);
			};
			$uBtn.button(userButton.options);
			installUserButtonClick($uBtn, userButton);
		};
		
		// First time to call refresh
		var $editorContainer = _this._getEditorContainer();
		_this.onRefreshFunctions.forEach(function(refreshFunction){
			refreshFunction(_this.editedDocument, $editorContainer, _this);
		});

		function deletion(editedDocument) {
			_this.documentSource.deleteDocument({
				doc: _this.editedDocument
				,onSuccess: function() {
					_this._discardEditor({deleted:true});
				}
				,onError: function(err){
					_this._enableControls();
					$n2.reportErrorForced('Unable to delete document: '+err);
				}
			});
		};

		function installUserButtonClick($uBtn, userButton){
			$uBtn.click(function(){
				if( userButton.click ){
					return userButton.click(_this.editedDocument, _this, userButton);
				};
				return false;
			});
		};
	},

	_save: function(){
		var _this = this;
		
		if (window.cordova) {
			// alert if media documents are missing the attachment
			if (!_this.attachmentEditor.cordovaAttachment &&
					(_this.attachmentEditor.doc.nunaliit_schema === 'demo_media' || _this.attachmentEditor.doc.nunaliit_schema === 'media' )) {
				alert(_loc('A file must be selected or recorded'));
				return;
			} else {
				// add the attachments
				_this.editedDocument.nunaliit_attachments = null;
				_this.editedDocument.nunaliit_mobile_attachments = _this.attachmentEditor.cordovaAttachment;
				
				// add the location flag
				_this.editedDocument.nunaliit_mobile_needs_new_location = _this.attachmentEditor.cordovaLocation;
				
				updateDocument();
			}
		} else {
			// Disable use of editor during uploading
			this._disableControls();
			
			// Verify that upload server is available
			if( this.uploadService ){
				// Verify that server is available
					this.uploadService.getWelcome({
					onSuccess: function(){ 
						preSaveAttachmentEditor(); 
					}
					,onError: function(err) {
							_this._enableControls();
						$n2.reportErrorForced('Server is not available: '+err);
					}
				});
			} else {
				preSaveAttachmentEditor();
			};
		}
		
		function preSaveAttachmentEditor() {
			if( _this.attachmentEditor ){
				_this.attachmentEditor.performPreSavingActions({
					onSuccess: function(doc){
						removeCompulsoryAttachmentFlag();
					}
					,onError: function(err){
			    		_this._enableControls();
						$n2.reportErrorForced(err);
					}
				});
			} else {
				removeCompulsoryAttachmentFlag();
			};
		};
		
		function removeCompulsoryAttachmentFlag(){
			if( _this.editedDocument 
			 && _this.editedDocument.nunaliit_attachments ){
				
				if( typeof _this.editedDocument.nunaliit_attachments._compulsory !== 'undefined' ){
					delete _this.editedDocument.nunaliit_attachments._compulsory;
				};
				
				if( _this.editedDocument.nunaliit_attachments.files ){
					for(var attName in _this.editedDocument.nunaliit_attachments.files){
						var att = _this.editedDocument.nunaliit_attachments.files[attName];
						if( typeof att._compulsory !== 'undefined' ){
							delete att._compulsory;
						};
					};
				};
			};
			
			updateDocument();
		};
			
		function updateDocument() {
			var isSubmissionDs = false;
			if( _this.documentSource.isSubmissionDataSource ){
				isSubmissionDs = true;
			};

			// Create or update document
			if( _this.isInsert ) {
				// This is an insert
				_this.documentSource.createDocument({
					doc: _this.editedDocument
					,onSuccess: function(updatedDoc) {
						postSaveAttachmentEditor(updatedDoc, true, isSubmissionDs);
					}
					,onError: function(err){
						_this._enableControls();
						$n2.reportErrorForced( _loc('Unable to submit document: {err}',{err:err}) );
					}
				});
			} else {
				// This is an update
				_this.documentSource.updateDocument({
					doc: _this.editedDocument
					,originalDoc: _this.originalDocument
					,onSuccess: function(updatedDoc) {
						postSaveAttachmentEditor(updatedDoc, false, isSubmissionDs);
					}
					,onError: function(err){
						_this._enableControls();
						$n2.reportErrorForced( _loc('Unable to submit document: {err}',{err:err}) );
					}
				});
			};
		};

		function postSaveAttachmentEditor(editedDocument, inserted, isSubmissionDs) {
			if (window.cordova) {
				completeSave(editedDocument, inserted, isSubmissionDs);
			} else {
				if( _this.attachmentEditor ){
					_this.attachmentEditor.performPostSavingActions({
						onSuccess: function(doc){
							completeSave(editedDocument, inserted, isSubmissionDs);
						}
						,onError: function(err){
							_this._enableControls();
							$n2.reportErrorForced(err);
						}
					});
				} else {
					completeSave(editedDocument, inserted, isSubmissionDs);
				};
			}
		};

		function completeSave(editedDocument, inserted, isSubmissionDs) {
			// Report that save is complete
			var discardOpts = {
				saved: true
				,submissionDs: isSubmissionDs
			};
			if( inserted ) {
				discardOpts.inserted = true;
			} else {
				discardOpts.updated = true;
			};
			_this._discardEditor(discardOpts);
		};
	},
	
	_addRelationDialog: function() {
		var _this = this;

		if( this.dialogService ){
			this.dialogService.searchForDocumentId({
				onSelected: function(docId){
					_this._addRelation(docId);
				}
			});
		};
	},

	_addRelation: function(relDocId){
		var data = this.editedDocument;

		if( data 
		 && data.nunaliit_source 
		 && data.nunaliit_source.doc === relDocId ){
			return;
		};

		if( data 
		 && data.nunaliit_relations 
		 && data.nunaliit_relations.length ){
			for(var i=0,e=data.nunaliit_relations.length; i<e; ++i){
				var rel = data.nunaliit_relations[i];
				if( rel.doc === relDocId ){
					return;
				};
			};
		};
		
		if( data ){
			if( !data.nunaliit_relations ){
				data.nunaliit_relations = [];
			};
			
			data.nunaliit_relations.push({
				nunaliit_type: 'reference'
				,doc: relDocId
			});
			
			this.refresh();
		};
	},

	_removeRelation: function(relDocId){
		var data = this.editedDocument;
		var refreshRequired = false;
		
		if( data 
		 && data.nunaliit_source 
		 && data.nunaliit_source.doc === relDocId ){
			delete data.nunaliit_source;
			refreshRequired = true;
		};

		if( data 
		 && data.nunaliit_relations 
		 && data.nunaliit_relations.length ){
			var relRemoved = false;
			var newRels = [];
			for(var i=0,e=data.nunaliit_relations.length; i<e; ++i){
				var rel = data.nunaliit_relations[i];
				if( rel.doc === relDocId ){
					relRemoved = true;
				} else {
					newRels.push(rel);
				};
			};
			
			if( newRels.length < 1 ){
				delete data.nunaliit_relations;
				refreshRequired = true;
			} else if( relRemoved ){
				data.nunaliit_relations = newRels;
				refreshRequired = true;
			};
		};
		
		if( refreshRequired ){
			this.refresh();
		};
	},

	_manageLayersDialog: function(){
		var _this = this;
		var data = this.editedDocument;
		var layers = data.nunaliit_layers;
		if( !layers ){
			layers = [];
		};
		if( this.dialogService ){
			this.dialogService.selectLayersDialog({
				currentLayers: layers
				,onSelected: function(selectedLayers){
					if( selectedLayers.length < 1 ){
						if( data.nunaliit_layers ){
							delete data.nunaliit_layers;
						};
					} else {
						data.nunaliit_layers = selectedLayers;
					};
					_this.refresh();
				}
			});
		};
	},

	_removeAttachment: function(attNameToRemove){
		var data = this.editedDocument;
		
		// Accumulate all the keys that must be removed
		var keys = {};
		if( data 
		 && data.nunaliit_attachments 
		 && data.nunaliit_attachments.files ){
			for(var attName in data.nunaliit_attachments.files){
				var att = data.nunaliit_attachments.files[attName];
				if( attName === attNameToRemove ){
					keys[attName] = true;
				} else if( att.source === attNameToRemove ){
					// Remove associated thumbnail and original
					keys[attName] = true;
				};
			};
		};
		
		// Delete necessary keys
		var refreshRequired = false;
		var attName = null;
		for(attName in keys){
			if( data._attachments && data._attachments[attName] ){
				delete data._attachments[attName];
				refreshRequired = true;
			};
			if( data.nunaliit_attachments.files[attName] ){
				delete data.nunaliit_attachments.files[attName];
				refreshRequired = true;
			};
		};
		
		// Remove _attachments if empty
		if( data._attachments ){
			var empty = true;
			for(attName in data._attachments){
				empty = false;
			};
			if( empty ){
				delete data._attachments;
				refreshRequired = true;
			};
		};
		
		// Remove nunaliit_attachments if empty
		if( data.nunaliit_attachments ){
			var empty = true;
			if( data.nunaliit_attachments.files ) {
				for(attName in data.nunaliit_attachments.files){
					empty = false;
				};
			};
			if( empty ){
				delete data.nunaliit_attachments;
				refreshRequired = true;
			};
		};
		
		if( refreshRequired ){
			this.refresh();
		};
	},

	_cancelEdit: function(){
		this._dispatch({
			type: 'editCancel'
			,doc: this.editedDocument
		});
	},

	// Restores feature geometry before discarding the form
	performCancellation: function(opts_) {
		var opts = $n2.extend({
			suppressEvents:false
		},opts_);
		if( null == this.editedDocument ) {
			return;
		};
	
		this.onCancelFn(this.editedDocument);

		this._discardEditor({
			cancelled:true
			,suppressEvents: opts.suppressEvents
		});
	},
	
	performSave: function(opts_) {
		var opts = $n2.extend({
		},opts_);

		if( null == this.editedDocument ) {
			return;
		};
	
		this._save();
	},

	_discardEditor: function(opts_) {
		var opts = $n2.extend({
			saved: false
			,inserted: false
			,updated: false
			,submissionDs: false
			,deleted: false
			,cancelled: false
			,suppressEvents: false
		},opts_);
		
		if( null == this.editedDocument ) {
			return;
		};
		
		var originalDocument = this.originalDocument;
		var editedDocument = this.editedDocument;
		this.editedDocument = null;
		
		var $editorContainer = this._getEditorContainer();
		$editorContainer.remove();

		this.onCloseFn(editedDocument, this, {
			saved: opts.saved
			,inserted: opts.inserted
			,updated: opts.updated
			,deleted: opts.deleted
			,cancelled: opts.cancelled
		});
		
		if( !opts.suppressEvents ) {
			var doc = undefined;
			var docId = undefined;
			if( opts.cancelled ) {
				// If cancelled, send original document
				if( originalDocument && originalDocument._id ){
					// Send a document only if it already existed
					doc = originalDocument;
					docId = doc._id;
				};
			} else if( opts.saved && editedDocument && editedDocument._id ) {
				// If saved, send edited document
				doc = editedDocument;
				docId = doc._id;
			};
			
			this._dispatch({
				type: 'editClosed'
				,docId: docId
				,doc: doc
				,saved: opts.saved
				,inserted: opts.inserted
				,updated: opts.updated
				,deleted: opts.deleted
				,cancelled: opts.cancelled
				,submissionDs: opts.submissionDs
			});
		};
		
		this.editorContainerId = null;
		
		$('body').removeClass('nunaliit_editing');
		$('.n2_disable_on_edit')
			.removeAttr('disabled');
	},
	
	refresh: function() {
		this._adjustInternalValues(this.editedDocument);
		if( this.treeEditor ) {
			this.treeEditor.refresh();
		};
		if( this.slideEditor ) {
			this.slideEditor.refresh();
		};
		if( this.schemaEditor ) {
			this.schemaEditor.refresh();
		};
		this._refreshRelations(this.editedDocument);
		this.onEditorObjectChanged(this.editedDocument);
	},
	
	_adjustInternalValues: function(obj) {
		// BBOX
		if( typeof(OpenLayers) !== 'undefined' ) {
			var geomData = obj.nunaliit_geom;
			if( geomData ) {
				// Check if editor has changed the geometry's WKT
				if( this.currentGeometryWkt != geomData.wkt ) {
					$n2.couchGeom.updatedGeometry(geomData);
				};
			};
		};
	},
	
	_refreshRelations: function(data){
		var _this = this;
		var $editorContainer = this._getEditorContainer();
		var $displayRelationsDiv = $editorContainer.find('.editorDisplayRelations');
		if( $displayRelationsDiv.length < 1 ) return;

		var showService = this.showService;

		// Compute relations
		var docIdMap = {};
		if( data 
		 && data.nunaliit_relations
		 && data.nunaliit_relations.length ){
			for(var i=0,e=data.nunaliit_relations.length; i<e; ++i){
				var ref = data.nunaliit_relations[i];
				if( ref.doc ) {
					docIdMap[ref.doc] = true;
				};
			};
		};
		if( data 
		 && data.nunaliit_source
		 && data.nunaliit_source.doc ){
			docIdMap[data.nunaliit_source.doc] = true;
		};
		
		// Remove displayed relations that are no longer valid
		$displayRelationsDiv.find('.editorDisplayRelation').each(function(){
			var $display = $(this);
			var relDocId = $display.attr('nunaliitRelationDocId');
			if( !docIdMap[relDocId] ){
				$display.remove();
			} else {
				// This relDocId is already displayed. Remove from map.
				delete docIdMap[relDocId];
			};
		});
		
		// Function to delete a relation
		var removeRelationFn = function(e){
			var $btn = $(this);
			var $removeRelationDiv = $btn.parents('.editorDisplayRelation');
			if( $removeRelationDiv.length > 0 ){
				var relDocId = $removeRelationDiv.attr('nunaliitRelationDocId');
				_this._removeRelation(relDocId);
				$removeRelationDiv.remove();
			};
			
			return false;
		};
		
		// Add missing relations. At this point, docIdMap contains
		// only missing relations
		for(var relDocId in docIdMap){
			var $displayRelationDiv = $('<div class="editorDisplayRelation"></div>');
			$displayRelationsDiv.append($displayRelationDiv);
			$displayRelationDiv.attr('nunaliitRelationDocId',relDocId);

			$('<span></span>')
				.text( _loc('Relation: '))
				.appendTo($displayRelationDiv);
			
			var $brief = $('<span></span>')
				.text(relDocId)
				.appendTo($displayRelationDiv);
			if( showService ){
				showService.printBriefDescription($brief, relDocId);
			};
			
			$('<button class="editorDisplayRelationButton"></button>')
				.text( _loc('Remove') )
				.appendTo($displayRelationDiv)
				.button({icons:{primary:'ui-icon-trash'}})
				.click(removeRelationFn)
				;
		};
	},
	
	onEditorObjectChanged: function(obj) {
		var _this = this;
		
		var wkt = undefined;
		if( obj 
		 && obj.nunaliit_geom ){
			wkt = obj.nunaliit_geom.wkt;
		};
			
		// Check if editor has changed the geometry's WKT
		if( typeof OpenLayers  !== 'undefined' 
		 && this.currentGeometryWkt !== wkt ) {
		
			this.currentGeometryWkt = wkt;

			var olGeom = null;
			if( wkt ){
				olGeom = $n2.couchGeom.getOpenLayersGeometry({wkt:wkt});
			};
			
			this._dispatch({
				type: 'editGeometryModified'
				,docId: obj._id
				,geom: olGeom
				,proj: this.couchProj
				,_origin: this
			});
		};
		
		var $editorContainer = this._getEditorContainer();
		this.onRefreshFunctions.forEach(function(refreshFunction){
			refreshFunction(_this.editedDocument, $editorContainer, _this);
		});
	},
	
	_geometryModified: function(docId, geom, proj) {

		if( proj.getCode() != this.couchProj.getCode() ) {
			// Need to convert
			geom = geom.clone();
			geom.transform(proj,this.couchProj);
		};

		var geomData = this.editedDocument.nunaliit_geom;
		geomData.wkt = geom.toString();
		$n2.couchGeom.updatedGeometry(geomData);
		this.currentGeometryWkt = geomData.wkt;
		if( this.schemaEditor ) {
			this.schemaEditor.refresh();
		};
		if( this.treeEditor ) {
			this.treeEditor.refresh();
		};
		if( this.slideEditor ) {
			this.slideEditor.refresh();
		};
	},
	
	_addGeometry: function(geom, proj) {
		if( proj.getCode() != this.couchProj.getCode() ) {
			// Need to convert
			geom = geom.clone();
			geom.transform(proj,this.couchProj);
		};
    	
		var geomData = this.editedDocument.nunaliit_geom;
		if( !geomData ){
			geomData = {
				nunaliit_type: 'geometry'
			};
			this.editedDocument.nunaliit_geom = geomData;
		};
		geomData.wkt = geom.toString();
		$n2.couchGeom.updatedGeometry(geomData);
		this.currentGeometryWkt = geomData.wkt;
		if( this.schemaEditor ) {
			this.schemaEditor.refresh();
		};
		if( this.treeEditor ) {
			this.treeEditor.refresh();
		};
		if( this.slideEditor ) {
			this.slideEditor.refresh();
		};
    },
	
	_getEditorContainer: function() {
		var $editorContainer = $('#'+this.editorContainerId);
		return $editorContainer;
	},
	
	_disableControls: function() {
		var $editorContainer = this._getEditorContainer();
		$editorContainer.find('button').attr('disabled','disabled');
		$editorContainer.find('input:text').attr('disabled','disabled');
		
		// Do not disable text fields from upload forms, since it does not send
		// the information
		$editorContainer.find('.editorAttachFile').find('input:text').removeAttr('disabled');
	},
	
	_enableControls: function() {
		var $editorContainer = this._getEditorContainer();
		$editorContainer.find('button').removeAttr('disabled');
		$editorContainer.find('input:text').removeAttr('disabled');
	},
	
	_dispatch: function(m){
		var dispatcher = this.dispatchService;
		if( dispatcher ){
			dispatcher.send(DH,m);
		};
	},
	
	_synchronousCall: function(m){
		var dispatcher = this.dispatchService;
		if( dispatcher ){
			dispatcher.synchronousCall(DH,m);
		};
	},
	
	_handle: function(m){
		if( m.type === 'editGeometryModified' ){
			if( m._origin !== this ){
				this._geometryModified(m.docId, m.geom, m.proj);
			};
			
		} else if( m.type === 'mapGeometryAdded' ){
			this._addGeometry(m.geometry, m.projection);

		} else if( 'historyIsHashChangePermitted' === m.type ) {
			if( null != this.editedDocument ) {
				if( confirm( _loc('Do you wish to leave document editor?') ) ) {
					// OK, cancel editor
					this._cancelEdit();
					
				} else {
					// Do not allow change in hash
					m.permitted = false;
				};
			};
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++

var CouchEditService = $n2.Class({

	options: null,
	
	documentSource: null,
	
	panelName: null,
	
	couchProj: null,
	
	schema: null,
	
	defaultEditSchema: null,
	
	schemaRepository: null,
	
	uploadService: null,
	
	showService: null,
	
	authService: null,
	
	dispatchService: null,
	
	searchService: null,
	
	schemaEditorService: null,
	
	customService: null,
	
	dialogService: null,
	
	initialLayers: null,
	
	userButtons: null,
	
	relatedDocProcess: null,

	isFormEditor: null,

	currentEditor: null,

	moduleEditInfo: null,

	initialize: function(opts_) {
		var opts = $n2.extend({
			documentSource: null // must be provided
			,panelName: null // location where editor is opened
			,couchProj: null
			,schema: null
			,defaultEditSchema: null
			,schemaRepository: null
			,uploadService: null
			,showService: null
			,authService: null
			,dispatchService: null
			,searchService: null
			,schemaEditorService: null
			,customService: null
			,dialogService: null
			,createDocProcess: null
			,initialLayers: []
		},opts_);
		
		var _this = this;
		
		this.options = {};
		this.documentSource = opts.documentSource;
		this.panelName = opts.panelName;
		this.couchProj = opts.couchProj;
		this.options.schema = opts.schema;
		this.defaultEditSchema = opts.defaultEditSchema;
		this.initialLayers = opts.initialLayers;
		this.schemaRepository = opts.schemaRepository;
		this.uploadService = opts.uploadService;
		this.showService = opts.showService;
		this.authService = opts.authService;
		this.dispatchService = opts.dispatchService;
		this.searchService = opts.searchService;
		this.schemaEditorService = opts.schemaEditorService;
		this.customService = opts.customService;
		this.dialogService = opts.dialogService;
		this.isFormEditor = true;
		this.relatedDocProcess = opts.createDocProcess;
		
		if( !this.couchProj ) {
			this.couchProj = getDefaultCouchProjection();
		};
		
		var dispatcher = this.dispatchService;
		if( dispatcher ){
			var f = function(m){ _this._handle(m); };
			dispatcher.register(DH, 'editInitiate', f);
			dispatcher.register(DH, 'editCreateFromGeometry', f);
			dispatcher.register(DH, 'editCancel', f);
			dispatcher.register(DH, 'editTriggerSave', f);
			dispatcher.register(DH, 'editGetState', f);
			dispatcher.register(DH, 'selected', f);

			// The following events will be routed to the current editor
			dispatcher.register(DH, 'editGeometryModified', f);
			dispatcher.register(DH, 'mapGeometryAdded', f);
			dispatcher.register(DH, 'historyIsHashChangePermitted', f);
		};
		
		// Service defined buttons
		this.userButtons = {};
		var label = 'button';
		for(var key in opts) {
			if( key.substr(0,label.length) === label ) {
				this.userButtons[key] = opts[key];
			};
		};
	},

	showDocumentForm: function(document_, editorOptions_) {
		if( null != this.currentEditor ) {
			this.currentEditor.performCancellation();
			this.currentEditor = null;
		};
		
		this.currentEditor = this._createEditor(editorOptions_);
		this.currentEditor.startDocumentEditing(
			document_
			);
	},

	configureOptions: function(editInfo){
		this.moduleEditInfo = editInfo;
	},

	_createEditor: function(o_){
		
		o_ = o_ ? o_ : {};
		
		var opts = {
			panelName: o_.panelName ? o_.panelName : this.panelName
			,initialLayers: o_.initialLayers ? o_.initialLayers : this.initialLayers
			,schema: o_.schema ? o_.schema : this.options.schema
			,onCancelFn: o_.onCancelFn
			,onCloseFn: o_.onCloseFn
			,moduleEditInfo: this.moduleEditInfo
			,uploadService: this.uploadService
			,searchService: this.searchService
			,showService: this.showService
			,schemaEditorService: this.schemaEditorService
			,schemaRepository: this.schemaRepository
			,customService: this.customService
			,dispatchService: this.dispatchService
			,dialogService: this.dialogService
			,defaultEditSchema: this.defaultEditSchema
			,documentSource: this.documentSource
			,couchProj: this.couchProj
			,relatedDocProcess: this.relatedDocProcess
			
			// buttonX....
		};
		
		// Add service buttons
		for(var key in this.userButtons){
			opts[key] = this.userButtons[key];
		};

		// Add caller buttons
		var label = 'button';
		for(var key in o_) {
			if( key.substr(0,label.length) === label ) {
				opts[key] = o_[key];
			};
		};
		
		var editor = new CouchDocumentEditor(opts);
		
		return editor;
	},

	cancelDocumentForm: function(opts) {
		if( null != this.currentEditor ) {
			this.currentEditor.performCancellation(opts);
			this.currentEditor = null;
		};
	},
	
	saveDocumentForm: function(opts){
		if( null != this.currentEditor ) {
			this.currentEditor.performSave(opts);
			this.currentEditor = null;
		};
	},

	setPanelName: function(panelName) {
		this.panelName = panelName;
	},
	
	setSchemas: function(schemas){
		this.options.schema = schemas;
	},

	getInitialLayerIds: function() {
		return this.initialLayers;
	},

	setInitialLayerIds: function(layerIds) {
		this.initialLayers = layerIds;
	},
	
	_initiateEditor: function(doc){
		var _this = this;
		
		// Check that we are logged in
		var authService = this.authService;
		if( authService && false == authService.isLoggedIn() ) {
			authService.showLoginForm({
				onSuccess: function(result,options) {
					_this._initiateEditor(doc);
				}
			});
			return;
		};
		
		this.showDocumentForm(doc);
	},
	
	_createFromGeometry: function(olGeom, olProj){
		var _this = this;
		
		// Check that we are logged in
		var authService = this.authService;
		if( authService && false == authService.isLoggedIn() ) {
			authService.showLoginForm({
				onSuccess: function(result,options) {
					_this._createFromGeometry(olGeom, olProj);
				}
			});
			return;
		};
		
		if( null != this.currentEditor ) {
			this.currentEditor.performCancellation();
			this.currentEditor = null;
		};
		
		this.currentEditor = this._createEditor();
		this.currentEditor.startEditingFromGeometry(olGeom, olProj);
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'editInitiate' === m.type ){
			this._initiateEditor(m.doc);
			
		} else if( 'editCreateFromGeometry' === m.type ) {
			this._createFromGeometry(m.geometry, m.projection);
			
		} else if( 'editCancel' === m.type ) {
			this.cancelDocumentForm();

		} else if( 'editTriggerSave' === m.type ) {
			this.saveDocumentForm();

		} else if( 'editGetState' === m.type ) {
			// Synchronous event
			if( this.currentEditor 
			 && this.currentEditor.isEditing() ){
				m.isEditing = true;
			};

		} else if( 'selected' === m.type ) {
			if( null != this.currentEditor ){
				this.cancelDocumentForm();

				// Re-send the selection event
				this.dispatchService.send(DH,m);
			};
			
		} else if( this.currentEditor
		 && this.currentEditor.isEditing() ) {
			this.currentEditor._handle(m);
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
// Create an editor based on a schema. This
// performs only the portion that deals with the
// schema.

var SchemaEditor = $n2.Class({

	doc: null,
	
	schema: null,
	
	$div: null,
	
	onChanged: null,
	
	formEditor: null,
	
	postProcessFns: null,

	showService: null,

	initialize: function(opts_) {
		var opts = $n2.extend({
			doc: null
			,schema: null
			,$div: null
			,onChanged: function(){}
			,funcMap: null
			,postProcessFns: null
			,showService: null
		},opts_);
		
		var _this = this;
		
		this.doc = opts.doc;
		
		this.schema = opts.schema;
		this.$div = opts.$div;
		this.onChanged = opts.onChanged;
		this.postProcessFns = opts.postProcessFns;
		this.showService = opts.showService;
		
		this.formEditor = this.schema.form(
			this.doc
			,this.$div
			,{} // context
			,function(){ // callback on changes
				var showService = _this.showService;
				if( showService ){
					showService.fixElementAndChildren(_this.$div, {}, _this.doc);
				};
				
				_this.onChanged();
			}
			,opts.funcMap
		);
		
		var showService = this.showService;
		if( showService ){
			showService.fixElementAndChildren(this.$div, {}, this.doc);
		};
		
		this._performPostProcess();
	},

	refresh: function(){
		this.formEditor.refresh();
		
		var showService = this.showService;
		if( showService ){
			showService.fixElementAndChildren(this.$div, {}, this.doc);
		};
		
		this._performPostProcess();
	},

	_performPostProcess: function(){
		
		for(var i=0,e=this.postProcessFns.length; i<e; ++i){
			var fn = this.postProcessFns[i];
			if( typeof(fn) === 'function' ){
				fn(this.doc, this.$div);
			};
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
// Schema editing service. This should be used to set
// attributes that all schema editors should have in
// common.
var _defaultOnChanged = function(){};

var SchemaEditorService = $n2.Class({

	documentSource: null,
	
	showService: null,

	searchService: null,
	
	dispatchService: null,

	dialogService: null,
	
	funcMap: null,
	
	postProcessFunctions: null,

	initialize: function(opts_) {
		var opts = $n2.extend({
			postProcessFn: null
			,documentSource: null
			,showService: null
			,searchService: null
			,dispatchService: null
			,dialogService: null
		},opts_);
	
		var _this = this;
		
		this.postProcessFunctions = [];
		this.documentSource = opts.documentSource;
		this.showService = opts.showService;
		this.searchService = opts.searchService;
		this.dispatchService = opts.dispatchService;
		this.dialogService = opts.dialogService;
		
		this.funcMap = {};
		if( this.dialogService ){
			this.funcMap = this.dialogService.getFunctionMap();
		};
		
		if( opts.postProcessFn ){
			this.postProcessFunctions.push( opts.postProcessFn );
		};
	},

	editDocument: function(opts_){
		var opts = $n2.extend({
			doc: null // document
			,schema: null // schema that should be used for editing document
			,$div: null // location where editor should be
			,onChanged: _defaultOnChanged
		},opts_);
		
		var editor = new SchemaEditor({
			doc: opts.doc
			,schema: opts.schema
			,$div: opts.$div
			,onChanged: opts.onChanged
			,funcMap: this.funcMap
			,postProcessFns: this.postProcessFunctions
			,showService: this.showService
		});
		
		return editor;
	},
	
	addPostProcessFunction: function(fn){
		if( typeof(fn) === 'function' ){
			this.postProcessFunctions.push(fn);
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++

var AttachmentEditor = $n2.Class({
	
	doc: null,
	
	elemId: null,
	
	documentSource: null,
	
	uploadService: null,
	
	onChangedFn: null,
	
	creationAttachmentNames: null,
	
	compulsoryAttachmentNames: null,

	disableAddFile: null,
	
	disableRemoveFile: null,

	moduleEditInfo: null,

	recordingButton: null,

	recordingStatus: null,

	recorder: null,

	recordingStream: null,

	recordingInterval: null,

	currentRecordingType: null,

	maxAudioRecordingLengthSeconds: null,

	maxVideoRecordingLengthSeconds: null,

	recordVideoSize: null,

	mediaElementEl: null,

	cordovaAttachment: null,

	cordovaLocation: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			doc: null
			,elem: null
			,documentSource: null
			,uploadService: null
			,onChangedFn: function(){}
			,disableAddFile: false
			,disableRemoveFile: false
			,moduleEditInfo: undefined
		},opts_);
		
		this.doc = opts.doc;
		this.documentSource = opts.documentSource;
		this.uploadService = opts.uploadService;
		this.onChangedFn = opts.onChangedFn;
		this.disableAddFile = opts.disableAddFile;
		this.disableRemoveFile = opts.disableRemoveFile;
		this.moduleEditInfo = opts.moduleEditInfo;

		this.creationAttachmentNames = [];
		this.compulsoryAttachmentNames = [];

		this.maxAudioRecordingLengthSeconds = 300;
		this.maxVideoRecordingLengthSeconds = 300;
		this.recordVideoSize = {width: 640, height: 480};
		
		if( this.moduleEditInfo ){
			if( typeof this.moduleEditInfo.maxAudioRecordingLengthSeconds === 'number' ){
				if( this.moduleEditInfo.maxAudioRecordingLengthSeconds > 0 ){
					this.maxAudioRecordingLengthSeconds = this.moduleEditInfo.maxAudioRecordingLengthSeconds;
				};
			};
			if( typeof this.moduleEditInfo.maxVideoRecordingLengthSeconds === 'number' ){
				if( this.moduleEditInfo.maxVideoRecordingLengthSeconds > 0 ){
					this.maxVideoRecordingLengthSeconds = this.moduleEditInfo.maxVideoRecordingLengthSeconds;
				};
			};
			if( typeof this.moduleEditInfo.recordVideoSize === 'object' ){
				this.recordVideoSize = $n2.extend(
						this.recordVideoSize, 
						this.moduleEditInfo.recordVideoSize
					);
			};
		};
		
		var $elem = $(opts.elem);
		$elem.addClass('attachmentEditor');

		this.elemId = $n2.utils.getElementIdentifier( $elem );

		//load configuration
		if( this.doc
			&& !this.doc._rev) {
			if(typeof this.doc.nunaliit_maxAudioRecordingLengthSeconds !== 'undefined') {
				this.maxAudioRecordingLengthSeconds = this.doc.nunaliit_maxAudioRecordingLengthSeconds;
				delete this.doc.nunaliit_maxAudioRecordingLengthSeconds;
			}
			if(typeof this.doc.nunaliit_maxVideoRecordingLengthSeconds !== 'undefined') {
				this.maxVideoRecordingLengthSeconds = this.doc.nunaliit_maxVideoRecordingLengthSeconds;
				delete this.doc.nunaliit_maxVideoRecordingLengthSeconds;
			}
			if(typeof this.doc.nunaliit_recordVideoSize !== 'undefined') {
				var videoSizeParts = this.doc.nunaliit_recordVideoSize.split('x');
				this.recordVideoSize = {width: videoSizeParts[0], height: videoSizeParts[1]};
				delete this.doc.nunaliit_recordVideoSize;
			}
		}

		// cordovaLocation toggle is enabled for new documents and disabled for edits
		this.cordovaLocation = !this.doc._rev;

		// When a document is first created, if attachments are already present,
		// this is because they were created from schema.
		var compulsory = true;
		if( this.doc
		 && !this.doc._rev
		 && this.doc.nunaliit_attachments ){
			if( typeof this.doc.nunaliit_attachments._compulsory !== 'undefined' ){
				compulsory = this.doc.nunaliit_attachments._compulsory;
			};

			if( this.doc.nunaliit_attachments.files ){
				for(var attName in this.doc.nunaliit_attachments.files){
					var att = this.doc.nunaliit_attachments.files[attName];
					
					var attCompulsory = compulsory;
					if( typeof att._compulsory !== 'undefined' ){
						attCompulsory = att._compulsory;
					};
					
					this.creationAttachmentNames.push(attName);
					if( attCompulsory ){
						this.compulsoryAttachmentNames.push(attName);
					};
					
					att.attachmentName = attName;
					att.status = "waiting for upload";
					if( !att.data ){
						att.data = {};
					};
				};
			};
		};
		
		this.refresh();
	},
	
	/*
	 * This is when the view must be recomputed because we suspect a change
	 * in the document
	 */
	refresh: function(){
		
		var $elem = this._getElem();
		if( $elem.length < 1 ) return;
		
		var _this = this;
		
		// Scan document for attachments
		var attachments = {};
		if( this.doc.nunaliit_attachments 
		 && this.doc.nunaliit_attachments.files ){
			for(var attName in this.doc.nunaliit_attachments.files){
				var att = this.doc.nunaliit_attachments.files[attName];
				attachments[attName] = att;
			};
		};
		
		// Remove attachments that are derived from others
		var discountAttNames = [];
		for(var attName in attachments){
			var att = attachments[attName];
			var sourceName = att.source;
			if( sourceName 
			 && attachments[sourceName] ){
				// Do not display if this is a derived attachment and
				// original is displayed
				discountAttNames.push(attName);
			};
		};
		for(var i=0,e=discountAttNames.length; i<e; ++i){
			var attName = discountAttNames[i];
			delete attachments[attName];
		};
		
		// Sort attachments by name
		var attNames = [];
		for(var attName in attachments){
			attNames.push(attName);
		};
		attNames.sort();
		
		// Remove deleted attachments
		$elem.find('.attachmentEditor_att').each(function(){
			var $div = $(this);
			var attName = $div.attr('n2AttName');
			if( !attName ){
				$div.remove();
			} else if( !attachments[attName] ){
				$div.remove();
			};
		});
		
		// Add new attachments
		for(var i=0,e=attNames.length; i<e; ++i){
			var attName = attNames[i];
			
			var className = 'attachmentEditor_att_' + $n2.utils.stringToHtmlId(attName);
			var $div = $elem.find('.'+className);
			if( $div.length < 1 ) {
				var label = _loc('File');
				
				if( this.creationAttachmentNames.indexOf(attName) >= 0 ) {
					// This is an initial attachemnt
					this._addCreationAttachmentElement({
						attName: attName
						,label: label
					});
					
				} else if( !this.disableRemoveFile ){
					this._addFileElement({
						attName: attName
						,label: label
					});
				};
			};
		};

		if (!attNames.length && window.cordova) {
			if (this.doc.nunaliit_mobile_attachments) {
				this.cordovaAttachment = this.doc.nunaliit_mobile_attachments;
				this._addCreationAttachmentElement({
					attName: this.cordovaAttachment
					,label: _loc('File')
				});
			}
		}
	},
	
	printButtons: function(opts_){
		var opts = $n2.extend({
			elem: null
			,classNames: null
		},opts_);
		
		var _this = this;
		
		if( this.disableAddFile ){
			return;
		};
		
		var $elem = $(opts.elem);

		var attachBtn = $('<button>')
			.text(_loc('Add File'))
			.appendTo($elem)
			.click(function(){
				_this._openAddFileDialog();
				return false;
			});
		
		if( opts.classNames ){
			attachBtn.addClass(opts.classNames);
		};

		attachBtn.button({icons:{primary:'ui-icon-plusthick'}});
	},
	
	performPreSavingActions: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		var documentSource = this.documentSource;
		
		var $elem = this._getElem();

		// Verify that all compulsory files are provided
		var missingAttachment = null;
		for(var i=0,e=this.compulsoryAttachmentNames.length; i<e; ++i){
			var attName = this.compulsoryAttachmentNames[i];
			var $form = $elem.find('.attachmentEditor_att_' + $n2.utils.stringToHtmlId(attName));
			var $file = $form.find('input[type="file"]');
			var fileName = $file.val();
			if(!fileName) {
				if(hasMediaPlayerFile($form)) {
					fileName = 'recordedFile';
				}
			}

			if( !fileName ){
				missingAttachment = attName;	
			};
		};
		if( missingAttachment ){
			opts.onError( _loc('A file must be selected or recorded') );
			return;
		};

		//Stop video capturing with close of the form
		if(typeof _this.recordingStream !== 'undefined' && _this.recordingStream != null) {
			_this.recordingStream.stop();
		}
		
		// Remove forms that do not have a file assigned
		for(var i=0,e=this.creationAttachmentNames.length; i<e; ++i){
			var attName = this.creationAttachmentNames[i];
			var $form = $elem.find('.attachmentEditor_att_' + $n2.utils.stringToHtmlId(attName));
			var $file = $form.find('input[type="file"]');
			var fileName = $file.val();
			if(!fileName) {
				if(hasMediaPlayerFile($form)) {
					fileName = 'recordedFile';
				}
			}
			if( !fileName ){
				$form.remove();
				
				if( this.doc.nunaliit_attachments 
				 && this.doc.nunaliit_attachments.files
				 && this.doc.nunaliit_attachments.files[attName] ){
					delete this.doc.nunaliit_attachments.files[attName];
				};
			};
		};
		
		// Remove doc.nunaliit_attachments if empty
		if( this.doc.nunaliit_attachments ){
			var count = 0;
			if( this.doc.nunaliit_attachments.files ){
				for(var attName in this.doc.nunaliit_attachments.files){
					++count;
				};
			};
			
			if( count < 1 ){
				delete this.doc.nunaliit_attachments;
			};
		};
		
		// If nothing to load, no point in continuing
		var $forms = $elem.find('form');
		var formCount = $forms.length;
		if( formCount < 1 ){
			// Nothing to do
			opts.onSuccess();
			return;
		};
		
		// Obtain uuids for the forms
		var uuids = [];
		getUuids();
		
		function getUuids(){
			if( uuids.length >= formCount ){
				onUuids();
			} else {
				documentSource.getUniqueIdentifier({
					onSuccess: function(uuid){
						uuids.push(uuid);
						getUuids();
					}
					,onError: function(err){
						opts.onError( _loc('Unable to reach server: {err}',{err:err}) );
					}
				});
			};
		};
		
		function onUuids(){
			var doc = _this.doc;
			
			$forms.each(function(){
				var $form = $(this);
				var attName = $form.attr('n2AttName');
				var uuid = uuids.pop();
				
				var att = null;
				if( doc 
				 && doc.nunaliit_attachments 
				 && doc.nunaliit_attachments.files ){
					att = doc.nunaliit_attachments.files[attName];
				};
				
				if( att ){
					att.uploadId = uuid;
					
					if( doc._id ) {
						$('<input type="hidden">')
							.attr('name','id')
							.attr('value',doc._id)
							.prependTo($form);
					};
					
					if( doc._rev ) {
						$('<input type="hidden">')
							.attr('name','rev')
							.attr('value',doc._rev)
							.prependTo($form);
					};
					
					if( uuid ) {
						$('<input type="hidden">')
							.attr('name','uploadId')
							.attr('value',uuid)
							.prependTo($form);
					};
					
				} else {
					$form.remove();
				};
			});
			
			opts.onSuccess();
		};

		function hasMediaPlayerFile($form) {
			var audioFile = $form.find('audio');
			var videoFile = $form.find('video');
			var mediaPlayer = null;
			if(audioFile.length > 0) {
				mediaPlayer = audioFile[0];
			} else if(videoFile.length > 0) {
				mediaPlayer = videoFile[0];
			}
			if(mediaPlayer &&
				mediaPlayer.currentSrc !== null &&
				mediaPlayer.currentSrc !== '' &&
				mediaPlayer.srcObject === null) {
					return true;
			}
			return false;
		}
	},

	performPostSavingActions: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(doc){}
			,onError: function(err){}
		},opts_);

		var _this = this;

		var $elem = this._getElem();
		
		var $forms = $elem.find('form');
		var formCount = $forms.length;
		if( formCount < 1 ){
			// Nothing to do
			opts.onSuccess();
			return;
		};
		
		// From this point on, the logic is to deal with the first form
		// and when done, continue on to the next one by calling recursively
		// this function.
		var $form = $forms.first();
		var attName = $form.attr('n2AttName');
		
		var uploadId = null;
		var att = null;
		if( this.doc
		 && this.doc.nunaliit_attachments
		 && this.doc.nunaliit_attachments.files 
		 && attName 
		 && this.doc.nunaliit_attachments.files[attName] ){
			att = this.doc.nunaliit_attachments.files[attName];
			uploadId = att.uploadId;
		};
		
		var $fileInput = $form.find('input[type="file"]');
		var filename = $fileInput.val();
		var mediaFile = null;
		//generate file data for mp3 file.
		if(!filename) {
			var audio = $form.find('audio');
			if(audio.length > 0) {
				audio = audio[0];
				mediaFile = mediaTagToFile(audio, 'audio/mp3', '.mp3');
				filename = 'audio.mp3';
			}
		}
		if(!filename) {
			var video = $form.find('video');
			if(video.length > 0) {
				video = video[0];
				if(video.currentSrc !== null && video.currentSrc !== '' && video.srcObject === null) {
					mediaFile = mediaTagToFile(video, 'video/webm', '.webm');
					filename = 'video.webm';
				}
			}
		}

		if( !filename || !att || !uploadId ){
			$form.remove();
			continueUpload();
			
		} else {
			// Upload file via the upload service.
			// Perform actual upload
			this.uploadService.submitForm({
				form: $form
				,uploadFile: mediaFile
				,suppressInformationDialog: true
				,onSuccess: function(){
					$form.remove();
					continueUpload();
				}
				,onError: function(err) {
					opts.onError( _loc('Unable to upload file. Cause: {err}',{err:err}) );
				}
			});
		};

		function continueUpload(){
			_this.performPostSavingActions(opts_);
		};

		function mediaTagToFile(element, mediaType, extension) {
			var blob = dataURLtoBlob(element.src, mediaType);
			//Check that File API Constructor is supported by this browser
			if(typeof File === 'function' && File.length >= 2) {
				filename = (Math.random() * new Date().getTime()).toString(36).replace( /\./g , '') + extension;
				return new File([blob], filename, { type: mediaType });
			} else {
				return new Blob([blob], {type: mediaType});
			}
		}

		function dataURLtoBlob(dataURL, mediaType) {
			//Based on https://github.com/bubkoo/dataurl-to-blob (MIT License)
			if (!window || window.window !== window) {
				throw new Error('This module is only available in browser');
			}

			var Blob = window.Blob || window.MozBlob || window.WebKitBlob;
			if (!Blob) {
				throw new Error('Blob was not supported');
			}

			var dataURLPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/;

			// parse the dataURL components as per RFC 2397
			var matches = dataURL.match(dataURLPattern);
			if (!matches) {
				throw new Error('invalid dataURI');
			}

			// default to text/plain;charset=utf-8
			var isBase64   = !!matches[4];
			var dataString = dataURL.slice(matches[0].length);
			var byteString = isBase64
				// convert base64 to raw binary data held in a string
				? atob(dataString)
				// convert base64/URLEncoded data component to raw binary
				: decodeURIComponent(dataString);

			var array = [];
			for (var i = 0; i < byteString.length; i++) {
				array.push(byteString.charCodeAt(i));
			}

			return new Blob([new Uint8Array(array)], { type: mediaType });
		}
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},

	_openAddFileDialog: function(){
		var _this = this;
		
		var $elem = this._getElem();
		if( $elem.length < 1 ) {
			return;
		};
		
		var dialogId = $n2.getUniqueId();
		var addFileFormId = $n2.getUniqueId();
		
		var $addFileDialog = $('<div>')
			.attr('id',dialogId)
			.addClass('attachmentEditor_dialog');

		var $content = $('<div>')
			.addClass('attachmentEditor_dialog_content')
			.appendTo($addFileDialog);

		var $addFileForm = $('<form>')
			.attr('id',addFileFormId)
			.addClass('attachmentEditor_form')
			.appendTo($content);
		
		$('<input type="file">')
			.attr('name','media')
			.appendTo($addFileForm);

		var $buttons = $('<div>')
			.addClass('attachmentEditor_dialog_buttons')
			.appendTo($addFileDialog);

		var $addBtn = $('<button>')
			.text( _loc('Attach') )
			.appendTo($buttons)
			.click(function(){
				var $addFileDialog = $('#'+dialogId);
				var $addFileForm = $('#'+addFileFormId);
				var $input = $addFileForm.find('input');
				var filename = $input.val();
				if( filename ) {
					_this._addFileForm($addFileForm);
					$addFileDialog.dialog('close');
				} else {
					alert( _loc('You must select a file') );
				};
				return false;
			});
		$addBtn.button({icons:{primary:'ui-icon-plusthick'}});

		var $cancelBtn = $('<button>')
			.text( _loc('Cancel') )
			.appendTo($buttons)
			.click(function(){
				var $addFileDialog = $('#'+dialogId);
				$addFileDialog.dialog('close');
				return false;
			});
		$cancelBtn.button({icons:{primary:'ui-icon-cancel'}});
		
		$addFileDialog.dialog({
			autoOpen: true
			,title: _loc('Add File')
			,modal: true
			,width: 740
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		});
	},
	
	_addFileForm: function($addFileForm){
		
		if( !this.doc ){
			return;
		};
		if( !this.doc.nunaliit_attachments ){
			this.doc.nunaliit_attachments = {
				nunaliit_type: 'attachment_descriptions'
				,files: {}
			};
		};
		if( !this.doc.nunaliit_attachments.files ){
			this.doc.nunaliit_attachments.files = {};
		};
		
		// Compute a new attachment name
		var attName = 'media';
		if( this.doc.nunaliit_attachments.files[attName] ){
			var prefix = 'media_';
			var count = 0;
			while( this.doc.nunaliit_attachments.files[attName] ){
				++count;
				attName = prefix + count;
				
				if( count > 100 ){
					$n2.log('Unable to compute attachment name for new attachment');
					return;
				};
			};
		};

		// Update document
		this.doc.nunaliit_attachments.files[attName] = {
			attachmentName: attName
			,status: "waiting for upload"
			,data: {}
		};
		
		// Add form to the list of files
		$addFileForm.attr('n2AttName',attName);
		$addFileForm.addClass('attachmentEditor_form');
		this._addFileElement({
			attName: attName
			,label: _loc('New File')
			,form: $addFileForm
		});
		
		// Let editor know that document was changed
		this.onChangedFn();
	},
	
	_removeAttachment: function(attName){
		var docChanged = false;
		
		var derivedNames = [];
		if( this.doc 
		 && this.doc.nunaliit_attachments 
		 && this.doc.nunaliit_attachments.files ){
			
			if( this.doc.nunaliit_attachments.files[attName] ){
				delete this.doc.nunaliit_attachments.files[attName];
				docChanged = true;
			};
			
			// Delete derived attachments
			for(var otherName in this.doc.nunaliit_attachments.files){
				var att = this.doc.nunaliit_attachments.files[otherName];
				
				if( attName === att.source ){
					derivedNames.push(otherName);
				};
			};
			for(var i=0,e=derivedNames.length; i<e; ++i){
				var derivedName = derivedNames[i];
				delete this.doc.nunaliit_attachments.files[derivedName];
				docChanged = true;
			};
			
			var count = 0;
			for(otherName in this.doc.nunaliit_attachments.files){
				++count;
			};
			if( count < 1 ){
				delete this.doc.nunaliit_attachments;
			};
		};
		
		if( this.doc 
		 && this.doc._attachments ){
			if( this.doc._attachments[attName] ){
				delete this.doc._attachments[attName];
				docChanged = true;
			};

			for(var i=0,e=derivedNames.length; i<e; ++i){
				var derivedName = derivedNames[i];

				if( this.doc._attachments[derivedName] ){
					delete this.doc._attachments[derivedName];
					docChanged = true;
				};
			};
		};
		
		if( docChanged ){
			this.refresh();
			this.onChangedFn();
		};
	},
	
	_addCreationAttachmentElement: function(opts_){
		var opts = $n2.extend({
			attName: null
			,label: null
		},opts_);

		var _this = this;
		
		var $elem = this._getElem();
		var attName = opts.attName;
		var className = 'attachmentEditor_att_' + $n2.utils.stringToHtmlId(attName);
		
		var $div = $('<div>')
			.addClass('attachmentEditor_att')
			.addClass(className)
			.attr('n2AttName',attName)
			.appendTo($elem);

		var $form = $('<form>')
			.addClass('attachmentEditor_creationForm')
			.attr('n2AttName',attName)
			.appendTo($div);

		var attachmentPreviewComponents = [];
		var $recordingControls;
		var $previewButton;

		if (window.cordova) {
			// On Cordova devices show buttons to upload media
			var $buttonsContainer = $('<div>')
				.addClass('attachmentEditor_cordovaCaptureButtonsContainer')
				.appendTo($form);
			
			// Add the "Remove" button
			var $removeAttachmentContainer = $('<div>')
				.addClass('attachmentEditor_cordovaCaptureButtonsContainer')
				.appendTo($form)
				.hide();
			var $removeAttachmentButton = $('<label>')
				.addClass('cordova-btn cordova-icon icon-remove cordova-remove-button')
				.appendTo($removeAttachmentContainer)
				.text(_loc('Remove'))
				.click(function(event) {
					event.preventDefault();
					_this.cordovaAttachment = null;
					$buttonsContainer.show();
					clearAttachmentPreview();
					$removeAttachmentContainer.hide();
					if ($previewButton) {
						$previewButton.remove();
						$previewButton = null;
					}
				});

			if (_this.cordovaAttachment) {
				var lastSlashIndex = _this.cordovaAttachment.lastIndexOf('/');
				var filename = _this.cordovaAttachment.substring(lastSlashIndex + 1);
				var $filenamePreview = $('<p>')
					.text(filename)
					.appendTo($form);
				attachmentPreviewComponents.push($filenamePreview);
				$buttonsContainer.hide();
				$removeAttachmentContainer.show();
			}

			document.addEventListener("deviceready", function() {
				// Add the "Choose File" button
				var $fileInputDiv = $('<div>')
					.addClass('attachmentEditor_buttonDiv')
					.appendTo($buttonsContainer);
				$('<input type="file" id="file-input">')
					.addClass('attachmentEditor_hiddenFileInput')
					.appendTo($fileInputDiv)
					.change(function(event) {
						if (event.target && event.target.files && event.target.files[0]) {
							// Great! The user chose a file, but we don't have access to its path (damn file system security).
							// So, we the store the file in our persistent app storage location.
							var fileName = event.target.files[0].name;
							if (!fileName) {
								console.error('Impossible to get the file name.');
								alert('Our apologies, there was a problem getting the file.');
								return;
							}

							var _this = this;

							// Create a file in the file system
							window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function (fs) {
								fs.root.getFile(fileName, { create: true, exclusive: false }, function (fileEntry) {
									// Write in the given file
									fileEntry.createWriter(function (fileWriter) {
										fileWriter.onwriteend = function() {
											addCordovaAttachment(fileEntry.nativeURL);
											// On success, show the file
											clearAttachmentPreview();
											var $filePreview = $('<div>')
												.addClass('attachmentEditor_fileName')
												.text(event.target.files[0].name)
												.appendTo($form);
											showCordovaAttachmentPreview($removeAttachmentContainer); 
											attachmentPreviewComponents.push($filePreview);
											$buttonsContainer.hide();
											$removeAttachmentContainer.show();

											// Reset the input value so that we can re-select the same file
											_this.value = null;
										};

										fileWriter.onerror = function (e) {
											console.error("Failed file write: " + e.toString());
											alert(_loc('Our apologies, there was a problem getting the file.'));
										};

										fileWriter.write(event.target.files[0]);
									});
								}, function(err) {
									console.error('Error getting file', err);
									alert(_loc('Our apologies, there was a problem getting the file.'));
								});
							}, function(err) {
								console.error('Error requesting file system', err);
								alert(_loc('Our apologies, there was a problem getting the file.'));
							});
						}
					});
				
				$('<label for="file-input">')
					.addClass('cordova-btn width-150 cordova-icon icon-file')
					.text(_loc('Choose File'))
					.appendTo($fileInputDiv);
				
				// Add the "Capture Photo" button
				var $capturePhotoDiv = $('<div>')
					.addClass('attachmentEditor_buttonDiv')
					.appendTo($buttonsContainer)
				if (navigator.camera) {
					$('<label>')
						.addClass('cordova-btn width-150 cordova-icon icon-camera')
						.appendTo($capturePhotoDiv)
						.text(_loc('Capture Photo'))
						.click(function(event) {
							event.preventDefault();
							navigator.camera.getPicture(function(fileName) {
								addCordovaAttachment(fileName);
								// On success, show the file
								clearAttachmentPreview();
								var $imgPreview = $('<img>', {src: fileName})
									.addClass('attachmentEditor_photoPreview')
									.appendTo($form);
								showCordovaAttachmentPreview($removeAttachmentContainer); 
								attachmentPreviewComponents.push($imgPreview);
								$buttonsContainer.hide();
								$removeAttachmentContainer.show();
							}, function(error) {
								console.error('Error getting picture:', error);
								alert(_loc('Our apologies, there was a problem getting the photo.'));
							}, {
								correctOrientation: true
							});
						});
				}
			
				// Add the "Capture Video" button
				var $captureVideoDiv = $('<div>')
					.addClass('attachmentEditor_buttonDiv')
					.appendTo($buttonsContainer)
				if (navigator.device && navigator.device.capture) {
					$('<label>')
						.addClass('cordova-btn width-150 cordova-icon icon-video')
						.appendTo($captureVideoDiv)
						.text(_loc('Capture Video'))
						.click(function(event) {
							event.preventDefault();
							navigator.device.capture.captureVideo(
								function(mediaFiles) {
									if (mediaFiles && mediaFiles[0] && mediaFiles[0].fullPath) {
										var lastSlashIndex = mediaFiles[0].fullPath.lastIndexOf('/');
										var filename = mediaFiles[0].fullPath.substring(lastSlashIndex + 1);
										addCordovaAttachment(mediaFiles[0].fullPath);

										// On success, show the file
										clearAttachmentPreview();
										var $videoPreview = $('<p>')
											.addClass('attachmentEditor_fileName')
											.text(filename)
											.appendTo($form);
										showCordovaAttachmentPreview($removeAttachmentContainer); 
										attachmentPreviewComponents.push($videoPreview);
										$buttonsContainer.hide();
										$removeAttachmentContainer.show();
									} else {
										console.error('No video uploaded.');
										alert(_loc('Our apologies, we cannot get your video.'));
									}
								}, function(error) {
									console.error('Error getting video:', error);
									alert(_loc('Our apologies, there was a problem getting the video.'));
								}, {
									quality: 0,
									duration: 30
								});
						});
				}
							
				// Add the "Capture Audio" button
				var $captureAudioDiv = $('<div>')
					.addClass('attachmentEditor_buttonDiv')
					.appendTo($buttonsContainer)
				if (window.Media) {
					$('<label>')
						.addClass('cordova-btn width-150 cordova-icon icon-audio')
						.appendTo($captureAudioDiv)
						.text(_loc('Capture Audio'))
						.click(function(event) {
							event.preventDefault();
							var audioFilename = 'audio_' + _this.doc.nunaliit_created.time + '.aac';
							var mediaRec = new window.Media(audioFilename,
								function() {
									var fileFullPath = window.file.externalRootDirectory + audioFilename;
									addCordovaAttachment(fileFullPath);
									// On success, show the file
									clearAttachmentPreview();
									var $audioPreview = $('<p>')
										.addClass('attachmentEditor_fileName')
										.text( _loc('Recording complete: {audioFilename}', {audioFilename:audioFilename}) )
										.appendTo($form);
									showCordovaAttachmentPreview($removeAttachmentContainer); 
									attachmentPreviewComponents.push($audioPreview);
									$removeAttachmentContainer.show();
									$buttonsContainer.hide();
								}, function(err) {
									console.error("recordAudio():Audio Error: ", err);
									alert( _loc('Our apologies, there was a problem recording audio. Error code: {code}',{code:err.code}) );
								});
								
							showCordovaRecordingUI(mediaRec);
						});
				}
			}, false);
		} else {
			//clearfix div to prevent buttons from floating
			$('<div>')
				.addClass('attachmentEditor_clearfix')
				.appendTo($div);

			var firstTabDisplayed = 'file';

			var $tabList = $('<div>')
				.addClass('attachmentEditor_uploadTabs')
				.appendTo($form);

			$('<button>')
				.text(_loc('File Upload'))
				.addClass('attachmentEditor_uploadTab_file')
				.appendTo($tabList)
				.click(function(event) {
					event.preventDefault();
					_this._clickTab(attName, 'file');
				});

			var $chooseFileDiv = $('<div>')
				.addClass('attachmentEditor_uploadTabContent attachmentEditor_uploadTabContent_file')
				.appendTo($form);

			$('<input type="file">')
				.attr('name','media')
				.change(function(event) {
					_this._attachmentFileChanged(event);
				})
				.appendTo($chooseFileDiv);

			// only display recording if libraries required are present and https
			var protocolSupportsRecording = false;
			if(document.location.protocol == 'https:'
			 || window.location.hostname == 'localhost'
			 || window.location.hostname.startsWith('127.0.')) {
				protocolSupportsRecording = true;
			}

			if(typeof DetectRTC !== 'undefined'
			 && typeof RecordRTC !== 'undefined'
			 && typeof lamejs !== 'undefined'
			 && protocolSupportsRecording) {

				DetectRTC.load(function() {
					if(DetectRTC.hasMicrophone) {
						$('<button>')
							.text(_loc('Record Audio'))
							.addClass('attachmentEditor_uploadTab_audio')
							.click(function(event) {
								event.preventDefault();
								_this._clickTab(attName, 'audio');
							})
							.appendTo($tabList);

						//firstTabDisplayed = 'audio';

						var $recordDiv = $('<div>')
							.addClass('attachmentEditor_uploadTabContent attachmentEditor_uploadTabContent_audio')
							.appendTo($form);

						var recordInputDiv = $('<div>')
							.addClass('attachmentEditor_recordingContainer')
							.appendTo($recordDiv);

						_this.audioRecordingButton = $('<button>')
							.addClass('attachmentEditor_micButton')
							.appendTo(recordInputDiv)
							.click(function(event) {
								_this._clickRecording(event, 'audio');
							});

						_this.audioRecordStatus = $('<div>')
							.addClass('attachmentEditor_recordStatus')
							.appendTo(recordInputDiv);

						if( DetectRTC.hasWebcam && !DetectRTC.browser.isEdge ) {
							$form.addClass('attachmentEditor_creationFormWithVideo');
							$('<button>')
								.text(_loc('Record Video'))
								.addClass('attachmentEditor_uploadTab_video')
								.click(function(event) {
									event.preventDefault();
									_this._clickTab(attName, 'video');
								})
								.appendTo($tabList);

							//firstTabDisplayed = 'video';

							var $recordVideoDiv = $('<div>')
								.addClass('attachmentEditor_uploadTabContent attachmentEditor_uploadTabContent_video')
								.appendTo($form);

							var recordInputVideoDiv = $('<div>')
								.addClass('attachmentEditor_videoRecordingContainer')
								.appendTo($recordVideoDiv);

							_this.videoRecordingButton = $('<button>')
								.addClass('attachmentEditor_videoButton')
								.appendTo(recordInputVideoDiv)
								.click(function(event) {
									_this._clickRecording(event, 'video');
								});

							var meVideoEl = $('<div>').addClass('attachmentEditor_meVideo').appendTo(recordInputVideoDiv);

							_this.videoRecordStatus = $('<div>')
								.addClass('attachmentEditor_recordStatus')
								.appendTo(meVideoEl);
						} else {
							$n2.log('no webcam present');
						}
					} else {
						$n2.log('no microphone present');
					}

					allTabsDisplayed();
				});
			} else {
				allTabsDisplayed();
			}
		}

		function showCordovaAttachmentPreview(containerDiv) {
			window.resolveLocalFileSystemURL('file:' + _this.cordovaAttachment, 
				function(fileEntry) {
					fileEntry.file(function(file) {
						if (file && file.type) {
							// Image are already displayed, no need to show a preview button
							if (!file.type.startsWith('image')) {
								$previewButton = $('<label>')
									.addClass('cordova-btn cordova-icon icon-preview cordova-preview-button')
									.appendTo(containerDiv)
									.text(_loc('Preview'))
									.click(function(event) {
										event.preventDefault();
										// Try to open it using a plugin
										window.cordova.plugins.fileOpener2.open(
											_this.cordovaAttachment,
											file.type, {
												error : function(error) { console.error('Error opening file', file); }, 
												success : function() { console.log('Opening file', file); } 
											});
									});
							}
						} 
					});
				}, function(error) {
					console.error('Problem fetching cordova attachment preview for ' + _this.cordovaAttachment, error);
				});
		}

		function showCordovaRecordingUI(mediaRec) {
			$removeAttachmentContainer.show();
			$buttonsContainer.hide();

			$recordingControls = $('<div>')
				.addClass('attachmentEditor_cordovaRecordingControls')
				.appendTo($form);

			$('<div>')
				.addClass('cordova-btn cordova-icon icon-record')
				.text(_loc('Record'))
				.appendTo($recordingControls)
				.click(function(event) {
					event.preventDefault();
					mediaRec.startRecord();

					$(this).hide();
					$stopButton.show();
				});

			var $stopButton = $('<div>')
				.addClass('cordova-btn cordova-icon icon-stop')
				.text(_loc('Stop'))
				.appendTo($recordingControls)
				.click(function(event) {
					event.preventDefault();
					mediaRec.stopRecord();

					$recordingControls.hide();
				})
				.hide();
		}

		function clearAttachmentPreview() {
			for (var i = 0; i < attachmentPreviewComponents.length; i++) {
				attachmentPreviewComponents[i].remove();
			}
			if ($recordingControls) {
				$recordingControls.hide();
			}
		}

		function allTabsDisplayed() {
			_this._clickTab(attName, firstTabDisplayed);
		}

		function addCordovaAttachment(fileName) {
			_this.cordovaAttachment = fileName.replace('file:/','/');
		}
	},
	
	_addFileElement: function(opts_){
		var opts = $n2.extend({
			attName: null
			,label: null
			,form: null
		},opts_);

		var _this = this;
		
		var $elem = this._getElem();
		var attName = opts.attName;
		var className = 'attachmentEditor_att_' + $n2.utils.stringToHtmlId(attName);
		
		var $div = $('<div>')
			.addClass('attachmentEditor_att')
			.addClass(className)
			.attr('n2AttName',attName)
			.appendTo($elem);
		
		$('<span>')
			.addClass('attachmentEditor_label')
			.text( opts.label )
			.appendTo($div);
	
		if( opts.form ) {
			var fileName = opts.form.find('input[type="file"]').val();
			if( fileName ){
				var index = fileName.lastIndexOf('/');
				if( index >= 0 ){
					fileName = fileName.substr(index+1);
				};
			};
			if( fileName ){
				var index = fileName.lastIndexOf('\\');
				if( index >= 0 ){
					fileName = fileName.substr(index+1);
				};
			};
			$('<span>')
				.addClass('attachmentEditor_attName')
				.text(fileName)
				.appendTo($div);
		} else {
			$('<span>')
				.addClass('attachmentEditor_attName')
				.text(attName)
				.appendTo($div);
		};
		
		$('<a>')
			.attr('href','#')
			.attr('n2AttName',attName)
			.addClass('attachmentEditor_delete')
			.text( _loc('Remove') )
			.appendTo($div)
			.click(function(){
				var $a = $(this);
				var attName = $a.attr('n2AttName');
				if( attName ) {
					_this._removeAttachment(attName);
				};
				return false;
			});
		
		if( opts.form ) {
			opts.form.appendTo($div);
		};
	},

  _attachmentFileChanged: function(event) {
	  var _this = this;
    if( typeof RecordRTC === 'undefined' && typeof lamejs === 'undefined') {
      return;
    }
  },

	_clickTab: function(attName, type) {
		var _this = this;
		
		var $elem = this._getElem();
		var $attachmentEditor = $elem.find('.attachmentEditor_att_' + $n2.utils.stringToHtmlId(attName));
		var $clickedTab = $attachmentEditor.find('.attachmentEditor_uploadTab_'+type);

		var contentClass = 'attachmentEditor_uploadTabContent_' + type;
		
		// Check if already selected
		var currentType = $attachmentEditor.attr('n2attType');
		if( type === currentType ){
			// Already selected
			return;
		};
		$attachmentEditor.attr('n2attType',type);
		
		$attachmentEditor.find('.attachmentEditor_uploadTabContent').hide();
		$attachmentEditor.find('.attachmentEditor_uploadTabs button').removeClass('active');
		if(_this.recordingInterval !== null) {
			_this._cancelRecording();
		}
		if(typeof _this.recordStatus !== 'undefined') {
			_this.recordStatus.text('');
		}
		var $recordingVideos = $attachmentEditor.find('.attachmentEditor_videoRecordingContainer video');
		if($recordingVideos.length > 0) {
			if(typeof _this.recordingStream !== 'undefined' && _this.recordingStream != null) {
				_this.recordingStream.stop();
			}
			$recordingVideos.remove();
			_this.mediaElementEl.remove();
			$attachmentEditor.find('.attachmentEditor_videoRecordingContainer .mejs__container')[0].remove();
		}
		var $recordingAudio = $attachmentEditor.find('.attachmentEditor_recordingContainer audio');
		if($recordingAudio.length > 0) {
			$recordingAudio.remove();
		}
		
		// Clear file upload
		$attachmentEditor.find('.attachmentEditor_uploadTabContent_file input').val('')
		
		$clickedTab.addClass('active');
		$attachmentEditor.find('.'+contentClass).show();
		if(type === 'audio' || type === 'video') {
			_this._setupRecording(type);
			_this.currentRecordingType = type;
		}
	},

	_clickRecording: function(event, recordType) {
		event.preventDefault();
		var _this = this;

		if(_this.recordingInterval === null) {
			_this._startRecording(recordType);
		} else {
			_this._stopRecording(recordType);
		}
	},

	_setupRecording: function(recordType) {
		var _this = this;
		if(recordType === 'audio') {
			_this.recordStatus = _this.audioRecordStatus;
			_this.recordingButton = _this.audioRecordingButton;
		} else if(recordType === 'video') {
			_this.recordStatus = _this.videoRecordStatus;
			_this.recordingButton = _this.videoRecordingButton;
		}

		_this._captureUserMedia(recordType, function(stream) {
			_this.recordingStream = stream;
			if(recordType === 'audio') {
				_this.recorder = RecordRTC(stream, {
					type: 'audio',
					recorderType: StereoAudioRecorder,
					numberOfAudioChannels: 1
				});
			} else {
				_this._setupVideoPreview(stream);
				var mimeType = 'video/webm';
				if(_this._isMimeTypeSupported('video/webm;codecs=h264')) {
					mimeType = 'video/webm;codecs=h264'
				}
				_this.recorder = RecordRTC(stream, { mimeType: mimeType });
			}

			var oldAudio = $('.attachmentEditor_recordingContainer audio');
			if(oldAudio.length > 0) {
				oldAudio[0].remove();
			}
		});
	},

	_setupVideoPreview: function(stream) {
		var _this = this;
		var recordingVideos = $('.attachmentEditor_videoRecordingContainer video');
		if(recordingVideos.length > 0) {
			_this.mediaElementEl.remove();
			delete recordingVideos[0];
			$('.attachmentEditor_videoRecordingContainer .mejs__container')[0].remove();
		}

		var mejsDiv = $('.attachmentEditor_meVideo');
		var height = 320/(_this.recordVideoSize.width/_this.recordVideoSize.height);

		var recordingVideo = ($('<video>')
			.attr('controls', 'controls')
			.attr('height', height + 'px')
			.attr('width', '320px')
			.prependTo(mejsDiv))[0];

		if($.fn && $.fn.mediaelementplayer) {
			_this.mediaElementEl = $(recordingVideo).mediaelementplayer({
				features: ['fullscreen']
			});

			$('.attachmentEditor_videoRecordingContainer .mejs__container .mejs__overlay-play .mejs__overlay-button').hide();
		}

		recordingVideo.muted = true;
		recordingVideo.controlls = false;
		recordingVideo.src = null;
		recordingVideo.srcObject = stream;
		recordingVideo.play();
	},

	_isMimeTypeSupported: function(mimeType) {
		if(DetectRTC.browser.name === 'Edge' || DetectRTC.browser.name === 'Safari' || typeof MediaRecorder === 'undefined') {
			return false;
		}

		if(typeof MediaRecorder.isTypeSupported !== 'function') {
			return true;
		}

		return MediaRecorder.isTypeSupported(mimeType);
	},

	_startRecording: function(recordType) {
		var _this = this;
		var obj = this.obj;
		_this.recordStatus.text('');
		_this.recorder.startRecording();

		if(recordType === 'audio') {
			_this.recordingButton.toggleClass('attachmentEditor_stopRecordingButton attachmentEditor_micButton');
		} else {
			_this.recordingButton.toggleClass('attachmentEditor_stopRecordingButton attachmentEditor_videoButton');
			var recordingVideos = $('.attachmentEditor_videoRecordingContainer video');
			if(recordingVideos[0].srcObject == null) {
				_this._setupVideoPreview(_this.recordingStream);
			}
		}
		_this._recordingTimer(recordType);
	},

	_recordingTimer: function(recordType) {
		var _this = this;
		var seconds_elapsed = 0;
		var max_time = recordType === 'audio' ? _this.maxAudioRecordingLengthSeconds : _this.maxVideoRecordingLengthSeconds;
		var max_time_str = _this._secondsToTimeString(max_time);

		_this.recordingInterval = setInterval(function() {
			seconds_elapsed++;

			if(seconds_elapsed >= max_time) {
				_this._stopRecording();
				return;
			}

			var cur_time_str = _this._secondsToTimeString(seconds_elapsed);
			_this.recordStatus.text(cur_time_str + '/' + max_time_str);
		}, 1000);
	},

	_secondsToTimeString: function(seconds) {
		var min = Math.floor(seconds/60);
		var sec = seconds - min * 60;
		if(sec < 10) {
			sec = '0' + sec;
		}
		return min + ':' + sec
	},

	_stopRecordingTimer: function() {
		var _this = this;
		clearInterval(_this.recordingInterval);
		_this.recordingInterval = null;
	},

	_captureUserMedia: function(type, success_callback) {
		var _this = this;
		var session = {
			audio: true
		};
		if(type === 'video') {
			var videoHints = true;

			if (DetectRTC.browser.name === 'Firefox' || (DetectRTC.browser.name === 'Chrome' && DetectRTC.browser.version >= 60)) {
				videoHints = {
					width: _this.recordVideoSize.width,
					height: _this.recordVideoSize.height
				};
			} else {
				videoHints = {
					optional: [],
					mandatory: {
						minWidth: _this.recordVideoSize.width,
						minHeight: _this.recordVideoSize.height
					}
				}
			}
			session.video = videoHints;
		}

		navigator.getUserMedia(session, success_callback, function(error) {
			alert(_loc('Unable to capture your microphone and/or camera.'));
			$n2.logError(error);
		});
	},

	_cancelRecording: function() {
		var _this = this;
		_this._stopRecordingTimer();
		_this.recorder.stopRecording();
		_this.recordingStream.stop();
		if(_this.currentRecordingType === 'video') {
			_this.recordingButton.toggleClass('attachmentEditor_stopRecordingButton attachmentEditor_videoButton');
		} else if(_this.currentRecordingType === 'audio') {
			_this.recordingButton.toggleClass('attachmentEditor_stopRecordingButton attachmentEditor_micButton');
		}
		_this.recordStatus.text('');
	},

	_stopRecording: function(recordType) {
		var _this = this;
		var obj = this.obj;

		_this._stopRecordingTimer();
		_this.recordingButton.prop('disabled', true);
		_this.recordStatus.text(_loc('Processing...'));

		_this.recorder.stopRecording(function() {
			var blobResult = _this.recorder.getBlob();

			if(recordType === 'audio') {
				_this._processAudioRecording(blobResult);
			} else {
				_this.recorder.getDataURL(function(dataURL) {
					_this._processVideoRecording(dataURL);
				});
			}
		});
	},

	_processAudioRecording: function(blob) {
		var _this = this;
		var fileReader = new FileReader();
		fileReader.onload = function() {
			var samples = _this._getWavSamples(this.result);
			var mp3Blob = _this._encodeMp3(samples);

			var reader = new FileReader();
			reader.onload = function(event) {
				var oldAudio = $('.attachmentEditor_recordingContainer audio');
					if(oldAudio.length > 0) {
						oldAudio[0].src = event.target.result;
					} else {
						$('<audio>')
							.attr('src', event.target.result)
							.attr('controls', 'controls')
							.insertAfter(_this.recordingButton);
					}

				_this.recordingButton.prop('disabled', false);
				_this.recordingButton.toggleClass('attachmentEditor_stopRecordingButton attachmentEditor_micButton');

				_this.recordStatus.text(_loc('Captured Audio'));
			};
			reader.readAsDataURL(mp3Blob);
		};
		fileReader.readAsArrayBuffer(blob);
	},

	_processVideoRecording: function(dataURL) {
		var _this = this;
		var oldVideo = $('.attachmentEditor_videoRecordingContainer video');
		if(oldVideo.length > 0) {
			_this.mediaElementEl.remove();
			delete oldVideo[0];
			$('.attachmentEditor_videoRecordingContainer .mejs__container')[0].remove();
		}

		var mejsDiv = $('.attachmentEditor_meVideo');
		var height = 320/(_this.recordVideoSize.width/_this.recordVideoSize.height);
		var video = $('<video>')
			.attr('src', dataURL)
			.attr('height', height + 'px')
			.attr('width', '320px')
			.attr('controls', 'controls')
			.prependTo(mejsDiv);
		_this.mediaElementEl = $(video).mediaelementplayer({
			features: ['playpause', 'progress','volume','fullscreen']
		});

		_this.recordingButton.prop('disabled', false);
		_this.recordingButton.toggleClass('attachmentEditor_stopRecordingButton attachmentEditor_videoButton');

		_this.recordStatus.text(_loc('Captured Video'));
	},

	_getWavSamples: function(arrayBuffer) {
		var samples = new Int16Array(arrayBuffer);
		var wavHeader = lamejs.WavHeader.readHeader(new DataView(arrayBuffer));

		if (wavHeader.channels === 2) {
			var left = [];
			var right = [];
			var i = 0;

			while (i < samples.length) {
				left.push(samples[i]);
				right.push(samples[i + 1]);

				i += 2;
			}

			samples = new Int16Array(left);
		}
	// trim the first and last millisecond to remove click noise at start
	return samples.slice(45, samples.length - 45);

	},

	_encodeMp3: function(samples) {
		var channels = 1;
		var sampleRate = 44100;
		var kbps = 128;
		var mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, kbps);
		var mp3Data = [];
		var sampleBlockSize = 1152; //can be anything but make it a multiple of 576 to make encoders life easier

		for (var i = 0; i < samples.length; i += sampleBlockSize) {
			var sampleChunk = samples.subarray(i, i + sampleBlockSize);
			var mp3buf = mp3encoder.encodeBuffer(sampleChunk);
			if (mp3buf.length > 0) {
				mp3Data.push(mp3buf);
			}
		}
		var mp3buf = mp3encoder.flush();   //finish writing mp3

		if (mp3buf.length > 0) {
			mp3Data.push(new Int8Array(mp3buf));
		}

		return new Blob(mp3Data, {type: 'audio/mp3'});
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++

$n2.couchEdit = {
	EditService: CouchEditService
	,SchemaEditorService: SchemaEditorService
	,CouchSimpleDocumentEditor: CouchSimpleDocumentEditor
	,Constants: {
		ALL_SCHEMAS: {}
		,FORM_EDITOR: {}
		,TREE_EDITOR: {}
		,SLIDE_EDITOR: {}
		,RELATION_EDITOR: {}
	}
	,AttachmentEditor: AttachmentEditor
};

// Support legacy code
$n2.CouchEditor = {
	Constants: $n2.couchEdit.Constants 
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchRelatedDoc.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

var DH = 'n2.couchRelatedDoc';

//===============================================================

var CreateDocWidget = $n2.Class({
	
	elemId: null,
	
	schemaNames: null,
	
	allSchemas: null,
	
	label: null,
	
	dialogPrompt: null,
	
	createDocProcess: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,schemaNames: null
			,allSchemas: false
			,label: null
			,dialogPrompt: null
			,createDocProcess: null
		},opts_);
		
		this.createDocProcess = opts.createDocProcess;
		this.schemaNames = opts.schemaNames;
		this.allSchemas = opts.allSchemas;
		this.label = opts.label;
		this.dialogPrompt = opts.dialogPrompt;
		
		this.elemId = $n2.utils.getElementIdentifier(opts.elem);
		
		if( !this.label ){
			this.label = _loc('Create Document');
		};
		
		this._refresh();
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_refresh: function(){
		var _this = this;
		
		var $elem = this._getElem();
		$elem.empty();
		
		$('<button>')
			.text( this.label )
			.appendTo($elem)
			.click(function(){
				_this._createDocClicked();
			});
	},
	
	_createDocClicked: function(){
		this.createDocProcess.createDocumentFromSchemaNames({
			schemaNames: this.schemaNames
			,allSchemas: this.allSchemas
			,prompt: this.dialogPrompt
		});
	}
});

//===============================================================
var Editor = $n2.Class({
	
	documentSource: null,

	uploadService: null,
	
	showService: null,
	
	dialogService: null,
	
	obj: null,
	
	schema: null,
	
	prompt: null,
	
	onSuccess: null,
	
	onError: null,
	
	onCancel: null,

	moduleEditInfo: null,

	diagId: null,
	
	attachmentUploadHandler: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend(
			{
				documentSource: null
				,uploadService: null
				,showService: null
				,dialogService: null
				,obj: null
				,schema: null
				,prompt: null
				,elem: null // location where editor should be opened
				,onSuccess: function(docId){}
				,onError: $n2.reportErrorForced
				,onCancel: function(){}
				,moduleEditInfo: undefined
			}
			,opts_
		);
		
		this.documentSource = opts.documentSource;
		this.uploadService = opts.uploadService;
		this.showService = opts.showService;
		this.dialogService = opts.dialogService;
		this.schema = opts.schema;
		this.prompt = opts.prompt;
		this.onSuccess = opts.onSuccess;
		this.onError = opts.onError;
		this.onCancel = opts.onCancel;
		this.moduleEditInfo = opts.moduleEditInfo;

		this.obj = {};
		for(var key in opts.obj){
			if( '__n2Source' === key ){
				// ignore
			} else {
				this.obj[key] = opts.obj[key];
			};
		};

		var _this = this;
		
		var diagId = $n2.getUniqueId();
		this.diagId = diagId;
		var $dialog = $('<div>')
			.attr('id',diagId)
			.addClass('n2RelatedDoc_dialog');
		
		if( opts.elem ){
			var $elem = $(opts.elem);
			$dialog
				.addClass('n2RelatedDoc_located')
				.appendTo($elem);
		} else {
			$dialog.appendTo( $('body') );
		};
		
		var obj = this.obj;
		var schema = this.schema;
		
		var funcMap = {};
		if( this.dialogService ){
			funcMap = this.dialogService.getFunctionMap();
		};
		
		var $diagContent = $('<div>')
			.addClass('n2RelatedDoc_dialogContent')
			.appendTo($dialog);
		
		var $form = $('<div>')
			.appendTo($diagContent);
		schema.form(
			obj
			,$form
			,null // context
			,function(){ // callback on changes
				if( _this.showService ){
					_this.showService.fixElementAndChildren($form, {}, obj);
				};
			}
			,funcMap
		);
		
		if( this.showService ){
			this.showService.fixElementAndChildren($form, {}, obj);
		};

		var $fileElement = $('<div>')
			.appendTo($diagContent);
		this.attachmentUploadHandler = new $n2.couchEdit.AttachmentEditor({
			doc: obj
			,elem: $fileElement
			,documentSource: this.documentSource
			,uploadService: this.uploadService
			,disableAddFile: true
			,disableRemoveFile: true
			,moduleEditInfo: this.moduleEditInfo
		});
		
		// OK
		$('<button>')
			.text( _loc('OK') )
			.button({icons:{primary:'ui-icon-check'}})
			.appendTo($diagContent)
			.click(function(){
				_this._clickOK();
				return false;
			});
		
		// Cancel
		$('<button>')
			.text( _loc('Cancel') )
			.button({icons:{primary:'ui-icon-cancel'}})
			.appendTo( $diagContent )
			.click(function(){
				_this._clickCancel();
				return false;
			});
		
		if( !opts.elem ){
			var dialogOptions = {
				autoOpen: true
				,title: _loc('Fill Out Related Document')
				,modal: !window.cordova
				,width: window.cordova ? '100%' : 740
				,close: function(event, ui){
					var diag = $('#'+diagId);
					diag.remove();
				}
			};
			$dialog.dialog(dialogOptions);
		};
	},

	_clickOK: function(){

		var _this = this;
		var obj = this.obj;

		if (window.cordova) {
			// Check that a file was provided
			if (_this.attachmentUploadHandler.cordovaAttachment) {
				_this._saveObj();
			} else {
				alert(_loc('A file must be selected or recorded'));
				return;
			}
		} else {
			// Check that a file was provided
			this.attachmentUploadHandler.performPreSavingActions({
				doc: obj
				,documentSource: this.documentSource
				,onSuccess: function(){
					_this._saveObj();
				}
				,onError: function(err){
					alert(err);
				}
			});
		}
	},

	_clickCancel: function(){
		var $diag = $('#'+this.diagId);
		
		if( $diag.hasClass('n2RelatedDoc_located') ){
			$diag.remove();
		} else {
			$diag.dialog('close');
		};

		this.onCancel();
	},
	
	_saveObj: function(){
		var _this = this;
		var obj = this.obj;

		$n2.couchDocument.adjustDocument(obj);

		if (window.cordova) {
			obj.nunaliit_attachments = null;
			obj.nunaliit_mobile_attachments = _this.attachmentUploadHandler.cordovaAttachment;
		}

		this.documentSource.createDocument({
			doc: obj
			,onSuccess: function(updatedDoc) {
				if (window.cordova) {
					_this._success(updatedDoc._id);
				} else {
					_this._uploadFile(updatedDoc);
				}
			}
			,onError: function(err){
				_this._error( _loc('Unable to reach database to submit document: {err}',{err:err}) );
			}
		});
	},
	
	_uploadFile: function(doc){
		var _this = this;

		this.attachmentUploadHandler.performPostSavingActions({
			doc: doc
			,onSuccess: function(){
				_this._success(doc._id);
			}
			,onError: function(err){
				_this._error( 
					_loc('Error occurred after related document was created. Error: {err}',{err:err})
				);
			}
		});
	},
	
	_success: function(docId){
		// Close upload dialog
		var $diag = $('#'+this.diagId);
		
		if( $diag.hasClass('n2RelatedDoc_located') ){
			$diag.remove();
		} else {
			$diag.dialog('close');
		};
		
		// Call back client
		this.onSuccess(docId);
	},
	
	_error: function(err){
		var _this = this;
		
		var $content = $('#'+this.diagId).find('.n2RelatedDoc_dialogContent')
			.empty();
		
		$('<div>')
			.addClass('n2RelatedDoc_error')
			.text( err )
			.appendTo($content);

		$('<button>')
			.text( _loc('Cancel') )
			.button({icons:{primary:'ui-icon-cancel'}})
			.appendTo( $content )
			.click(function(){
				_this._clickCancel();
				return false;
			});
		
		// Call back client
		this.onError(err);
	}
});

// ===============================================================
var CreateRelatedDocProcess = $n2.Class({
	
	documentSource: null,

	schemaRepository: null,
	
	uploadService: null,
	
	showService: null,
	
	authService: null,

	dialogService: null,

	moduleEditInfo: null,

	initialize: function(opts_) {
		var opts = $n2.extend(
			{
				documentSource: null
				,schemaRepository: null
				,dispatchService: null
				,uploadService: null
				,showService: null
				,authService: null
				,dialogService: null
			}
			,opts_
		);
		
		this.documentSource = opts.documentSource;
		this.schemaRepository = opts.schemaRepository;
		this.uploadService = opts.uploadService;
		this.showService = opts.showService;
		this.authService = opts.authService;
		this.dialogService = opts.dialogService;
		this.dispatchService = opts.dispatchService;
	},

	configureOptions: function(editInfo){
		this.moduleEditInfo = editInfo;
	},

	getCreateWidget: function(opts_){
		var opts = $n2.extend({
			elem: null
			,schemaNames: null
			,allSchemas: false
			,label: null
			,dialogPrompt: null
		},opts_);
		
		return new CreateDocWidget({
			elem: opts.elem
			,schemaNames: opts.schemaNames
			,allSchemas: opts.allSchemas
			,label: opts.label
			,dialogPrompt: opts.dialogPrompt
			,createDocProcess: this
		});
	},

	createDocumentFromSchema: function(opt_){
	
		var _this = this;
	
		// Check that we are logged in
		var authService = this.authService;
		if( authService && false == authService.isLoggedIn() ) {
			authService.showLoginForm({
				onSuccess: function(result,options) {
					_this.createDocumentFromSchema(opt_);
				}
			});
			return;
		};
	
		var opt = $n2.extend({
			schema: null
			,elem: null
			,relatedDoc: null
			,originDocId: null
			,prompt: null
			,onSuccess: function(docId){}
			,onError: $n2.reportErrorForced
			,onCancel: function(){}
		},opt_);
		
		if( opt.schema && opt.schema.isSchema ) {
			// OK
		} else {
			opt.onError( _loc('A valid schema must be provided') );
			return;
		};
		
		if (window.cordova) {
			uploadServiceAvailable();
		} else {
			// Check that upload service is available
			this.uploadService.checkWelcome({
				onSuccess: uploadServiceAvailable
				,onError: function(err){
					alert( _loc('Upload service can not be reached. Unable to submit a related document.') );
				}
			});
		}
	
		function uploadServiceAvailable(){
			var obj = opt.schema.createObject();
			
			if( opt.relatedDoc ){
				obj.nunaliit_source = {
					nunaliit_type: 'reference'
					,doc: opt.relatedDoc._id
					,category: 'attachment'
				};
			};
			
			if( opt.originDocId ){
				obj.nunaliit_origin = {
					nunaliit_type: 'reference'
					,doc: opt.originDocId
				};
			};
			
			if( _this.dispatchService ){
				_this.dispatchService.synchronousCall(DH,{
					type: 'preDocCreation'
					,doc: obj
					,relatedDoc: opt.relatedDoc
				});
			};
			
			// Compute prompt, if not provided
			var prompt = opt.prompt;
			if( !prompt ){
				if( opt.originDocId ){
					prompt = _loc('Fill Out Reply');
					
				} else if( opt.relatedDoc ){
					prompt = _loc('Fill Out Related Document');

				} else {
					prompt = _loc('Fill out content of new document');
				};
			};
			
			new Editor({
				documentSource: _this.documentSource
				,uploadService: _this.uploadService
				,showService: _this.showService
				,dialogService: _this.dialogService
				,obj: obj
				,schema: opt.schema
				,prompt: prompt
				,elem: opt.elem
				,onSuccess: opt.onSuccess
				,onError: opt.onError
				,onCancel: opt.onCancel
				,moduleEditInfo: _this.moduleEditInfo
			});
		};
	},

	createDocumentFromSchemaNames: function(opt_){
		
		var _this = this;
		
		// Check that we are logged in
		var authService = this.authService;
		if( authService && false == authService.isLoggedIn() ) {
			authService.showLoginForm({
				onSuccess: function(result,options) {
					_this.createDocumentFromSchemaNames(opt_);
				}
			});
			return;
		};
		
		var opt = $n2.extend({
			schemaNames: []
			,allSchemas: false
			,relatedDoc: null
			,originDocId: null
			,prompt: null
			,onSuccess: function(docId){}
			,onError: $n2.reportErrorForced
			,onCancel: function(){}
		},opt_);
		
		if( opt.allSchemas ){
			this.dialogService.selectSchema({
				onSelected: selectedSchema
				,onError: opt.onError
				,onReset: opt.onCancel
			});
		} else {
			this.dialogService.selectSchemaFromNames({
				schemaNames: opt.schemaNames
				,onSelected: selectedSchema
				,onError: opt.onError
				,onReset: opt.onCancel
			});
		};
		
		function selectedSchema(schema){
			_this.createDocumentFromSchema({
				schema: schema
				,relatedDoc: opt.relatedDoc
				,originDocId: opt.originDocId
				,prompt: opt.prompt
				,onSuccess: opt.onSuccess
				,onError: opt.onError
				,onCancel: opt.onCancel
			});
		};
	},

	replyToDocument: function(opt_){
		
		var _this = this;
		
		// Check that we are logged in
		var authService = this.authService;
		if( authService && false == authService.isLoggedIn() ) {
			authService.showLoginForm({
				onSuccess: function(result,options) {
					_this.replyToDocument(opt_);
				}
			});
			return;
		};
		
		var opt = $n2.extend({
			doc: null
			,elem: null
			,schema: null
			,originDocId: null
			,onSuccess: function(docId){}
			,onError: $n2.reportErrorForced
			,onCancel: function(){}
		},opt_);

		if( opt.schema && opt.schema.isSchema ) {
			// OK
		} else {
			opt.onError( _loc('A valid schema must be provided') );
			return;
		};
		
		var originDocId = null;
		if( opt.originDocId ){
			originDocId = opt.originDocId;
		} else if( opt.doc.nunaliit_origin && opt.doc.nunaliit_origin.doc ) {
			originDocId = opt.doc.nunaliit_origin.doc;
		} else if( opt.doc.nunaliit_source && opt.doc.nunaliit_source.doc ) {
			originDocId = opt.doc.nunaliit_source.doc;
		};
		
		this.createDocumentFromSchema({
			schema: opt.schema
			,elem: opt.elem
			,relatedDoc: opt.doc
			,originDocId: originDocId
			,onSuccess: opt.onSuccess
			,onError: opt.onError
			,onCancel: opt.onCancel
		});
	},
	
	insertAddRelatedSelection: function(opts_){
		var opts = $n2.extend({
			placeHolderElem: null
			,doc: null
			,onElementCreated: function($elem){}
			,onRelatedDocumentCreated: function(docId){}
		},opts_);
		
		var _this = this;
		
		var $placeHolder = $(opts.placeHolderElem);
		var doc = opts.doc;
		
		var docSchemaName = doc.nunaliit_schema;
		if( !docSchemaName ){
			noButton();
			return;
		};
		
		this.schemaRepository.getSchema({
			name: docSchemaName
			,onSuccess: function(docSchema){
				// Check if there are any related document schemas
				if( docSchema.relatedSchemaNames 
				 && docSchema.relatedSchemaNames.length > 0 ){
					_this.schemaRepository.getSchemas({
						names: docSchema.relatedSchemaNames
						,onSuccess: loadedRelatedSchemas
						,onError: noButton
					});
				} else {
					noButton();
				};
			}
			,onError: noButton
		});
		
		function loadedRelatedSchemas(relatedSchemas){
			if( relatedSchemas.length < 1 ){
				noButton();
				return;
			};
			
			var $select = $('<select>');

			$('<option>')
				.text( _loc('Add Related Item') )
				.val('')
				.appendTo($select);
			
			for(var i=0,e=relatedSchemas.length; i<e; ++i){
				var relatedSchema = relatedSchemas[i];
				
				$('<option>')
					.text( relatedSchema.getLabel() )
					.val( relatedSchema.name )
					.appendTo($select);
			};
			
			$select.insertBefore($placeHolder)
				.change(function(){
					var val = $(this).val();
					$(this).val('');
					if( val && val.length > 0 ) {
						_this.createDocumentFromSchemaNames({
							schemaNames: [val]
							,relatedDoc: doc
							,onSuccess: opts.onRelatedDocumentCreated
						});
					};
					return false;
				});
			
			$placeHolder.remove();
			
			opts.onElementCreated($select);
		};
		
		function noButton(){
			$placeHolder.remove();
		};
	}
});


$n2.couchRelatedDoc = {
	CreateRelatedDocProcess: CreateRelatedDocProcess	
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDisplay.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

var DH = 'n2.couchDisplay';

function docCreationTimeSort(lhs, rhs) {
	var timeLhs = 0;
	var timeRhs = 0;
	
	if( lhs && lhs.doc && lhs.doc.nunaliit_created && lhs.doc.nunaliit_created.time ) {
		timeLhs = lhs.doc.nunaliit_created.time;
	}
	if( rhs && rhs.doc && rhs.doc.nunaliit_created && rhs.doc.nunaliit_created.time ) {
		timeRhs = rhs.doc.nunaliit_created.time;
	}
	
	if( timeLhs < timeRhs ) return -1;
	if( timeLhs > timeRhs ) return 1;
	return 0;
};

function startsWith(s, prefix) {
	var left = s.substr(0,prefix.length);
	return (left === prefix);
};

function boolOption(optionName, options, customService){
	var flag = false;
	
	if( options[optionName] ){
		flag = true;
	};
	
	if( customService && !flag ){
		var o = customService.getOption(optionName);
		if( o ){
			flag = true;
		};
	};
	
	return flag;
};

// ===================================================================================

var Display = $n2.Class({
	
	options: null
	
	,documentSource: null
	
	,displayPanelName: null
	
	,currentFeature: null
	
	,createRelatedDocProcess: null
	
	,defaultSchema: null
	
	,displayRelatedInfoProcess: null
	
	,displayOnlyRelatedSchemas: null
	
	,displayBriefInRelatedInfo: null
	
	,restrictAddRelatedButtonToLoggedIn: null
	
	,restrictReplyButtonToLoggedIn: null
	
	,classDisplayFunctions: null
	
	,showService: null
	
	,uploadService: null
	
	,customService: null
	
	,authService: null
	
	,requestService: null
	
	,dispatchService: null
	
	,schemaRepository: null
	
	,initialize: function(opts_) {
		var _this = this;
		
		var opts = $n2.extend({
			documentSource: null
			,displayPanelName: null
			,showService: null // asynchronous resolver
			,uploadService: null
			,createDocProcess: null
			,serviceDirectory: null
			,displayRelatedInfoFunction: null // legacy
			,displayRelatedInfoProcess: null
			,classDisplayFunctions: {}
		
			// Boolean options
			,displayOnlyRelatedSchemas: false
			,displayBriefInRelatedInfo: false
			,restrictAddRelatedButtonToLoggedIn: false
			,restrictReplyButtonToLoggedIn: false
		}, opts_);
		
		this.documentSource = opts.documentSource;
		this.displayPanelName = opts.displayPanelName;
		this.uploadService = opts.uploadService;
		this.classDisplayFunctions = opts.classDisplayFunctions;
		this.createRelatedDocProcess = opts.createDocProcess;
		
		if( opts.serviceDirectory ){
			this.showService = opts.serviceDirectory.showService;
			this.customService = opts.serviceDirectory.customService;
			this.authService = opts.serviceDirectory.authService;			
			this.requestService = opts.serviceDirectory.requestService;
			this.schemaRepository = opts.serviceDirectory.schemaRepository;
			this.dispatchService = opts.serviceDirectory.dispatchService;
		};
		
		if( !this.showService ){
			this.showService = opts.showService;
		};
		
		this.displayOnlyRelatedSchemas = 
			boolOption('displayOnlyRelatedSchemas',opts,this.customService);
		this.displayBriefInRelatedInfo = 
			boolOption('displayBriefInRelatedInfo',opts,this.customService);
		this.restrictAddRelatedButtonToLoggedIn = 
			boolOption('restrictAddRelatedButtonToLoggedIn',opts,this.customService);
		this.restrictReplyButtonToLoggedIn = 
			boolOption('restrictReplyButtonToLoggedIn',opts,this.customService);
			
		var customService = this.customService;

		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			var f = function(msg, addr, dispatcher){
				_this._handleDispatch(msg, addr, dispatcher);
			};
			dispatcher.register(DH, 'selected', f);
			dispatcher.register(DH, 'searchResults', f);
			dispatcher.register(DH, 'documentDeleted', f);
			dispatcher.register(DH, 'authLoggedIn', f);
			dispatcher.register(DH, 'authLoggedOut', f);
			dispatcher.register(DH, 'editClosed', f);
			dispatcher.register(DH, 'documentContentCreated', f);
			dispatcher.register(DH, 'documentContentUpdated', f);
		};

		if( this.requestService ){
			this.requestService.addDocumentListener(function(doc){
				_this._refreshDocument(doc);
				_this._populateWaitingDocument(doc);
			});
		};
		
		// Function to display related information
		if( opts.displayRelatedInfoProcess ){
			this.displayRelatedInfoProcess = opts.displayRelatedInfoProcess;
		};
		if( !this.displayRelatedInfoProcess 
		 && opts.displayRelatedInfoFunction ){
			this.displayRelatedInfoProcess 
				= new LegacyDisplayRelatedFunctionAdapter(opts.displayRelatedInfoFunction);
		};
		if( !this.displayRelatedInfoProcess 
		 && customService ){
			var displayRelatedProcess = customService.getOption('displayRelatedInfoProcess');
			if( displayRelatedProcess ){
				this.displayRelatedInfoProcess = displayRelatedProcess;
			};
		};
		if( !this.displayRelatedInfoProcess 
		 && customService ){
			var displayRelatedFn = customService.getOption('displayRelatedInfoFunction');
			if( typeof displayRelatedFn === 'function' ){
				this.displayRelatedInfoProcess 
					= new LegacyDisplayRelatedFunctionAdapter(displayRelatedFn);
			};
		};
		if( !this.displayRelatedInfoProcess ) {
			if( this.displayOnlyRelatedSchemas ) {
				this.displayRelatedInfoProcess 
					= new LegacyDisplayRelatedFunctionAdapter(DisplayRelatedInfo);
			} else {
				this.displayRelatedInfoProcess 
					= new LegacyDisplayRelatedFunctionAdapter(DisplayLinkedInfo);
			};
		};

		$('body').addClass('n2_display_format_classic');
		
		$n2.log('ClassicDisplay',this);
	}

	// external
	,setSchema: function(schema) {
		this.defaultSchema = schema;
	}
	
	,_displayDocument: function($set, doc) {

		var _this = this;
		
		$set.empty();
		
		this._displayObject($set, doc, {
			onUpdated: function() {
				_this._displayDocument($set, doc);
			}
			,onDeleted: function() {
				$set.empty();
			}
		});
	}

	,_shouldSuppressNonApprovedMedia: function(){
		return this.showService.eliminateNonApprovedMedia;
	}

	,_shouldSuppressDeniedMedia: function(){
		return this.showService.eliminateDeniedMedia;
	}
	
	,_getDisplayDiv: function(){
		var divId = this.displayPanelName;
		return $('#'+divId);
	}
	
	,_displayObject: function($side, data, opt_) {
		var _this = this;
		
		var opt = $n2.extend({
			onUpdated: function(){ 
			}
			,onDeleted: function() {
			}
			,suppressContributionReferences: false
			,showContributionReplyButton: false
			,showAddContributionButton: false
			,showRelatedContributions: false
		},opt_);

		var docId = data._id;
		
		var $elem = $('<div class="couchDisplay_'+$n2.utils.stringToHtmlId(docId)+'"></div>');
		$side.append($elem);

		var $sElem = $('<div class="n2s_handleHover"></div>');
		$elem.append($sElem);
		
		this.showService.displayDocument($sElem, {
			onDisplayed: onDisplayed
		}, data);

		if( data.nunaliit_schema ) {
			var schemaRepository = _this.schemaRepository;
			if( schemaRepository ) {
				schemaRepository.getSchema({
					name: data.nunaliit_schema
					,onSuccess: function(schema) {
						continueDisplay(schema);
					}
					,onError: function(){
						continueDisplay(null);
					}
				});
				
			} else {
				continueDisplay(null);
			};
			
		} else {
			continueDisplay(null);
		};
		
		function continueDisplay(schema){
			_this._addAttachmentProgress($elem, data);
			
			_this._addButtons($elem, data, {
				schema: schema
				,related: true
				,reply: true
				,geom: true
				,edit: true
				,'delete': true
				,addLayer: true
				,treeView: true
				,simplifiedGeoms: true
			});
			
			var $div = $('<div>')
				.addClass('n2Display_relatedInfo couchDisplayRelated_'+$n2.utils.stringToHtmlId(data._id))
				.appendTo($elem);
			var relatedInfoId = $n2.utils.getElementIdentifier($div);
			_this.displayRelatedInfoProcess.display({
				divId: relatedInfoId
				,display: _this
				,doc: data
				,schema: schema
			});
		};
		
		function onDisplayed($sElem, data, schema, opt_){
			if( _this.classDisplayFunctions ) {
				for(var className in _this.classDisplayFunctions){
					var fn = _this.classDisplayFunctions[className];
					var jqCallback = eachFunctionForClass(className, fn, data, opt);
					$sElem.find('.'+className).each(jqCallback);
				};
			};
		};

		function eachFunctionForClass(className, fn, data, opt){
			return function(){
				var $jq = $(this);
				fn(data, $jq, opt);
				$jq.removeClass(className);
			};
		};
	}
	
	,_addButtons: function($elem, data, opt_) {
		var _this = this;
		
		var opt = $n2.extend({
			schema: null
			,focus: false
			,related: false
			,reply: false
			,geom: false
			,edit: false
			,'delete': false
			,addLayer: false
			,treeView: false
			,simplifiedGeoms: false
		},opt_);

		var $buttons = $('<div></div>');
		$buttons.addClass('n2Display_buttons');
		$buttons.addClass('n2Display_buttons_'+$n2.utils.stringToHtmlId(data._id));
		$elem.append( $buttons );
		
		var optionClass = 'options';
		if( opt.focus ) optionClass += '_focus';
		if( opt.edit ) optionClass += '_edit';
		if( opt.related ) optionClass += '_related';
		if( opt.reply ) optionClass += '_reply';
		if( opt.geom ) optionClass += '_geom';
		if( opt['delete'] ) optionClass += '_delete';
		if( opt.addLayer ) optionClass += '_addLayer';
		if( opt.treeView ) optionClass += '_treeView';
		if( opt.simplifiedGeoms ) optionClass += '_simplifiedGeoms';
		$buttons.addClass(optionClass);

		var opts = {
			doc: data
			,schema: opt.schema
			,focus: opt.focus
			,edit: opt.edit
			,related: opt.related
			,reply: opt.reply
			,geom: opt.geom
			,addLayer: opt.addLayer
			,treeView: opt.treeView
			,simplifiedGeoms: opt.simplifiedGeoms
		};
		opts['delete'] = opt['delete'];
		this._displayButtons($buttons, opts);
	}
	
	,_refreshButtons: function($elem){
		var _this = this;
		
		var docId = null;
		var fFocus = false;
		var fEdit = false;
		var fRelated = false;
		var fReply = false;
		var fGeom = false;
		var fDelete = false;
		var fAddLayer = false;
		var fTreeView = false;
		var fSimplifiedGeoms = false;
		var classAttr = $elem.attr('class');
		var classes = classAttr.split(' ');
		for(var i=0,e=classes.length; i<e; ++i){
			var className = classes[i];
			if( startsWith(className,'n2Display_buttons_') ){
				var escapedDocId = className.substr('n2Display_buttons_'.length);
				docId = $n2.utils.unescapeHtmlId(escapedDocId);
				
			} else if( startsWith(className,'options') ){
				var options = className.split('_');
				for(var j=0,k=options.length; j<k; ++j){
					var o = options[j];
					if( 'focus' === o ){ fFocus = true; }
					else if( 'edit' === o ){ fEdit = true; }
					else if( 'related' === o ){ fRelated = true; }
					else if( 'reply' === o ){ fReply = true; }
					else if( 'geom' === o ){ fGeom = true; }
					else if( 'addLayer' === o ){ fAddLayer = true; }
					else if( 'treeView' === o ){ fTreeView = true; }
					else if( 'simplifiedGeoms' === o ){ fSimplifiedGeoms = true; }
					else if( 'delete' === o ){ fDelete = true; };
				};
			};
		};
		
		if( docId ){
			this.documentSource.getDocument({
				docId: docId
				,onSuccess: getSchema
				,onError:function(){}
			});
		};
		
		function getSchema(doc){
			if( doc.nunaliit_schema ) {
				var schemaRepository = _this.schemaRepository;
				if( schemaRepository ) {
					schemaRepository.getSchema({
						name: doc.nunaliit_schema
						,onSuccess: function(schema) {
							drawButtons(doc,schema);
						}
						,onError: function(){
							drawButtons(doc,null);
						}
					});
					
				} else {
					drawButtons(doc,null);
				};
				
			} else {
				drawButtons(doc,null);
			};
		};
		
		function drawButtons(doc,schema){
			var opts = {
				doc: doc
				,schema: schema
				,focus: fFocus
				,edit: fEdit
				,related: fRelated
				,reply: fReply
				,geom: fGeom
				,addLayer: fAddLayer
				,treeView: fTreeView
				,simplifiedGeoms: fSimplifiedGeoms
			};
			opts['delete'] = fDelete;
			$elem.empty();
			_this._displayButtons($elem, opts);
		};
	}
	
	,_displayButtons: function($buttons, opt){

		var _this = this;
		var data = opt.doc;
		var schema = opt.schema;
		
		var buttonDisplay = new ButtonDisplay();
		
		var dispatcher = this.dispatchService;
		var schemaRepository = _this.schemaRepository;

 		// Show 'focus' button
 		if( opt.focus 
 		 && data
 		 && data._id ) {
 			buttonDisplay.drawButton({
 				elem: $buttons
 				,name: 'more_info'
 				,label: _loc('More Info')
 				,click: function(){
 					_this._dispatch({
 						type:'userSelect'
 						,docId: data._id
 					});
 				}
 			});
 		};

 		// Show 'edit' button
 		if( opt.edit 
 		 && $n2.couchMap.canEditDoc(data) ) {
 			buttonDisplay.drawButton({
 				elem: $buttons
 				,name: 'edit'
 				,label: _loc('Edit')
 				,click: function(){
 					_this._performDocumentEdit(data, opt);
 				}
 			});
 		};

 		// Show 'delete' button
 		if( opt['delete'] 
 		 && $n2.couchMap.canDeleteDoc(data) ) {
 			buttonDisplay.drawButton({
 				elem: $buttons
 				,name: 'delete'
 				,label: _loc('Delete')
 				,click: function(){
 					_this._performDocumentDelete(data, opt);
 				}
 			});
 		};
		
 		// Show 'add related' button
		if( opt.related
		 && this.displayRelatedInfoProcess ) {
 			this.displayRelatedInfoProcess.addButton({
 				display: this
 				,div: $buttons[0]
 				,doc: data
 				,schema: opt.schema
 				,buttonDisplay: buttonDisplay
 			});
 		};
		
 		// Show 'reply' button
		if( opt.reply
		 && opt.schema
		 && opt.schema.options 
		 && opt.schema.options.enableReplies
		 ) {
			var showReplyButton = true;
			if( this.restrictReplyButtonToLoggedIn ){
				var isLoggedInMsg = {
					type: 'authIsLoggedIn'
					,isLoggedIn: false
				};
				if( dispatcher ){
					dispatcher.synchronousCall(DH,isLoggedInMsg);
				};
				if( !isLoggedInMsg.isLoggedIn ) {
					showReplyButton = false;
				};
			};
			
			if( showReplyButton ) {
	 			buttonDisplay.drawButton({
	 				elem: $buttons
	 				,name: 'reply'
	 				,label: _loc('Reply')
	 				,click: function(){
						_this._replyToDocument(data, opt.schema);
	 				}
	 			});
			};
		};
		
 		// Show 'find on map' button
		if( data ) {
			var $findGeomButton = buttonDisplay.drawButton({
 				elem: $buttons
 				,name: 'find_on_map'
 				,label: _loc('Find on Map')
 				,click: function(){
 					_this._dispatch({
 						type: 'find'
 						,docId: data._id
 						,doc: data
 					});
 				}
 			});
			
			this.showService.showFindAvailable({
				elem: $findGeomButton
				,doc: data
			});
		};

		// Show 'Add Layer' button
		if( opt.addLayer
		 && data
		 && data.nunaliit_layer_definition
		 && dispatcher
		 && dispatcher.isEventTypeRegistered('addLayerToMap')
		 ) {
 			buttonDisplay.drawButton({
 				elem: $buttons
 				,name: 'add_layer'
 				,label: _loc('Add Layer')
 				,click: function(){
 					var layerDefinition = data.nunaliit_layer_definition;
 					var layerId = layerDefinition.id;
 					if( !layerId ){
 						layerId = data._id;
 					};
 					var layerDef = {
 						name: layerDefinition.name
 						,type: 'couchdb'
 						,options: {
 							layerName: layerId
 							,documentSource: _this.documentSource
 						}
 					};

 					_this._dispatch({
 						type: 'addLayerToMap'
 						,layer: layerDef
 						,options: {
 							setExtent: {
 								bounds: layerDefinition.bbox
 								,crs: 'EPSG:4326'
 							}
 						}
 					});
 				}
 			});
		};

		// Show 'Tree View' button
		if( opt.treeView
		 && data
		 ) {
 			buttonDisplay.drawButton({
 				elem: $buttons
 				,name: 'tree_view'
 				,label: _loc('Tree View')
 				,click: function(){
					_this._performDocumentTreeView(data);
 				}
 			});
		};

		// Show 'Simplified Geoms' button
		if( opt.simplifiedGeoms
		 && data
		 && data.nunaliit_geom
		 ) {
 			buttonDisplay.drawButton({
 				elem: $buttons
 				,name: 'simplified_geoms'
 				,label: _loc('Geometries')
 				,click: function(){
					_this._performSimplifiedGeometries(data);
 				}
 			});
		};
	}
	
	,_addAttachmentProgress: function($elem, data){
		var $progress = $('<div></div>')
			.addClass('n2Display_attProgress')
			.addClass('n2Display_attProgress_'+$n2.utils.stringToHtmlId(data._id) )
			.appendTo( $elem );
		
		this._refreshAttachmentProgress($progress, data);
	}
	
	,_refreshAttachmentProgress: function($progress, data){

		var status = null;
		
		$progress.empty();

		// Display a preview of local Cordova attachments
		if (window.cordova && data.nunaliit_mobile_attachments) {
			var lastSlashIndex = data.nunaliit_mobile_attachments.lastIndexOf('/');
			var filename = data.nunaliit_mobile_attachments.substring(lastSlashIndex + 1);
			$('<p>1 mobile attachment: ' + filename + '</p>')
				.appendTo($progress);

			window.resolveLocalFileSystemURL('file:' + data.nunaliit_mobile_attachments, 
				function(fileEntry) {
					fileEntry.file(function(file) {
						if (file && file.type) {
							if (file.type.startsWith('image')) {
								// If the file is an image, display it
								$('<img>', {src: data.nunaliit_mobile_attachments})
									.addClass('n2Display_cordovaImgAttachmentPreview')
									.on('error', function() { 
										$(this).hide();
									})
									.appendTo($progress);
							} else {
								var $previewButtton = $('<label>')
									.addClass('cordova-btn cordova-preview-button icon-preview width-100')
									.appendTo($progress)
									.text(_loc('Preview'))
									.click(function(event) {
										event.preventDefault();
										// Try to open it using a plugin
										window.cordova.plugins.fileOpener2.open(
											data.nunaliit_mobile_attachments,
											file.type, {
												error : function(error) { console.error('Error opening file', file); }, 
												success : function() { console.log('Opening file', file); } 
											});
									});
							}
						} 
					});
				});
		}
		
		// Find an attachment which is in progress
		if( data.nunaliit_attachments 
		 && data.nunaliit_attachments.files ){
			for(var attName in data.nunaliit_attachments.files){
				var att = data.nunaliit_attachments.files[attName];
				
				// Skip non-original attachments
				if( !att.source ){
					if( att.status 
					 && 'attached' !== att.status ){
						// OK, progress must be reported. Accumulate
						// various status since there could be more than
						// one attachment.
						if( !status ){
							status = {};
						};
						status[att.status] = true;
					};
				};
			};
		};

		// Report status
		if( status ){
			var $outer = $('<div></div>')
				.addClass('n2Display_attProgress_outer')
				.appendTo($progress);

			$('<div></div>')
				.addClass('n2Display_attProgress_icon')
				.appendTo($outer);
		
			if( status['waiting for approval'] ){
				$outer.addClass('n2Display_attProgress_waiting');
				
				$('<div></div>')
					.addClass('n2Display_attProgress_message')
					.text( _loc('Attachment is waiting for approval') )
					.appendTo($outer);
				
			} else if( status['denied'] ){
				$outer.addClass('n2Display_attProgress_denied');
				
				$('<div></div>')
					.addClass('n2Display_attProgress_message')
					.text( _loc('Attachment has been denied') )
					.appendTo($outer);
				
			} else {
				// Robot is working
				$outer.addClass('n2Display_attProgress_busy');
				
				$('<div></div>')
					.addClass('n2Display_attProgress_message')
					.text( _loc('Attachment is being processed') )
					.appendTo($outer);
			};

			$('<div></div>')
				.addClass('n2Display_attProgress_outer_end')
				.appendTo($outer);
		};
	}
	
	,_getAllReferences: function(opts_){
		var opts = $n2.extend({
			doc: null
			,onSuccess: function(refInfo){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var doc = opts.doc;
		
		// Keep track of docIds and associated schemas
		var refInfo = {};
		
		// Compute forward references
		var references = [];
		$n2.couchUtils.extractLinks(doc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			if( !refInfo[linkDocId] ){
				refInfo[linkDocId] = {};
			};
			refInfo[linkDocId].forward = true;
		};
		
		// Get identifiers of all documents that reference this one
		this.documentSource.getReferencesFromId({
			docId: doc._id
			,onSuccess: function(refIds){
				for(var i=0,e=refIds.length;i<e;++i){
					var id = refIds[i];
					if( !refInfo[id] ){
						refInfo[id] = {};
					};
					refInfo[id].reverse = true;
				};
				
				getRefSchemas();
			}
			,onError: getRefSchemas
		});

		function getRefSchemas(){
			var requestDocIds = [];
			for(var requestDocId in refInfo){
				requestDocIds.push(requestDocId);
			};

			if( requestDocIds.length > 0 ){
				_this.documentSource.getDocumentInfoFromIds({
					docIds: requestDocIds
					,onSuccess: function(infos){
						for(var i=0,e=infos.length;i<e;++i){
							var requestDocId = infos[i].id;
							
							refInfo[requestDocId].exists = true;
							if( infos[i].schema ) {
								refInfo[requestDocId].schema = infos[i].schema;
							};
						};
						
						opts.onSuccess(refInfo);
					}
					,onError: opts.onError
				});
			} else {
				opts.onSuccess(refInfo);
			};
		};
	}

	,_replyToDocument: function(doc, schema){
		var _this = this;
		
		this.createRelatedDocProcess.replyToDocument({
			doc: doc
			,schema: schema
			,onSuccess: function(docId){
			}
		});
	},
	
	/**
	 * This function refreshes the sections surrounding the display of a
	 * document, such as the buttons below the document displayed.
	 */
	_refreshDocument: function(doc){

		var _this = this;
		
		// Retrieve schema document
		var schemaRepository = this.schemaRepository;
		if( doc.nunaliit_schema && schemaRepository ) {
			schemaRepository.getSchema({
				name: doc.nunaliit_schema
				,onSuccess: function(schema) {
					refreshDocWithSchema(doc, schema);
				}
				,onError: function(){
					refreshDocWithSchema(doc, null);
				}
			});
		} else {
			refreshDocWithSchema(doc, null);
		};
	
		function refreshDocWithSchema(doc, schema){
			var docId = doc._id;

			// Refresh buttons under main document display
			$('.n2Display_buttons_'+$n2.utils.stringToHtmlId(docId)).each(function(){
				var $elem = $(this);
				_this._refreshButtons($elem);
			});
			
			$('.displayRelatedButton_'+$n2.utils.stringToHtmlId(docId)).each(function(){
				var $buttonDiv = $(this);
				$buttonDiv.empty();
				_this._addButtons($buttonDiv, doc, {
					schema: schema
					,focus: true
					,geom: true
					,reply: true
					,treeView: true
					,simplifiedGeoms: true
				});
			});
			
			$('.n2Display_attProgress_'+$n2.utils.stringToHtmlId(docId)).each(function(){
				var $progress = $(this);
				_this._refreshAttachmentProgress($progress,doc);
			});
			
			if( _this._shouldSuppressNonApprovedMedia() ){
				if( $n2.couchMap.documentContainsMedia(doc) 
				 && false == $n2.couchMap.documentContainsApprovedMedia(doc) ) {
					$('.n2SupressNonApprovedMedia_'+$n2.utils.stringToHtmlId(docId)).each(function(){
						var $div = $(this);
						var $parent = $div.parent();
						$div.remove();
						_this._fixDocumentList($parent);
					});
				};
			} else if( _this._shouldSuppressDeniedMedia() ){
				if( $n2.couchMap.documentContainsMedia(doc) 
				 && $n2.couchMap.documentContainsDeniedMedia(doc) ) {
					$('.n2SupressDeniedMedia_'+$n2.utils.stringToHtmlId(docId)).each(function(){
						var $div = $(this);
						var $parent = $div.parent();
						$div.remove();
						_this._fixDocumentList($parent);
					});
				};
			};
		};
	},
	
	/**
	 * This function replaces a section that is waiting for the
	 * appearance of a document. It replaces the section with an
	 * actual display of the document.
	 */
	_populateWaitingDocument: function(doc){
		var _this = this;
		
		if( doc ) {
			var docId = doc._id;
			var escaped = $n2.utils.stringToHtmlId(docId);
			var cName = 'couchDisplayWait_'+escaped;
			$('.'+cName).each(function(){
				var $set = $(this);
				$set
					.removeClass(cName)
					.addClass('couchDisplayAdded_'+escaped);
				_this._displayDocument($set, doc);
			});
		};
	}
	
	,_fixDocumentList: function($elem){
		if( $elem.hasClass('_n2DocumentListParent') ) {
			var $relatedDiv = $elem;
		} else {
			$relatedDiv = $elem.parents('._n2DocumentListParent');
		};
		if( $relatedDiv.length > 0 ){
			var $docDiv = $relatedDiv.find('._n2DocumentListEntry');
			var count = $docDiv.length;
			$relatedDiv.find('._n2DisplayDocCount').text(''+count);
			
			$docDiv.each(function(i){
				var $doc = $(this);
				$doc.removeClass('olkitSearchMod2_0');
				$doc.removeClass('olkitSearchMod2_1');
				$doc.addClass('olkitSearchMod2_'+(i%2));
			});
		};
	}
	
	,_performDocumentEdit: function(data, options_) {
		var _this = this;
		
		this.documentSource.getDocument({
			docId: data._id
			,onSuccess: function(doc){
				_this._dispatch({
					type: 'editInitiate'
					,doc: doc
				});
			}
			,onError: function(errorMsg){
				$n2.log('Unable to load document: '+errorMsg);
			}
		});
	}
	
	,_performDocumentDelete: function(data, options_) {
		var _this = this;

		if( confirm( _loc('You are about to delete this document. Do you want to proceed?') ) ) {
			this.documentSource.deleteDocument({
				doc: data
				,onSuccess: function() {
					if( options_.onDeleted ) {
						options_.onDeleted();
					};
				}
			});
		};
	}
	
	,_performDocumentTreeView: function(data) {
		new TreeDocumentViewer({
			doc: data
		});
	}
	
	,_performSimplifiedGeometries: function(doc){
		var contentId = $n2.getUniqueId();
		
		if( doc 
		 && doc.nunaliit_geom 
		 && doc.nunaliit_geom.wkt ){
			var geometries = [];
			
			// Inline
			geometries.push({
				label: _loc('Inline')
				,wkt: doc.nunaliit_geom.wkt
			});
			if( doc.nunaliit_geom.simplified 
			 && doc.nunaliit_geom.simplified.reported_resolution ){
				geometries[0].resolution = doc.nunaliit_geom.simplified.reported_resolution;
			};

			if( doc.nunaliit_geom.simplified ){
				
				var simplified = doc.nunaliit_geom.simplified;
				if( simplified.original ){
					var url = this.documentSource.getDocumentAttachmentUrl(doc,simplified.original);
					geometries.push({
						label: _loc('Original')
						,url: url
						,attName: simplified.original
					});
				};
				
				if( simplified.resolutions ){
					var resolutions = [];
					for(var attName in simplified.resolutions){
						var res = simplified.resolutions[attName];
						var url = this.documentSource.getDocumentAttachmentUrl(doc,attName);
						resolutions.push({
							label: _loc('Resolution')
							,url: url
							,attName: attName
							,resolution: res
						});
					};
					resolutions.sort(function(a,b){
						if( a.resolution < b.resolution ) return -1;
						if( a.resolution > b.resolution ) return 1;
						return 0;
					});
					
					for(var i=0,e=resolutions.length; i<e; ++i){
						geometries.push( resolutions[i] );
					};
				};
			};
			
			var $content = $('<div>')
				.attr('id', contentId)
				;
			
			display($content);
			
			$content.dialog({
				autoOpen: true
				,title: _loc('Geometries')
				,modal: true
				,width: 600
				,close: function(event, ui){
					var diag = $(event.target);
					diag.dialog('destroy');
					diag.remove();
				}
			});

			// Request attachments
			for(var i=0,e=geometries.length; i<e; ++i){
				var geometry = geometries[i];
				if( geometry.url && geometry.attName ){
					loadAttachment(geometry.attName, geometry.url);
				};
			};
		};
		
		function display($content){
			
			if( !$content ){
				$content = $('#'+contentId);
			};

			$content.empty();
			
			for(var i=0,e=geometries.length; i<e; ++i){
				var geometry = geometries[i];

				var heading = geometry.label;
				if( geometry.resolution ){
					heading += ' - ' + geometry.resolution;
				};
				if( geometry.attName ){
					heading += ' - ' + geometry.attName;
				};
				
				$('<div>')
					.addClass('n2display_geometries_heading')
					.text( heading )
					.appendTo($content);
	
				if( geometry.wkt ){
					var wkt = geometry.wkt + ' ['+geometry.wkt.length+']';
					$('<div>')
						.addClass('n2display_geometries_wkt')
						.text( wkt )
						.appendTo($content);
				};
			};
		};
		
		function loadAttachment(attName, url){
			$.ajax({
				url: url
				,dataType: 'text'
				,success: function(wkt){
					for(var i=0,e=geometries.length; i<e; ++i){
						var geometry = geometries[i];
						if( geometry.attName === attName ){
							geometry.wkt = wkt;
						};
					};
					
					display();
				}
			});
		};
	}
	
	,_displayDocumentId: function($set, docId) {

		var _this = this;
		
		$set.empty();

		this.documentSource.getDocument({
			docId: docId
			,onSuccess: function(doc) {
				_this._displayDocument($set, doc);
			}
			,onError: function(err) {
				$set.empty();
				$('<div>')
					.addClass('couchDisplayWait_'+$n2.utils.stringToHtmlId(docId))
					.text( _loc('Unable to retrieve document') )
					.appendTo($set);
			}
		});
	}
	
	,_handleDispatch: function(msg, addr, dispatcher){
		var _this = this;
		
		var $div = this._getDisplayDiv();
		if( $div.length < 1 ){
			// No longer displaying. Un-register this event.
			dispatcher.deregister(addr);
			return;
		};
		
		// Selected document
		if( msg.type === 'selected' ) {
			if( msg.doc ) {
				this._displayDocument($div, msg.doc);
				
			} else if( msg.docId ) {
				this._displayDocumentId($div, msg.docId);
				
			} else if( msg.docs ) {
				this._displayMultipleDocuments($div, msg.docs);
				
			} else if( msg.docIds ) {
				$div.empty();
				this._displayMultipleDocumentIds($div, msg.docIds)
			};
			
		} else if( msg.type === 'searchResults' ) {
			this._displaySearchResults(msg.results);
			
		} else if( msg.type === 'documentDeleted' ) {
			var docId = msg.docId;
			this._handleDocumentDeletion(docId);
			
		} else if( msg.type === 'authLoggedIn' 
			|| msg.type === 'authLoggedOut' ) {
			$('.n2Display_buttons').each(function(){
				var $elem = $(this);
				_this._refreshButtons($elem);
			});
			
		} else if( msg.type === 'editClosed' ) {
			var deleted = msg.deleted;
			if( !deleted ) {
				var doc = msg.doc;
				if( doc ) {
					this._displayDocument($div, doc);
				};
			};
			
		} else if( msg.type === 'documentContentCreated' ) {
			this._handleDocumentCreation(msg.doc);
			this._populateWaitingDocument(msg.doc);
			
		} else if( msg.type === 'documentContentUpdated' ) {
			this._refreshDocument(msg.doc);
			this._populateWaitingDocument(msg.doc);
		};
	}
	
	,_displayMultipleDocuments: function($container, docs) {

		var _this = this;
		
		var $list = $('<div class="_n2DocumentListParent"></div>');
		$container
			.empty()
			.append($list);
		
		for(var i=0,e=docs.length; i<e; ++i) {
			var doc = docs[i];
			var docId = doc._id;
			
			var $div = $('<div></div>')
				.addClass('_n2DocumentListEntry')
				.addClass('_n2DocumentListEntry_'+$n2.utils.stringToHtmlId(docId))
				.addClass('olkitSearchMod2_'+(i%2))
				.addClass('n2SupressNonApprovedMedia_'+$n2.utils.stringToHtmlId(docId))
				.addClass('n2SupressDeniedMedia_'+$n2.utils.stringToHtmlId(docId))
				;
			$list.append($div);

			var $contentDiv = $('<div class="n2s_handleHover"></div>');
			$div.append($contentDiv);
			this.showService.displayBriefDescription($contentDiv, {}, doc);

			var $buttonDiv = $('<div></div>');
			$div.append($buttonDiv);
			this._addButtons($buttonDiv, doc, {focus:true,geom:true});
		};
	}

	,_displayMultipleDocumentIds: function($container, docIds) {

		var _this = this;
		
		var $list = $('<div class="_n2DocumentListParent"></div>');
		$container
			.empty()
			.append($list);
		
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			
			var $div = $('<div></div>')
				.addClass('_n2DocumentListEntry')
				.addClass('_n2DocumentListEntry_'+$n2.utils.stringToHtmlId(docId))
				.addClass('olkitSearchMod2_'+(i%2))
				.addClass('n2SupressNonApprovedMedia_'+$n2.utils.stringToHtmlId(docId))
				.addClass('n2SupressDeniedMedia_'+$n2.utils.stringToHtmlId(docId))
				;
			$list.append($div);

			var $contentDiv = $('<div class="n2s_handleHover"></div>');
			$div.append($contentDiv);
			this.showService.printBriefDescription($contentDiv, docId);
			
			if( this.requestService ) {
				var $progressDiv = $('<div class="n2Display_attProgress n2Display_attProgress_'+$n2.utils.stringToHtmlId(docId)+'"></div>');
				$div.append($progressDiv);

				var $buttonDiv = $('<div class="displayRelatedButton displayRelatedButton_'+$n2.utils.stringToHtmlId(docId)+'"></div>');
				$div.append($buttonDiv);
				
				this.requestService.requestDocument(docId);
			};
		};
	}
	
	,_displaySearchResults: function(results){
		var ids = [];
		if( results && results.sorted && results.sorted.length ) {
			for(var i=0,e=results.sorted.length; i<e; ++i){
				ids.push(results.sorted[i].id);
			};
		};
		var $div = this._getDisplayDiv();
		$div.empty();
		if( ids.length < 1 ) {
			$div.append( $('<div>'+_loc('Search results empty')+'</div>') );
		} else {
			var $results = $('<div class="n2_search_result"></div>')
				.appendTo($div);
			this._displayMultipleDocumentIds($results, ids);
		};
	}
	
	,_dispatch: function(m){
		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			dispatcher.send(DH,m);
		};
	}
	
	,_handleDocumentDeletion: function(docId){
		var _this = this;
		
		// Main document displayed
		var $elems = $('.couchDisplay_'+$n2.utils.stringToHtmlId(docId));
		$elems.remove();
		
		// Document waiting to be displayed
		var $elems = $('.couchDisplayWait_'+$n2.utils.stringToHtmlId(docId));
		$elems.remove();
		
		// Documents in list
		var $entries = $('._n2DocumentListEntry_'+$n2.utils.stringToHtmlId(docId));
		$entries.each(function(){
			var $entry = $(this);
			var $p = $entry.parent();
			$entry.remove();
			_this._fixDocumentList($p);
		});
		
	}
	
	,_handleDocumentCreation: function(doc){
		var _this = this;
		
		// Find all documents referenced by this one
		var links = [];
		$n2.couchUtils.extractLinks(doc, links);
		for(var i=0,e=links.length;i<e;++i){
			var refDocId = links[i].doc;
			if( refDocId ){
				// Check if we have a related document section displayed for
				// this referenced document
				var $elems = $('.couchDisplayRelated_'+$n2.utils.stringToHtmlId(refDocId));
				if( $elems.length > 0 ){
					// We must redisplay this related info section
					refreshRelatedInfo(refDocId, $elems);
				};
			};
		};

		function refreshRelatedInfo(docId, $elems) {
			// Get document
			var request = _this.requestService;
			if( request ){
				request.requestDocument(docId,function(d){
					loadedData(d, $elems);
				});
			};
		};
		
		function loadedData(data, $elems) {
			// Get schema
			var schemaName = data.nunaliit_schema ? data.nunaliit_schema : null;
			var schemaRepository = _this.schemaRepository;
			if( schemaName && schemaRepository ) {
				schemaRepository.getSchema({
					name: schemaName
					,onSuccess: function(schema) {
						loadedSchema(data, schema, $elems);
					}
					,onError: function(){
						loadedSchema(data, null, $elems);
					}
				});
			} else {
				loadedSchema(data, null, $elems);
			};
		};
		
		function loadedSchema(data, schema, $elems){
			$elems.each(function(){
				var $e = $(this);
				// Refresh
				$e.empty();
				_this.displayRelatedInfoProcess.display({
					div: $e
					,display: _this
					,doc: data
					,schema: schema
				});
			});
		};
	}
});

//===================================================================================

var LegacyDisplayRelatedFunctionAdapter = $n2.Class({
	legacyFunction: null,
	
	initialize: function(legacyFunction){
		this.legacyFunction = legacyFunction;
	},
	
	display: function(opts_){
		return this.legacyFunction(opts_);
	},
	
	addButton: function(opts_){
		var opts = $n2.extend({
			display: null
			,div: null
			,doc: null
			,schema: null
		},opts_);
		
		var display = opts.display;
		var doc = opts.doc;
		var $buttons = $(opts.div);
		var createRelatedDocProcess = display.createRelatedDocProcess;
		
		var $placeHolder = $('<span>')
			.appendTo($buttons);
		
		createRelatedDocProcess.insertAddRelatedSelection({
			placeHolderElem: $placeHolder
			,doc: doc
			,onElementCreated: function($addRelatedButton){
				$addRelatedButton.addClass('nunaliit_form_link');
				$addRelatedButton.addClass('nunaliit_form_link_add_related_item');
				
				$addRelatedButton.menuselector();
			}
			,onRelatedDocumentCreated: function(docId){}
		});
	}
});

//===================================================================================

function _displayRelatedDocuments(display_, contId, relatedSchemaName, relatedDocIds){
	var $container = $('#'+contId);
	
	if( !relatedDocIds || relatedDocIds.length < 1 ) {
		$container.remove();
		return;
	};
	
	var blindId = $n2.getUniqueId();
	var $blindWidget = $('<div id="'+blindId+'" class="_n2DocumentListParent"><h3></h3><div style="padding-left:0px;padding-right:0px;"></div></div>');
	$container.append($blindWidget);
	var bw = $n2.blindWidget($blindWidget,{
		data: relatedDocIds
		,onBeforeOpen: beforeOpen
	});
	bw.setHtml('<span class="_n2DisplaySchemaName"></span> (<span class="_n2DisplayDocCount"></span>)');
	if( null == relatedSchemaName ) {
		$blindWidget.find('._n2DisplaySchemaName').text( _loc('Uncategorized') );
	} else {
		$blindWidget.find('._n2DisplaySchemaName').text(relatedSchemaName);
	};
	$blindWidget.find('._n2DisplayDocCount').text(''+relatedDocIds.length);
	
	var schemaRepository = display_.schemaRepository;
	if( schemaRepository && relatedSchemaName ){
		schemaRepository.getSchema({
			name: relatedSchemaName
			,onSuccess: function(schema){
				var $blindWidget = $('#'+blindId);
				$blindWidget.find('._n2DisplaySchemaName').text( _loc(schema.getLabel()) );
			}
		});
	};

	function beforeOpen(info){
		var $div = info.content;
		
		var $dataloaded = $div.find('.___n2DataLoaded');
		if( $dataloaded.length > 0 ) {
			// nothing to do
			return;
		};
		
		// Fetch data
		var docIds = info.data;
		$div.empty();
		$div.append( $('<div class="___n2DataLoaded" style="display:none;"></div>') );
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			
			var $docWrapper = $('<div></div>');
			$div.append($docWrapper);
			if ( 0 === i ) { // mark first and last one
				$docWrapper.addClass('_n2DocumentListStart');
			};
			if ( (e-1) === i ) {
				$docWrapper.addClass('_n2DocumentListEnd');
			};
			$docWrapper
				.addClass('_n2DocumentListEntry')
				.addClass('_n2DocumentListEntry_'+$n2.utils.stringToHtmlId(docId))
				.addClass('olkitSearchMod2_'+(i%2))
				.addClass('n2SupressNonApprovedMedia_'+$n2.utils.stringToHtmlId(docId))
				.addClass('n2SupressDeniedMedia_'+$n2.utils.stringToHtmlId(docId))
				;
			
			var $doc = $('<div>')
				.addClass('n2s_handleHover')
				.appendTo($docWrapper);

			if( display_.showService ) {
				if( display_.displayBriefInRelatedInfo ){
					display_.showService.printBriefDescription($doc,docId);
				} else {
					display_.showService.printDocument($doc,docId);
				};
			} else {
				$doc.text(docId);
			};
			if( display_.requestService ) {
				var $progressDiv = $('<div class="n2Display_attProgress n2Display_attProgress_'+$n2.utils.stringToHtmlId(docId)+'"></div>');
				$docWrapper.append($progressDiv);

				var $buttonDiv = $('<div class="displayRelatedButton displayRelatedButton_'+$n2.utils.stringToHtmlId(docId)+'"></div>');
				$docWrapper.append($buttonDiv);
				
				display_.requestService.requestDocument(docId);
			};
		};
	};
};

function DisplayRelatedInfo(opts_){
	var opts = $n2.extend({
		divId: null
		,div: null
		,display: null
		,doc: null
		,schema: null
	},opts_);
	
	var doc = opts.doc;
	var docId = doc._id;
	var display = opts.display;
	var schema = opts.schema;
	
	var $elem = opts.div;
	if( ! $elem ) {
		$elem = $('#'+opts.divId);
	};
	if( ! $elem.length) {
		return;
	};
	
	if( !schema 
	 || !schema.relatedSchemaNames
	 || !schema.relatedSchemaNames.length ){
		return;
	};
	
	// Make a map of related schemas
	var schemaInfoByName = {};
	for(var i=0,e=schema.relatedSchemaNames.length; i<e; ++i){
		var relatedSchemaName = schema.relatedSchemaNames[i];
		schemaInfoByName[relatedSchemaName] = { docIds:[] };
	};

	// Get references
	display._getAllReferences({
		doc: doc
		,onSuccess: showSections
	});

	function showSections(refInfo){
		// Accumulate document ids under the associated schema
		for(var requestDocId in refInfo){
			if( refInfo[requestDocId].exists 
			 && refInfo[requestDocId].reverse
			 && refInfo[requestDocId].schema ) {
				var schemaName = refInfo[requestDocId].schema;
				var schemaInfo = schemaInfoByName[schemaName];
				if( schemaInfo ){
					schemaInfo.docIds.push(requestDocId);
				};
			};
		};

		// Add section with related documents
		for(var schemaName in schemaInfoByName){
			var schemaInfo = schemaInfoByName[schemaName];
			if( schemaInfo.docIds.length > 0 ) {
				var contId = $n2.getUniqueId();
				var $div = $('<div id="'+contId+'"></div>');
				$elem.append($div);

				var relatedDocIds = schemaInfo.docIds;
				
				_displayRelatedDocuments(display, contId, schemaName, relatedDocIds);
			};
		};
	};
};

//===================================================================================

function DisplayLinkedInfo(opts_){
	var opts = $n2.extend({
		divId: null
		,div: null
		,display: null
		,doc: null
		,schema: null
	},opts_);
	
	var display = opts.display;
	var doc = opts.doc;
	var docId = doc._id;
	
	var $elem = opts.div;
	if( ! $elem ) {
		$elem = $('#'+opts.divId);
	};
	if( ! $elem.length) {
		return;
	};

	// Get references
	display._getAllReferences({
		doc: doc
		,onSuccess: showSections
	});

	function showSections(refInfo){
		// Accumulate document ids under the associated schema
		var relatedDocsFromSchemas = {};
		var uncategorizedDocIds = [];
		for(var requestDocId in refInfo){
			if( refInfo[requestDocId].exists ) {
				var schemaName = refInfo[requestDocId].schema;
				
				if( schemaName ) {
					if( !relatedDocsFromSchemas[schemaName] ) {
						relatedDocsFromSchemas[schemaName] = {
							docIds: []
						};
					};
					relatedDocsFromSchemas[schemaName].docIds.push(requestDocId);
				} else {
					uncategorizedDocIds.push(requestDocId);
				};
			};
		};

		// Add section with related documents
		for(var schemaName in relatedDocsFromSchemas){
			var contId = $n2.getUniqueId();
			var $div = $('<div id="'+contId+'"></div>');
			$elem.append($div);

			var relatedDocIds = relatedDocsFromSchemas[schemaName].docIds;
			
			_displayRelatedDocuments(display, contId, schemaName, relatedDocIds);
		};
		
		// Add uncategorized
		if( uncategorizedDocIds.length > 0 ) {
			var contId = $n2.getUniqueId();
			var $div = $('<div id="'+contId+'"></div>');
			$elem.append($div);

			_displayRelatedDocuments(display, contId, null, uncategorizedDocIds);
		};
	};
};

//===================================================================================

var CommentRelatedInfo = $n2.Class({
	
	commentSchema: null,
	
	dispatchService: null,
	
	commentService: null,
	
	initialize: function(opts_){
		
		var opts = $n2.extend({
			schema: null
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.commentSchema = opts.schema;
		this.dispatchService = opts.dispatchService;
		
		if( this.dispatchService ){
			var m = {
				type: 'configurationGetCurrentSettings'
			};
			this.dispatchService.synchronousCall(DH, m);
			
			if( m.configuration && m.configuration.directory ){
				this.commentService = m.configuration.directory.commentService;
			};
		};
	},
	
	display: function(opts_){
		var opts = $n2.extend({
			divId: null
			,div: null
			,doc: null
		},opts_);
		
		var _this = this;

		if( !this.commentService ){
			$n2.log('Comment service not available for comment process');
			return;
		};
		
		// Set schema for comments
		if( this.commentSchema ){
			this.commentService.setCommentSchema(this.commentSchema);
		};
		
		var commentStreamDisplay = this.commentService.getCommentStreamDisplay();
		if( commentStreamDisplay ){
			commentStreamDisplay.display(opts_);
		};
	},
	
	addButton: function(opts_){
		var opts = $n2.extend({
			display: null
			,div: null
			,doc: null
			,schema: null
			,buttonDisplay: null
		},opts_);
		
		if( !this.commentService ){
			$n2.log('Comment service not available for comment process');
			return;
		};
		
		this.commentService.insertAddCommentButton({
			div: opts.div
			,doc: opts.doc
			,buttonDisplay: opts.buttonDisplay
		});
	}
});

//===================================================================================
// An instance of this class is used to draw a HTML button in the DOM structure.
var ButtonDisplay = $n2.Class({

	initialize: function(opts_){
		
	},
	
	drawButton: function(opts_){
		var opts = $n2.extend({
			// Location where button is to be drawn
			elem: null,
			
			// Name of button
			name: null,
			
			// Label is shown on the button
			label: null,
			
			// Function to be called when button is clicked
			click: null,
			
			// String. Class name to be added to button
			className: null,
			
			// Array of string. Class names to be added to button
			classNames: null
		},opts_);
		
		if( !opts.elem ){
			throw new Error('In ButtonDisplay.drawButton(), parameter "elem" must be provided');
		};
		
		var $elem = $(opts.elem);
		var name = opts.name;
		var label = opts.label;
		if( !label ){
			label = name;
		};
		
		var $linkButton = $('<a>')
			.attr('href','#')
			.appendTo($elem)
			.addClass('nunaliit_form_link')
			.click(wrapAndReturnFalse(opts.click));
		
		if( label ){
			$linkButton.text(label);
		};

		if( name ){
			var compactTag = name;
			var spaceIndex = compactTag.indexOf(' ');
			while (-1 !== spaceIndex) {
				compactTag = compactTag.slice(0,spaceIndex) + '_' +
					compactTag.slice(spaceIndex + 1);
				spaceIndex = compactTag.indexOf(' ');
			};
			$linkButton.addClass('nunaliit_form_link_' + compactTag.toLowerCase());
		};
		
		if( typeof opts.className === 'string' ){
			$linkButton.addClass(opts.className);
		};
		
		if( $n2.isArray(opts.classNames) ){
			opts.classNames.forEach(function(className){
				if( typeof className === 'string' ){
					$linkButton.addClass(className);
				};
			});
		};
		
		return $linkButton;

		function wrapAndReturnFalse(callback){
			return function(){
				if( typeof callback === 'function' ){
					callback.apply(this,arguments);
				};
				return false;
			};
		};
	}
});

//===================================================================================

var TreeDocumentViewer = $n2.Class({
	
	doc: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			doc: null
		},opts_);
		
		this.doc = {};
		for(var key in opts.doc){
			if( key !== '__n2Source' ){
				this.doc[key] = opts.doc[key];
			};
		};
		
		this._display();
	},
	
	_display: function(){
		var $dialog = $('<div>')
			.addClass('n2Display_treeViewer_dialog');
		var diagId = $n2.utils.getElementIdentifier($dialog);
		
		var $container = $('<div>')
			.addClass('n2Display_treeViewer_content')
			.appendTo($dialog);
		
		new $n2.tree.ObjectTree($container, this.doc);
		
		var $buttons = $('<div>')
			.addClass('n2Display_treeViewer_buttons')
			.appendTo($dialog);
		
		$('<button>')
			.text( _loc('Close') )
			.appendTo($buttons)
			.click(function(){
				var $diag = $('#'+diagId);
				$diag.dialog('close');
				return false;
			});
		
		$dialog.dialog({
			autoOpen: true
			,title: _loc('Tree View')
			,modal: true
			,width: 370
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		});
	}
});

//===================================================================================
function HandleDisplayAvailableRequest(m){
	if( m.displayType === 'classic' ){
		m.isAvailable = true;
	};
};

function HandleDisplayRenderRequest(m){
	if( m.displayType === 'classic' ){
		var options = {};
		if( m.displayOptions ){
			for(var key in m.displayOptions){
				options[key] = m.displayOptions[key];
			};
		};
		
		options.documentSource = m.config.documentSource;
		options.displayPanelName = m.displayId;
		options.showService = m.config.directory.showService;
		options.uploadService = m.config.directory.uploadService;
		options.createDocProcess = m.config.directory.createDocProcess;
		options.serviceDirectory = m.config.directory;
		
		var displayControl = new Display(options);

		var defaultDisplaySchemaName = 'object';
		if( m.displayOptions && m.displayOptions.defaultSchemaName ){
			defaultDisplaySchemaName = m.displayOptions.defaultSchemaName;
		};
		m.config.directory.schemaRepository.getSchema({
			name: defaultDisplaySchemaName
			,onSuccess: function(schema){
				if( displayControl.setSchema ) {
					displayControl.setSchema(schema);
				};
			}
		});

		m.onSuccess(displayControl);
	};
};

//===================================================================================

// Exports
$n2.couchDisplay = {
	Display: Display,
	CommentRelatedInfo: CommentRelatedInfo,
	TreeDocumentViewer: TreeDocumentViewer
	,HandleDisplayAvailableRequest: HandleDisplayAvailableRequest
	,HandleDisplayRenderRequest: HandleDisplayRenderRequest
	,ButtonDisplay: ButtonDisplay
//	DisplayRelatedInfo: DisplayRelatedInfo,
//	DisplayLinkedInfo: DisplayLinkedInfo
	
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDisplayTiles.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

var DH = 'n2.couchDisplayTiles';

function docCreationTimeSort(lhs, rhs) {
	var timeLhs = 0;
	var timeRhs = 0;
	
	if( lhs && lhs.doc && lhs.doc.nunaliit_created && lhs.doc.nunaliit_created.time ) {
		timeLhs = lhs.doc.nunaliit_created.time;
	}
	if( rhs && rhs.doc && rhs.doc.nunaliit_created && rhs.doc.nunaliit_created.time ) {
		timeRhs = rhs.doc.nunaliit_created.time;
	}
	
	if( timeLhs < timeRhs ) return -1;
	if( timeLhs > timeRhs ) return 1;
	return 0;
};

function startsWith(s, prefix) {
	var left = s.substr(0,prefix.length);
	return (left === prefix);
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*
* Template for document display
*/
var GridTemplateDocument = $n2.Class({
	height: null,
	
	tileHeight: null,
	
	initialize: function(height, tileHeight){
		this.height = (height ? height : 0);
		this.tileHeight = (tileHeight ? tileHeight : 150);
	},
	
	get: function(numCols, targetTiles) {
		// Have space to grow
		targetTiles = targetTiles + 12;
		
      var numRows = Math.ceil(targetTiles / numCols),
	        rects = [],
	        x, y, i;
	
      var firstTileHeight = Math.max(1, Math.ceil(this.height / this.tileHeight));
      
      // First tile is 2x1
      var firstTileWidth = 2;
      rects.push(new Tiles.Rectangle(0, 0, firstTileWidth, firstTileHeight));
      
      x = firstTileWidth - 1;
      y = 0;
      
      for(i = 1; i<targetTiles; ++i){
      	x = x + 1;
      	while( x >= numCols ){
      		y = y + 1;
      		x = 0;
      		
      		if( y < firstTileHeight ){
      			x = firstTileWidth;
      		};
      	};
      	
          rects.push(new Tiles.Rectangle(x, y, 1, 1));
      };
	
	    return new Tiles.Template(rects, numCols, numRows);
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var TiledDisplay = $n2.Class({
	
	documentSource: null,
	
	displayPanelName: null,
	
	showService: null,
	
	requestService: null,
	
	schemaRepository: null,
	
	customService: null,
	
	dispatchService: null,
	
	boolOptions: null,
	
	restrictAddRelatedButtonToLoggedIn: null,
	
	currentDetails: null,
	
	displayedDocumentsOrder: null,
	
	displayedDocuments: null,
	
	grid: null,
	
	createDocProcess: null,
	
	defaultSchema: null,
	
	relatedDocumentDiscoveryProcess: null,
	
	documentInfoFunction: null,
	
	sortFunction: null,
	
	filterFactory: null,
	
	filter: null,
	
	hoverInFn: null,
	
	hoverOutFn: null,
	
	hoverDocId: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			documentSource: null
			,displayPanelName: null
			,showService: null
			,requestService: null
			,schemaRepository: null
			,customService: null
			,dispatchService: null
			,createDocProcess: null
			,displayRelatedInfoFunction: null
			
			// Boolean options
			,displayOnlyRelatedSchemas: false
			,displayBriefInRelatedInfo: false
			,restrictAddRelatedButtonToLoggedIn: false
			
			// Process used to discover related information from
			// a document
			,relatedDocumentDiscoveryProcess: null
			
			// Function to obtain document information structures based on
			// document ids
			,documentInfoFunction: null
			
			// Function to sort documents based on info structures
			,sortFunction: null
			
			// Factory to create filters
			,filterFactory: null
		}, opts_);
		
		var _this = this;
		
		/*
			currentDetails = {
				// single document selection
				docId // document identifier
				doc // document content
				schema // schema associated with the document
				height // last detected content height for current document
				referenceDocIds // doc ids of related info
				
				// multiple document selection
				docIds // document identifiers
				docs // map of document contents by id
			}
		 */
		this.currentDetails = {};
		/*
		 	displayedDocuments = {
		 		<doc-id>: {
		 			id: <doc-id>
		 			,info: <info object>
		 			,doc: <content>
		 		}
		 	}
		 */
		this.displayedDocuments = {};
		/*
		 	Array of document ids
		 */
		this.displayedDocumentsOrder = null;
		
		this.documentSource = opts.documentSource;
		this.displayPanelName = opts.displayPanelName;
		this.showService = opts.showService;
		this.requestService = opts.requestService;
		this.schemaRepository = opts.schemaRepository;
		this.customService = opts.customService;
		this.dispatchService = opts.dispatchService;
		this.createDocProcess = opts.createDocProcess;
		
		// Initialize display
		this._getDisplayDiv();
		
		// Boolean options
		this.boolOptions = {
			displayOnlyRelatedSchemas: opts.displayOnlyRelatedSchemas
			,displayBriefInRelatedInfo: opts.displayBriefInRelatedInfo
		};
		this.restrictAddRelatedButtonToLoggedIn = opts.restrictAddRelatedButtonToLoggedIn;
		if( !this.restrictAddRelatedButtonToLoggedIn 
		 && this.customService ){
			this.restrictAddRelatedButtonToLoggedIn = 
				this.customService.getOption('restrictAddRelatedButtonToLoggedIn',false);
		};

		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			var f = function(msg, addr, d){
				_this._handleDispatch(msg, addr, d);
			};
			dispatcher.register(DH, 'selected', f);
			dispatcher.register(DH, 'searchResults', f);
			dispatcher.register(DH, 'documentDeleted', f);
			dispatcher.register(DH, 'authLoggedIn', f);
			dispatcher.register(DH, 'authLoggedOut', f);
			dispatcher.register(DH, 'editClosed', f);
			dispatcher.register(DH, 'documentContent', f);
			dispatcher.register(DH, 'documentContentCreated', f);
			dispatcher.register(DH, 'documentContentUpdated', f);
		};
		
		if( !opts.displayRelatedInfoFunction ) {
			var flag = this._getBooleanOption('displayOnlyRelatedSchemas');
			if( flag ) {
				opts.displayRelatedInfoFunction = function(opts_){
					_this._displayRelatedInfo(opts_);
				};
			} else {
				opts.displayRelatedInfoFunction = function(opts_){
					_this._displayLinkedInfo(opts_);
				};
			};
		};
		
		// Related document discovery process
		this.relatedDocumentDiscoveryProcess = opts.relatedDocumentDiscoveryProcess;
		if( !this.relatedDocumentDiscoveryProcess 
		 && this.customService ){
			this.relatedDocumentDiscoveryProcess = 
				this.customService.getOption('relatedDocumentDiscoveryProcess',null);
		};
		if( !this.relatedDocumentDiscoveryProcess ){
			this.relatedDocumentDiscoveryProcess = new ReferenceRelatedDocumentDiscovery({
				documentSource: this.documentSource
			});
		};
		
		// Document info function
		this.documentInfoFunction = opts.documentInfoFunction;
		if( !this.documentInfoFunction 
		 && this.customService ){
			var docInfoFn = this.customService.getOption('displayDocumentInfoFunction');
			if( typeof docInfoFn === 'function' ){
				this.documentInfoFunction = docInfoFn;
			};
		};
		if( !this.documentInfoFunction ){
			this.documentInfoFunction = function(opts_){
				var opts = $n2.extend({
					docIds: null
					,display: null
					,onSuccess: function(docInfos){}
					,onError: function(err){}
				},opts_);
				
				var ds = opts.display.documentSource;
				ds.getDocumentInfoFromIds({
					docIds: opts.docIds
					,onSuccess: opts.onSuccess
					,onError: opts.onError
				});
			};
		};
		
		// Sort function
		this.sortFunction = opts.sortFunction;
		if( !this.sortFunction 
		 && this.customService ){
			var sortFn = this.customService.getOption('displaySortFunction');
			if( typeof sortFn === 'function' ){
				this.sortFunction = sortFn;
			};
		};
		if( !this.sortFunction ){
			this.sortFunction = function(infos){
				infos.sort(function(a,b){
					if( a.updatedTime && b.updatedTime ){
						if( a.updatedTime > b.updatedTime ){
							return -1;
						};
						if( a.updatedTime < b.updatedTime ){
							return 1;
						};
					};

					if( a.id > b.id ){
						return -1;
					};
					if( a.id < b.id ){
						return 1;
					};
					
					return 0;
				});
			};
		};
		
		// Filter factory
		this.filterFactory = opts.filterFactory;
		if( !this.filterFactory 
		 && this.customService ){
			var factory = this.customService.getOption('displayFilterFactory');
			if( factory && typeof factory.get === 'function' ){
				this.filterFactory = factory;
			};
		};
		if( !this.filterFactory ){
			this.filterFactory = new SchemaFilterFactory({
				schemaRepository: this.schemaRepository
			});
		};
		
		// Hover in and out
		this.hoverInFn = function(){
			var $tile = $(this);
			var docId = $tile.attr('n2DocId');
			if( docId && docId !== _this.hoverDocId ) {
				_this.hoverDocId = docId;
				_this._dispatch({
					type: 'userFocusOn'
					,docId: docId
				});
			};
		};
		this.hoverOutFn = function(){
			var $tile = $(this);
			var docId = $tile.attr('n2DocId');
			if( docId && docId === _this.hoverDocId ) {
				_this.hoverDocId = null;
				_this._dispatch({
					type: 'userFocusOff'
					,docId: docId
				});
			};
		};
		
		// Detect changes in displayed current content size
		var intervalID = window.setInterval(function(){
			var $set = _this._getDisplayDiv();
			if( $set.length < 0 ) {
				window.clearInterval(intervalID);
			} else {
				_this._performIntervalTask();
			};
		}, 500);

		$('body').addClass('n2_display_format_tiled');
		
		$n2.log('TiledDisplay',this);
	},

	// external
	setSchema: function(schema) {
		this.defaultSchema = schema;
	},
	
	_handleDispatch: function(msg, addr, dispatcher){
		var $div = this._getDisplayDiv();
		if( $div.length < 1 ){
			// No longer displaying. Un-register this event.
			dispatcher.deregister(addr);
			return;
		};
		
		// Selected document
		if( msg.type === 'selected' ) {
			if( msg.doc ) {
				this._displayDocument(msg.doc._id, msg.doc);
				
			} else if( msg.docId ) {
				this._displayDocument(msg.docId, null);
				
			} else if( msg.docs ) {
				var ids = [];
				for(var i=0, e=msg.docs.length; i<e; ++i){
					ids.push( msg.docs[i]._id );
				};
				this._displayMultipleDocuments(ids, msg.docs);
				
			} else if( msg.docIds ) {
				this._displayMultipleDocuments(msg.docIds, null);
			};
			
		} else if( msg.type === 'searchResults' ) {
			this._displaySearchResults(msg.results);
			
		} else if( msg.type === 'documentDeleted' ) {
//			var docId = msg.docId;
//			this._handleDocumentDeletion(docId);
			
		} else if( msg.type === 'authLoggedIn' 
			|| msg.type === 'authLoggedOut' ) {
			
			// Redisplay buttons
			if( this.currentDetails 
			 && this.currentDetails.docId 
			 && this.currentDetails.doc ){
				this._receiveDocumentContent(this.currentDetails.doc);
				this._displayDocumentButtons(this.currentDetails.doc, this.currentDetails.schema);
			};
			
		} else if( msg.type === 'editClosed' ) {
			var deleted = msg.deleted;
			if( !deleted ) {
				var doc = msg.doc;
				if( doc ) {
					this._displayDocument(doc._id, doc);
				};
			};
			
		} else if( msg.type === 'documentContent' ) {
			this._receiveDocumentContent(msg.doc);
			
		} else if( msg.type === 'documentContentCreated' ) {
			this._receiveDocumentContent(msg.doc);
			
		} else if( msg.type === 'documentContentUpdated' ) {
			this._receiveDocumentContent(msg.doc);
		};
	},
	
	_displayDocument: function(docId, doc) {

//		var _this = this;
		
		this._reclaimDisplayDiv();
		
		if( this.currentDetails
		 && this.currentDetails.docId === docId ){
			// Already in process of displaying this document
			return;
		};
		
		this.currentDetails = {
			docId: docId
		};

		this._addDisplayedDocument(docId, doc);

		var $set = this._getDisplayDiv();

		var $current = $set.find('.n2DisplayTiled_info');
		$current.hide();

		// Use template for document display
		this.grid.template = null;
		this.grid.templateFactory = new GridTemplateDocument();
		
		this._adjustCurrentTile(docId);
		
		// Request document
		if( doc ){
			this._receiveDocumentContent(doc);
		} else {
			this._requestDocumentWithId(docId);
		};
	},
	
	/*
	 * Accepts search results and display them in tiled mode
	 */
	_displaySearchResults: function(results){
		
		this._reclaimDisplayDiv();
		
		var ids = [];
		if( results && results.sorted && results.sorted.length ) {
			for(var i=0,e=results.sorted.length; i<e; ++i){
				ids.push(results.sorted[i].id);
			};
		};
		
		this._displayMultipleDocuments(ids, null);
		
		if( ids.length < 1 ){
			var $set = this._getDisplayDiv();
			var $current = $set.find('.n2DisplayTiled_info');
			$current
				.text( _loc('Empty search results') )
				.show();
		};
	},
	
	/*
	 * Displays multiple documents
	 */
	_displayMultipleDocuments: function(ids, docs){
		
		this._reclaimDisplayDiv();

		var $set = this._getDisplayDiv();
		var $current = $set.find('.n2DisplayTiled_info');
		$current.hide();
		
		this.currentDetails = {
			docIds: ids
			,docs: {}
		};
		
		// Use template for multiple documents display
		this.grid.template = null;
		this.grid.templateFactory = Tiles.UniformTemplates;
		
		this._adjustCurrentTile(null);
		
		var docsById = {};
		if( docs ){
			for(var i=0,e=docs.length; i<e; ++i){
				var doc = docs[i];
				this.currentDetails.docs[doc._id] = doc;
				docsById[doc._id] = doc;
			};
		};

		this._changeDisplayedDocuments(ids, docsById);
	},
	
	_displayDocumentButtons: function(doc, schema){
		
		var _this = this;
		
		if( doc 
		 && doc._id 
		 && this.currentDetails.docId === doc._id ){
			var $set = this._getDisplayDiv();
			var $btnDiv = $set.find('.n2DisplayTiled_current_buttons')
				.empty();

	 		// 'edit' button
	 		if( $n2.couchMap.canEditDoc(doc) ) {
	 			$('<a href="#"></a>')
	 				.addClass('n2DisplayTiled_current_button n2DisplayTiled_current_button_edit')
	 				.text( _loc('Edit') )
	 				.appendTo($btnDiv)
	 				.click(function(){
						_this._performDocumentEdit(doc);
						return false;
					});
	 		};

	 		// Show 'delete' button
	 		if( $n2.couchMap.canDeleteDoc(doc) ) {
	 			$('<a href="#"></a>')
	 				.addClass('n2DisplayTiled_current_button n2DisplayTiled_current_button_delete')
	 				.text( _loc('Delete') )
	 				.appendTo($btnDiv)
	 				.click(function(){
						_this._performDocumentDelete(doc);
						return false;
					});
	 		};
	
	 		// 'add related' button
			if( schema
			 && schema.relatedSchemaNames 
			 && schema.relatedSchemaNames.length
			 ) {
				var showAddRelatedButton = true;
				if( this.restrictAddRelatedButtonToLoggedIn ){
					var isLoggedIn = false;

					if( this.dispatchService ){
						var m = {
							type: 'authIsLoggedIn'
							,isLoggedIn: false
						};
						this.dispatchService.synchronousCall(DH,m);
						isLoggedIn = m.isLoggedIn;
					};
					
					if( !isLoggedIn ){
						showAddRelatedButton = false;
					};
				};
				
				if( showAddRelatedButton ) {
					var $placeHolder = $('<span>')
						.appendTo($btnDiv);
					this.createDocProcess.insertAddRelatedSelection({
						placeHolderElem: $placeHolder
						,doc: doc
						,onElementCreated: function($elem){
							$elem.addClass('n2DisplayTiled_current_button n2DisplayTiled_current_button_add_related_item');
						}
					});
				}; // show button
			};
			
	 		// Show 'find on map' button
			{
				var $findOnMapButton = $('<a href="#"></a>')
					.addClass('n2DisplayTiled_current_button n2DisplayTiled_current_button_find_on_map')
	 				.text( _loc('Find on Map') )
	 				.appendTo($btnDiv)
	 				.click(function(){
	 					_this._dispatch({
	 						type: 'find'
 							,docId: doc._id
 							,doc: doc
 						});
						return false;
					});
				
				this.showService.showFindAvailable({
					elem: $findOnMapButton
					,doc: doc
				});
			};

			// Show 'Add Layer' button
			if( doc
			 && doc.nunaliit_layer_definition
			 && this.dispatchService
			 && this.dispatchService.isEventTypeRegistered('addLayerToMap')
			 ) {
				$('<a href="#"></a>')
					.addClass('n2DisplayTiled_current_button n2DisplayTiled_current_button_add_layer')
	 				.text( _loc('Add Layer') )
	 				.appendTo($btnDiv)
	 				.click(function(){
	 					_this._performAddLayerToMap(doc);
						return false;
					});
			};

			// Show 'Tree View' button
			if( doc ) {
				$('<a href="#"></a>')
					.addClass('n2DisplayTiled_current_button n2DisplayTiled_current_button_tree_view')
	 				.text( _loc('Tree View') )
	 				.appendTo($btnDiv)
	 				.click(function(){
	 					_this._performTreeView(doc);
						return false;
					});
			};
		};
	},
	
	_currentDocReferencesUpdated: function(){
		if( this.currentDetails 
		 && this.currentDetails.doc 
		 && this.currentDetails.referenceDocIds ){
			// Accumulate all references
			var refDocIds = {};
			for(var i=0, e=this.currentDetails.referenceDocIds.length; i<e; ++i){
				var linkDocId = this.currentDetails.referenceDocIds[i];
				refDocIds[linkDocId] = true;
			};
			
			// Figure out information that must be removed
			var idsToRemove = [];
			for(var docId in this.displayedDocuments){
				if( docId === this.currentDetails.docId ) {
					// OK
				} else if( !refDocIds[docId] ){
					idsToRemove.push(docId);
				};
			};
			for(var i=0,e=idsToRemove.length; i<e; ++i){
				this._removeDisplayedDocument(idsToRemove[i]);
			};
			
			// Add new ones
			for(var docId in refDocIds){
				this._addDisplayedDocument(docId);
			};
			
			// Use dynamic sorting
			this.displayedDocumentsOrder = null;

			// Perform updates
			this._updateDisplayedDocuments();
		};
	},
	
	/*
	 * Verify information found in the instance variable displayedDocuments
	 * and affect the displaying accordingly
	 */
	_updateDisplayedDocuments: function(){
		var _this = this;
		
		// Get all the required info
		var neededInfoIds = [];
		for(var docId in this.displayedDocuments){
			if( !this.displayedDocuments[docId].info ) {
				neededInfoIds.push(docId);
			};
		};
		if( neededInfoIds.length > 0 ) {
			this.documentInfoFunction({
				docIds: neededInfoIds
				,display: this
				,onSuccess: function(docInfos){
					for(var i=0, e=docInfos.length; i<e; ++i){
						var docInfo = docInfos[i];
						var docId = docInfo.id;
						if( _this.displayedDocuments[docId] ){
							_this.displayedDocuments[docId].info = docInfo;
						};
					};
					performUpdate();
				}
				,onError: function(errorMsg){
					$n2.log('Unable to obtain document information',errorMsg);
				}
			});
		} else {
			performUpdate();
		};

		function performUpdate() {
			// Ensure we have display
			_this._getDisplayDiv();

			// Sort
			var sortedDocIds = null;
			if( _this.displayedDocumentsOrder ){
				sortedDocIds = _this.displayedDocumentsOrder;

				var infos = [];
				for(var i=0,e=sortedDocIds.length; i<e; ++i){
					var docId = sortedDocIds[i];
					if( _this.displayedDocuments[docId] 
					 && _this.displayedDocuments[docId].info ){
						infos.push( _this.displayedDocuments[docId].info );
					};
				};
				
				_this.filter.display(infos,_this);
				infos = _this.filter.filter(infos,_this);

				sortedDocIds = [];
				for(var i=0,e=infos.length; i<e; ++i){
					var info = infos[i];
					sortedDocIds.push(info.id);
				};
				
			} else {
				var infos = [];
				for(var docId in _this.displayedDocuments){
					if( _this.displayedDocuments[docId].info ){
						infos.push( _this.displayedDocuments[docId].info );
					};
				};

				_this.filter.display(infos,_this);
				infos = _this.filter.filter(infos,_this);
				
				_this.sortFunction(infos);

				var alreadySorted = {};
				sortedDocIds = [];
				if( _this.currentDetails
				 && _this.currentDetails.docId ){
					sortedDocIds.push(_this.currentDetails.docId);
					alreadySorted[_this.currentDetails.docId] = true;
				};
				
				for(var i=0,e=infos.length; i<e; ++i){
					var docId = infos[i].id;
					
					// Remove duplicates
					if( !alreadySorted[docId] ) {
						sortedDocIds.push(docId);
						alreadySorted[docId] = true;
					};
				};
			};
			
			_this.grid.updateTiles(sortedDocIds);
			_this.grid.isDirty = true; // force redraw to reflect change in order
            _this.grid.redraw(true);

            // Request content for documents
			for(var i=0,e=sortedDocIds.length; i<e; ++i){
				var docId = sortedDocIds[i];
				_this._requestDocumentWithId(docId);
			};
		};
	},
	
	/*
	 * Changes the list of displayed documents
	 */
	_changeDisplayedDocuments: function(docIds, docsById){
		var displayDocsByIds = {};
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			displayDocsByIds[docId] = true;
		};
		
		for(var docId in this.displayedDocuments){
			if( !displayDocsByIds[docId] ){
				this._removeDisplayedDocument(docId);
			};
		};
		
		for(var i=0,e=docIds.length; i<e; ++i){
			var docId = docIds[i];
			var doc = null;
			if( docsById && docsById[docId] ){
				doc = docsById[docId];
			};
			
			this._addDisplayedDocument(docId, doc);
		};
		
		this.displayedDocumentsOrder = docIds;
		
		this._updateDisplayedDocuments();
	},
	
	/*
	 * This function adds a new document to be displayed among the related items
	 * of the display. _updateDisplayedDocuments should be called, next.
	 */
	_addDisplayedDocument: function(docId, doc){
		if( !this.displayedDocuments[docId] ){
			this.displayedDocuments[docId] = {
				id: docId
			};
		};
		
		if( doc ){
			this.displayedDocuments[docId].doc = doc;
		};
	},
	
	/*
	 * This function removes the information relating to the document
	 * associated with the given document id. _updateDisplayedDocuments
	 * should be called, next.
	 */
	_removeDisplayedDocument: function(docId){
		// Remove information
		if( this.displayedDocuments[docId] ){
			delete this.displayedDocuments[docId];
		};
	},
	
	_receiveDocumentContent: function(doc){
		var _this = this;

		var $set = this._getDisplayDiv();
		
		var docId = doc._id;
		if( this.displayedDocuments[docId] ){
			// We are interested in this document. Save the content
			this.displayedDocuments[docId].doc = doc;
		};

		// Currently displayed document?
		if( doc._id === this.currentDetails.docId ){
			
			var update = false;
			
			if( !this.currentDetails.doc ) {
				// We do not yet have the content of the current document
				this.currentDetails.doc = doc;
				update = true;
				
			} else {
				// We already have the content. Check for update.
				
				if( doc._rev !== this.currentDetails.doc._rev ) {
					this.currentDetails.doc = doc;
					update = true;
				};
			};
			
			if( update ){
				// Renew related document ids
				this.relatedDocumentDiscoveryProcess.getRelatedDocumentIds({
					doc: doc
					,onSuccess: function(doc, refDocIds){
						if( _this.currentDetails.docId === doc._id ){
							_this.currentDetails.referenceDocIds = refDocIds;
							_this._currentDocReferencesUpdated();
						};
					}
					,onError: function(err){
						$n2.log('Error obtaining reference ids',err);
					}
				});
			};
		};
		
		// Display brief associated with the document
		var waitClassName = 'n2DisplayTiled_wait_brief_' + $n2.utils.stringToHtmlId(docId);
		$set.find('.'+waitClassName).each(function(){
			var $div = $(this);
			if( _this.showService ) {
				_this.showService.displayBriefDescription($div, {}, doc);
			};
			$div.removeClass(waitClassName);
		});
		
		// Display full document for currently selected document
		var waitClassName = 'n2DisplayTiled_wait_current_' + $n2.utils.stringToHtmlId(docId);
		var buttonClassName = 'n2DisplayTiled_current_buttons_' + $n2.utils.stringToHtmlId(docId);
		$set.find('.'+waitClassName).each(function(){
			var $div = $(this)
				.empty();

			$('<div>')
				.addClass('n2DisplayTiled_current_buttons')
				.addClass(buttonClassName)
				.appendTo($div);			

			var $content = $('<div>')
				.appendTo($div);
			if( _this.showService ) {
				_this.showService.displayDocument($content, {}, doc);
			} else {
				$content.text( doc._id );
			};
			
			$div.removeClass(waitClassName);
		});
		
		// Refresh buttons
		$('.'+buttonClassName).each(function(){
			var $div = $(this);
			
			_this._displayDocumentButtons(doc, _this.currentDetails.schema);
		});
		
		// Set tile classes based on media associated with document, and schema name
		var includesImage = false;
		var includesAudio = false;
		var includesVideo = false;
		var thumbnailName = null;
		var schemaName = null;
		if( doc.nunaliit_attachments 
		 && doc.nunaliit_attachments.files ){
			for(var attName in doc.nunaliit_attachments.files){
				var att = doc.nunaliit_attachments.files[attName];
				if( att.source ) {
					// discount thumbnails
				} else {
					if( 'image' === att.fileClass ) {
						includesImage = true;
					} else if( 'audio' === att.fileClass ) {
						includesAudio = true;
					} else if( 'video' === att.fileClass ) {
						includesVideo = true;
					};
					if( att.thumbnail ){
						thumbnailName = att.thumbnail;
					};
				};
			};
		};
		if( doc.nunaliit_schema ){
			schemaName = doc.nunaliit_schema;
		};
		$set.find('.n2DisplayTiled_tile_' + $n2.utils.stringToHtmlId(docId)).each(function(){
			var $tile = $(this);
			
			$tile.removeClass('n2DisplayTiled_tile_image n2DisplayTiled_tile_audio n2DisplayTiled_tile_video');
			if(includesVideo){
				$tile.addClass('n2DisplayTiled_tile_video');
			} else if(includesAudio){
				$tile.addClass('n2DisplayTiled_tile_audio');
			} else if(includesImage){
				$tile.addClass('n2DisplayTiled_tile_image');
			};
			
			if( schemaName ){
				$tile.addClass('n2DisplayTiled_tile_schema_'+$n2.utils.stringToHtmlId(schemaName));
			};
		});
		if( thumbnailName ){
			// Check that thumbnail is attached
			if( doc.nunaliit_attachments.files[thumbnailName]
			 && doc.nunaliit_attachments.files[thumbnailName].status === 'attached' ){
				// OK
			} else {
				thumbnailName = null;
			};
		};
		if( thumbnailName ){
			var url = this.documentSource.getDocumentAttachmentUrl(doc,thumbnailName);
			if( url ){
				$set.find('.n2DisplayTiled_wait_thumb_' + $n2.utils.stringToHtmlId(docId)).each(function(){
					var $div = $(this);
					$div.empty();
					$('<img>')
						.attr('src',url)
						.appendTo($div);
				});
			};
		};
		

		// Obtain the schema associated with the document
		if( doc.nunaliit_schema 
		 && this.schemaRepository ){
			this.schemaRepository.getSchema({
				name: doc.nunaliit_schema
				,onSuccess: function(schema){
					schemaLoaded(doc, schema);
				}
				,onError: function(err){
					schemaLoaded(doc, null);
				}
			});
		} else {
			schemaLoaded(doc, null);
		};
		
		// Check if the given document contains links to the currently
		// displayed document
		if( this.currentDetails.doc 
		 && doc._id !== this.currentDetails.docId ){
			
			this.relatedDocumentDiscoveryProcess.areDocumentsRelated({
				selectedDoc: this.currentDetails.doc
				,relatedDoc: doc
				,onRelated: function(selectedDoc, relatedDoc){
					// Check validity of callback
					if( selectedDoc._id === _this.currentDetails.docId ){
						var refIndex = -1;
						if( _this.currentDetails.referenceDocIds ) {
							refIndex = _this.currentDetails.referenceDocIds.indexOf(doc._id);
						};
						
						if( refIndex < 0 ) {
							// The previous time we saw this document, there were no reference to the
							// currently displayed document. Now, this new version of the document
							// contains a reference to the displayed document. Add reference and
							// re-display.
							if( !_this.currentDetails.referenceDocIds ){
								_this.currentDetails.referenceDocIds = [];
							};
							_this.currentDetails.referenceDocIds.push(doc._id);
							_this._currentDocReferencesUpdated();
						};
					};
				}
				,onNotRelated: function(selectedDoc, relatedDoc){
					// Check validity of callback
					if( selectedDoc._id === _this.currentDetails.docId ){
						var refIndex = -1;
						if( _this.currentDetails.referenceDocIds ) {
							refIndex = _this.currentDetails.referenceDocIds.indexOf(doc._id);
						};

						if( refIndex >= 0 ) {
							// The previous time we saw this document, it had a reference to the
							// currently displayed document. Now, this reference is no longer there.
							// Remove the reference and redisplay
							_this.currentDetails.referenceDocIds.splice(refIndex,1);
							_this._currentDocReferencesUpdated();
						};
					};
				}
				,onError: function(err){
					$n2.log('Error in displayTiled. Unable to check relation.',err);
				}
			});
		};
		
		function schemaLoaded(doc, schema){
			if( _this.currentDetails.docId === doc._id ){
				// This is the schema associated with the current
				// document.
				if( schema && !_this.currentDetails.schema ){
					_this.currentDetails.schema = schema;
					_this._displayDocumentButtons(doc, schema);
					
				} else if( _this.currentDetails.schema && !schema ) {
					_this.currentDetails.schema = null;
					_this._displayDocumentButtons(doc, null);
				
				} else if( _this.currentDetails.schema 
				 && schema
				 && _this.currentDetails.schema.name !== schema.name
				 ) {
					// Schema is changed
					_this.currentDetails.schema = schema;
					_this._displayDocumentButtons(doc, schema);
				};
			};
		};
	},
	
	/*
	 * Initiates the editing of a document
	 */
	_performDocumentEdit: function(doc){
		var _this = this;
		
		this.documentSource.getDocument({
			docId: doc._id
			,onSuccess: function(doc){
				_this._dispatch({
					type: 'editInitiate'
					,doc: doc
				});
			}
			,onError: function(errorMsg){
				$n2.log('Unable to load document: '+errorMsg);
			}
		});
	},
	
	/*
	 * Initiates the deletion of a document
	 */
	_performDocumentDelete: function(doc){
		if( confirm( _loc('You are about to delete this document. Do you want to proceed?') ) ) {
			this.documentSource.deleteDocument({
				doc: doc
				,onSuccess: function() {}
			});
		};
	},
	
	/*
	 * Initiates the 'Add Layer to Map' action for the button
	 */
	_performAddLayerToMap: function(doc){
		var layerDefinition = doc.nunaliit_layer_definition;
		var layerId = layerDefinition.id;
		if( !layerId ){
			layerId = doc._id;
		};
		var layerDef = {
			name: layerDefinition.name
			,type: 'couchdb'
			,options: {
				layerName: layerId
				,documentSource: this.documentSource
			}
		};
		
		this._dispatch({
			type: 'addLayerToMap'
			,layer: layerDef
			,options: {
				setExtent: {
					bounds: layerDefinition.bbox
					,crs: 'EPSG:4326'
				}
			}
		});
	},
	
	/*
	 * Opens a tree view dialog
	 */
	_performTreeView: function(doc){
		new $n2.couchDisplay.TreeDocumentViewer({
			doc: doc
		});
	},
	
	/*
	 * This function should be called before any displaying is performed.
	 * This ensures that the div element in use still contains the required
	 * elements for performing display.
	 */
	_reclaimDisplayDiv: function() {
		var _this = this;
		
		var $set = this._getDisplayDiv();
		
		var $filters = $set.find('.n2DisplayTiled_filters');
		var $current = $set.find('.n2DisplayTiled_info');
		var $docs = $set.find('.n2DisplayTiled_documents');
		if( $filters.length < 1 
		 || $current.length < 1
		 || $docs.length < 1 ){
			$set.empty();
			$filters = $('<div>')
				.addClass('n2DisplayTiled_filters')
				.appendTo($set);
			$current = $('<div>')
				.addClass('n2DisplayTiled_info')
				.appendTo($set);
			$docs = $('<div>')
				.addClass('n2DisplayTiled_documents')
				.appendTo($set);
			
			// When the side panel must be re-claimed, then we must
			// forget what is currently displayed since it has to be
			// re-computed
			this.currentDetails = {};
			
			// Create grid
			this.grid = new Tiles.Grid($docs);
			this.grid.createTile = function(docId) {
		        var $elem = $('<div>')
		        	.addClass('n2DisplayTiled_tile')
		        	.addClass('n2DisplayTiled_tile_' + $n2.utils.stringToHtmlId(docId))
		        	.attr('n2DocId',docId);
		        
		        $elem.hover(
	        		_this.hoverInFn
	        		,_this.hoverOutFn
		        );

		        var tile = new Tiles.Tile(docId, $elem);
		        
		        if( _this.currentDetails
		         && _this.currentDetails.docId === docId ){
		        	// Current document
		        	$elem.addClass('n2DisplayTiled_tile_current');
		        	_this._generateCurrentDocumentContent($elem, docId);

		        } else {
		        	// Not current document
		        	_this._generateDocumentContent($elem, docId);
		        };
		        return tile;
		    };
		    
		    // Create document filter
		    this.filter = this.filterFactory.get($filters,function(){
		    	_this._documentFilterChanged();
		    });
		};
	},
	
	/*
	 * Goes over all the tiles and remove the class 'n2DisplayTiled_tile_current'
	 * to from tiles that should not have it. Also, it adds the class to the tile
	 * that should have it, if it exists.
	 * 
	 * When adding and removing the class, adjust the content accordingly.
	 */
	_adjustCurrentTile: function(docId){
		var _this = this;
		
		var $set = this._getDisplayDiv();
		var $docs = $set.find('.n2DisplayTiled_documents');
		
		var targetClass = null;
		if( docId ){
			targetClass = 'n2DisplayTiled_tile_' + $n2.utils.stringToHtmlId(docId);
		};
		
		// Remove
		$docs.find('.n2DisplayTiled_tile_current').each(function(){
			var $elem = $(this);
			if( targetClass && $elem.hasClass(targetClass) ) {
				// That's OK. Leave it
			} else {
				$elem.removeClass('n2DisplayTiled_tile_current');
				var id = $elem.attr('n2DocId');
				_this._generateDocumentContent($elem, id);
			};
		});
		
		// Add
		if( targetClass ) {
			$docs.find('.'+targetClass).each(function(){
				var $elem = $(this);
				if( $elem.hasClass('n2DisplayTiled_tile_current') ) {
					// That's OK. Leave it
				} else {
					$elem.addClass('n2DisplayTiled_tile_current');
					var id = $elem.attr('n2DocId');
					_this._generateCurrentDocumentContent($elem, id);
				};
			});
		};
	},
	
	_getDisplayDiv: function(){
		var divId = this.displayPanelName;
		return $('#'+divId);
	},
	
	_dispatch: function(m){
		var dispatcher = this.dispatchService;
		if( dispatcher ) {
			dispatcher.send(DH,m);
		};
	},

	/*
	 * Get a boolean option based on a name and return it. Defaults
	 * to false. If the option is found set in either the options map
	 * or the custom service, then the result is true.
	 */
	_getBooleanOption: function(optionName){
		var flag = false;
		
		if( this.boolOptions[optionName] ){
			flag = true;
		};
		
		var cs = this.customService;
		if( cs && !flag ){
			var o = cs.getOption(optionName);
			if( o ){
				flag = true;
			};
		};
		
		return flag;
	},
	
	/*
	 * Look at documents stored in display code and return if one
	 * found with the correct identifier.
	 */
	_getCachedDocumentFromId: function(docId){
		if( this.displayedDocuments 
		 && this.displayedDocuments[docId]
		 && this.displayedDocuments[docId].doc ){
			return this.displayedDocuments[docId].doc;
		};
		
		if( this.currentDetails 
		 && this.currentDetails.docId === docId 
		 && this.currentDetails.doc ){
			return this.currentDetails.doc;
		};
		
		return null;
	},
	
	/*
	 * Given a document identifier, request the document content.
	 */
	_requestDocumentWithId: function(docId){
		// Look internally, first
		var doc = this._getCachedDocumentFromId(docId);
		if( doc ){
			this._receiveDocumentContent(doc);
			return;
		};
		
		if( this.requestService ){
			this.requestService.requestDocument(docId);
		};
	},
	
	_generateCurrentDocumentContent: function($elem, docId){
		$elem.empty();
		
		var waitClassName = 'n2DisplayTiled_wait_current_' + $n2.utils.stringToHtmlId(docId);
		$('<div>')
			.addClass(waitClassName)
			.addClass('n2DisplayTiled_tile_content')
			.text(docId)
			.appendTo($elem);
	},
	
	_generateDocumentContent: function($elem, docId){
		var _this = this;
		
		$elem.empty();
		
		$('<div>')
			.addClass('n2DisplayTiled_thumb n2DisplayTiled_wait_thumb_' + $n2.utils.stringToHtmlId(docId))
			.appendTo($elem);
		
		$('<div>')
			.addClass('n2DisplayTiled_wait_brief_' + $n2.utils.stringToHtmlId(docId))
			.addClass('n2DisplayTiled_tile_brief')
			.text(docId)
			.appendTo($elem);

		var clickInstalled = $elem.attr('n2Click');
		if( !clickInstalled ) {
			$elem.click(function(){
				_this._dispatch({
					type:'userSelect'
					,docId: docId
				});
			});
			$elem.attr('n2Click','installed');
		};
	},
	
	_performIntervalTask: function(){
		var $set = this._getDisplayDiv();
		var $docs = $set.find('.n2DisplayTiled_documents');

		if( this.currentDetails
		 && this.currentDetails.docId ){
			var $currentTile = $docs.find('.n2DisplayTiled_tile_current')
				.find('.n2DisplayTiled_tile_content');
			if( $currentTile.length > 0 ){
				var height = $currentTile.height();
				if( height != this.currentDetails.height ){
					this.currentDetails.height = height;
					var cellSize = this.grid.cellSize;
					this.grid.template = null;
					this.grid.templateFactory = new GridTemplateDocument(height,cellSize);
					this.grid.redraw(true);
				};
			};
		};
	},
	
	_documentFilterChanged: function(){
		this._updateDisplayedDocuments();
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var SchemaFilter = $n2.Class({
	
	elemId: null,
	
	changeCallback: null,
	
	schemaRepository: null,
	
	selectedSchema: null,
	
	initialize: function(elem, changeCallback, schemaRepository){
		var $elem = $(elem);
		this.elemId = $elem.attr('id');
		if( !this.elemId ){
			this.elemId = $n2.getUniqueId();
			$elem.attr('id',this.elemId);
		};
		
		this.changeCallback = changeCallback;
		this.schemaRepository = schemaRepository;
	},
	
	display: function(infos){
		var _this = this;
		
		var schemas = {};
		if( infos ){
			for(var i=0,e=infos.length; i<e; ++i){
				var info = infos[i];
				if( info.schema ){
					schemas[info.schema] = true;
				};
			};
		};
		
		var schemaNames = [];
		for(var schemaName in schemas){
			schemaNames.push(schemaName);
		};
		
		this.schemaRepository.getSchemas({
			names: schemaNames
			,onSuccess: function(schemas){
				_this._displaySchemas(schemas);
			}
			,onError: function(err){
				$n2.log('Error getting schemas for displaying schema filter',err);
			}
		});
	},
	
	filter: function(infos){
		if( this.selectedSchema ){
			var filteredInfos = [];
			
			for(var i=0,e=infos.length; i<e; ++i){
				var info = infos[i];
				
				if( info.schema === this.selectedSchema ){
					filteredInfos.push(info);
				};
			};
			
			return filteredInfos;
			
		} else {
			// Return all
			return infos;
		};
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_displaySchemas: function(schemas){
		var _this = this;
		
		var $elem = this._getElem();
		
		$elem.empty();
		
		var clickFn = function(){
			var $a = $(this);
			
			var schemaName = $a.attr('n2SchemaName');
			schemaName = schemaName ? schemaName : null;
			
			_this._schemaSelected(schemaName);
			
			return false;
		};
		
		$('<a>')
			.attr('href','#')
			.text( _loc('All') )
			.addClass('n2DisplayTiled_filter')
			.addClass('n2DisplayTiled_filter_all')
			.appendTo($elem)
			.click(clickFn);

		var keepCurrentSelection = false;
		for(var i=0,e=schemas.length; i<e; ++i){
			var schema = schemas[i];
			
			if( schema.name === this.selectedSchema ){
				keepCurrentSelection = true;
			};
			
			var schemaLabel = schema.name;
			if( schema.label ){
				schemaLabel = _loc(schema.label);
			};

			$('<a>')
				.attr('href','#')
				.attr('n2SchemaName',schema.name)
				.text( schemaLabel )
				.addClass('n2DisplayTiled_filter_schema')
				.addClass('n2DisplayTiled_filter_schema_'+$n2.utils.stringToHtmlId(schema.name))
				.appendTo($elem)
				.click(clickFn);
		};
		
		if( !keepCurrentSelection ) {
			this.selectedSchema = null;
		};
		
		this._adjustSelection();
	},
	
	_adjustSelection: function(){
		var $elem = this._getElem();
		
		$elem.find('.n2DisplayTiled_filter_selected')
			.removeClass('n2DisplayTiled_filter_selected');
		
		if( this.selectedSchema ){
			$elem.find('.n2DisplayTiled_filter_schema_'+$n2.utils.stringToHtmlId(this.selectedSchema))
				.addClass('n2DisplayTiled_filter_selected');
			
		} else {
			$elem.find('.n2DisplayTiled_filter_all')
				.addClass('n2DisplayTiled_filter_selected');
		};
	},
	
	_schemaSelected: function(schemaName){
		this.selectedSchema = schemaName;
		this._adjustSelection();
		this.changeCallback();
	}
});

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var SchemaFilterFactory = $n2.Class({
	
	schemaRepository: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			schemaRepository: null
		},opts_);
		
		this.schemaRepository = opts.schemaRepository;
	},

	get: function(elem, changeCallback){
		return new SchemaFilter(elem, changeCallback, this.schemaRepository);
	}
});

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var ReferenceRelatedDocumentDiscovery = $n2.Class({
	
	documentSource: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: null
		},opts_);
		
		this.documentSource = opts.documentSource;
	},
	
	getRelatedDocumentIds: function(opts_){
		var opts = $n2.extend({
			doc: null
			,onSuccess: function(doc, refDocIds){}
			,onError: function(err){}
		},opts_);
		
		var doc = opts.doc;

		this.documentSource.getReferencesFromId({
			docId: doc._id
			,onSuccess: loadedRefIds
			,onError: function(errorMsg){
				opts.onError(errorMsg);
			}
		});
		
		function loadedRefIds(referenceIds){
			// Map to accumulate all references
			var docIdMap = {};
			
			// Forward references
			var references = [];
			$n2.couchUtils.extractLinks(doc, references);
			for(var i=0, e=references.length; i<e; ++i){
				var linkDocId = references[i].doc;
				docIdMap[linkDocId] = true;
			};
			
			// Reverse links
			for(var i=0, e=referenceIds.length; i<e; ++i){
				var linkDocId = referenceIds[i];
				docIdMap[linkDocId] = true;
			};
			
			// Convert map to array
			var refDocIds = [];
			for(var docId in docIdMap){
				refDocIds.push(docId);
			};
			
			opts.onSuccess(doc, refDocIds);
		};
	},
	
	areDocumentsRelated: function(opts_){
		var opts = $n2.extend({
			selectedDoc: null
			,relatedDoc: null
			,onRelated: function(selectedDoc, relatedDoc){}
			,onNotRelated: function(selectedDoc, relatedDoc){}
			,onError: function(err){}
		},opts_);
		
		var selectedDoc = opts.selectedDoc;
		var relatedDoc = opts.relatedDoc;
		
		// Try to find related document in selected document
		var references = [];
		$n2.couchUtils.extractLinks(selectedDoc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			if( linkDocId === relatedDoc._id ){
				opts.onRelated(selectedDoc, relatedDoc);
				return;
			};
		};
		
		// Try to find selected document in related document
		var references = [];
		$n2.couchUtils.extractLinks(relatedDoc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			if( linkDocId === selectedDoc._id ){
				opts.onRelated(selectedDoc, relatedDoc);
				return;
			};
		};
		
		// At this point, the two documents are deemed not related
		opts.onNotRelated(selectedDoc, relatedDoc);
	}
});

//===================================================================================
function HandleDisplayAvailableRequest(m){
	if( m.displayType === 'tiled' ){
		m.isAvailable = true;
	};
};

function HandleDisplayRenderRequest(m){
	if( m.displayType === 'tiled' ){
		var options = {};
		if( m.displayOptions ){
			for(var key in m.displayOptions){
				options[key] = m.displayOptions[key];
			};
		};
		
		options.documentSource = m.config.documentSource;
		options.displayPanelName = m.displayId;
		options.showService = m.config.directory.showService;
		options.createDocProcess = m.config.directory.createDocProcess;
		options.requestService = m.config.directory.requestService;
		options.schemaRepository = m.config.directory.schemaRepository;
		options.customService = m.config.directory.customService;
		options.dispatchService = m.config.directory.dispatchService;
		
		var displayControl = new TiledDisplay(options);

		m.onSuccess(displayControl);
	};
};

//===================================================================================

$n2.couchDisplayTiles = {
	TiledDisplay: TiledDisplay
	,SchemaFilterFactory: SchemaFilterFactory
	,ReferenceRelatedDocumentDiscovery: ReferenceRelatedDocumentDiscovery
	,HandleDisplayAvailableRequest: HandleDisplayAvailableRequest
	,HandleDisplayRenderRequest: HandleDisplayRenderRequest
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchSearch.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

// Dispatcher
var DH = 'n2.couchSearch';

function SplitSearchTerms(line) {
	if( !line ) return null;
	
	var map = $n2.couchUtils.extractSearchTerms(line, false);

	var searchTerms = [];
	for(var term in map){
		var folded = map[term].folded;
		if( folded ) {
			searchTerms.push(folded);
		};
	};
	
	return searchTerms;
};

//============ ResearchResult ========================
// Class that convey the result of a research
var ResearchResult = $n2.Class({
	
	// identifier of the document found in research
	id: null,
	
	// How relevant this result is (lower number is better)
	index: null,
	
	// How many terms matched by this result
	count: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			id: null
			,index: null
			,count: null
		},opts_);
		
		this.id = opts.id;
		this.index = opts.index;
		
		if( opts.count ){
			this.count = opts.count;
		} else {
			this.count = 1;
		};
	},
	
	add: function(result){
		if( this.index > result.index ){
			this.index = result.index;
		};
		
		this.count += result.count;
	}
});

//============ Research ========================
// Abstract class that defines the API for researching
// a concept in the database
var Research = $n2.Class({
	
	id: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			
		},opts_);
		
		this.id = $n2.getUniqueId();
	},
	
	execute: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(resultMap, research){}
			,onError: function(err, research){}
			,onPartial: function(resultMap, research){}
		},opts_);

		throw 'Subclasses must implement method execute';
	}
});

//============ ResearchTerm ========================
// Specialization of Research that looks up all documents
// associated with one search term
var ResearchTerm = $n2.Class(Research,{
	textTerm: null,

	constraint: null,
	
	designDoc: null,
	
	searchView: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			textTerm: null
			,constraint: null
			,designDoc: null
			,searchView: null
		},opts_);
		
		Research.prototype.initialize.apply(this,arguments);

		this.textTerm = opts.textTerm;
		this.constraint = opts.constraint;
		this.designDoc = opts.designDoc;
		this.searchView = opts.searchView;
		
		if( typeof this.textTerm !== 'string' ){
			throw 'In ResearchTerm constructor, the textTerm must be a string';
		};
		if( typeof this.designDoc !== 'object' ){
			throw 'In ResearchTerm constructor, the designDoc must be provided';
		};
		if( typeof this.searchView !== 'string' ){
			throw 'In ResearchTerm constructor, the searchView must be provided';
		};
	},
	
	execute: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(resultMap, research){}
			,onError: function(err, research){}
			,onPartial: function(resultMap, research){}
		},opts_);
		
		var _this = this;

		// Search terms are stored lower case in database
		var term = this.textTerm.toLowerCase();
		
		var resultsByDocId = null;

		if( this.constraint ){
			// Convert string to an array of 1 element for performing query view
			if( typeof(this.constraint) === 'string'){
				var key = [];
				key.push(this.constraint);
				this.constraint = key;
			};
			
			if( $n2.isArray(this.constraint)
			 && this.constraint.length > 0 ){

				var expectedCount = this.constraint.length;
				
				for(var i = 0, e = this.constraint.length; i<e; ++i){
					if (!resultsByDocId){
						resultsByDocId = {};
					};

					this.designDoc.queryView({
						viewName: this.searchView
						,startkey: [this.constraint[i],term,0]
						,endkey: [this.constraint[i],term,{}]
						,constraint: this.constraint
						,onSuccess: function(rows) {
							for(var i=0,e=rows.length; i<e; ++i) {
								var docId = rows[i].id;
								var index = rows[i].key[1];
								
								if( resultsByDocId[docId] 
								&& resultsByDocId[docId].index <= index ){
									// Do nothing
								} else {
									var result = new ResearchResult({
										id: docId
										,index: index
									});
									resultsByDocId[docId] = result;
								};
							};

							// Only call opts.onSuccess when all the queries have returned.
							// Otherwise call opts.onPartial
							--expectedCount;
							if( expectedCount <= 0 ){
								opts.onSuccess(resultsByDocId);
							} else {
								opts.onPartial(resultsByDocId);
							};
						}
						,onError: function(err) {
							opts.onError(err);
						}
					});
				};
			} else {
				opts.onError('Invalid search constraint');
			};

		} else {
			var startKey = [term,0];
			var endKey = [term,{}];

			this.designDoc.queryView({
				viewName: this.searchView
				,startkey: startKey
				,endkey: endKey
				,onSuccess: function(rows) {
					var resultsByDocId = {};
					for(var i=0,e=rows.length; i<e; ++i) {
						var docId = rows[i].id;
						var index = rows[i].key[1];
						
						if( resultsByDocId[docId] 
						 && resultsByDocId[docId].index <= index ){
							// Do nothing
						} else {
							var result = new ResearchResult({
								id: docId
								,index: index
							});
							resultsByDocId[docId] = result;
						};
					};
					
					opts.onSuccess(resultsByDocId);
				}
				,onError: function(err) {
					opts.onError(err);
				}
			});
		};
	}
});

//============ ResearchDate ========================
// Specialization of Research that looks up all documents
// associated with a date interval
var ResearchDate = $n2.Class(Research,{
	
	dateInterval: null,

	dateService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dateInterval: null
			,dateService: null
		},opts_);
		
		Research.prototype.initialize.apply(this,arguments);

		this.dateInterval = opts.dateInterval;
		this.dateService = opts.dateService;
		
		if( typeof this.dateInterval !== 'object' ){
			throw 'In ResearchDate constructor, the dateInterval must be provided';
		};
		if( typeof this.dateService !== 'object' ){
			throw 'In ResearchDate constructor, the dateService must be provided';
		};
	},
	
	execute: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(resultMap, research){}
			,onError: function(err, research){}
			,onPartial: function(resultMap, research){}
		},opts_);
		
		this.dateService.getDocIdsFromInterval({
			interval: this.dateInterval
			,onSuccess: function(docIds){
				var dateResults = [];
				for(var i=0,e=docIds.length; i<e; ++i) {
					dateResults.push({
						docId: docIds[i]
						,index: 0
					});
				};
				var resultsByDocId = {};
				for(var i=0,e=docIds.length; i<e; ++i) {
					var docId = docIds[i];
					var index = 0;
					
					var result = new ResearchResult({
						id: docId
						,index: index
					});
					resultsByDocId[docId] = result;
				};
				
				opts.onSuccess(resultsByDocId);
			}
			,onError: function(err) {
				opts.onError(err);
			}
		});
	}
});

//============ ResearchUnion ========================
// Specialization of Research that accepts a number
// of instances of Research and provides a result which
// is a union of all research results from children.
var ResearchUnion = $n2.Class(Research,{
	
	childrenById: null,
	
	resultsByDocId: null,
	
	count: null,
	
	waiting: null,
	
	error: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			
		},opts_);
		
		Research.prototype.initialize.apply(this,arguments);
		
		this.childrenById = {};
		this.resultsByDocId = {};
	},
	
	addResearch: function(research){
		var id = research.id;
		this.childrenById[id] = research;
	},
	
	execute: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(resultMap, research){}
			,onError: function(err, research){}
			,onPartial: function(resultMap, research){}
		},opts_);
		
		var _this = this;

		var f = function(resultMap, research){
			_this._receiveResult(resultMap, research, opts.onSuccess, opts.onPartial);
		};
		
		// Reset error
		this.error = undefined;

		// Count children
		this.count = 0;
		for(var id in this.childrenById){
			++this.count;
		};
		this.waiting = this.count;
		
		// Request results
		this.resultsByDocId = {};
		for(var id in this.childrenById){
			var childResearch = this.childrenById[id];
			childResearch.execute({
				onSuccess: f
				,onError: function(err){
					--_this.waiting;
					if( !_this.error ){
						_this.error = err;
						opts.onError(err);
					};
				}
			});
		};

		if( this.count < 1 ){
			this._checkIfFinished(opts.onSuccess, opts.onPartial);
		};
	},
	
	_receiveResult: function(resultMap, research, onSuccess, onPartial){
		for(var docId in resultMap){
			var result = resultMap[docId];
			
			result.count = 1;
			
			if( this.resultsByDocId[docId] ){
				this.resultsByDocId[docId].add(result);
			} else {
				this.resultsByDocId[docId] = result;
			};
		};
		
		--this.waiting;
		this._checkIfFinished(onSuccess, onPartial);
	},
	
	_checkIfFinished: function(onSuccess, onPartial){
		if( this.error ){
			// Error already reported. Do nothing

		} else if( this.waiting < 1 ){
			// Complete
			onSuccess(this.resultsByDocId, this);

		} else {
			// Partial
			onPartial(this.resultsByDocId, this);
		};
	}
});

//============ ResearchIntersection ========================
// Specialization of Research that accepts a number
// of instances of Research and provides a result which
// is an intersection of all research results from children.
var ResearchIntersection = $n2.Class(Research,{
	
	childrenById: null,
	
	resultsByDocId: null,
	
	waiting: null,

	count: null,
	
	error: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			
		},opts_);
		
		Research.prototype.initialize.apply(this,arguments);
		
		this.childrenById = {};
		this.resultsByDocId = {};
	},
	
	addResearch: function(research){
		var id = research.id;
		this.childrenById[id] = research;
	},
	
	execute: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(resultMap, research){}
			,onError: function(err, research){}
			,onPartial: function(resultMap, research){}
		},opts_);
		
		var _this = this;

		var f = function(resultMap, research){
			_this._receiveResult(resultMap, research, opts.onSuccess, opts.onPartial);
		};
		
		// Reset error
		this.error = undefined;

		// Count children
		this.count = 0;
		for(var id in this.childrenById){
			++this.count;
		};
		this.waiting = this.count;
		
		// Request results
		this.resultsByDocId = {};
		for(var id in this.childrenById){
			var childResearch = this.childrenById[id];
			childResearch.execute({
				onSuccess: f
				,onError: function(err){
					--_this.waiting;
					if( !_this.error ){
						_this.error = err;
						opts.onError(err);
					};
				}
			});
		};

		if( this.count < 1 ){
			this._checkIfFinished(opts.onSuccess, opts.onPartial);
		};
	},
	
	_receiveResult: function(resultMap, research, onSuccess, onPartial){
		// The first time, accept all results
		if( this.waiting === this.count ){
			for(var docId in resultMap){
				var result = resultMap[docId];
				
				result.count = 1;
				
				this.resultsByDocId[docId] = result;
			};
		} else {
			// Import results that were already present
			for(var docId in resultMap){
				var result = resultMap[docId];
				
				if( this.resultsByDocId[docId] ) {
					this.resultsByDocId[docId].add(result);
				};
			};
			
			// Remove from previous results the one not offered by this
			// result map
			var docIdsToRemove = [];
			for(var docId in this.resultsByDocId){
				if( !resultMap[docId] ){
					docIdsToRemove.push(docId);
				};
			};
			for(var i=0,e=docIdsToRemove.length; i<e; ++i){
				var docId = docIdsToRemove[i];
				delete this.resultsByDocId[docId];
			};
		};
		
		--this.waiting;
		this._checkIfFinished(onSuccess, onPartial);
	},
	
	_checkIfFinished: function(onSuccess, onPartial){
		if( this.error ){
			// Error already reported. Do nothing

		} else if( this.waiting < 1 ){
			// Complete
			onSuccess(this.resultsByDocId, this);

		} else {
			// Partial
			onPartial(this.resultsByDocId, this);
		};
	}
});

//============ SearchRequest ========================
/*
 * Returns a search result:
 * {
 *    pending: <integer> // number of search terms that have not yet been returned
 *    ,actionReturnedCount: <integer> // number of search terms returned so far
 *    ,terms: <array of strings> // search terms
 *    ,sorted: <array of found result> // Sorted list of found results
 *    ,list: <array of found result> // Same as "sorted" but including only the found results
 *                                   // with the most search terms matched
 * }
 * 
 * found result:
 * {
 *    id: <document id>
 *    ,index: <integer> // earliest position of found term in a field
 *    ,terms: <integer> // number of terms matched
 * }
 */
var SearchRequest = $n2.Class({
	
	options: null,
	
	searchResults: null,
	
	initialize: function(searchTermsLine, opts_) {
		this.options = $n2.extend({
			designDoc: null
			,db: null
			,constraint: null
			,dateService: null
			,searchLimit: 25
			,onlyFinalResults: false
			,strict: true
			,onSuccess: function(searchResults){}
			,onError: function(err){ $n2.reportErrorForced(err); }
		},opts_);

		// If search terms are array, rejoin into a line
		if( $n2.isArray(searchTermsLine) ){
			searchTermsLine = searchTerms.join(' ');
		};
		
		// Extract dates and date ranges from search term line
		var dateTerms = [];
		if( this.options.dateService ){
			var dateStrings = $n2.date.findAllDateStrings(searchTermsLine);
			for(var i=0,e=dateStrings.length; i<e; ++i){
				dateTerms.push( dateStrings[i] );
				
				var dateStr = dateStrings[i].str;
				if( searchTermsLine.indexOf(dateStr) >= 0 ){
					searchTermsLine = searchTermsLine.replace(dateStr,'');
				};
			};
		};
		
		// Break out into search terms
		var searchTerms = undefined;
		if( typeof(searchTermsLine) === 'string' ) {
			searchTerms = SplitSearchTerms(searchTermsLine);
			if( !searchTerms ){
				searchTerms = [];
			};
		} else {
			throw 'Search terms must be a string or an array';
		};
		
		// Start research
		var research = undefined;
		if( this.options.strict ){
			research = new ResearchIntersection();
		} else {
			research = new ResearchUnion();
		};

		// Figure out view
		var searchView = 'text-search';
		if( this.options.constraint ){
			searchView = 'text-search-constrained';
		};

		// Initialize results
		this.searchResults = {
			terms: []
			,actionReturnedCount: 0
			,pending: 0
			,map: {}
			,sorted: []
			,list: []
		};
		
		// Add research for each term
		for(var i=0,e=searchTerms.length; i<e; ++i){
			var childResearch = new ResearchTerm({
				textTerm: searchTerms[i]
				,constraint: this.options.constraint
				,designDoc: this.options.designDoc
				,searchView: searchView
			});
			
			research.addResearch(childResearch);
			++this.searchResults.pending;
		};
		
		// Add research for dates. Each date research is a union between
		// a date interval research and a research of the terms. This is because
		// a user that enters a string that looks like a date but means to look
		// for a particular string should be able to find either one
		for(var i=0,e=dateTerms.length; i<e; ++i){
			var dateTerm = dateTerms[i];
			
			var childResearch = new ResearchUnion();
			
			// Add the date research
			var dateResearch = new ResearchDate({
				dateInterval: dateTerm.interval
				,dateService: this.options.dateService
			});
			childResearch.addResearch(dateResearch);
			
			// Split the terms and add them to the research, one at a time
			var textTerms = SplitSearchTerms(dateTerm.str);
			for(var j=0,k=textTerms.length; j<k; ++j){
				var textTerm = textTerms[j];
				
				var textResearch = new ResearchTerm({
					textTerm: textTerm
					,constraint: this.options.constraint
					,designDoc: this.options.designDoc
					,searchView: searchView
				});
				
				childResearch.addResearch(textResearch);
			};
			
			research.addResearch(childResearch);
			++this.searchResults.pending;
		};
		
		// Handle case where nothing is asked
		if( this.searchResults.pending < 1 ) {
			this._returnSearchResults();
			return;
		};
		
		// Execute research
		var _this = this;
		research.execute({
			onSuccess: function(resultMap, research){
				_this._receiveSearchResults(resultMap, false);
			}
			,onError: function(err, research){
				_this.searchResults = null;
				_this.options.onError(err);
			}
			,onPartial: function(resultMap, research){
				_this._receiveSearchResults(resultMap, true);
			}
		});
	},

	abortSearch: function() {
		this.searchResults = null;
	},
	
	/*
	 * Receives a map of results by docIds. Each result is:
	 * {
	 *    docId: <docId>
	 *    ,index: <integer>
	 *    ,count: <integer>
	 * }
	 * 
	 * The higher the count, the better the match
	 * The lower the index, the better the match.
	 */
	_receiveSearchResults: function(interimResults, isInterim) {
	
		var searchResults = this.searchResults;
		
		// Aborted
		if( !searchResults ) return;
		
		// Remember the returned response
		--searchResults.pending;
		++searchResults.actionReturnedCount;

		searchResults.map = interimResults;
		
		if( isInterim ) {
			if( !this.options.onlyFinalResults ){
				this._returnSearchResults();
			};
		} else {
			this._returnSearchResults();
		};
	},
	
	_returnSearchResults: function() {
		
		var searchResults = this.searchResults;

		// Aborted?
		if( !searchResults ) return;

		var _this = this;

		// Created sorted results. This is a list of all results
		// ordered in importance
		var maxCount = 0;
		searchResults.sorted = [];
		for(var docId in searchResults.map){
			var result = searchResults.map[docId];
			searchResults.sorted.push(result);
			if( maxCount < result.count ){
				maxCount = result.count;
			};
		};
		searchResults.sorted.sort(function(a,b){
			if( a.count > b.count ) {
				return -1;
			} else if( a.count < b.count ) {
				return 1;
			} else {
				if( a.index < b.index ) {
					return -1;
				} else if( a.index > b.index ) {
					return 1;
				};
			};
			
			return 0;
		});
		
		// Create list that should be consumed by the client. Include only
		// the results that match the most terms
		searchResults.list = [];
		for(var i=0,e=searchResults.sorted.length; i<e; ++i){
			var r = searchResults.sorted[i];
			if( r.count >= maxCount ) {
				searchResults.list.push(r);
			};
		};
		
		this.options.onSuccess(searchResults);
	}
});

//============ LookAheadService ========================

var LookAheadService = $n2.Class({

	designDoc: null,
	
	lookAheadLimit: null,
	
	lookAheadPrefixMin: null,
	
	lookAheadCacheSize: null,
	
	lookAheadMap: null,
	
	lookAheadCounter: null,
	
	constraint: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			designDoc: null
			,lookAheadLimit: 5
			,lookAheadPrefixMin: 3
			,lookAheadCacheSize: 10
			,constraint: null
		},opts_);
		
		this.designDoc = opts.designDoc;
		this.lookAheadLimit = opts.lookAheadLimit;
		this.lookAheadPrefixMin = opts.lookAheadPrefixMin;
		this.lookAheadCacheSize = opts.lookAheadCacheSize;
		this.constraint = opts.constraint;
		
		this.lookAheadMap = {};
		this.lookAheadCounter = 0;
	},
	
	setConstraint: function(constraint){
		this.constraint = constraint;
	},

	queryPrefix: function(prefix,callback) {
		var _this = this;
	
		var words = this._retrievePrefix(prefix);
		if( words ) {
			callback(prefix,words);
			return;
		};
		
		// Figure out query view
		var viewName = 'text-lookahead';
		if( this.constraint ){
			viewName = 'text-lookahead-constrained';
		};
		
		// Figure out start and end keys
		var startKey = [prefix,null];
		var endKey = [prefix + '\u9999',{}];
		if( this.constraint ){
			startKey = [this.constraint, prefix, null];
			endKey = [this.constraint, prefix + '\u9999', {}];
		};
		
		// Make request
		this.designDoc.queryView({
			viewName: viewName
			,listName: 'text-lookahead'
			,startkey: startKey
			,endkey: endKey
			,top: this.lookAheadLimit
			,group: true
			,onlyRows: false
			,reduce: true
			,onSuccess: function(response) {
				var rows = response.rows;
	
				var words = [];
				for(var i=0,e=rows.length; i<e; ++i) {
					words.push(rows[i][0]);
				};
				
				// Cache these results
				_this._cachePrefix({
					prefix: prefix
					,words: words
					,full: response.all_rows
				});
				
				if( 0 == words.length ) {
					callback(prefix,null);
				} else {
					callback(prefix,words);
				};
			}
			,onError: function(){
				callback(prefix,null);
			}
		});
	},
	
	queryTerms: function(terms,callback) {

		if( null === terms
		 || 0 == terms.length ) {
			callback(null);
			return;
		};
		
		var index = terms.length - 1;
		while( index >= 0 ) {
			var lastTerm = terms[index];
			if( '' === lastTerm ) {
				--index;
			} else {
				var previousWords = null;
				if( index > 0 ) {
					previousWords = terms.slice(0,index);
				};
				break;
			};
		};
		
		lastTerm = lastTerm.toLowerCase();
		
		if( !lastTerm ) {
			callback(null);
			return;
		};
		if( lastTerm.length < this.lookAheadPrefixMin ) {
			callback(null);
			return;
		};
		
		var previousWordsString = '';
		if( previousWords ) {
			previousWordsString = previousWords.join(' ') + ' ';
		};
		
		this.queryPrefix(lastTerm,function(prefix,words){
			
			if( null === words ) {
				callback(null);
			} else {
				var results = [];
				for(var i=0,e=words.length; i<e; ++i) {
					results.push( previousWordsString + words[i] );
				};
				callback(results);
			};
		});
	},
	
	_cachePrefix: function(prefixResult) {
		
		// Save result under prefix
		this.lookAheadMap[prefixResult.prefix] = prefixResult;
		
		// Mark generation
		prefixResult.counter = this.lookAheadCounter;
		++(this.lookAheadCounter);
		
		// Trim cache
		var keysToDelete = [];
		var cachedMap = this.lookAheadMap; // faster access
		var limit = this.lookAheadCounter - this.lookAheadCacheSize;
		for(var key in cachedMap) {
			if( cachedMap[key].counter < limit ) {
				keysToDelete.push(key);
			};
		};
		for(var i=0,e=keysToDelete.length; i<e; ++i) {
			delete cachedMap[keysToDelete[i]];
		};
	},
	
	_retrievePrefix: function(prefix) {
		
		// Do we have exact match in cache?
		if( this.lookAheadMap[prefix] ) {
			return this.lookAheadMap[prefix].words;
		};
		
		// Look for complete results from shorter prefix
		var sub = prefix.substring(0,prefix.length-1);
		while( sub.length >= this.lookAheadPrefixMin ) {
			if( this.lookAheadMap[sub] && this.lookAheadMap[sub].full ) {
				var cachedWords = this.lookAheadMap[sub].words;
				var words = [];
				for(var i=0,e=cachedWords.length; i<e; ++i) {
					var word = cachedWords[i];
					if( word.length >= prefix.length ) {
						if( word.substr(0,prefix.length) === prefix ) {
							words.push(word);
						};
					};
				};
				return words;
			};
			sub = sub.substring(0,sub.length-1);
		};
		
		// Nothing of value found
		return null;
	},

	getJqAutoCompleteSource: function() {
		var _this = this;
		return function(request, cb) {
			_this._jqAutoComplete(request, cb);
		};
	},
	
	_jqAutoComplete: function(request, cb) {
		var terms = SplitSearchTerms(request.term);
		var callback = cb;
//		var callback = function(res){
//			$n2.log('look ahead results',res);
//			cb(res);
//		}
		this.queryTerms(terms, callback);
	}

});

//============ SearchInput ========================

var SearchInput = $n2.Class({
	options: null
	
	,searchServer: null
	
	,textInputId: null
	
	,searchButtonId: null
	
	,keyPressedSinceLastSearch: null
	
	,dispatchHandle: null
	
	,initialize: function(opts_, server_){
		this.options = $n2.extend({
			textInput: null
			,searchButton: null
			,initialSearchText: null
			,constraint: null
			,displayFn: null // one of displayFn or
			,dispatchService: null // dispatchService should be supplied
		},opts_);
		
		var _this = this;
		
		this.searchServer = server_;

		this.keyPressedSinceLastSearch = false;
		
		if( this.options.dispatchService ) {
			var f = function(m){
				_this._handle(m);
			};
			this.options.dispatchService.register(DH,'searchInitiate',f);
			this.options.dispatchService.register(DH,'selected',f);
			this.options.dispatchService.register(DH,'unselected',f);
			this.options.dispatchService.register(DH,'searchActivated',f);
			this.options.dispatchService.register(DH,'searchDeactivated',f);            

			// Activate/Deactivate Search Box
			$('.searchIcon').click(function() {
				if( $('.nunaliit_search_input').hasClass('search_active') ){
					_this.options.dispatchService.send(DH,{
						type: 'searchDeactivated'
					});

				} else if( $('.nunaliit_search_input').hasClass('search_inactive') ){
					_this.options.dispatchService.send(DH,{
						type: 'searchActivated'
					});

				} else {
					_this.options.dispatchService.send(DH,{
						type: 'searchActivated'
					});
				};
			});
		};
		
		// Figure out id. We should not hold onto a reference
		// to the input since it would create a circular reference.
		// This way, if the element is removed from the window tree,
		// it all cleans up easy.
		var $textInput = this.options.textInput;
		this.textInputId = $n2.utils.getElementIdentifier($textInput);
		this.options.textInput = null; // get rid of reference

		// Same for button
		if( this.options.searchButton ) {
			var $searchButton = this.options.searchButton;
			var searchButtonId = $searchButton.attr('id');
			if( !searchButtonId ) {
				searchButtonId = $n2.getUniqueId();
				$searchButton.attr('id',searchButtonId);
			};
			this.searchButtonId = searchButtonId;
			this.options.searchButton = null; // get rid of reference
		};
		
		if( !this.options.initialSearchText ){
			this.options.initialSearchText = '';
		};
		
		this._install();
	}

	,getTextInput: function() {
		return $('#'+this.textInputId);
	}

	,getSearchButton: function() {
		if( this.searchButtonId ) {
			return $('#'+this.searchButtonId);
		};
		return null;
	}
	
	,getSearchLine: function(){
		var $textInput = this.getTextInput();
		var line = $textInput.val();
		if( line && line.length > 0 ) {
			if( line === this.options.initialSearchText ){
				return '';
			} else {
				return line;
			};
		} else {
			return '';
		};
	}
	
	,performSearch: function(line){
		
		var _this = this;

		if( this.options.dispatchService ) {
			this.options.dispatchService.send(DH, {
				type: 'searchInitiate'
				,searchLine: line
			});
			
		} else if( this.searchServer ){
			this.searchServer.submitRequest(
				line
				,{
					onSuccess: function(searchResults){
						_this._processSearchResults(searchResults);
					}
					,onError: function(err){ 
						_this._processSearchError(err);
					}
				}
			);
		};

		this.keyPressedSinceLastSearch = false;
		this._displayWait();
	}

	,_install: function(){
		
		var _this = this;
		
		var $textInput = this.getTextInput();
		
		if( this.options.initialSearchText ) {
			$textInput.val(this.options.initialSearchText);
		};
		
		if( $textInput.autocomplete ) {
			$textInput.autocomplete({
				source: this._getJqAutoCompleteSource()
			});
		};
		
		$textInput.keydown(function(e){
			_this._keyDown(e);
		});
		
		$textInput.focus(function(e) {
			_this._focus(e);
		});
		
		$textInput.blur(function(e) { 
			_this._blur(e);
		});
		
		var $searchButton = this.getSearchButton();
		if( $searchButton ) {
			$searchButton.click(function(e){
				_this._clickSearch(e);
			});
		};
	}
	
	,_focus: function(e) {
		var $textInput = this.getTextInput();
		if( this.options.initialSearchText ) {
			var value = $textInput.val();
			if(this.options.initialSearchText === value) {
				$textInput.val('');
			};
		};
		$textInput.select();
	}
	
	,_blur: function(e){
		if( this.options.initialSearchText ) {
			var $textInput = this.getTextInput();

			var value = $textInput.val();
			if( '' === value ) {
				$textInput.val(this.options.initialSearchText);
			};
		};
	}
	
	,_keyDown: function(e) {
		var charCode = null;
		if( null === e ) {
			e = window.event; // IE
		};
		if( null !== e ) {
			if( e.keyCode ) {
				charCode = e.keyCode;
			};
		};
		
		this.keyPressedSinceLastSearch = true;

//		$n2.log('_keyDown',charCode,e);
		if (13 === charCode || null === charCode) {
			// carriage return or I'm not detecting key codes
			// and have to submit on each key press - yuck...
			var line = this.getSearchLine();
			if( line.length > 0 ) {
				this._closeLookAhead();
				this.performSearch(line);
				this._closeLookAhead();
			};
		};
	}
	
	,_clickSearch: function(e){
		var line = this.getSearchLine();
		if( line.length > 0 ) {
			this._closeLookAhead();
			this.performSearch(line);
			this._closeLookAhead();
		};
	}
	
	,_closeLookAhead: function($textInput){
		if( !$textInput ) {
			$textInput = this.getTextInput();
		};
		if( $textInput.autocomplete ) {
			// Close autocomplete
			$textInput.autocomplete('close');
		};
	}
	
	,_processSearchResults: function(searchResults){
		var _this = this;
		
		if( this.options.displayFn ) {
			searchResults.type = 'results';
			this.options.displayFn(searchResults);
			
		} else if( this.options.dispatchService ) {
			this.options.dispatchService.send(DH, {
				type: 'searchResults'
				,results: searchResults
			});
			
		} else {
			$n2.log('Unable to return search results');
		};
	}

	,_processSearchError: function(err){
		if( this.options.displayFn ) {
			var display = {
				type:'error'
				,error: err
			};

			this.options.displayFn(display);
			
		} else if( this.options.dispatchService ) {
			this.options.dispatchService.send(DH, {
				type: 'searchResults'
				,error: err
			});
		};
	}

	,_displayWait: function(){
		if( this.options.displayFn ) {
			this.options.displayFn({type:'wait'});
		};
	}

	,_getJqAutoCompleteSource: function() {
		var _this = this;
		return function(request, cb) {
			_this._jqAutoComplete(request, cb);
		};
	}
	
	,_jqAutoComplete: function(request, cb) {
		// Redirect to look ahead service, but intercept
		// result.
		var _this = this;
		var lookAheadService = this.searchServer.getLookAheadService();
		lookAheadService._jqAutoComplete(request, function(res){
			if( _this.keyPressedSinceLastSearch ) {
				cb(res);
			} else {
				// suppress since the result of look ahead service
				// comes after search was requested
				cb(null);
			};
		});
	}	

	,_activateSearchBar: function(){	
		$('.nunaliit_search_input')
			.addClass('search_active')
			.removeClass('search_inactive');

		// Move focus to search input box
		$('.nunaliit_search_input input').focus();
	}

	,_deactivateSearchBar: function(){    	
		$('.nunaliit_search_input')
			.addClass('search_inactive')
			.removeClass('search_active');
	}

	,_handle: function(m){
		
		if( 'searchInitiate' === m.type ){
			var $textInput = this.getTextInput();
			$textInput.val(m.searchLine);
			this.options.dispatchService.send(DH,{
				type: 'searchActivated'
			});

		} else if( 'selected' === m.type 
		 || 'unselected' === m.type ){
			var $textInput = this.getTextInput();
			if( this.options.initialSearchText ) {
				$textInput.val(this.options.initialSearchText);

				// Hide search bar after document selection
				this.options.dispatchService.synchronousCall(DH,{
					type: 'searchDeactivated'
				});

			} else {
				$textInput.val('');
			};

		} else if( 'searchActivated' === m.type ){
			this._activateSearchBar();

		} else if( 'searchDeactivated' === m.type ){ 
			this._deactivateSearchBar();
		};
	}
});

// ============ SearchServer ========================

var SearchServer = $n2.Class({
	
	options: null,

	designDoc: null,
	
	db: null,
	
	dateService: null,
	
	dispatchService: null,
	
	customService: null,
	
	constraint: null,
	
	searchLimit: null,
	
	lookAheadLimit: null,
	
	lookAheadPrefixMin: null,
	
	lookAheadCacheSize: null,
	
	lookAheadService: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			designDoc: null
			,db: null
			,dateService: null
			,dispatchService: null
			,customService: null
			,constraint: null
			,searchLimit: 25
			,lookAheadLimit: 5
			,lookAheadPrefixMin: 3
			,lookAheadCacheSize: 10
		},opts_);
		
		var _this = this;

		this.designDoc = opts.designDoc;
		this.db = opts.db;
		this.dateService = opts.dateService;
		this.dispatchService = opts.dispatchService;
		this.customService = opts.customService;
		this.constraint = opts.constraint;
		this.searchLimit = opts.searchLimit;
		this.lookAheadLimit = opts.lookAheadLimit;
		this.lookAheadPrefixMin = opts.lookAheadPrefixMin;
		this.lookAheadCacheSize = opts.lookAheadCacheSize;

		this.lookAheadService = null;

		var d = this.dispatchService;
		if( d ){
			var f = function(m){
				_this._handle(m);
			};
			var h = d.getHandle('n2.couchSearch');
			d.register(h,'searchInitiate',f);
		};
	},
	
	setConstraint: function(constraint){
		this.constraint = constraint;
		
		if( this.lookAheadService ){
			this.lookAheadService.setConstraint(constraint);
		};
	},

	getLookAheadService: function() {
		if( null === this.lookAheadService ) {
			this.lookAheadService = new LookAheadService({
				designDoc: this.designDoc
				,lookAheadLimit: this.lookAheadLimit
				,lookAheadPrefixMin: this.lookAheadPrefixMin
				,lookAheadCacheSize: this.lookAheadCacheSize
				,constraint: this.constraint
			});
		};
		
		return this.lookAheadService;
	},

	/*
	 * Creates a request for search terms and returns an
	 * object to represent the request. The returned object
	 * is an instance of class SearchRequest 
	 */
	submitRequest: function(searchTerms, opts_) {
		var requestOptions = $n2.extend({
			designDoc: this.designDoc
			,db: this.db
			,dateService: this.dateService
			,searchLimit: this.searchLimit
			,constraint: this.constraint
		},opts_);
		
		return new SearchRequest(searchTerms, requestOptions);
	},
	
	getJqAutoCompleteSource: function() {
		return this.getLookAheadService().getJqAutoCompleteSource();
	},
	
	installSearch: function(opts_) {
		return new SearchInput(opts_, this);
	},
	
	installSearchWidget: function(opts_) {
		var opts = $n2.extend({
			elem: null
			,label: null
			,useButton: false
			,buttonLabel: null
			,doNotDisable: false
			,constraint: null
		},opts_);
		
		var customService = this.customService;

		// Parent element
		var $elem = $(opts.elem);

		// Text box label
		var searchWidgetLabel = opts.label;
		if( null === searchWidgetLabel 
		 && customService){
			searchWidgetLabel = customService.getOption('searchWidgetText',null);
		};
		if( null === searchWidgetLabel ){
			searchWidgetLabel = _loc('search the atlas');
		};

		$elem.empty();

		// Search icon
		var searchIcon = $('<div>')
			.addClass('searchIcon')
			.appendTo($elem);

		// Text box
		var searchInput = $('<input type="text">')
			.addClass('search_panel_input')
			.val( searchWidgetLabel )
			.appendTo($elem);

		if( opts.doNotDisable ){
			// OK
		} else {
			searchInput.addClass('n2_disable_on_edit');
		};
		
		// Search button label
		var searchButtonLabel = opts.buttonLabel;
		if( null === searchButtonLabel 
		 && customService ){
			searchButtonLabel = customService.getOption('searchButtonText',null);
		};
		if( null === searchButtonLabel ){
			searchButtonLabel = _loc('Search');
		};
		
		// Search button
		var searchButton = null;
		if( opts.useButton ){
			searchButton = $('<input type="button">')
				.val( searchButtonLabel )
				.appendTo($elem);
		};
		
		return new SearchInput({
				textInput: searchInput
				,initialSearchText: searchWidgetLabel
				,dispatchService: this.dispatchService
				,searchButton: searchButton
				,constraint: opts.constraint
			}, this);
	},
	
	_handle: function(m){
		if( 'searchInitiate' === m.type ){
			var searchTerms = m.searchLine;

			var dispatcher = this.dispatchService;
			var h = dispatcher.getHandle('n2.couchSearch');
			this.submitRequest(searchTerms, {
				onSuccess: function(searchResults){
					dispatcher.send(h, {
						type: 'searchResults'
						,results: searchResults
					});
				}
				,onError: function(err){
					dispatcher.send(h, {
						type: 'searchError'
						,error: err
					});
				}
			});
		};
	}
});

// ================ API ===============================

$n2.couchSearch = {
	SearchServer: SearchServer
	,SearchRequest: SearchRequest
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDialogs.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2) {
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };
var DH = 'n2.couchDialogs';

//++++++++++++++++++++++++++++++++++++++++++++++
function computeMaxDialogWidth(preferredWidth){
	var dialogWidth = preferredWidth;
	
	var screenWidth = $('body').width();
	if( typeof screenWidth === 'number' ){
		var maxWidth = screenWidth * 0.90;
		if( dialogWidth > maxWidth ){
			dialogWidth = maxWidth;
		};
	};

	return dialogWidth;
};

// **********************************************************************
var ProgressDialog = $n2.Class({
	
	dialogId: null,
	
	progressLabel: null,
	
	onCancelFn: null,
	
	cancellingLabel: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			title: _loc('Progress')
			,progressLabel: _loc('Progress')
			,onCancelFn: null
			,cancelButtonLabel: _loc('Cancel') 
			,cancellingLabel: _loc('Cancelling Operation...')
		},opts_);
		
		var _this = this;
		
		this.dialogId = $n2.getUniqueId();
		this.progressLabel = opts.progressLabel;
		this.onCancelFn = opts.onCancelFn;
		this.cancellingLabel = opts.cancellingLabel;

		var $dialog = $('<div id="'+this.dialogId+'" class="n2dialogs_progress">'
			+'<div class="n2dialogs_progress_message">'
			+'<span class="n2dialogs_progress_label"></span>: <span class="n2dialogs_progress_percent"></span>'
			+'</div></div>');
		$dialog.find('span.n2dialogs_progress_label').text( this.progressLabel );
		
		var dialogOptions = {
			autoOpen: true
			,title: opts.title
			,modal: true
			,closeOnEscape: false
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$dialog.dialog(dialogOptions);
		
		// Remove close button
		$dialog.parents('.ui-dialog').first().find('.ui-dialog-titlebar-close').hide();

		// Add cancel button, if needed
		if( typeof(opts.onCancelFn) === 'function'  ) {
			var cancelLine = $('<div><button class="n2dialogs_progress_cancelButton"></button></div>');
			$dialog.append(cancelLine);
			cancelLine.find('button')
				.text(opts.cancelButtonLabel)
				.click(function(){
					_this.cancel();
					return false;
				})
				;
		};
		
		this.updatePercent(0);
	},

	cancel: function(){
		if( typeof(this.onCancelFn) === 'function' ) {
			var $dialog = $('#'+this.dialogId);
			var $cb = $dialog.find('.n2dialogs_progress_cancelButton');
			var $m = $('<span></span>').text(this.cancellingLabel);
			$cb.before($m).remove();
			
			this.onCancelFn();
		};
	},

	close: function(){
		var $dialog = $('#'+this.dialogId);
		$dialog.dialog('close');
	},

	updatePercent: function(percent){
		var $dialog = $('#'+this.dialogId);
		var $p = $dialog.find('.n2dialogs_progress_percent');
		$p.text( ''+Math.floor(percent)+'%' );
	},
	
	updateHtmlMessage: function(html){
		var $dialog = $('#'+this.dialogId);
		var $div = $dialog.find('.n2dialogs_progress_message');
		$div.html( html );
	}
});


//**********************************************************************
var AlertDialog = $n2.Class({
	
	dialogId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			title: _loc('Alert')
			,message: null
		},opts_);
		
		var _this = this;
		
		this.dialogId = $n2.getUniqueId();

		var $dialog = $('<div>')
			.attr('id',this.dialogId)
			.addClass('n2dialogs_alert');
		$('<div>')
			.addClass('n2dialogs_alert_message')
			.text(opts.message)
			.appendTo($dialog);
		
		var $okLine = $('<div>')
			.appendTo($dialog);
		$('<button>')
			.addClass('n2dialogs_alert_okButton')
			.text( _loc('OK') )
			.appendTo($okLine)
			.click(function(){
				_this.close();
				return false;
			});
	
		var dialogOptions = {
			autoOpen: true
			,title: opts.title
			,modal: true
			,closeOnEscape: false
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$dialog.dialog(dialogOptions);
		
	},

	close: function(){
		var $dialog = $('#'+this.dialogId);
		$dialog.dialog('close');
	}
});


//++++++++++++++++++++++++++++++++++++++++++++++
function searchForDocumentId(options_){

	var options = $n2.extend({
		searchServer: null
		,showService: null
		,onSelected: function(docId){}
		,onReset: function(){}
	},options_);
	
	var shouldReset = true;
	
	var dialogId = $n2.getUniqueId();
	var inputId = $n2.getUniqueId();
	var searchButtonId = $n2.getUniqueId();
	var displayId = $n2.getUniqueId();
	var $dialog = $('<div id="'+dialogId+'" class="editorSelectDocumentDialog">'
			+'<div><label for="'+inputId+'">'+_loc('Search:')+'</label>'
			+'<input id="'+inputId+'" type="text"/>'
			+'<button id="'+searchButtonId+'">'+_loc('Search')+'</button></div>'
			+'<div  class="editorSelectDocumentDialogResults" id="'+displayId+'"></div>'
			+'<div><button class="cancel">'+_loc('Cancel')+'</button></div>'
			+'</div>');
	
	$dialog.find('button.cancel')
			.button({icons:{primary:'ui-icon-cancel'}})
			.click(function(){
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			})
		;
	
	var dialogOptions = {
		autoOpen: true
		,title: _loc('Select Document')
		,modal: true
		,close: function(event, ui){
			var diag = $(event.target);
			diag.dialog('destroy');
			diag.remove();
			if( shouldReset ) {
				options.onReset();
			};
		}
	};
	
	var width = computeMaxDialogWidth(370);
	if( typeof width === 'number' ){
		dialogOptions.width = width;
	};

	$dialog.dialog(dialogOptions);

	options.searchServer.installSearch({
		textInput: $('#'+inputId)
		,searchButton: $('#'+searchButtonId)
		,displayFn: receiveSearchResults
		,onlyFinalResults: true
	});
	
	var $input = $('#'+inputId);
	$('#'+inputId).focus();
	
	function receiveSearchResults(displayData) {
		if( !displayData ) {
			reportError('Invalid search results returned');

		} else if( 'wait' === displayData.type ) {
			$('#'+displayId).empty();

		} else if( 'results' === displayData.type ) {
			var docIds = [];
			for(var i=0,e=displayData.list.length; i<e; ++i) {
				var docId = displayData.list[i].id;
				docIds.push(docId);
			};
			displayDocIds(docIds);
			
		} else {
			reportError('Invalid search results returned');
		};
	};
	
	function displayDocIds(docIds){
		if( docIds.length < 1 ){
			$('#'+displayId)
				.empty()
				.append( _loc('Search result is empty') );
			
		} else {
			var $table = $('<table></table>');
			$('#'+displayId).empty().append($table);
		
			for(var i=0,e=docIds.length; i<e; ++i) {
				var docId = docIds[i];
				
				var $tr = $('<tr>')
					.appendTo($table);

				var $td = $('<td>')
					.addClass('n2_search_result olkitSearchMod2_'+(i%2))
					.appendTo($tr);
				
				var $a = $('<a>')
					.attr('href','#'+docId)
					.attr('alt',docId)
					.appendTo($td)
					.click( createClickHandler(docId) );

				if( options.showService ) {
					options.showService.printBriefDescription($a,docId);
				} else {
					$a.text(docId);
				};
			};
		};
	};
	
	function createClickHandler(docId) {
		return function(e){
			options.onSelected(docId);
			shouldReset = false;
			var $dialog = $('#'+dialogId);
			$dialog.dialog('close');
			return false;
		};
	};
};

//++++++++++++++++++++++++++++++++++++++++++++++
function selectLayersDialog(opts_){
	
	var opts = $n2.extend({
		currentLayers: []
		,cb: function(selectedLayerIds){}
		,resetFn: function(){}
		,documentSource: null
		,showService: null
		,dispatchService: null
	},opts_);
	
	var layers = {};
	if( typeof(opts.currentLayers) === 'string' ){
		var layerNames = opts.currentLayers.split(',');
		for(var i=0,e=layerNames.length;i<e;++i){
			var layerId = $n2.trim(layerNames[i]);
			layers[layerId] = {
				currentlySelected: true
				,id: layerId
				,label: null
			};
		};
		
	} else if( $n2.isArray(opts.currentLayers) ){
		for(var i=0,e=opts.currentLayers.length;i<e;++i){
			var layerId = $n2.trim(opts.currentLayers[i]);
			layers[layerId] = {
				currentlySelected: true
				,id: layerId
				,label: null
			};
		};
	};

	var shouldReset = true;
	var dialogId = $n2.getUniqueId();
	var $dialog = $('<div id="'+dialogId+'" class="editorSelectLayerDialog">'
			+'<div class="editorSelectLayerContent"></div>'
			+'<div class="editorSelectLayerButtons"><button class="ok">'+_loc('OK')+'</button>'
			+'<button class="cancel">'+_loc('Cancel')+'</button></div>'
			+'</div>');
	
	$dialog.find('button.cancel')
		.button({icons:{primary:'ui-icon-cancel'}})
		.click(function(){
			var $dialog = $('#'+dialogId);
			$dialog.dialog('close');
			return false;
		});
	$dialog.find('button.ok')
		.button({
			icons:{primary:'ui-icon-check'}
			,disabled: true
		});
	
	var dialogOptions = {
		autoOpen: true
		,title: _loc('Select Layers')
		,modal: true
		,close: function(event, ui){
			var diag = $(event.target);
			diag.dialog('destroy');
			diag.remove();
			if( shouldReset ) {
				opts.resetFn();
			};
		}
	};
	
	var width = computeMaxDialogWidth(370);
	if( typeof width === 'number' ){
		dialogOptions.width = width;
	};

	$dialog.dialog(dialogOptions);
	
	// Get layers
	if( opts.documentSource ){
		opts.documentSource.getLayerDefinitions({
			onSuccess: function(layerDefs){
				for(var i=0,e=layerDefs.length;i<e;++i){
					var layerDef = layerDefs[i];
					var layerId = layerDef.id;
					if( !layers[layerId] ){
						layers[layerId] = {
							currentlySelected: false
						};
					};
					if( layerDef.name ){
						layers[layerId].label = layerDef.name;
					};
				};
				getInnerLayers();
			}
			,onError: function(errorMsg){ 
				reportError(errorMsg);
			}
		});
	} else {
		getInnerLayers();
	};
	
	function getInnerLayers(){
		var m = {
			type: 'mapGetLayers'
			,layers: {}
		};
		opts.dispatchService.synchronousCall(DH, m);
		for(var layerId in m.layers){
			if( !layers[layerId] ){
				layers[layerId] = {
					currentlySelected: false	
				};
			};
		};
		displayLayers();
	};
	
	function displayLayers(){
		var $diag = $('#'+dialogId);
		
		var $c = $diag.find('.editorSelectLayerContent');
		$c.empty();
		for(var layerId in layers){
			var label = layerId;
			if( layers[layerId].label ){
				label = _loc( layers[layerId].label );
			};
			
			var inputId = $n2.getUniqueId();
			var $div = $('<div>')
				.appendTo($c);
			var $input = $('<input type="checkbox">')
				.addClass('layer')
				.attr('id',inputId)
				.attr('name',layerId)
				.appendTo($div);
			var $label = $('<label>')
				.attr('for',inputId)
				.text(label)
				.appendTo($div);

			if( layers[layerId].currentlySelected ){
				$input.attr('checked','checked');
			};
			
			if( opts.showService && !layers[layerId].label ){
				opts.showService.printLayerName($label, layerId);
			};
		};
		
		$diag.find('button.ok')
			.button('option','disabled',false)
			.click(function(){
				var selectedLayers = [];
				var $diag = $('#'+dialogId);
				$diag.find('input.layer').each(function(){
					var $input = $(this);
					if( $input.is(':checked') ){
						var layerId = $input.attr('name');
						selectedLayers.push(layerId);
					};
				});
				opts.cb(selectedLayers);

				shouldReset = false;
				$diag.dialog('close');
			});
	};
	
	function reportError(err){
		$('#'+dialogId).find('.editorSelectLayerContent').text('Error: '+err);
	};
};

//++++++++++++++++++++++++++++++++++++++++++++++
// This is a factory class to generate a dialog function that
// can be used in selecting a document id from a list of presented
// documents. This is an abstract class and it must be specialized
// before it can be useful. Each sub-class should implement the
// method getDocuments() to return a sorted list of documents that
// can be selected.
//
// The dialog presented offers a search box which narrows the list
// of presented documents, based on the displayed brief.
var SearchBriefDialogFactory = $n2.Class({

	showService: null,
	
	dialogPrompt: null,
	
	sortOnBrief: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			showService: null
			,sortOnBrief: false
			,dialogPrompt: _loc('Select')
		},opts_);
		
		this.showService = opts.showService;
		this.dialogPrompt = opts.dialogPrompt;
		this.sortOnBrief = opts.sortOnBrief;
	},
	
	/*
	 * This method returns a function that can be used in
	 * DialogService.addFunctionToMap
	 */
	getDialogFunction: function(){
		var _this = this;
		return function(opts){
			_this.showDialog(opts);
		};
	},
	
	/*
	 * This method must be implemented by sub-classes
	 */
	getDocuments: function(opts_){
		var opts = $n2.extend({
			args: []
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		$n2.log('Subclasses to SearchBriefDialogFactory must implement getDocuments()');
		
		opts.onSuccess([]);
	},
	
	showDialog: function(opts_){
		var opts = $n2.extend({
			args: []
			,onSelected: function(docId){}
			,onReset: function(){}
		},opts_);
		
		var _this = this;

		var shouldReset = true;
		
		var dialogId = $n2.getUniqueId();
		var inputId = $n2.getUniqueId();
		var displayId = $n2.getUniqueId();
		var $dialog = $('<div>')
			.attr('id',dialogId)
			.addClass('editorSelectDocumentDialog')
			;
		
		var $searchLine = $('<div>')
			.appendTo($dialog);
		
		$('<label>')
			.attr('for', inputId)
			.text( _loc('Search:') )
			.appendTo($searchLine);
		
		$('<input>')
			.attr('id', inputId)
			.attr('type', 'text')
			.appendTo($searchLine)
			.keyup(function(){
				var $input = $(this);
				var text = $input.val();
				var frags = text.split(' ');
				var words = [];
				for(var i=0,e=frags.length; i<e; ++i){
					var frag = $n2.trim( frags[i].toLowerCase() );
					if( frag.length > 0 ){
						words.push(frag);
					};
				};
				$n2.log('text : '+words.join('+'));
				filterList(words);
			});
		
		var $results = $('<div>')
			.attr('id',displayId)
			.addClass('editorSelectDocumentDialogResults')
			.appendTo($dialog);

		$('<div>')
			.addClass('olkit_wait')
			.appendTo($results);

		var $buttons = $('<div>')
			.appendTo($dialog);
		
		$('<button>')
			.addClass('cancel')
			.text( _loc('Cancel') )
			.appendTo($buttons)
			.button({icons:{primary:'ui-icon-cancel'}})
			.click(function(){
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			});
		
		var dialogOptions = {
			autoOpen: true
			,title: this.dialogPrompt
			,modal: true
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
				if( shouldReset ) {
					opts.onReset();
				};
			}
		};
		
		var width = computeMaxDialogWidth(370);
		if( typeof width === 'number' ){
			dialogOptions.width = width;
		};

		$dialog.dialog(dialogOptions);

		this.getDocuments({
			args: opts.args
			,onSuccess: displayDocs
			,onError: function(errorMsg){ 
				reportError( _loc('Unable to retrieve documents: {err}',{
					err: errorMsg
				}) ); 
			}
		});

		function displayDocs(docs) {

			if( docs.length < 1 ){
				$('#'+displayId)
					.empty()
					.text( _loc('No document found') );
				
			} else {
				var $table = $('<table></table>');
				$('#'+displayId).empty().append($table);
				
				var displayedById = {};

				for(var i=0,e=docs.length; i<e; ++i) {
					var doc = docs[i];
					var docId = doc._id;
					
					if( displayedById[docId] ){
						// Already displayed. Skip
					} else {
						displayedById[docId] = true;
						
						var $tr = $('<tr>')
							.addClass('trResult')
							.appendTo($table);

						var $td = $('<td>')
							.addClass('n2_search_result olkitSearchMod2_'+(i%2))
							.appendTo($tr);
						
						var $a = $('<a>')
							.attr('href','#'+docId)
							.attr('alt',docId)
							.appendTo($td)
							.click( createClickHandler(docId) );
						
						if( _this.showService ) {
							_this.showService.displayBriefDescription($a, {}, doc);
						} else {
							$a.text(docId);
						};
					};
				};
				
				if( _this.sortOnBrief ){
					sortTable($table);
				};
			};
		};
		
		function sortTable($table){
			// Get all rows
			var $trs = $table.find('tr');
			
			// Assign the text value as a sort key to each row
			$trs.each(function(){
				var $tr = $(this);
				$tr.attr('n2-sort-key',$tr.text());
			});
			
			// Sort on the key
			var trArray = $trs.toArray().sort(function(trA,trB){
				var keyA = $(trA).attr('n2-sort-key');
				var keyB = $(trB).attr('n2-sort-key');
				if( keyA === keyB ){
					return 0;
				} else if( !keyA ){
					return -1;
				} else if( !keyB ){
					return 1;
				} else if( keyA < keyB ){
					return -1;
				} else if( keyA > keyB ){
					return 1;
				} else {
					// should not get here
					return 0;
				};
			});

			// Re-order table
			trArray.forEach(function(tr){
				$table.append(tr);
			});
		};
		
		function filterList(words){
			var $dialog = $('#'+dialogId);
			var $trs = $dialog.find('.trResult');
			if( !words || words.length < 1 ){
				$trs.show();
			} else {
				$trs.each(function(){
					var $tr = $(this);
					var trText = $tr.text().toLowerCase();
					//$n2.log('trText : '+trText);
					var show = true;
					for(var i=0,e=words.length; i<e && show; ++i){
						var word = words[i];
						if( trText.indexOf(word) < 0 ){
							show = false;
						};
					};
					
					if( show ){
						$tr.show();
					} else {
						$tr.hide();
					};
				});
			};
		};
		
		function createClickHandler(docId) {
			return function(e){
				opts.onSelected(docId);
				shouldReset = false;
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			};
		};
		
		function reportError(err){
			$('#'+displayId)
				.empty()
				.text( err );
		};
	}

});

//++++++++++++++++++++++++++++++++++++++++++++++
/**
 * Search for documents based on schema name(s)
 * @class
 */
var SearchOnSchemaDialogFactory = $n2.Class('SearchOnSchemaDialogFactory', SearchBriefDialogFactory, {

	atlasDesign: null,
	
	showService: null,
	
	dialogPrompt: null,
	
	/**
	 * @constructor
	 */
	initialize: function(opts_){
		var opts = $n2.extend({
			atlasDesign: undefined
			,showService: undefined
			,sortOnBrief: true
			,dialogPrompt: _loc('Select a Document')
		},opts_);
		
		$n2.couchDialogs.SearchBriefDialogFactory.prototype.initialize.call(this, opts);
		
		this.atlasDesign = opts.atlasDesign;
	},

	getDocuments: function(opts_){
		var opts = $n2.extend({
			args: []
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		var keys = [];
		var errorEncountered = true;
		if( $n2.isArray(opts.args) 
		 && opts.args.length > 0 ){
			errorEncountered = false;
			
			var keys = [];
			opts.args.forEach(function(k){
				if( typeof k === 'string' ){
					keys.push(k);
				} else {
					errorEncountered = true;
				};
			});
		};
		
		if( errorEncountered ){
			$n2.logError('Can not search for documents based on schema', opts.args);
			opts.onError( _loc('Can not search for documents based on schema') ); 

		} else {
			this.atlasDesign.queryView({
				viewName: 'nunaliit-schema'
				,keys: keys
				,include_docs: true
				,onSuccess: function(rows){
					var docs = [];
					for(var i=0,e=rows.length; i<e; ++i){
						var doc = rows[i].doc;
						if( doc ){
							docs.push(doc);
						};
					};
					
					opts.onSuccess(docs);
				}
				,onError: function(errorMsg){
					$n2.logError('Unable to retrieve documents for schema '+keys+': '+errorMsg);
					opts.onError( _loc('Unable to retrieve documents for schema {name}', {name:''+keys}) ); 
				}
			});
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
/**
* Search for documents based on layer identifier
* @class
*/
var SearchOnLayerDialogFactory = $n2.Class('SearchOnLayerDialogFactory', SearchBriefDialogFactory, {

	atlasDesign: null,
	
	showService: null,
	
	dialogPrompt: null,
	
	/**
	 * @constructor
	 */
	initialize: function(opts_){
		var opts = $n2.extend({
			atlasDesign: undefined
			,showService: undefined
			,sortOnBrief: true
			,dialogPrompt: _loc('Select a Document')
		},opts_);
		
		$n2.couchDialogs.SearchBriefDialogFactory.prototype.initialize.call(this, opts);
		
		this.atlasDesign = opts.atlasDesign;
	},

	getDocuments: function(opts_){
		var opts = $n2.extend({
			args: []
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		var keys = [];
		var errorEncountered = true;
		if( $n2.isArray(opts.args) 
		 && opts.args.length > 0 ){
			errorEncountered = false;
			
			var keys = [];
			opts.args.forEach(function(k){
				if( typeof k === 'string' ){
					keys.push(k);
				} else {
					errorEncountered = true;
				};
			});
		};
		
		if( errorEncountered ){
			$n2.logError('Can not search for documents based on layer', opts.args);
			opts.onError( _loc('Can not search for documents based on layer') ); 

		} else {
			this.atlasDesign.queryView({
				viewName: 'layers'
				,keys: keys
				,include_docs: true
				,onSuccess: function(rows){
					var docs = [];
					for(var i=0,e=rows.length; i<e; ++i){
						var doc = rows[i].doc;
						if( doc ){
							docs.push(doc);
						};
					};
					
					opts.onSuccess(docs);
				}
				,onError: function(errorMsg){
					$n2.logError('Unable to retrieve documents for layer '+keys+': '+errorMsg);
					opts.onError( _loc('Unable to retrieve documents for layer {name}', {name:''+keys}) ); 
				}
			});
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
/**
 * Search for a related media file
 * @class
 */
var SearchRelatedMediaDialogFactory = $n2.Class('SearchRelatedMediaDialogFactory',{

	documentSource: null,
	
	searchService: null,
	
	showService: null,
	
	dialogPrompt: null,
	
	/**
	 * @constructor
	 */
	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: null
			,searchService: null
			,showService: null
			,dialogPrompt: _loc('Select a Media')
		},opts_);
		
		this.documentSource = opts.documentSource;
		this.searchService = opts.searchService;
		this.showService = opts.showService;
		this.dialogPrompt = opts.dialogPrompt;
	},
	
	/*
	 * This method returns a function that can be used in
	 * DialogService.addFunctionToMap
	 */
	getDialogFunction: function(){
		var _this = this;
		return function(opts){
			_this.showDialog(opts);
		};
	},
	
	/*
	 * Keeps only documents that have a media attachment
	 */
	filterDocuments: function(opts_){
		var opts = $n2.extend({
			docs: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		var docsWithMedia = [];
		
		if( $n2.isArray(opts.docs) ){
			opts.docs.forEach(function(doc){
				var attachments = $n2.couchAttachment.getAttachments(doc);
				attachments.forEach(function(att){
					if( att.isSource() 
					 && att.isAttached() ){
						docsWithMedia.push(doc);
					};
				});
			});
		};
		
		opts.onSuccess( docsWithMedia );
	},
	
	showDialog: function(opts_){
		var opts = $n2.extend({
			contextDoc: null
			,onSelected: function(docId){}
			,onReset: function(){}
		},opts_);
		
		var _this = this;

		var shouldReset = true;
		
		var dialogId = $n2.getUniqueId();
		var inputId = $n2.getUniqueId();
		var searchButtonId = $n2.getUniqueId();
		var suggestionId = $n2.getUniqueId();
		var displayId = $n2.getUniqueId();
		
		var $dialog = $('<div>')
			.attr('id',dialogId)
			.addClass('editorSelectDocumentDialog editorSelectDocumentDialog_relatedMedia');
		
		var $suggestedHeader = $('<div>')
			.addClass('editorSelectDocumentDialog_suggestedHeader')
			.text( _loc('Suggestions') )
			.appendTo($dialog);
		
		var $suggestedList = $('<div>')
			.attr('id',suggestionId)
			.addClass('editorSelectDocumentDialog_suggestedList')
			.appendTo($dialog);
	
		var $searchLine = $('<div>')
			.addClass('editorSelectDocumentDialog_searchLine')
			.appendTo($dialog);

		$('<label>')
			.attr('for', inputId)
			.text( _loc('Search:') )
			.appendTo($searchLine);

		$('<input>')
			.attr('id', inputId)
			.attr('type', 'text')
			.appendTo($searchLine);

		$('<button>')
			.attr('id', searchButtonId)
			.text( _loc('Search') )
			.appendTo($searchLine);
		
		$('<div>')
			.attr('id',displayId)
			.addClass('editorSelectDocumentDialogResults')
			.appendTo($dialog);
		
		var $buttons = $('<div>')
			.appendTo($dialog);
		
		$('<button>')
			.addClass('cancel')
			.text( _loc('Cancel') )
			.appendTo($buttons)
			.button({icons:{primary:'ui-icon-cancel'}})
			.click(function(){
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			});

		var dialogOptions = {
			autoOpen: true
			,title: this.dialogPrompt
			,modal: true
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
				if( shouldReset ) {
					opts.onReset();
				};
			}
		};
		
		var width = computeMaxDialogWidth(370);
		if( typeof width === 'number' ){
			dialogOptions.width = width;
		};

		$dialog.dialog(dialogOptions);

		this.searchService.installSearch({
			textInput: $('#'+inputId)
			,searchButton: $('#'+searchButtonId)
			,displayFn: receiveSearchResults
			,onlyFinalResults: true
		});
		
		var $input = $('#'+inputId);
		$('#'+inputId).focus();
		
		// Get suggestions
		if( opts.contextDoc && typeof opts.contextDoc._id === 'string' ){
			this.documentSource.getReferencesFromId({
				docId: opts.contextDoc._id
				,onSuccess: receiveSuggestions
				,onError: function(errorMsg){
					// Ignore
					$n2.logError('Unable to fetch related documents for ' + opts.contextDoc._id);
				}
			});
		};
		
		function receiveSearchResults(displayData) {
			if( !displayData ) {
				reportError( _loc('Invalid search results returned') );

			} else if( 'wait' === displayData.type ) {
				$('#'+displayId).empty();

			} else if( 'results' === displayData.type ) {
				var docIds = [];
			
				for(var i=0,e=displayData.list.length; i<e; ++i) {
					var docId = displayData.list[i].id;
					docIds.push(docId);
				};
				
				if( docIds.length < 1 ){
					displayDocs([]);
					
				} else {
					_this.documentSource.getDocuments({
						docIds: docIds
						,onSuccess: function(docs){

							_this.filterDocuments({
								docs: docs
								,onSuccess: function(docs){
									displayDocs(docs, displayId);
								}
								,onError: reportError
							});
						}
						,onError: function(errorMsg){ 
							reportError( _loc('Unable to retrieve documents') );
						}
					});
				};
				
			} else {
				reportError( _loc('Invalid search results returned') );
			};
		};

		function receiveSuggestions(docIds) {
			if( docIds.length < 1 ){
				displayDocs([]);
				
			} else {
				_this.documentSource.getDocuments({
					docIds: docIds
					,onSuccess: function(docs){

						_this.filterDocuments({
							docs: docs
							,onSuccess: function(docs){
								displayDocs(docs, suggestionId);
							}
							,onError: reportError
						});
					}
					,onError: function(errorMsg){ 
						reportError( _loc('Unable to retrieve documents') );
					}
				});
			};
		};

		function displayDocs(docs, elemId) {

			if( docs.length < 1 ){
				$('#'+elemId)
					.empty()
					.text( _loc('No results returned by search') );
				
			} else {
				var $table = $('<table></table>');
				$('#'+elemId).empty().append($table);

				for(var i=0,e=docs.length; i<e; ++i) {
					var doc = docs[i];
					var docId = doc._id;
					
					var $tr = $('<tr></tr>');

					$table.append($tr);

					var $td = $('<td>')
						.addClass('n2_search_result olkitSearchMod2_'+(i%2))
						.appendTo($tr);
					
					var $a = $('<a>')
						.attr('href','#'+docId)
						.attr('alt',docId)
						.appendTo($td)
						.click( createClickHandler(docId) );
					
					if( _this.showService ) {
						_this.showService.displayBriefDescription($a, {}, doc);
					} else {
						$a.text(docId);
					};
				};
			};
		};
		
		function createClickHandler(docId) {
			return function(e){
				opts.onSelected(docId);
				shouldReset = false;
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			};
		};
		
		function reportError(err){
			$('#'+displayId)
				.empty()
				.text( err );
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
/**
 * Search for a related image media file
 * @class
 */
var SearchRelatedImageDialogFactory = $n2.Class('SearchRelatedImageDialogFactory', SearchRelatedMediaDialogFactory, {

	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: undefined
			,searchService: undefined
			,showService: undefined
			,dialogPrompt: _loc('Select a Related Image')
		},opts_);
		
		SearchRelatedMediaDialogFactory.prototype.initialize.call(this, opts);
	},
	
	/*
	 * Keeps only documents that have an audio attachment
	 */
	filterDocuments: function(opts_){
		var opts = $n2.extend({
			docs: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		var selectedDocs = [];
		
		if( $n2.isArray(opts.docs) ){
			opts.docs.forEach(function(doc){
				var attachments = $n2.couchAttachment.getAttachments(doc);
				attachments.forEach(function(att){
					if( att.isSource() 
					 && att.isAttached() 
					 && 'image' === att.getFileClass() ){
						selectedDocs.push(doc);
					};
				});
			});
		};
		
		opts.onSuccess( selectedDocs );
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
/**
 * Search for a related audio media file
* @class
*/
var SearchRelatedAudioDialogFactory = $n2.Class('SearchRelatedAudioDialogFactory', SearchRelatedMediaDialogFactory, {

	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: undefined
			,searchService: undefined
			,showService: undefined
			,dialogPrompt: _loc('Select a Related Audio File')
		},opts_);
		
		SearchRelatedMediaDialogFactory.prototype.initialize.call(this, opts);
	},
	
	/*
	 * Keeps only documents that have an audio attachment
	 */
	filterDocuments: function(opts_){
		var opts = $n2.extend({
			docs: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		var selectedDocs = [];
		
		if( $n2.isArray(opts.docs) ){
			opts.docs.forEach(function(doc){
				var attachments = $n2.couchAttachment.getAttachments(doc);
				attachments.forEach(function(att){
					if( att.isSource() 
					 && att.isAttached() 
					 && 'audio' === att.getFileClass() ){
						selectedDocs.push(doc);
					};
				});
			});
		};
		
		opts.onSuccess( selectedDocs );
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
/**
* Search for a related video media file
* @class
*/
var SearchRelatedVideoDialogFactory = $n2.Class('SearchRelatedVideoDialogFactory', SearchRelatedMediaDialogFactory, {

	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: undefined
			,searchService: undefined
			,showService: undefined
			,dialogPrompt: _loc('Select a Related Video File')
		},opts_);
		
		SearchRelatedMediaDialogFactory.prototype.initialize.call(this, opts);
	},
	
	/*
	 * Keeps only documents that have an audio attachment
	 */
	filterDocuments: function(opts_){
		var opts = $n2.extend({
			docs: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		var selectedDocs = [];
		
		if( $n2.isArray(opts.docs) ){
			opts.docs.forEach(function(doc){
				var attachments = $n2.couchAttachment.getAttachments(doc);
				attachments.forEach(function(att){
					if( att.isSource() 
					 && att.isAttached() 
					 && 'video' === att.getFileClass() ){
						selectedDocs.push(doc);
					};
				});
			});
		};
		
		opts.onSuccess( selectedDocs );
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
/**
 * Search for a related hover sound file
 * @class
 */
var HoverSoundSearchDialogFactory = $n2.Class('HoverSoundSearchDialogFactory', SearchRelatedMediaDialogFactory, {

	initialize: function(opts_){
		var opts = $n2.extend({
			documentSource: undefined
			,searchService: undefined
			,showService: undefined
			,dialogPrompt: _loc('Select a Hover Sound')
		},opts_);
		
		SearchRelatedMediaDialogFactory.prototype.initialize.call(this, opts);
	},
	
	/*
	 * Keeps only documents that have an audio attachment
	 */
	filterDocuments: function(opts_){
		var opts = $n2.extend({
			docs: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		var docsWithHoverSound = [];
		
		if( $n2.isArray(opts.docs) ){
			opts.docs.forEach(function(doc){
				var attachments = $n2.couchAttachment.getAttachments(doc);
				attachments.forEach(function(att){
					if( att.isSource() 
					 && att.isAttached() 
					 && 'audio' === att.getFileClass() ){
						docsWithHoverSound.push(doc);
					};
				});
			});
		};
		
		opts.onSuccess( docsWithHoverSound );
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
// This is a factory class to generate a dialog function that
// can be used in selecting a document id from a list of presented
// documents. This is an abstract class and it must be specialized
// before it can be useful. Each sub-class should implement the
// method filterDocuments() to return a sorted list of documents that
// can be selected.
//
// The dialog presented offers a search box which performs a text
// search through the database. The documents retrieved this way
// are filtered and sorted by the sub-class. Then filtered list is
// presented to the user for selection.
var FilteredSearchDialogFactory = $n2.Class({

	atlasDb: null,
	
	searchService: null,
	
	showService: null,
	
	dialogPrompt: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			atlasDb: null
			,searchService: null
			,showService: null
			,dialogPrompt: _loc('Search')
		},opts_);
		
		this.atlasDb = opts.atlasDb;
		this.searchService = opts.searchService;
		this.showService = opts.showService;
		this.dialogPrompt = opts.dialogPrompt;
	},
	
	/*
	 * This method returns a function that can be used in
	 * DialogService.addFunctionToMap
	 */
	getDialogFunction: function(){
		var _this = this;
		return function(opts){
			_this.showDialog(opts);
		};
	},
	
	/*
	 * This method must be implemented by sub-classes
	 */
	filterDocuments: function(opts_){
		var opts = $n2.extend({
			docs: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		},opts_);
		
		$n2.log('Subclasses to FilteredSearchDialogFactory must implement filterDocuments()');
		
		opts.onSuccess( opts.docs );
	},
	
	showDialog: function(opts_){
		var opts = $n2.extend({
			onSelected: function(docId){}
			,onReset: function(){}
		},opts_);
		
		var _this = this;

		var shouldReset = true;
		
		var dialogId = $n2.getUniqueId();
		var inputId = $n2.getUniqueId();
		var searchButtonId = $n2.getUniqueId();
		var displayId = $n2.getUniqueId();
		
		var $dialog = $('<div>')
			.attr('id',dialogId)
			.addClass('editorSelectDocumentDialog');
		
		var $searchLine = $('<div>')
			.appendTo($dialog);

		$('<label>')
			.attr('for', inputId)
			.text( _loc('Search:') )
			.appendTo($searchLine);

		$('<input>')
			.attr('id', inputId)
			.attr('type', 'text')
			.appendTo($searchLine);

		$('<button>')
			.attr('id', searchButtonId)
			.text( _loc('Search') )
			.appendTo($searchLine);
		
		$('<div>')
			.attr('id',displayId)
			.addClass('editorSelectDocumentDialogResults')
			.appendTo($dialog);
		
		var $buttons = $('<div>')
			.appendTo($dialog);
		
		$('<button>')
			.addClass('cancel')
			.text( _loc('Cancel') )
			.appendTo($buttons)
			.button({icons:{primary:'ui-icon-cancel'}})
			.click(function(){
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			});

		var dialogOptions = {
			autoOpen: true
			,title: this.dialogPrompt
			,modal: true
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
				if( shouldReset ) {
					opts.onReset();
				};
			}
		};
		
		var width = computeMaxDialogWidth(370);
		if( typeof width === 'number' ){
			dialogOptions.width = width;
		};

		$dialog.dialog(dialogOptions);

		this.searchService.installSearch({
			textInput: $('#'+inputId)
			,searchButton: $('#'+searchButtonId)
			,displayFn: receiveSearchResults
			,onlyFinalResults: true
		});
		
		var $input = $('#'+inputId);
		$('#'+inputId).focus();
		
		function receiveSearchResults(displayData) {
			if( !displayData ) {
				reportError( _loc('Invalid search results returned') );

			} else if( 'wait' === displayData.type ) {
				$('#'+displayId).empty();

			} else if( 'results' === displayData.type ) {
				var docIds = [];
			
				for(var i=0,e=displayData.list.length; i<e; ++i) {
					var docId = displayData.list[i].id;
					docIds.push(docId);
				};
				
				if( docIds.length < 1 ){
					displayDocs([]);
					
				} else {
					_this.atlasDb.getDocuments({
						docIds: docIds
						,onSuccess: function(docs){

							_this.filterDocuments({
								docs: docs
								,onSuccess: displayDocs
								,onError: reportError
							});
						}
						,onError: function(errorMsg){ 
							reportError( _loc('Unable to retrieve documents') );
						}
					});
				};
				
			} else {
				reportError( _loc('Invalid search results returned') );
			};
		};

		function displayDocs(docs) {

			if( docs.length < 1 ){
				$('#'+displayId)
					.empty()
					.text( _loc('No results returned by search') );
				
			} else {
				var $table = $('<table></table>');
				$('#'+displayId).empty().append($table);

				for(var i=0,e=docs.length; i<e; ++i) {
					var doc = docs[i];
					var docId = doc._id;
					
					var $tr = $('<tr></tr>');

					$table.append($tr);

					var $td = $('<td>')
						.addClass('n2_search_result olkitSearchMod2_'+(i%2))
						.appendTo($tr);
					
					var $a = $('<a>')
						.attr('href','#'+docId)
						.attr('alt',docId)
						.appendTo($td)
						.click( createClickHandler(docId) );
					
					if( _this.showService ) {
						_this.showService.displayBriefDescription($a, {}, doc);
					} else {
						$a.text(docId);
					};
				};
			};
		};
		
		function createClickHandler(docId) {
			return function(e){
				opts.onSelected(docId);
				shouldReset = false;
				var $dialog = $('#'+dialogId);
				$dialog.dialog('close');
				return false;
			};
		};
		
		function reportError(err){
			$('#'+displayId)
				.empty()
				.text( err );
		};
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++
var DialogService = $n2.Class({

	dispatchService: null,
	
	documentSource: null,

	searchService: null,
	
	showService: null,
	
	schemaRepository: null,
	
	funcMap: null,
	
	atlasDesign: null,
	
	initialize: function(opts_) {
		var opts = $n2.extend({
			dispatchService: null
			,documentSource: null
			,searchService: null
			,showService: null
			,schemaRepository: null
			,funcMap: null
			,atlasDesign: null
		},opts_);
	
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.documentSource = opts.documentSource;
		this.searchService = opts.searchService;
		this.showService = opts.showService;
		this.schemaRepository = opts.schemaRepository;
		this.atlasDesign = opts.atlasDesign;
		
		this.funcMap = {};
		for(var key in opts.funcMap){
			var fn = opts.funcMap[key];
			
			if( typeof(fn) === 'function' ){
				this.funcMap[key] = fn;
			};
		};
		
		// Add 'getDocumentId', if not defined
		if( !this.funcMap['getDocumentId'] ){
			this.funcMap['getDocumentId'] = function(opts){
				_this.searchForDocumentId(opts);
			};			
		};
		if( !this.funcMap['getLayers'] ){
			this.funcMap['getLayers'] = function(opts){
				_this.selectLayersDialog(opts);
			};			
		};
		
		if( !this.funcMap['getRelatedMedia'] ){
			var relatedMediaDialogFactory = new SearchRelatedMediaDialogFactory({
				documentSource: this.documentSource
				,searchService: this.searchService
				,showService: this.showService
			});
			this.funcMap['getRelatedMedia'] = relatedMediaDialogFactory.getDialogFunction();
		};
		
		if( !this.funcMap['getRelatedImage'] ){
			var factory = new SearchRelatedImageDialogFactory({
				documentSource: this.documentSource
				,searchService: this.searchService
				,showService: this.showService
			});
			this.funcMap['getRelatedImage'] = factory.getDialogFunction();
		};
		
		if( !this.funcMap['getRelatedAudio'] ){
			var factory = new SearchRelatedAudioDialogFactory({
				documentSource: this.documentSource
				,searchService: this.searchService
				,showService: this.showService
			});
			this.funcMap['getRelatedAudio'] = factory.getDialogFunction();
		};
		
		if( !this.funcMap['getRelatedVideo'] ){
			var factory = new SearchRelatedVideoDialogFactory({
				documentSource: this.documentSource
				,searchService: this.searchService
				,showService: this.showService
			});
			this.funcMap['getRelatedVideo'] = factory.getDialogFunction();
		};
		
		if( !this.funcMap['getHoverSound'] ){
			var hoverSoundDialogFactory = new HoverSoundSearchDialogFactory({
				documentSource: this.documentSource
				,searchService: this.searchService
				,showService: this.showService
			});
			this.funcMap['getHoverSound'] = hoverSoundDialogFactory.getDialogFunction();
		};

		if( !this.funcMap['getDocumentFromSchema'] ){
			var factory = new SearchOnSchemaDialogFactory({
				atlasDesign: this.atlasDesign
				,showService: this.showService
			});
			this.funcMap['getDocumentFromSchema'] = factory.getDialogFunction();
		};

		if( !this.funcMap['getDocumentFromLayer'] ){
			var factory = new SearchOnLayerDialogFactory({
				atlasDesign: this.atlasDesign
				,showService: this.showService
			});
			this.funcMap['getDocumentFromLayer'] = factory.getDialogFunction();
		};
	},
	
	getFunctionMap: function(){
		return this.funcMap;
	},
	
	addFunctionToMap: function(fnName, fn){
		if( typeof(fn) === 'function' ){
			this.funcMap[fnName] = fn;
		};
	},

	searchForDocumentId: function(opts_){
		var opts = $n2.extend({
			onSelected: function(docId){}
			,onReset: function(){}
		},opts_);
		
		
		var searchServer = this.searchService;
		var showService = this.showService;
		
		searchForDocumentId({
			searchServer: searchServer
			,showService: showService
			,onSelected: opts.onSelected
			,onReset: opts.onReset
		});
	},
	
	selectLayersDialog: function(opts_){
		var opts = $n2.extend({
			currentLayers: []
			,onSelected: function(layerIds){}
			,onReset: function(){}
		},opts_);

		selectLayersDialog({
			currentLayers: opts.currentLayers
			,cb: opts.onSelected
			,resetFn: opts.onReset
			,showService: this.showService
			,dispatchService: this.dispatchService
			,documentSource: this.documentSource
		});
	},

	selectSchemaFromNames: function(opt_){
		var opt = $n2.extend({
			schemaNames: []
			,onSelected: function(schema){}
			,onError: $n2.reportErrorForced
			,onReset: function(){}
		},opt_);
		
		var _this = this;
		
		this.schemaRepository.getSchemas({
			names: opt.schemaNames
			,onSuccess: function(schemas){
				_this.selectSchema({
					schemas: schemas
					,onSelected: opt.onSelected
					,onError: opt.onError
					,onReset: opt.onReset
				});
			}
			,onError: opt.onError
		});
	},
	
	selectSchema: function(opt_){
		var opt = $n2.extend({
			schemas: null
			,onSelected: function(schema){}
			,onError: $n2.reportErrorForced
			,onReset: function(){}
		},opt_);
		
		var _this = this;
		
		// Check if all schemas
		if( null === opt.schemas ){
			this.schemaRepository.getRootSchemas({
				names: opt.schemaNames
				,onSuccess: function(schemas){
					_this.selectSchema({
						schemas: schemas
						,onSelected: opt.onSelected
						,onError: opt.onError
						,onReset: opt.onReset
					});
				}
				,onError: opt.onError
			});
			return;
		};
		
		if( !opt.schemas.length ) {
			opt.onReset();
			return;
		}

		if( opt.schemas.length == 1 ) {
			opt.onSelected( opt.schemas[0] );
			return;
		}
		
		var diagId = $n2.getUniqueId();
		var $dialog = $('<div id="'+diagId+'"></div>');

		if (!window.cordova) {
			var $label = $('<span></span>');
			$label.text( _loc('Select schema') + ': ' );
			$dialog.append($label);
		}
		
		var $select = $('<select></select>');

		if (window.cordova) {
			$select.addClass('cordova-select-dropdown');
		}

		$dialog.append($select);
		for(var i=0,e=opt.schemas.length; i<e; ++i){
			var schema = opt.schemas[i];
			var schemaName = schema.name;
			var schemaLabel = schema.getLabel();
			$('<option>')
				.text(schemaLabel)
				.val(schemaName)
				.appendTo($select);
		};

		$dialog.append( $('<br/>') );
		
		var mustReset = true;
		
		var $btnContainer;
		if (window.cordova) {
			$btnContainer = $('<div></div>')
				.addClass('cordova-button-container');
		}

		var $ok;
		if (window.cordova) {
			$ok = $('<label></label>')
				.text(_loc('Select'))
				.addClass('cordova-dialog-btn')
			$btnContainer.append($ok);
		} else {
			$ok = $('<button></button>');
			$ok.text( _loc('OK') );
			$ok.button({icons:{primary:'ui-icon-check'}});
			$dialog.append( $ok );
		} 
		$ok.click(function(){
			mustReset = false;
			
			var $diag = $('#'+diagId);
			var schemaName = $diag.find('select').val();
			$diag.dialog('close');
			_this.schemaRepository.getSchema({
				name: schemaName
				,onSuccess: opt.onSelected
				,onError: function(err){
					opt.onError( _loc('Unable to fetch schema') );
				}
			});
			return false;
		});
		
		var $cancel;
		if (window.cordova) {
			$cancel = $('<label></label>')
				.addClass('cordova-dialog-btn');
			$btnContainer.append($cancel);
		} else {
			$cancel = $('<button></button>');
			$cancel.button({icons:{primary:'ui-icon-cancel'}});
			$dialog.append( $cancel );
		}
		$cancel.text( _loc('Cancel') );
		$cancel.click(function(){
			$('#'+diagId).dialog('close');
			return false;
		});

		if (window.cordova) {
			$dialog.append($btnContainer);
		}

		var dialogOptions = {
			autoOpen: true
			,title: _loc('Select a schema')
			,modal: true
			,resizable: !window.cordova
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
				
				if( mustReset ){
					opt.onReset();
				};
			}
			,open: function(event, ui) {
				if (window.cordova) {
					$(".ui-dialog-titlebar-close", ui.dialog | ui).hide();
				}
    	}
		};
		
		if (window.cordova) {
			// Make the dialog title larger on Cordova
			$("<style type='text/css'> .ui-dialog-title { font-size: large } </style>").appendTo("head");
		}
		
		if (window.cordova) {
			dialogOptions.maxWidth = '300px'
		} else {
			var width = computeMaxDialogWidth(740);
			if( typeof width === 'number' ){
				dialogOptions.width = width;
			};
		}
		
		$dialog.dialog(dialogOptions);
	}
});

//++++++++++++++++++++++++++++++++++++++++++++++

$n2.couchDialogs = {
	DialogService: DialogService
	,SearchBriefDialogFactory: SearchBriefDialogFactory
	,FilteredSearchDialogFactory: FilteredSearchDialogFactory
	,ProgressDialog: ProgressDialog
	,AlertDialog: AlertDialog
	,SearchRelatedMediaDialogFactory: SearchRelatedMediaDialogFactory
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couch.ol.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($n2){
"use strict";

// If OpenLayers is not included, do not process further
if( typeof OpenLayers === 'undefined' ) return;

/**
 * Class: OpenLayers.Format.Couch
 * A parser to read/write CouchDb documents.  Create a new instance with the
 *     <OpenLayers.Format.Couch> constructor.
 *
 * Inherits from:
 *  - <OpenLayers.Format>
 */
OpenLayers.Format.Couch = OpenLayers.Class(OpenLayers.Format, {
	
	/**
	 * Projection that the database uses for the given geometry
	 */
	dbProj: null,
    
    /**
     * Constructor: OpenLayers.Format.Couch
     * Create a new parser for JSON.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        OpenLayers.Format.prototype.initialize.apply(this, [options]);
        
        this.dbProj = new OpenLayers.Projection('EPSG:4326');
    },

    /**
     * APIMethod: read
     * Accepts a CouchDb response and returns an array of features.
     *
     * Parameters:
     * response - {Array} CouchDb documents
     *     
     * Returns:
     * {Object} An object, array, string, or number .
     */
    read: function(docs) {

        try {
        	var results = [];
			for(var i=0,e=docs.length; i<e; ++i) {
				var doc = docs[i];
				
				var id = null;
				var geom = null;
				
				if( doc._id ) {
					id = doc._id;
				};
				
				if( doc.nunaliit_geom.wkt ) {
					geom = OpenLayers.Geometry.fromWKT(doc.nunaliit_geom.wkt);
					
					if( geom ){
						if( !$n2.olUtils.isValidGeom(geom) ) {
							geom = null;
						};
					};

					if( !geom ){
						$n2.log('Invalid WKT('+doc._id+'): '+doc.nunaliit_geom.wkt);
					};
				};
				
				if( id && geom ) {
					var f = new OpenLayers.Feature.Vector(geom,doc);
					f.fid = id;
					f.n2GeomProj = this.dbProj;
					results.push(f);
				} else {
					$n2.log('Invalid feature',doc);
				};
			};
			
			return results;
        } catch(e) {
            $n2.log('Error during CouchDB format read',e);
        }
        return null;
    },

    /**
     * APIMethod: write
     * Serialize an object.
     *
     * Parameters:
     * features - {Array} Features to be serialized.
     *
     * Returns:
     * {Array} Documents to be sent to CouchDb.
     */
    write: function(features) {
    	var result = [];
    	
        for(var i=0,e=features.length; i<e; ++i) {
        	var f = features[i];
        	
        	var data = f.data;
        	if( null == data ) {
        		data = {};
        	};
        	
        	// Add FID
        	if( f.fid ) {
        		data._id = f.fid;
        	};
        	
        	// Update geometry
        	var geom = f.geometry;
        	var mapProjection = f.layer.map.getProjectionObject();
        	if( f.layer.projection 
        	 && mapProjection
        	 && f.layer.projection.getCode() != mapProjection.getCode() ) {
        	 	geom = geom.clone();
        	 	geom.transform(mapProjection, f.layer.projection);
        	};
        	if( !data.nunaliit_geom ) data.nunaliit_geom = { nunaliit_type: 'geometry' };
        	data.nunaliit_geom.wkt = geom.toString();
        	var bbox = geom.getBounds();
        	data.nunaliit_geom.bbox = [bbox.left,bbox.bottom,bbox.right,bbox.top];
        	
        	if( data.nunaliit_geom.simplified ){
        		delete data.nunaliit_geom.simplified;
        	};
        	
        	result.push( data );
        };
        
        return result;
    },

    CLASS_NAME: "OpenLayers.Format.Couch" 

});     


/**
 * Class: OpenLayers.Protocol.Couch
 * A basic protocol for accessing vector layers from couchDb.  Create a new instance with the
 *     <OpenLayers.Protocol.Couch> constructor.
 *
 * Inherits from:
 *  - <OpenLayers.Protocol>
 */
OpenLayers.Protocol.Couch = OpenLayers.Class(OpenLayers.Protocol, {

    /**
     * Property: documentSource
     * {Object} Instance of DocumentSource to access map geometries.
     */
    documentSource: null,

    /**
     * Property: layerName
     * {String} Name of layer associated with seeked features. Null if all geometries
     * are to be accepted.
     */
    layerName: null,

    /**
     * Property: callback
     * {Object} Function to be called when the <read>, <create>,
     *     <update>, <delete> or <commit> operation completes, read-only,
     *     set through the options passed to the constructor.
     */
    callback: null,

    /**
     * Property: scope
     * {Object} Callback execution scope, read-only, set through the
     *     options passed to the constructor.
     */
    scope: null,

    /**
     * Property: notifications
     * {Object} Set of functions to call to report on bubsy status
     */
    notifications: null,

    /**
     * Property: wildcarded.
     * {Boolean} If true percent signs are added around values
     *     read from LIKE filters, for example if the protocol
     *     read method is passed a LIKE filter whose property
     *     is "foo" and whose value is "bar" the string
     *     "foo__ilike=%bar%" will be sent in the query string;
     *     defaults to false.
     */
    wildcarded: false,

    /**
     * Constructor: OpenLayers.Protocol.Couch
     * A class for giving layers generic HTTP protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options include:
     * view - {String} Name of couchDb view, including design url.
     * format - {<OpenLayers.Format>}
     * callback - {Function}
     * scope - {Object}
     */
    initialize: function(options) {
        options = options || {};
        
        // Install default format
        if( !options.format ) {
        	options.format = new OpenLayers.Format.Couch();
        };
        
       	options.projection = new OpenLayers.Projection('EPSG:4326');
        
        OpenLayers.Protocol.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        OpenLayers.Protocol.prototype.destroy.apply(this);
    },
   
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Valid options:
     * view - {String} Name of couchDb view, including design url.
     * filter - {<OpenLayers.Filter>} Filter to get serialized as a
     *     query string.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} A response object, whose "priv" property
     *     references the HTTP request, this object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the the features received from the server.
     */
    read: function(options) {

    	var _this = this;

    	if( this.notifications && this.notifications.readStart ){
    		this.notifications.readStart();
    	};
    	
    	// Obtain layer
    	var layer = options.object;
    	
        OpenLayers.Protocol.prototype.read.apply(this, arguments);
        options = OpenLayers.Util.applyDefaults(options, this.options);
        var resp = new OpenLayers.Protocol.Response({requestType: 'read'});
		
		// Add BBOX tiling
		var bounds = this.getBboxFromFilter(options.filter);
		var fids = this.getFidsFromFilter(options.filter);
		var layerName = ('string' === typeof(options.layerName) ? options.layerName : null);
		
		var projectionCode = null;
		var mapProjection = null;
		if( layer && layer.map ){
			mapProjection = layer.map.getProjectionObject();
			projectionCode = mapProjection.getCode();
		};
		
		this.documentSource.getDocumentsFromGeographicFilter({
			docIds: fids
			,layerId: layerName
			,bbox: bounds
			,projectionCode: projectionCode
			,onSuccess: function(docs){
				_this.handleRead(resp, options, docs);
			}
			,onError: function(errorMsg){
				$n2.log(errorMsg); 
            	if( _this.notifications && _this.notifications.readEnd ){
            		_this.notifications.readEnd();
            	};
			}
		});

        return resp;
    },

    /**
     * Method: handleRead
     * Individual callbacks are created for read, create and update, should
     *     a subclass need to override each one separately.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(resp, options, docs) {
    	
    	var _this = this;

        if(options.callback) {
            resp.features = this.format.read(docs);

            // Sorting now saves on rendering a re-sorting later
	    	$n2.olUtils.sortFeatures(resp.features);

            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
            
            window.setTimeout(function(){
            	if( _this.notifications && _this.notifications.readEnd ){
            		_this.notifications.readEnd();
            	};
            },0);
        };
    },

    /**
     * APIMethod: create
     * Construct a request for writing newly created features.
     *
     * Parameters:
     * features - {Array({<OpenLayers.Feature.Vector>})} or
     *     {<OpenLayers.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the features received from the server.
     */
    create: function(features, options) {
        options = OpenLayers.Util.applyDefaults(options, this.options);
        
        var documents = this.format.write(features);
        
        // Apply layer name, if needed
        if( options.layerName ) {
        	for(var i=0,e=documents.length; i<e; ++i) {
        		var doc = documents[i];
        		if( !doc.nunaliit_layers ) {
        			doc.nunaliit_layers = [];
        		};
        		if( jQuery.inArray(options.layerName, doc.nunaliit_layers) < 0 ) {
        			doc.nunaliit_layers.push(options.layerName);
        		};
        	};
        };

        var resp = new OpenLayers.Protocol.Response({
            reqFeatures: features,
            requestType: "create"
        });
        
		var _this = this;
        this.db.bulkDocuments(documents,{
        	onSuccess: function(docIds){
				_this.handleCreate(resp, options, docIds);        		
        	}
			,onError: function(errorMsg){ $n2.reportError(errorMsg); }
        });

        return resp;
    },

    /**
     * Method: handleCreate
     * Called when the request issued by <create> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create call.
     */
    handleCreate: function(resp, options, docIds) {
    	
    	// Update features with FIDs and _rev
        var features = resp.reqFeatures;
        var insertedFeatures = [];
        if( features.length != docIds.length ) {
        	// There is an error
        	$n2.reportError($n2.ERROR_NO_SUPRESS, 'Invalid feature bulk create');
        } else {
        	for(var i=0,e=docIds.length; i<e; ++i) {
        		var f = features[i];
        		var d = docIds[i];
        		
        		if( d.error ) {
        			if( d.reason ) {
        				$n2.reportError($n2.ERROR_NO_SUPRESS, d.error+' : '+d.reason);
        			} else {
        				$n2.reportError($n2.ERROR_NO_SUPRESS, d.error);
        			};
        		} else {
	        		f.fid = d.id;
	        		if( f.data ) {
		        		f.data._id = d.id;
		        		f.data._rev = d.rev;
	        		};
	        		if( f.attribute ) {
		        		f.attribute._id = d.id;
		        		f.attribute._rev = d.rev;
	        		};
	        		insertedFeatures.push(f);
        		};
        	};
        };
        
        // Perform call back, if needed
        if(options.callback && insertedFeatures.length > 0) {
        	resp.features = insertedFeatures;
        	
            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * APIMethod: update
     * Construct a request updating modified feature.
     *
     * Parameters:
     * feature - {<OpenLayers.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the feature received from the server.
     */
    update: function(feature, options) {
        options = options || {};
        options = OpenLayers.Util.applyDefaults(options, this.options);

		var documents = this.format.write([feature]);

        var resp = new OpenLayers.Protocol.Response({
            reqFeatures: feature,
            requestType: "update"
        });
        
		var _this = this;
        this.db.updateDocument({
        	data: documents[0]
        	,onSuccess: function(docInfo){
				_this.handleUpdate(resp, options, docInfo);        		
        	}
			,onError: function(errorMsg){ $n2.reportError(errorMsg); }
        });

        return resp;
    },

    /**
     * Method: handleUpdate
     * Called the the request issued by <update> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the update call.
     */
    handleUpdate: function(resp, options, docInfo) {
    	
    	// Update feature with _rev
        var feature = resp.reqFeatures;
        if( feature.data ) {
        	feature.data._rev = docInfo.rev;
        };
        if( feature.attribute ) {
        	feature.attribute._rev = docInfo.rev;
        };
        
        // Perform call back, if needed
        if(options.callback) {
        	resp.features = [feature];
        	
            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * APIMethod: delete
     * Construct a request deleting a removed feature.
     *
     * Parameters:
     * feature - {<OpenLayers.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes.
     */
    "delete": function(feature, options) {
        options = options || {};
        options = OpenLayers.Util.applyDefaults(options, this.options);

        var resp = new OpenLayers.Protocol.Response({
            reqFeatures: feature,
            requestType: "delete"
        });
        
		var _this = this;
        this.db.deleteDocument({
        	data: feature.data
        	,onSuccess: function(docInfo){
				_this.handleDelete(resp, options, docInfo);        		
        	}
			,onError: function(errorMsg){ $n2.reportError(errorMsg); }
        });

        return resp;
    },

    /**
     * Method: handleDelete
     * Called the the request issued by <delete> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the delete call.
     */
    handleDelete: function(resp, options) {

        // Perform call back, if needed
        if(options.callback) {
            resp.code = OpenLayers.Protocol.Response.SUCCESS;
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * APIMethod: commit
     * Iterate over each feature and take action based on the feature state.
     *     Possible actions are create, update and delete.
     *
     * Parameters:
     * features - {Array({<OpenLayers.Feature.Vector>})}
     * options - {Object} Optional object for setting up intermediate commit
     *     callbacks.
     *
     * Valid options:
     * create - {Object} Optional object to be passed to the <create> method.
     * update - {Object} Optional object to be passed to the <update> method.
     * delete - {Object} Optional object to be passed to the <delete> method.
     * callback - {Function} Optional function to be called when the commit
     *     is complete.
     * scope - {Object} Optional object to be set as the scope of the callback.
     *
     * Returns:
     * {Array(<OpenLayers.Protocol.Response>)} An array of response objects,
     *     one per request made to the server, each object's "priv" property
     *     references the corresponding HTTP request.
     */
    commit: function(features, options) {
        options = OpenLayers.Util.applyDefaults(options, this.options);
        var resp = [], nResponses = 0;
        
        // Divide up features before issuing any requests.  This properly
        // counts requests in the event that any responses come in before
        // all requests have been issued.
        var types = {};
        types[OpenLayers.State.INSERT] = [];
        types[OpenLayers.State.UPDATE] = [];
        types[OpenLayers.State.DELETE] = [];
        var feature, list, requestFeatures = [];
        for(var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            list = types[feature.state];
            if(list) {
                list.push(feature);
                requestFeatures.push(feature); 
            }
        }
        // tally up number of requests
        var nRequests = (types[OpenLayers.State.INSERT].length > 0 ? 1 : 0) +
            types[OpenLayers.State.UPDATE].length +
            types[OpenLayers.State.DELETE].length;
        
        // This response will be sent to the final callback after all the others
        // have been fired.
        var success = true;
        var finalResponse = new OpenLayers.Protocol.Response({
            reqFeatures: requestFeatures        
        });
        
        function insertCallback(response) {
            var len = response.features ? response.features.length : 0;
            var fids = new Array(len);
            for(var i=0; i<len; ++i) {
                fids[i] = response.features[i].fid;
            }   
            finalResponse.insertIds = fids;
            callback.apply(this, [response]);
        }
 
        function callback(response) {
            this.callUserCallback(response, options);
            success = success && response.success();
            nResponses++;
            if (nResponses >= nRequests) {
                if (options.callback) {
                    finalResponse.code = success ? 
                        OpenLayers.Protocol.Response.SUCCESS :
                        OpenLayers.Protocol.Response.FAILURE;
                    options.callback.apply(options.scope, [finalResponse]);
                }    
            }
        }

        // start issuing requests
        var queue = types[OpenLayers.State.INSERT];
        if(queue.length > 0) {
            resp.push(this.create(
                queue, OpenLayers.Util.applyDefaults(
                    {callback: insertCallback, scope: this}, options.create
                )
            ));
        }
        queue = types[OpenLayers.State.UPDATE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this.update(
                queue[i], OpenLayers.Util.applyDefaults(
                    {callback: callback, scope: this}, options.update
                ))
            );
        }
        queue = types[OpenLayers.State.DELETE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this["delete"](
                queue[i], OpenLayers.Util.applyDefaults(
                    {callback: callback, scope: this}, options["delete"]
                ))
            );
        }
        return resp;
    },

    /**
     * APIMethod: abort
     * Abort an ongoing request, the response object passed to
     * this method must come from this HTTP protocol (as a result
     * of a create, read, update, delete or commit operation).
     *
     * Parameters:
     * response - {<OpenLayers.Protocol.Response>}
     */
    abort: function(response) {
        if (response) {
            //response.priv.abort();
            // not supported in CouchDb?
        }
    },

    /**
     * Method: callUserCallback
     * This method is used from within the commit method each time an
     *     an HTTP response is received from the server, it is responsible
     *     for calling the user-supplied callbacks.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>}
     * options - {Object} The map of options passed to the commit call.
     */
    callUserCallback: function(resp, options) {
        var opt = options[resp.requestType];
        if(opt && opt.callback) {
            opt.callback.call(opt.scope, resp);
        }
    },
    
    /**
     * Method: getBboxFromFilter
     * This method is used to find the bounding box filter within the given
     * filter and return the information in a format useable by the tiling system.
     *
     * Parameters:
     * filter - {<OpenLayers.Filter>}
     */
    getBboxFromFilter: function(filter) {

    	if( !filter ) return null;

    	if( filter.type === OpenLayers.Filter.Spatial.BBOX ) {
    		// This is a BBOX
    		return [filter.value.left,filter.value.bottom,filter.value.right,filter.value.top]
    	}

    	if( filter.filters ) {
    		// Logical, continue search
    		for(var i=0,e=filter.filters.length; i<e; ++i) {
    			var bounds = this.getBboxFromFilter(filter.filters[i]);
    			if( bounds ) return bounds;
    		}
    	}

    	return null;
    },

    /**
     * Method: getFidsFromFilter
     * This method is used to find the FID filter within the given
     * filter and return the information in a format useable by the view system.
     *
     * Parameters:
     * filter - {<OpenLayers.Filter>}
     */
    getFidsFromFilter: function(filter) {

    	if( !filter ) return null;

    	if( filter.CLASS_NAME === 'OpenLayers.Filter.FeatureId' ) {
    		// This is a FIDs
    		return filter.fids;
    	}

    	if( filter.filters ) {
    		// Logical, continue search
    		for(var i=0,e=filter.filters.length; i<e; ++i) {
    			var fids = this.getFidsFromFilter(filter.filters[i]);
    			if( fids ) return fids;
    		}
    	}

    	return null;
    },
    
    CLASS_NAME: "OpenLayers.Protocol.Couch" 
});

/**
 * Property: OpenLayers.Protocol.Couch.COMP_TYPE_TO_OP_STR
 * {Object} A private class-level property mapping the
 *     OpenLayers.Filter.Comparison types to the operation
 *     strings of the protocol.
 */
(function() {
    var o = OpenLayers.Protocol.Couch.COMP_TYPE_TO_OP_STR = {};
    o[OpenLayers.Filter.Comparison.EQUAL_TO]                 = "eq";
    o[OpenLayers.Filter.Comparison.NOT_EQUAL_TO]             = "ne";
    o[OpenLayers.Filter.Comparison.LESS_THAN]                = "lt";
    o[OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO]    = "lte";
    o[OpenLayers.Filter.Comparison.GREATER_THAN]             = "gt";
    o[OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO] = "gte";
    o[OpenLayers.Filter.Comparison.LIKE]                     = "ilike";
})();

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couch.l10n.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

// L10N = LOCALIZATION

// @ requires n2.core.js
// @ requires n2.utils.js
// @ requires n2.l10n.js
// @namespace nunaliit2
;(function($n2){
"use strict";

var DH = 'n2.couchL10n';

//----------------------------------------------------------------------------
var LocalizationService = $n2.Class({
	
	db: null,

	designDoc: null,
	
	dispatchService: null,
	
	lookupViewName: null,
	
	translatedViewName: null,
	
	scriptList: null,
	
	isLoggedIn: null,
	
	pendingRequests: null,
	
	processingRequests: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			db: null // must be supplied
			,designDoc: null // must be supplied
			,dispatchService: null
			,lookupViewName: 'l10n-all'
			,translatedViewName: 'l10n-translated'
			,scriptList: 'l10n'
		},opts_);
		
		var _this = this;
		
		this.db = opts.db;
		this.designDoc = opts.designDoc;
		this.dispatchService = opts.dispatchService;
		this.lookupViewName = opts.lookupViewName;
		this.translatedViewName = opts.translatedViewName;
		this.scriptList = opts.scriptList;
	
		this.pendingRequests = [];
		this.processingRequests = false;
		this.isLoggedIn = false;
		
		if( this.dispatchService ){
			var f = function(m, address, dispatcher){
				_this._handle(m, address, dispatcher);
			};
			
			this.dispatchService.register(DH, 'authLoggedIn', f);
			this.dispatchService.register(DH, 'authLoggedOut', f);
			
			// Check if already logged in
			var m = {
				type: 'authIsLoggedIn'
				,isLoggedIn: false
			};
			this.dispatchService.synchronousCall(DH,m);
			if( m.isLoggedIn ){
				this.isLoggedIn = true;
			};
		};
		
		// Configure $n2.l10n.sendTranslationRequest to call this implementation
		$n2.l10n.sendTranslationRequest = function(request){
			_this.sendTranslationRequest(request);
		};
		
		// Load translations stored in database
		this._loadTranslatedStrings();
		
		// Start loading translation requests in database
		this._processPendingRequests();
	},
		
	sendTranslationRequest: function(request) {
		$n2.log('Translate '+request.str+' to '+request.lang+' ('+request.packageName+')');
		this.pendingRequests.push(request);
		this._processPendingRequests();
	},
	
	_handle: function(m, address, dispatcher){
		if( 'authLoggedIn' === m.type ){
			this.isLoggedIn = true;
			this._processPendingRequests();
			
		} else if( 'authLoggedOut' === m.type ){
			this.isLoggedIn = false;
		};
	},
	
	_tryPostingRequests: function() {
		var _this = this;
		
		if( this.pendingRequests.length < 1 ) {
			this.processingRequests = false;
			return;
		};
		if( !this.isLoggedIn ) {
			this.processingRequests = false;
			return;
		};
		
		var request = this.pendingRequests.shift();
		var startkey = [request.lang, request.str];
		
		
		this.designDoc.queryView({
			viewName: this.lookupViewName
			,startkey: startkey
			,endkey: startkey
			,onSuccess: function(results) {
				if( results.length < 1 ) {
					// Must upload
					_uploadRequest(request);
				} else {
					// Go to next one
					_this._tryPostingRequests();
				}
			}
			,onError: function(errorMsg) {
				$n2.log(errorMsg);
				_this._tryPostingRequests();
			}
		});
		
		function _uploadRequest(request) {
			// Get user name
			var userName = null;
			{
				var sessionContext = null;
				
				if( _this.dispatchService ){
					var isLoggedInMsg = {
						type: 'authIsLoggedIn'
					};
					_this.dispatchService.synchronousCall(DH,isLoggedInMsg);
					
					sessionContext = isLoggedInMsg.context;
				};

				if( sessionContext ) {
					userName = sessionContext.name;
				};
			};
			
			// Get now
			var nowTime = (new Date()).getTime();
			
			var data = {
				nunaliit_type: 'translationRequest'
				,nunaliit_schema: 'translationRequest'
				,str: request.str
				,lang: request.lang
				,packageName: request.packageName
			};

			if( userName ) {
				data.nunaliit_created = {
					nunaliit_type: 'actionstamp'
					,name: userName
					,time: nowTime
					,action: 'created'
				};
				
				data.nunaliit_last_updated = {
					nunaliit_type: 'actionstamp'
					,name: userName
					,time: nowTime
					,action: 'updated'
				};
				
				_this.db.createDocument({
					data: data
					,onSuccess: function(){
						_this._tryPostingRequests();
					}
					,onError: function(errorMsg) {
						$n2.reportError(errorMsg);
						_this._tryPostingRequests();
					}
				});
			} else {
				// Not logged in. Strange.
				$n2.log('User not logged in. Translation request ignored.');
				_this._tryPostingRequests();
			};
		};
	},

	_processPendingRequests: function() {
		if( !this.processingRequests ) {
			this.processingRequests = true;
			this._tryPostingRequests();
		};
	},
	
	_loadTranslatedStrings: function() {
		if( $n2.scripts ) {
			var lang = $n2.l10n.getLocale().lang;
			
			// Load already translated strings
			var url = this.designDoc.getQueryUrl({
				viewName: this.translatedViewName
				,listName: this.scriptList
			});

			url += '?startkey="' + lang
				+ '"&endkey="' + lang
				+ '"'
				+ '&include_docs=true&reduce=false'
				;

			var coreLocation = $n2.scripts.getCoreScriptLocation();
			$n2.scripts.loadScript({
				url: url
				,scriptLocation: coreLocation
			});
		};
	}
});

//----------------------------------------------------------------------------
$n2.couchL10n = {
	LocalizationService: LocalizationService
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchMap.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };
var DH = 'n2.couchMap';
	
var g_dispatcher;

function Configure(opts_){
	var opts = $n2.extend({
		dispatchService: null
	},opts_);
	
	if( opts.dispatchService ){
		g_dispatcher = opts.dispatchService;
	};
};

function getCurrentContext(){
	var sessionContext = null;
	
	if( g_dispatcher ){
		var isLoggedInMsg = {
			type: 'authIsLoggedIn'
		};
		g_dispatcher.synchronousCall(DH,isLoggedInMsg);
		
		sessionContext = isLoggedInMsg.context;
	};
	
	return sessionContext;
};

/*
 * This function retained for backward compatibility
 */
function adjustDocument(doc) {
	
	$n2.couchDocument.adjustDocument(doc);
};

function isAdmin() {

	var admin = false;
	var sessionContext = getCurrentContext();
	if( sessionContext
	 && sessionContext.roles ) {
		if( $n2.inArray('_admin',sessionContext.roles) !== -1 ) {
			admin = true;
		};
		if( $n2.inArray('administrator',sessionContext.roles) !== -1 ) {
			admin = true;
		};
		if( typeof(n2atlas) === 'object' 
		 && typeof(n2atlas.name) === 'string' ) {
			var dbAdmin = n2atlas.name + '_administrator';
			if( $n2.inArray(dbAdmin,sessionContext.roles) !== -1 ) {
				admin = true;
			};
		};
	};
	
	return admin;
};

function canEditDoc(data) {

	if( isAdmin() ) {
		return true;
	};

	var userName = null;
	var roleMap = {};
	var sessionContext = getCurrentContext();
	if( sessionContext ) {
		userName = sessionContext.name;
		
		if( sessionContext.roles ){
			for(var i=0,e=sessionContext.roles.length; i<e; ++i){
				roleMap[sessionContext.roles[i]] = true;
			};
		};
	};

	// On an atlas with a submission database, any user can submit
	// a change to any document
	if( typeof(n2atlas) === 'object' 
	 && n2atlas.submissionDbEnabled
	 && userName ) {
		return true;
	};
	
	// If a document is on a layer, then one must have the roles
	// associated with all layers. If a document is not on a layer,
	// then the roles are not relevant.
	var documentIsControlledLayer = false;
	if( data.nunaliit_layers && data.nunaliit_layers.length ){
		for(var i=0,e=data.nunaliit_layers.length; i<e; ++i){
			var layerId = data.nunaliit_layers[i];
			if( 'public' === layerId ){
				// Public layer. Ignore
			} else if( 'public_' === layerId.substr(0,7) ){
					// Public layer. Ignore
			} else {
				documentIsControlledLayer = true;
				
				var requiredRole = null;
				if( typeof(n2atlas) === 'object' 
				 && typeof(n2atlas.name) === 'string' ) {
					requiredRole = n2atlas.name + '_layer_' + layerId;
				} else {
					requiredRole = 'layer_' + layerId;
				};
				
				if( !roleMap[requiredRole] ){
					return false;
				};
			};
		};
		
		if( documentIsControlledLayer ){
			// At this point, there is at least one controlled layer
			// and we have the roles for all of them.
			return true;
		};
	};

	// If a document is not on a controlled layer, then the creator of the
	// document can edit it
	if( data.nunaliit_created
	 && data.nunaliit_created.nunaliit_type
	 && data.nunaliit_created.nunaliit_type === 'actionstamp'
	 && data.nunaliit_created.name === userName
	 ) {
		return true;
	};

	// By default, can not edit a document
	return false;
};

function canDeleteDoc(data) {

	// At this time, if one can edit a document, one can delete it
	return canEditDoc(data);
};

function documentContainsMedia(doc){
	var containsMedia = false;
	
	if( doc.nunaliit_attachments
	 && doc.nunaliit_attachments.files
	 ) {
		for(var attName in doc.nunaliit_attachments.files){
			containsMedia = true;
		};
	};
	
	return containsMedia;
};

function documentContainsApprovedMedia(doc){
	var containsApprovedMedia = false;
	
	if( doc.nunaliit_attachments
	 && doc.nunaliit_attachments.files
	 ) {
		for(var attName in doc.nunaliit_attachments.files){
			var att = doc.nunaliit_attachments.files[attName];
			
			if( att.status === 'approved' 
			 || att.status === 'attached' ) {
				containsApprovedMedia = true;
			};
		};
	};
	
	return containsApprovedMedia;
};

function documentContainsDeniedMedia(doc){
	var containsDeniedMedia = false;
	
	if( doc.nunaliit_attachments
	 && doc.nunaliit_attachments.files
	 ) {
		for(var attName in doc.nunaliit_attachments.files){
			var att = doc.nunaliit_attachments.files[attName];
			
			if( att.status === 'denied' ) {
				containsDeniedMedia = true;
			};
		};
	};
	
	return containsDeniedMedia;
};

// Exports
$n2.couchMap = {
	Configure: Configure
	,adjustDocument: adjustDocument
	,isAdmin: isAdmin
	,canEditDoc: canEditDoc
	,canDeleteDoc: canDeleteDoc
	,documentContainsMedia: documentContainsMedia
	,documentContainsApprovedMedia: documentContainsApprovedMedia
	,documentContainsDeniedMedia: documentContainsDeniedMedia
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchRequests.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

var DH = 'n2.couchRequests',
	MAX_REQUEST_SIZE = 25;

//======================================================
function DocumentRequest(cbFn, multipleDocs){
	this.pending = {};
	this.docsbyId = {};
	this.cbFn = cbFn;
	this.multipleDocs = multipleDocs;
};
DocumentRequest.prototype.waitForDocId = function(docId){
	this.pending[docId] = true;
};
DocumentRequest.prototype.continueDocId = function(docId){
	delete this.pending[docId];
};
DocumentRequest.prototype.isPending = function(){
	for(var docId in this.pending){
		return true;
	};
	return false;
};
DocumentRequest.prototype.receiveDocument = function(doc){
	var docId = doc._id;
	if( this.docsbyId[docId] ){
		this.docsbyId[docId] = doc;
	};
	if( this.pending[docId] ){
		delete this.pending[docId];
		this.docsbyId[docId] = doc;
	};
};
DocumentRequest.prototype.callListener = function(){
	if( typeof this.cbFn === 'function' ){
		if( this.multipleDocs ){
			var docs = [];
			for(var docId in this.docsbyId){
				var doc = this.docsbyId[docId];
				docs.push(doc);
			};
			this.cbFn(docs);
		} else {
			for(var docId in this.docsbyId){
				var doc = this.docsbyId[docId];
				this.cbFn(doc);
			};
		};
		
		// Do not call again
		this.cbFn = null;
	};
};

//======================================================
var DOCUMENT_REQUEST_NO_CALLBACK = new DocumentRequest();
DOCUMENT_REQUEST_NO_CALLBACK.waitForDocId = function(){};
DOCUMENT_REQUEST_NO_CALLBACK.continueDocId = function(){};
DOCUMENT_REQUEST_NO_CALLBACK.isPending = function(){ return false; };
DOCUMENT_REQUEST_NO_CALLBACK.receiveDocument = function(){};
DOCUMENT_REQUEST_NO_CALLBACK.callListener = function(){};

//======================================================
$n2.couchRequests = $n2.Class({
	options: null
	
	,currentRequests: null
	
	,scheduled: null
	
	,userListeners: null
	
	,documentListeners: null
	
	,initialize: function(options_) {
		this.options = $n2.extend({},{
			documentSource: null
			,userDb: null
			,dispatchService: null
			,userServerUrl: null
		},options_);
		
		var _this = this;
		
		this.currentRequests = {};
		
		this.scheduled = false;

		this.userListeners = [];
		
		this.documentListeners = [];
		
		if( this.options.dispatchService ){
			var f = function(m){
				_this._handleMessage(m);
			};
			this.options.dispatchService.register(DH, 'requestDocument', f);
			this.options.dispatchService.register(DH, 'requestDocuments', f);
			this.options.dispatchService.register(DH, 'requestUserDocument', f);
			this.options.dispatchService.register(DH, 'requestUserDocumentComplete', f);
			this.options.dispatchService.register(DH, 'requestLayerDefinition', f);
			this.options.dispatchService.register(DH, 'requestLayerDefinitions', f);
		};
	}

	,addUserListener: function(listener){
		if( typeof(listener) === 'function' ) {
			this.userListeners.push(listener);
		};
	}

	,addDocumentListener: function(listener){
		if( typeof(listener) === 'function' ) {
			this.documentListeners.push(listener);
		};
	}
	
	,requestUser: function(userName){
		// Remember request
		if( !this.currentRequests.users ) {
			this.currentRequests.users = {};
		};
		this.currentRequests.users[userName] = 1;
		
		this._schedule();
	}
	
	,requestCompleteUserDocument: function(userName){
		// Remember request
		if( !this.currentRequests.completeUsers ) {
			this.currentRequests.completeUsers = {};
		};
		this.currentRequests.completeUsers[userName] = 1;
		
		this._schedule();
	}

	,requestDocument: function(docId, cbFn){
		// Remember request
		if( !this.currentRequests.docs ) {
			this.currentRequests.docs = {};
		};
		
		if( !this.currentRequests.docs[docId] ) {
			this.currentRequests.docs[docId] = [];
		};
		
		var request = undefined;
		if( cbFn ){
			request = new DocumentRequest(cbFn);
		} else {
			request = DOCUMENT_REQUEST_NO_CALLBACK;
		};

		request.waitForDocId(docId);

		this.currentRequests.docs[docId].push(request);
		
		this._schedule();
	}

	,requestDocuments: function(docIds, cbFn){
		var _this = this;

		// Remember request
		if( !this.currentRequests.docs ) {
			this.currentRequests.docs = {};
		};
		
		var request = undefined;
		if( cbFn ){
			request = new DocumentRequest(cbFn, true);
		} else {
			request = DOCUMENT_REQUEST_NO_CALLBACK;
		};
		
		docIds.forEach(function(docId){
			request.waitForDocId(docId);

			if( !_this.currentRequests.docs[docId] ) {
				_this.currentRequests.docs[docId] = [];
			};
			
			_this.currentRequests.docs[docId].push(request);
		});
		
		this._schedule();
	}
	
	,requestLayerDefinition: function(layerId){
		// Remember request
		if( !this.currentRequests.layerIds ) {
			this.currentRequests.layerIds = {};
		};
		
		this.currentRequests.layerIds[layerId] = true;
		
		this._schedule();
	}
	
	,requestLayerDefinitions: function(layerIds){
		var _this = this;

		if( $n2.isArray(layerIds) ){
			layerIds.forEach(function(layerId){
				if( typeof layerId === 'string' ){
					_this.requestLayerDefinition(layerId);
				};
			});
		};
	}

	,_schedule: function() {
		if( this.scheduled ) return;
		
		var _this = this;
		this.scheduled = true;
		setTimeout(function(){
			_this.scheduled = false;
			_this._performRequests();
		},0);
	}
	
	,_performRequests: function() {
		var _this = this;
		
		var requests = this.currentRequests;
		this.currentRequests = {};
		
		// Users
		if( requests.users && this.options.userServerUrl ) {
			var params = [];
			for(var userName in requests.users) {
				params.push({
					name: 'user'
					,value: userName
				});
			};
			
			var url = this.options.userServerUrl + 'getUsers';
			
			$.ajax({
		    	url: url
		    	,type: 'GET'
		    	,async: true
		    	,traditional: true
		    	,data: params
		    	,dataType: 'json'
		    	,success: function(result) {
		    		if( result.users ) {
		    			for(var i=0,e=result.users.length;i<e;++i){
		    				var user = result.users[i];
		    				_this._callUserListeners(user);
		    			};
		    		};
		    	}
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {}
			});
			
		} else if( requests.users && this.options.userDb ) {
			// Attempt directly against user database. However, this is
			// likely to fail
			for(var userName in requests.users) {
				this.options.userDb.getUser({
					name: userName
					,onSuccess: function(user) {
						_this._callUserListeners(user);
					}
					,onError: function(err){}
				});
			};
		};

		// Complete user documents
		if( requests.completeUsers && this.options.userServerUrl ) {
			var params = [];
			for(var userName in requests.completeUsers) {
				params.push({
					name: 'user'
					,value: userName
				});
			};
			
			var url = this.options.userServerUrl + 'getUserDocuments';
			
			$.ajax({
		    	url: url
		    	,type: 'GET'
		    	,async: true
		    	,traditional: true
		    	,data: params
		    	,dataType: 'json'
		    	,success: function(result) {
		    		if( result.users ) {
		    			for(var i=0,e=result.users.length;i<e;++i){
		    				var user = result.users[i];
		    				_this._callCompleteUserListeners(user);
		    			};
		    		};
		    	}
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {}
			});
		};
		
		// Documents
		var cachedDocs = null;
		if( requests.docs && this.options.documentSource ) {
			var docIds = [];
			for(var docId in requests.docs) {
				// Check cache
				var cachedDoc = this._getCachedDoc(docId);
				
				if( cachedDoc ) {
					if( !cachedDocs ) {
						cachedDocs = [];
					};
					cachedDocs.push(cachedDoc);
				} else {
					// Not cached. Must request from db
					docIds.push(docId);
				};
			};

			// Request the required documents from db
			if( docIds.length ) {
				var effectiveDocIds = docIds;
				if( effectiveDocIds.length > MAX_REQUEST_SIZE ){
					var extraDocIds = effectiveDocIds.splice(MAX_REQUEST_SIZE);
					
					var extraRequests = this.currentRequests.docs;
					if( !extraRequests ){
						extraRequests = {};
						this.currentRequests.docs = extraRequests;
					};
					extraDocIds.forEach(function(docId){
						extraRequests[docId] = requests.docs[docId];
					});
					
					this._schedule();
				};
				
				this.options.documentSource.getDocuments({
					docIds: effectiveDocIds
					,onSuccess: function(docs) {
						_this._callDocumentListeners(docs, requests, true, effectiveDocIds);
					}
				});
			};
		};
		
		// Report cached documents, if any
		if( null !== cachedDocs ) {
			this._callDocumentListeners(cachedDocs, requests, false);
		};
		
		// Layer definitions
		if( requests.layerIds 
		 && this.options.documentSource ) {

			var layerIds = [];
			for(var layerId in requests.layerIds){
				layerIds[layerIds.length] = layerId;
			};
			
			if( layerIds.length > 0 ){
				this.options.documentSource.getLayerDefinitions({
					layerIds: layerIds
					,fullDocuments: true
					,onSuccess: function(docs) {
						_this._callDocumentListeners(docs, requests, true);
					}
				});
			};
		};
	}
	
	,_callUserListeners: function(userDoc){
		//$n2.log('Requested user doc: ',userDoc);		

		this._dispatch({
			type: 'userInfo'
			,userInfo: userDoc
		});

		for(var j=0,f=this.userListeners.length; j<f; ++j){
			var listener = this.userListeners[j];
			
			//try {
				listener(userDoc);
			//} catch(e){
			//	$n2.log('Error during user document listener: '+e);
			//}
		};
	}
	
	,_callCompleteUserListeners: function(userDoc){
		//$n2.log('Requested user doc: ',userDoc);		

		this._dispatch({
			type: 'userDocument'
			,userDoc: userDoc
		});
	}
	
	,_callDocumentListeners: function(docs, requests, sendVersionEvent, requestedDocIds){
		//$n2.log('Requested docs: ',docs);		
		for(var i=0,e=docs.length; i<e; ++i){
			var doc = docs[i];
			
			if( sendVersionEvent ){
				this._dispatch({
					type: 'documentVersion'
					,docId: doc._id
					,rev: doc._rev
				});
			};
			
			this._dispatch({
				type: 'documentContent'
				,docId: doc._id
				,doc: doc
			});

			// Call document listeners
			for(var j=0,f=this.documentListeners.length; j<f; ++j){
				var listener = this.documentListeners[j];
				
				//try {
					listener(doc);
				//} catch(e){
				//	$n2.log('Error during document listener: '+e);
				//}
			};
			
			// Associate document with a request
			var docId = doc._id;
			if( requests.docs && requests.docs[docId] ) {
				var documentRequests = requests.docs[docId];
				documentRequests.forEach(function(documentRequest){
					documentRequest.receiveDocument(doc);
				});
			};
		};
		
		// Stop waiting for documents if they do not exist
		if( requestedDocIds ) {
			requestedDocIds.forEach(function(requestedId){
				if( requests.docs && requests.docs[requestedId] ){
					var documentRequests = requests.docs[requestedId];
					documentRequests.forEach(function(documentRequest){
						documentRequest.continueDocId(requestedId);
					});
				};
			});
		};

		// Call listeners specific to requests
		if( requests.docs ){
			for(var docId in requests.docs){
				var documentRequests = requests.docs[docId];
				documentRequests.forEach(function(documentRequest){
					if( !documentRequest.isPending() ){
						documentRequest.callListener();
					};
				});
			};
		};
	}
	
	,_getDispatcher: function(){
		var d = null;
		if( this.options.dispatchService ){
			d = this.options.dispatchService;
		};
		return d;
	}
	
	,_dispatch: function(m){
		var dispatcher = this._getDispatcher();
		if( dispatcher ){
			dispatcher.send(DH,m);
		};
	}
	
	,_handleMessage: function(m){
		if( 'requestDocument' === m.type ) {
			var docId = m.docId;
			this.requestDocument(docId, m.callback);
			
		} else if( 'requestDocuments' === m.type ) {
			var docIds = m.docIds;
			this.requestDocuments(docIds, m.callback);

		} else if( 'requestUserDocument' === m.type ) {
			var userId = m.userId;
			this.requestUser(userId);

		} else if( 'requestUserDocumentComplete' === m.type ) {
			var userId = m.userId;
			this.requestCompleteUserDocument(userId);

		} else if( 'requestLayerDefinition' === m.type ) {
			var layerId = m.layerId;
			this.requestLayerDefinition(layerId);

		} else if( 'requestLayerDefinitions' === m.type ) {
			var layerIds = m.layerIds;
			this.requestLayerDefinitions(layerIds);
		};
	}
	
	,_getCachedDoc: function(docId){
		var dispatcher = this._getDispatcher();
		if( dispatcher ){
			var m = {
				type: 'cacheRetrieveDocument'
				,docId: docId
				,doc: null
			};
			
			dispatcher.synchronousCall(DH,m);
			
			if( m.doc ){
				return m.doc;
			};
		};
		
		return null;
	}
});

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couch.sound.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

var DH = 'n2.couch.sound';	
	
// ===========================================================================
function defaultInstallSound(info) {};
function defaultHandleDocumentSound(info_, cb_){cb_(info_);};

var HoverSoundService = $n2.Class({

	db: null,
	
	dispatcher: null,
	
	requestService: null,
	
	customService: null,
	
	handleDocumentSound: null,
	
	currentFocusDocIdMap: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			db: null // couchDb needed to access documents
			,dispatchService: undefined
			,requestService: undefined
			,customService: undefined
			,handleDocumentSound: defaultHandleDocumentSound
		},opts_);

		var _this = this;
		
		this.db = opts.db;
		this.dispatcher = opts.dispatchService;
		this.requestService = opts.requestService;
		this.customService = opts.customService;
		this.handleDocumentSound = opts.handleDocumentSound;
		
		this.currentFocusDocIdMap = {};

		if( this.dispatcher ) {
			var f = function(m){ _this._handleDispatch(m); };
			
			this.dispatcher.register(DH, 'focusOn', f);
			this.dispatcher.register(DH, 'focusOff', f);
			this.dispatcher.register(DH, 'playHoverSoundOn', f);
			this.dispatcher.register(DH, 'playHoverSoundOff', f);
			this.dispatcher.register(DH, 'playSoundOn', f);
			this.dispatcher.register(DH, 'playSoundOff', f);
		};
	},

	handleFeatureHover: function(feature, opts_) {

		if( !feature ) return;
		
		var data = feature.attributes;
		if( !data ) {
			data = feature.data;
		};
		if( !data ) {
			// can not do anything
			return;
		};

		this.findDocumentHoverSound(data, opts_);
	},

	findDocumentHoverSound: function(data, opts_) {

		var opts = $n2.extend({
			installSoundFn: defaultInstallSound
			,handleDocumentSound: this.handleDocumentSound
		},opts_);
		
		var _this = this;

		if( !data ) return;
		
		var info = {
			docId: data._id
			,doc: data
			,soundUrl: null
			,installSoundFn: opts.installSoundFn
		};
		
		opts.handleDocumentSound(info, function(info_){
			_this._defaultDocumentSound(info_);
		});
	},

	_defaultDocumentSound: function(info) {

		var _this = this;

		if( info.soundUrl ) {
			info.installSoundFn(info);
			
		} else {
			GetHoverSoundUrlFromDocument({
				db: this.db
				,requestService: this.requestService
				,doc: info.doc
				,onSuccess: function(soundUrl){
					info.soundUrl = soundUrl;
					info.installSoundFn(info);
				}
			});
		};
	},
	
	_handleDispatch: function(m){
		var _this = this;
		
		if(m.type==='focusOn'){
			if(m.doc) {
				for(var docId in this.currentFocusDocIdMap) {
					this._removeFocusSound(docId);
				};
				
				this.currentFocusDocIdMap = {};
				this.currentFocusDocIdMap[m.doc._id] = true;
				
				this.findDocumentHoverSound(m.doc, {
					installSoundFn: function(info){
						_this._installFocusSound(info);
					}
				});

			} else if(m.docs) {
				for(var docId in this.currentFocusDocIdMap) {
					this._removeFocusSound(docId);
				};
				
				this.currentFocusDocIdMap = {};
				
				var playMultiple = true;
				if( m.docs.length > 1 ){
					if( this.customService ){
						playMultiple = this.customService.getOption('soundPlayMultipleOnFocus', false);
					} else {
						playMultiple = false;
					};
				};
				
				if( playMultiple ){
					for(var i=0,e=m.docs.length; i<e; ++i){
						var doc = m.docs[i];
						
						this.currentFocusDocIdMap[doc._id] = true;
						
						this.findDocumentHoverSound(doc, {
							installSoundFn: function(info){
								_this._installFocusSound(info);
							}
						});
					};
				};
				
			} else if(m.docId) {
				for(var docId in this.currentFocusDocIdMap) {
					this._removeFocusSound(docId);
				};
				
				this.currentFocusDocIdMap = {};
				
				this.currentFocusDocIdMap[m.docId] = true;
				
				if( this.requestService ) {
					this.requestService.requestDocument(m.docId, function(doc){
						if( _this.currentFocusDocIdMap[m.docId] ){
							_this.findDocumentHoverSound(doc, {
								installSoundFn: function(info){
									_this._installFocusSound(info);
								}
							});
						};
					});
				};
				
			} else if(m.docIds) {
				for(var docId in this.currentFocusDocIdMap) {
					this._removeFocusSound(docId);
				};
				
				this.currentFocusDocIdMap = {};
				
				var playMultiple = true;
				if( m.docIds.length > 1 ){
					if( this.customService ){
						playMultiple = this.customService.getOption('soundPlayMultipleOnFocus', false);
					} else {
						playMultiple = false;
					};
				};
				
				if( playMultiple ){
					for(var i=0,e=m.docIds.length; i<e; ++i){
						this.currentFocusDocIdMap[m.docId] = true;
						
						if( this.requestService ) {
							this.requestService.requestDocument(m.docId, function(doc){
								if( _this.currentFocusDocIdMap[m.docId] ){
									_this.findDocumentHoverSound(doc, {
										installSoundFn: function(info){
											_this._installFocusSound(info);
										}
									});
								};
							});
						};
					};
				};
			};
			
		} else if(m.type==='focusOff'){
			for(var docId in this.currentFocusDocIdMap) {
				this._removeFocusSound(docId);
			};
			
		} else if(m.type==='playHoverSoundOn'){
			if(m.doc) {
				this._initiatePlaySound(m.doc._id);
				this.findDocumentHoverSound(m.doc, {
					installSoundFn: function(info){
						_this._installPlaySound(info);
					}
				});
			};
			
		} else if(m.type==='playHoverSoundOff'){
			if(m.doc) {
				this._removePlaySound(m.doc._id);
			};
			
		} else if(m.type==='playSoundOn'){
			if( m.id && m.url ) {
				this._initiatePlaySound(m.id);
				var info = {
					docId: m.id
					,soundUrl: m.url
				};
				this._installPlaySound(info);
			};
			
		} else if(m.type==='playSoundOff'){
			if(m.id) {
				this._removePlaySound(m.id);
			};
		};
	},
	
	_installFocusSound: function(info){
		var docId = info.docId;
		var url = info.soundUrl;
		
		if( url && this.currentFocusDocIdMap[docId] ) {
			var $div = this._getFocusSoundDiv();
			var className = this._computeFocusClassName(docId);
			
			this._insertSoundElement($div, url, className);
		};
	},
	
	_removeFocusSound: function(docId){
		var className = this._computeFocusClassName(docId);
		var $div = this._getFocusSoundDiv();
		$div.find('.'+className).remove();
	},
	
	_computeFocusClassName: function(docId){
		var className = 'n2SoundFocus_' + $n2.utils.stringToHtmlId(docId);
		return className;
	},

	/**
	 * Create a div to receive the play sound. If div is removed, then
	 * sound is no longer needed
	 */
	_initiatePlaySound: function(docId){
		var divId = 'n2CouchPlaySound_' + $n2.utils.stringToHtmlId(docId);

		var $div = $('#'+divId);
		if( $div.length < 1 ) {
			$div = $('<div id="'+divId+'"></div>');
			this._getSoundDiv().append($div);
		};
	},
	
	/**
	 * Takes the sound url and installs a playing element in the
	 * appropriate div. If the div has disappeared, then the sound
	 * is no longer needed and should be ignored.
	 */
	_installPlaySound: function(info){
		var docId = info.docId;
		var url = info.soundUrl;

		var $div = $('#n2CouchPlaySound_'+$n2.utils.stringToHtmlId(docId));
		this._insertSoundElement($div, url);
	},

	/**
	 * Sound no longer needed. Remove associated div.
	 */
	_removePlaySound: function(docId){
		var $div = $('#n2CouchPlaySound_'+$n2.utils.stringToHtmlId(docId));
		$div.remove();
	},
	
	_getSoundDiv: function(){
		var $div = $('#n2CouchSound');
		if( $div.length < 1 ) {
			$div = $('<div>')
				.attr('id','n2CouchSound')
				.addClass('n2CouchSound')
				.appendTo( $('body') );
		};
		return $div;
	},
	
	_getFocusSoundDiv: function(){
		var $div = $('#n2CouchFocusSound');
		if( $div.length < 1 ) {
			var $parent = this._getSoundDiv();
			$div = $('<div>')
				.attr('id','n2CouchFocusSound')
				.addClass('n2CouchFocusSound')
				.appendTo( $parent );
		};
		return $div;
	},
	
	_insertSoundElement: function($div, url, className){
		var browserInfo = $n2.utils.getBrowserInfo();
		$n2.log('browser info',browserInfo);
		if( "Safari" === browserInfo.browser ){
			var embedHtml = this._generateHtml5Tag({
				url: url
				,sourceType: 'audio'
				,autoplay: true
				,loop: false
				,controller: false
			});
			var $embed = $(embedHtml);
			if( className ){
				$embed.addClass(className);
			};
			$div.append($embed);
			
		} else {
			var $embed = $('<embed>')
				.attr('src',url)
				.attr('autostart',true)
				.attr('loop',false)
				;
			if( className ){
				$embed.addClass(className);
			};
			$embed.css('visibility','hidden');
			$div.append($embed);
		};
	},
	
	_generateHtml5Tag: function(opts_) {
		var opts = $n2.extend({
			url: null
			,sourceType: null
			,mimeType: null
			,width: null
			,height: null
			,autoplay: false
			,loop: false
			,controller: false
		},opts_);
		
		var html = [];
		if( 'video' === opts.sourceType ) {
			html.push('<video');
		} else if( 'audio' === opts.sourceType ) {
			html.push('<audio');
		} else {
			return null;
		};
		
		if( opts.width ) {
			html.push(' width="'+opts.width+'"');
		};
		if( opts.height ) {
			html.push(' height="'+opts.height+'"');
		};
		if( opts.controller ) {
			html.push(' controls="controls"');
		};
		if( opts.autoplay ) {
			html.push(' autoplay="autoplay"');
		};
		
		// Source
		html.push(' src="');
		html.push(opts.url);
		html.push('"');
		
		if( opts.mimeType ) {
			html.push(' type="'+opts.mimeType+'"');
		};
		
		html.push('>');
		
		// Embed tag in case HTML 5 is not supported
		html.push('<embed');
		if( opts.width ) {
			html.push(' width="'+opts.width+'"');
		};
		if( opts.height ) {
			html.push(' height="'+opts.height+'"');
		};
		if( opts.autoplay ) {
			html.push(' autoplay="true"');
		} else {
			html.push(' autoplay="false"');
		};
		if( opts.controller ) {
			html.push(' controller="true"');
		};
		if( opts.loop ) {
			html.push(' loop="true"');
		};
		html.push(' src="');
		html.push(opts.url);
		html.push('"></embed>');
		
		// Close Tag
		if( 'video' === opts.sourceType ) {
			html.push('</video>');
		} else if( 'audio' === opts.sourceType ) {
			html.push('</audio>');
		} else {
			return null;
		};
		 
		return html.join(''); 
	}
});	

//===========================================================================
var GetHoverSoundUrlFromDocument = function(opts_){
	var opts = $n2.extend({
		db: null // required
		,requestService: null // required
		,doc: null // required
		,onSuccess: function(soundUrl){}
		,onError: function(err){}
	},opts_);
	
	var data = opts.doc;
	
	var requestService = null;
	if( opts ){
		requestService = opts.requestService;
	};
	if( !requestService && opts.serviceDirectory ) {
		// For legacy code
		requestService = opts.serviceDirectory.requestService;
	};
	if( !requestService ) {
		opts.onError('Request service not available');
		return;
	};

	// Legacy for Kitikmeot?
	if( data.sound
	 && data.sound.nunaliit_type 
	 && data.sound.nunaliit_type === 'reference' 
	 && data.sound.doc ) {
		// There is a sound associated
		
		// Compute sound URL
		var soundUrl = opts.db.getAttachmentUrl(data.sound.doc,'converted');
		opts.onSuccess(soundUrl);
		return;
	};
	
	// Loop through attached media, looking for one that claims the hover sound
	if( data.nunaliit_attachments 
	 && data.nunaliit_attachments.nunaliit_type === 'attachment_descriptions'
	 && data.nunaliit_attachments.files
	 ) {
		var hoverSoundAttName = null;
		for(var attName in data.nunaliit_attachments.files ){
			var attDesc = data.nunaliit_attachments.files[attName];
			if( attDesc && attDesc.data && attDesc.data.hoverSound ) {
				hoverSoundAttName = attName;
				break;
			};
		};
		
		if( hoverSoundAttName ) {
			// Compute sound URL
			var soundUrl = opts.db.getAttachmentUrl(data,attName);
			opts.onSuccess(soundUrl);
			return;
		};
	};
	
	// Look for a nunaliit_hoverSound reference
	if( data.nunaliit_hoverSound
	 && data.nunaliit_hoverSound.nunaliit_type === 'reference'
	 && data.nunaliit_hoverSound.doc
	 ) {
		// Sound by reference
		var soundDocId = data.nunaliit_hoverSound.doc;
		requestService.requestDocument(soundDocId, function(doc){
			if( doc 
			 && doc.nunaliit_attachments
			 && doc.nunaliit_attachments.files
			 ) {
				// Get first sound
				for(var attName in doc.nunaliit_attachments.files){
					var attDesc = doc.nunaliit_attachments.files[attName];
					if( doc._attachments 
					 && doc._attachments[attName]
					 && attDesc.fileClass == 'audio'
					 ){
						var soundUrl = opts.db.getAttachmentUrl(doc._id,attName);
						opts.onSuccess(soundUrl);
						return;
					};
				};
			};
			opts.onError('Can not find sound url');
		});
		return;
	};

	opts.onError('Can not find sound url');
};

//===========================================================================
var DocumentContainsHoverSound = function(data){

	// Legacy for Kitikmeot?
	if( data.sound
	 && data.sound.nunaliit_type 
	 && data.sound.nunaliit_type === 'reference' 
	 && data.sound.doc ) {
		// There is a sound associated
		return true;
	};
	
	// Loop through attached media, looking for one that claims the hover sound
	if( data.nunaliit_attachments 
	 && data.nunaliit_attachments.nunaliit_type === 'attachment_descriptions'
	 && data.nunaliit_attachments.files
	 ) {
		var hoverSoundAttName = null;
		for(var attName in data.nunaliit_attachments.files ){
			var attDesc = data.nunaliit_attachments.files[attName];
			if( attDesc && attDesc.data && attDesc.data.hoverSound ) {
				hoverSoundAttName = attName;
				break;
			};
		};
		
		if( hoverSoundAttName ) {
			return true;
		};
	};
	
	// Look for a nunaliit_hoverSound reference
	if( data.nunaliit_hoverSound
	 && data.nunaliit_hoverSound.nunaliit_type === 'reference'
	 && data.nunaliit_hoverSound.doc
	 ) {
		return true;
	};

	return false;
};
	
//===========================================================================
$n2.couchSound = {
	HoverSoundService: HoverSoundService
	,GetHoverSoundUrlFromDocument: GetHoverSoundUrlFromDocument
	,DocumentContainsHoverSound: DocumentContainsHoverSound
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchAuth.js

/*
Copyright (c) 2010, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

// @ requires n2.utils.js
// @ requires n2.form.js
// @ requires n2.couch.js

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

var DH = 'n2.couchAuth';

// ===================================================================================

var defaultError = function(err, options) {
	var acc = [];
	
	if( err ) {
		acc.push(''+err.message);
		var cause = err.cause;
		while( cause ) {
			acc.push('\n>'+cause.message);
			cause = cause.cause;
		};
	} else {
		acc.push( _loc('<Unknown error>') );
	};
	
	alert(acc.join(''));
};

var AuthService = $n2.Class({
	options: null
	
	,couchServer: null

	,loginStateListeners: null
	
	,lastAuthSessionCookie: null
	
	,lastSessionContext: null
	
	,userServiceAvailable: null
	
	,autoRegistrationAvailable: null
	
	,currentUserDoc: null
	
	,initialize: function(options_){
		var _this = this;
		
		this.options = $n2.extend(
			{
				onSuccess: function(result,options) {}
				,onError: defaultError
				,atlasDb: null
				,schemaRepository: null
				,disableCreateUserButton: false
				,directory: null
				,listeners: null
				,autoRefresh: true
				,prompt: _loc('Please login')
				,refreshIntervalInSec: 2 // 120 // 2 minutes
				,userServerUrl: null
			}
			,options_
		);
		
		this.loginStateListeners = [];
		this.lastAuthSessionCookie = null;
		this.lastSessionContext = null;
		this.userServiceAvailable = false;
		this.autoRegistrationAvailable = false;
		
		this.couchServer = undefined;
		if( this.options.directory ){
			this.couchServer = this.options.directory.couchServer;
		};
		if( !this.couchServer ){
			$n2.log('Couch Server must be specified for CouchDb AuthService');
			this.options.onError( _loc('Server must be specified for CouchDb AuthService') );
			return;
		};
		
		// Install login state listeners - don't retain as stored options.
		if( this.options.listeners ) {
			this.addListeners(this.options.listeners);
			delete this.options.listeners;
		};
		
		/*
		 * carry either default or provided fns for onSuccess or onError
		 * and remove these from the stored options ... they are usually
		 * not appropriate for use as login and logout callbacks.
		 */
		var initOnSuccess = this.options.onSuccess;
		delete this.options.onSuccess;
		var initOnError = this.options.onError;
		delete this.options.onError;
		
		var optWithCallbacks = $n2.extend({}, // use this as init callback
			this.options,
			{
				onSuccess: initOnSuccess
				,onError: initOnError
			}
		);

		this.couchServer.getSession().refreshContext({
			onSuccess: onSuccess
			,onError: onError
		});		

		this.couchServer.getSession().addChangedContextListener(function(sessionContext){
			_this._handleSessionContextChange(sessionContext);
		});
		
		if( this.options.autoRefresh
		 && this.options.refreshIntervalInSec > 0
		 && typeof(setInterval) === 'function' ) {
			setInterval(
				function(){
					_this.couchServer.getSession().refreshContext({
						onError: function(){} // ignore
					});
				}
				,(1000 * this.options.refreshIntervalInSec) // expressed in ms
			);

			setInterval(
				function(){
					var cookie = $n2.cookie.getCookie('NunaliitAuth');
					if( cookie !== _this.lastAuthSessionCookie ) {
						_this.lastAuthSessionCookie = cookie;
						_this.couchServer.getSession().refreshContext({
							onError: function(){} // ignore
						});
					};
				}
				,2000 // 2 seconds
			);
		};
		
		// Listen to events
		var dispatcher = this._getDispatcher();
		if( dispatcher ){
			var fn = function(m){
				_this._handleEvent(m);
			};
			dispatcher.register(DH,'login',fn);
			dispatcher.register(DH,'loginShowForm',fn);
			dispatcher.register(DH,'logout',fn);
			dispatcher.register(DH,'authIsLoggedIn',fn);
		};
		
		// Detect if auto registration is available
		if( this.options.userServerUrl ){
			var url = this.options.userServerUrl;
			
			$.ajax({
		    	url: url
		    	,type: 'GET'
		    	,async: true
		    	,traditional: true
		    	,data: null
		    	,dataType: 'json'
		    	,success: function(result) {
		    		_this.userServiceAvailable = true;
		    		if( result.autoRegistration ) {
		    			_this.autoRegistrationAvailable = true;
		    		};
		    	}
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
		    		// Ignore
		    	}
			});
		};

		function onSuccess(context) {
			$n2.log("Login(adjustCookies) successful", context, _this.options);
			initOnSuccess(context, optWithCallbacks);
			_this._notifyListeners();
		};
		
		function onError(error) {
			$n2.log('Login(adjustCookies) error: '+error);
			
			var err = {
				message: 'Problem initializing authentication library'
				,cause: {
					message: error
				}
			};
			initOnError(err, optWithCallbacks);
			_this._notifyListeners();
		};
	}

	,addListeners: function(listeners) {
		var _this = this;
		var cUser = this._getCurrentListenerInfo();
		
		if( typeof(listeners) == 'function' ) {
			addListener(listeners);
			
		} else if( $n2.isArray(listeners) ) {
			for(var loop=0; loop<listeners.length; ++loop) {
				var listener = listeners[loop];
				if( typeof(listener) === 'function' ) {
					addListener(listener);
				};
			};
		};
		
		function addListener(listener) {
			_this.loginStateListeners.push(listener);
			try {
				listener(cUser);
			} catch(e) {
				$n2.log('CouchAuthService: EXCEPTION caught in listener (add)',e);
			};
		};
	}
	
	,_notifyListeners: function() {
		var context = this._getAuthContext();
		
		var userName = null;
		if( context ) {
			userName = context.name;
		};
		
		var isAdmin = false;
		if( context 
		 && context.roles 
		 && this.doRolesContainAdmin(context.roles) ){
			isAdmin = true;
		};

		// Notify other instances of atlas in browser
		$n2.cookie.setCookie({
			name: 'NunaliitAuth'
			,value: userName
			,path: '/'
		});
		
		// Notify via DOM classes
		var $body = $('body');
		if( userName ){
			$body.removeClass('nunaliit_logged_out');
			$body.addClass('nunaliit_logged_in');
		} else {
			$body.removeClass('nunaliit_logged_in');
			$body.removeClass('nunaliit_user_advanced');
			$body.addClass('nunaliit_logged_out');
		};
		if( isAdmin ) {
			$body.addClass('nunaliit_user_administrator');
		} else {
			$body.removeClass('nunaliit_user_administrator');
		};
		
		// Notify via dispatcher
		if( userName ){
			this._dispatch({
				type: 'authLoggedIn'
				,user: context
			});
		} else {
			this._dispatch({
				type: 'authLoggedOut'
			});
		};
		
		var cUser = this._getCurrentListenerInfo();
		for(var loop=0; loop<this.loginStateListeners.length; ++loop) {
			var listener = this.loginStateListeners[loop];
			if( listener ) {
				try {
					listener(cUser);
				} catch(e) {
					$n2.log('CouchAuthService: EXCEPTION caught in listener (notify)',e);
				};
			};
		};
	}
	
	,_getCurrentListenerInfo: function(){
		var context = this._getAuthContext();
		
		var info = null;
		if( context && context.name ){
			info = {
				name: context.name
				,roles: context.roles
			};
		};
		
		return info;
	}
	
	,login: function(opts_) {
		var opts = $n2.extend({
			username: null
			,password: null
			,onSuccess: function(context){}
			,onError: function(errMsg){}
		},opts_);

		var _this = this;
		var username = opts.username;
		var password = opts.password;
		
		if( typeof(username) !== 'string'
		 || typeof(password) !== 'string' ){
			opts.onError('Name and password must be provided when logging in');
			return;
		};

		if( this.userServiceAvailable ){
			var url = this.options.userServerUrl + 'getUser';
			
			$.ajax({
		    	url: url
		    	,type: 'GET'
		    	,async: true
		    	,traditional: true
		    	,data: {
		    		email: username
		    	}
		    	,dataType: 'json'
		    	,success: function(userDoc) {
		    		if( userDoc.name ) {
		    			username = userDoc.name;
		    		};
					doLogin();
		    	}
		    	,error: doLogin
			});
		} else {
			doLogin();
		};
		
		function doLogin() {
			_this.couchServer.getSession().login({
				name: username
				,password: password
				,onSuccess: checkUserAgreement
				,onError: function(err){
					$n2.log('Unable to log in: '+err);
					onError( _loc('Invalid e-mail and/or password') );
				}
			});
		};
		
		function checkUserAgreement(sessionResult){
			_this.couchServer.getUserDb().getUser({
				name: username
				,onSuccess: function(userDoc){
					// If the user agreement was accepted, the user
					// servlet add a role to the user which is
					// "nunaliit_agreement_" + name-of-atlas
					var atlasName = _this._getAtlasName();
					var agreementRole = 'nunaliit_agreement_'+atlasName;
					if( userDoc
					 && userDoc.roles ){
						for(var i=0,e=userDoc.roles.length; i<e; ++i){
							var role = userDoc.roles[i];
							if( role === agreementRole ){
								checkUserQuestionnaire(sessionResult, userDoc);
								return;
							};
						};
					};
					
					// At this point, a new user agreement must be accepted
					proposeNewUserAgreement(sessionResult, userDoc);
				}
				,onError: function(err){
					var isAdmin = false;
					if( sessionResult && sessionResult.roles ){
						for(var i=0,e=sessionResult.roles.length; i<e; ++i){
							var role = sessionResult.roles[i];
							if( '_admin' === role ){
								isAdmin = true;
								break;
							};
						};
					};
					
					if( isAdmin ){
						checkUserQuestionnaire(sessionResult, null);
					} else {
						$n2.log('Unable to obtain user information: '+err);
						onError( _loc('Unable to obtain information about user') );
					};
				}
			});
		};
		
		function proposeNewUserAgreement(sessionResult, userDoc){
			_this.options.atlasDb.getDocument({
				docId: 'org.nunaliit.user_agreement'
				,onSuccess: function(doc){
					if( doc 
					 && doc.nunaliit_user_agreement 
					 && doc.nunaliit_user_agreement.content
					 && doc.nunaliit_user_agreement.enabled ){
						
						var agreementContent = doc.nunaliit_user_agreement.content;
						if( typeof doc.nunaliit_user_agreement.content === 'object'
						 && doc.nunaliit_user_agreement.content.nunaliit_type === 'localized' ){
							agreementContent = _loc(doc.nunaliit_user_agreement.content);
						};
						
						var accepted = false;
						
						var diagId = $n2.getUniqueId();
						var $diag = $('<div>')
							.attr('id',diagId);
						
						var $content = $('<div>')
							.addClass('n2Auth_user_agreement_dialog')
							.appendTo($diag);
						
						$('<div>')
							.addClass('n2Auth_user_agreement_label')
							.text( _loc('User agreement has changed. You must accept before you can authenticate.') )
							.appendTo($content);
						
						$('<textarea>')
							.addClass('n2Auth_user_agreement_content')
							.attr('readonly','readonly')
							.val( agreementContent )
							.appendTo($content);

						var $buttons = $('<div>')
							.addClass('n2Auth_user_agreement_buttons')
							.appendTo($content);
						
						$('<button>')
							.addClass('n2_button_ok')
							.text( _loc('Accept') )
							.click(function(){
								accepted = true;
								var $diag = $('#'+diagId);
								$diag.dialog('close');
								acceptUserAgreement(agreementContent, sessionResult, userDoc);
							})
							.appendTo($buttons);
						
						$('<button>')
							.addClass('n2_button_cancel')
							.text( _loc('Reject') )
							.click(function(){
								var $diag = $('#'+diagId);
								$diag.dialog('close');
							})
							.appendTo($buttons);
					
						$diag.dialog({
							autoOpen: true
							,title: _loc('User Agreement and Terms of Service')
							,modal: true
							,width: 'auto'
							,close: function(event, ui){
								var $diag = $('#'+diagId);
								$diag.remove();
								if( !accepted ){
									onError( _loc('User refused agreement') );
								};
							}
						});
					} else {
						// If the user agreement is not enabled, accept anything and
						// the service will enable the role
						acceptUserAgreement('', sessionResult, userDoc);
					};
				}
				,onError: function(err){
					$n2.log('Error getting user agreement: '+err);
					onError( _loc('Unable to obtain user agreement') );
				}
			});
		};
		
		function acceptUserAgreement(userAgreement, sessionResult, userDoc){
			var url = _this.options.userServerUrl + 'acceptUserAgreement';
			
			$.ajax({
		    	url: url
		    	,type: 'POST'
		    	,async: true
		    	,traditional: true
		    	,data: {
		    		userAgreement: userAgreement
		    	}
		    	,dataType: 'json'
		    	,success: function() {
		    		checkUserQuestionnaire(sessionResult, userDoc);
		    	}
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
					onError( _loc('Error attempting to accept user agreement') );
				}	
			});
		};
		
		function checkUserQuestionnaire(sessionResult, userDoc){
			// No user document. Probably an admin.
			// Anyway, nothing we can do. Skip questions.
			if( !userDoc ){
				onLoginCompleted(sessionResult, userDoc);
				return;
			};
			
			// Load user questionnaire
			if( _this.options.schemaRepository ){
				_this.options.schemaRepository.getSchema({
					name: 'nunaliit_user_questions'
					,onSuccess: function(schema){
						var defaultAnswers = schema.createObject();
						if( !defaultAnswers.version ){
							$n2.log('User questions found without a version number. Ignored.');
							onLoginCompleted(sessionResult, userDoc);
							return;
						};
						
						var atlasName = _this._getAtlasName();

						var answers = null;
						if( userDoc 
						 && userDoc.nunaliit_answers ){
							answers = userDoc.nunaliit_answers[atlasName];
						};
						
						var interventionRequired = false;
						if( !answers ){
							interventionRequired = true;
							answers = defaultAnswers;
						} else if( answers.version != defaultAnswers.version ){
							interventionRequired = true;
						};
						
						if( interventionRequired ){
							gatherUserAnswers(sessionResult, userDoc, schema, answers);
						} else {
							onLoginCompleted(sessionResult, userDoc);
						};
					}
					,onError: function(err){
						// Schema not found. No questions. Just continue
						// with login process
						onLoginCompleted(sessionResult, userDoc);
					}
				});
				
			} else {
				// No schema repository. No questions. Just continue
				// with login process
				onLoginCompleted(sessionResult, userDoc);
			};
		};
		
		function gatherUserAnswers(sessionResult, userDoc, schema, answers){
			var diagId = $n2.getUniqueId();
			var $diag = $('<div>')
				.attr('id',diagId);
			
			var $content = $('<div>')
				.addClass('n2Auth_user_questions_dialog')
				.appendTo($diag);
			
			var $elem = $('<div>')
				.addClass('n2Auth_user_questions_form')
				.appendTo($content);
			
			schema.form(answers, $elem);
			
			var $buttons = $('<div>')
				.addClass('n2Auth_user_questions_buttons')
				.appendTo($content);
			
			$('<button>')
				.addClass('n2_button_ok')
				.text( _loc('OK') )
				.click(function(){
					var $diag = $('#'+diagId);
					$diag.dialog('close');
					saveUserAnswers(sessionResult, userDoc, answers);
				})
				.appendTo($buttons);
			
			$('<button>')
				.addClass('n2_button_cancel')
				.text( _loc('Remind me later') )
				.click(function(){
					var $diag = $('#'+diagId);
					$diag.dialog('close');
					onLoginCompleted(sessionResult, userDoc);
				})
				.appendTo($buttons);
		
			$diag.dialog({
				autoOpen: true
				,title: _loc('User Questionnaire')
				,modal: true
				,width: 'auto'
				,close: function(event, ui){
					var $diag = $('#'+diagId);
					$diag.remove();
				}
			});
		};
		
		function saveUserAnswers(sessionResult, userDoc, answers){
    		// Must reload the user document since it might have changed
			_this.couchServer.getUserDb().getUser({
				name: userDoc.name
				,onSuccess: function(userDoc){
					var atlasName = _this._getAtlasName();

					if( !userDoc.nunaliit_answers ){
						userDoc.nunaliit_answers = {};
					};

					userDoc.nunaliit_answers[atlasName] = answers;
					
					_this.couchServer.getUserDb().updateDocument({
						data: userDoc
						,onSuccess: reloadUserDoc
						,onError: errorSavingAnswers
					});
				}
				,onError: errorSavingAnswers
			});
			
			function errorSavingAnswers(err){
				$n2.log('Error saving user answers',err);
				alert( _loc('There was a problem saving your answers. You will be prompted again next time you log in.') );
				onLoginCompleted(sessionResult);
			};
			
			function reloadUserDoc(){
				_this.couchServer.getUserDb().getUser({
					id: userDoc._id
					,onSuccess: function(updatedUserDoc){
						onLoginCompleted(sessionResult, updatedUserDoc);
					}
					,onError: function(err){
						$n2.log('Error retrieving updated version of user document',err);
						onLoginCompleted(sessionResult, userDoc);
					}
				});
			};
		};
		
		function onLoginCompleted(result, userDoc) {

			var context = _this.couchServer.getSession().getContext();

			$n2.log('Login successful',context,opts);
			
			if( context && context.name ) {
				opts.onSuccess(context);
				_this._notifyListeners();

			} else {
				doErrorNotification();
			};
		};
		
		function onError(err) {
			_this.couchServer.getSession().logout({
				onError: function(){}
			});			
			$n2.log('Login error', err);
			doErrorNotification(err);
		};

		function doErrorNotification(err) {
			if( err ) {
				opts.onError( err );
			} else {
				opts.onError( _loc('Invalid e-mail and/or password') );
			};
			_this._notifyListeners();
		};
	}
	
	,_fillDialogWithLogin: function(dialogId, opts_){
		var opts = $n2.extend({
			prompt: null
			,userName: null
			,onSuccess: function(context){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		var $dialog = $('#'+dialogId);
		
		var $authDiag = $('<div class="n2Auth_login"></div>');
		
		var $authForm = $('<form></form>')
			.appendTo($authDiag);

		// User Line
		var $userLine = $('<div class="n2Auth_login_user_line"></div>')
			.appendTo($authForm);
		
		var nameLabel = _loc('user name');
		if( this.autoRegistrationAvailable ){
			nameLabel = _loc('e-mail address');
		};
		var nameValue = '';
		if( opts.userName ){
			nameValue = opts.userName;
		};
		
		var $labelDiv = $('<div class="n2Auth_login_input"></div>')
			.appendTo($userLine);

		$('<input class="n2Auth_user_input n2Auth_input_field" type="text" name="username"/>')
			.val(nameValue)
			.appendTo($labelDiv);
		
		$('<div class="n2Auth_login_label"></div>')
			.text(nameLabel)
			.appendTo($labelDiv);
		
		// Password line
		var $pwLine = $('<div class="n2Auth_login_pw_line"></div>')
			.appendTo($authForm);
		
		var $pwDiv = $('<div class="n2Auth_login_input"></div>')
			.appendTo($pwLine);
		
		$('<input class="n2Auth_pw_input n2Auth_input_field" type="password" name="password"/>')
			.appendTo($pwDiv);
		
		$('<div class="n2Auth_login_label"></div>')
			.text(_loc('password'))
			.appendTo($pwDiv);
		
		// Button line
		var $buttonLine = $('<div class="n2Auth_login_button_line"></div>')
			.appendTo($authForm);

		$('<input type="submit" class="n2Auth_button_login"></input>')
			.appendTo($buttonLine)
			.val( _loc('Login') )
			.click(function(){
				performLogin();
				return false;
			});

		// Create user line
		if( ! this._shouldDisableCreateUserButton() ) {
			var $createLine = $('<div class="n2Auth_login_create_line"></div>')
				.appendTo($authDiag);
	
			$('<a class="n2Auth_button_createUser" href="#"></a>')
				.appendTo($createLine)
				.text( _loc('Create a new user') )
				.click(function(){
					var $dialog = $('#'+dialogId);
					var userName = $dialog.find('.n2Auth_user_input').val();
					opts.userName = userName;
					_this._fillDialogWithUserCreation(dialogId, opts);
					return false;
				});
		};

		// Recover password line
		if( this.autoRegistrationAvailable ){
			var $recoverLine = $('<div class="n2Auth_login_recover_line"></div>')
				.appendTo($authDiag);
	
			$('<a class="n2Auth_button_recoverPassword" href="#"></a>')
				.appendTo($recoverLine)
				.text( _loc('Reset password?') )
				.click(function(){
					var $dialog = $('#'+dialogId);
					var userName = $dialog.find('.n2Auth_user_input').val();
					opts.userName = userName;
					_this._fillDialogWithPasswordRecovery(dialogId, opts);
					return false;
				});

		};

		
		// Populate current dialog div
		$dialog.empty().append($authDiag);
		
		// Capture enter key (not needed since enter key triggers submit in a
		// form)
//		$dialog.find('.n2Auth_input_field').keydown(function(e){
//			var charCode = null;
//			if( null === e ) {
//				e = window.event; // IE
//			};
//			if( null !== e ) {
//				if( e.keyCode ) {
//					charCode = e.keyCode;
//				};
//			};
//			
//			if( 13 === charCode ) {
//				performLogin();
//			};
//		});
		
		// Adjust dialog title
		if( opts.prompt ) {
			$dialog.dialog('option','title',opts.prompt);
		} else {
			$dialog.dialog('option','title',_loc('Please login'));
		};
		
		function performLogin(){
			var $dialog = $('#'+dialogId);
			var user = $dialog.find('.n2Auth_user_input').val();
			var password = $dialog.find('.n2Auth_pw_input').val();
			_this.login({
				username: user
				,password: password
				,onSuccess: opts.onSuccess
				,onError: opts.onError
			});
		};
	}
	
	,_fillDialogWithUserCreation: function(dialogId, opts_){
		if( this.autoRegistrationAvailable ){
			this._fillDialogWithUserAutoRegistration(dialogId, opts_);
			return;
		};
		
		var opts = $n2.extend({
			prompt: null
			,userName: null
			,onSuccess: function(context){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		var $dialog = $('#'+dialogId);
		
		$dialog.empty();
		
		var $form = $('<div>')
			.addClass('n2Auth_create')
			.appendTo($dialog);
		
		// User name 
		var $userLine = $('<div>')
			.addClass('n2Auth_create_user_line')
			.appendTo($form);
		
		var $userInput = $('<div>')
			.addClass('n2Auth_create_input')
			.appendTo($userLine);
		
		$('<input type="text" autofocus>')
			.addClass('n2Auth_user_input n2Auth_input_field')
			.appendTo($userInput)
			
		$('<div>')
			.addClass('n2Auth_create_label')
			.text( _loc('user name') )
			.appendTo($userInput);
		
		// Display name 
		var $displayLine = $('<div>')
			.addClass('n2Auth_create_display_line')
			.appendTo($form);
		
		var $displayInput = $('<div>')
			.addClass('n2Auth_create_input')
			.appendTo($displayLine);
		
		$('<input type="text">')
			.addClass('n2Auth_display_input n2Auth_input_field')
			.appendTo($displayInput)
			
		$('<div>')
			.addClass('n2Auth_create_label')
			.text( _loc('display name') )
			.appendTo($displayInput);
		
		// Password 
		var $pwLine = $('<div>')
			.addClass('n2Auth_create_pw1_line')
			.appendTo($form);
		
		var $pwInput = $('<div>')
			.addClass('n2Auth_create_input')
			.appendTo($pwLine);
		
		$('<input type="password">')
			.addClass('n2Auth_pw_input n2Auth_input_field')
			.appendTo($pwInput)
			
		$('<div>')
			.addClass('n2Auth_create_label')
			.text( _loc('password') )
			.appendTo($pwInput);
		
		// Password confirmation
		var $pw2Line = $('<div>')
			.addClass('n2Auth_create_pw2_line')
			.appendTo($form);
		
		var $pw2Input = $('<div>')
			.addClass('n2Auth_create_input')
			.appendTo($pw2Line);
		
		$('<input type="password">')
			.addClass('n2Auth_pw_input2 n2Auth_input_field')
			.appendTo($pw2Input)
			
		$('<div>')
			.addClass('n2Auth_create_label')
			.text( _loc('confirm password') )
			.appendTo($pw2Input);
		
		if( opts.userName ){
			var $n2AuthUserInput = $dialog.find('.n2Auth_user_input');
			$n2AuthUserInput.val( opts.userName );
			$n2AuthUserInput.addClass('n2_input_detected');
		};
		
		// Create User Button
		var $line = $('<div>')
			.addClass('n2Auth_create_button_line')
			.appendTo($form);
		$('<button>')
			.addClass('n2Auth_button_create')
			.text( _loc('Create User') )
			.appendTo($line)
			.click(function(){
				performUserCreation();
				return false;
			});
		
		$dialog.find('.n2Auth_input_field').keydown(function(e){
			var charCode = null;
			if( null === e ) {
				e = window.event; // IE
			};
			if( null !== e ) {
				if( e.keyCode ) {
					charCode = e.keyCode;
				};
			};
			
			if( 13 === charCode ) {
				performUserCreation();
			};
		});
		
		$dialog.dialog('option','title',_loc('User Creation'));
		
		function performUserCreation(){
			var $dialog = $('#'+dialogId);

			var user = $dialog.find('.n2Auth_user_input').val();
			var display = $dialog.find('.n2Auth_display_input').val();
			var password = $dialog.find('.n2Auth_pw_input').val();
			var password2 = $dialog.find('.n2Auth_pw_input2').val();
			
			if( null == user || user.length < 3 ) {
				alert( _loc('User name should have at least 3 characters') );
				return false;
			};

			if( password != password2 ) {
				alert( _loc('The two passwords should match') );
				return false;
			};
			
			if( null == password 
			 || password.length < 6 ) {
				alert( _loc('Password should have at least 6 characters') );
				return false;
			};
			
			if( null == display || display.length < 1 ) {
				display = user;
			};
			
			_this.couchServer.getUserDb().createUser({
				name: user
				,password: password
				,display: display
				,onSuccess: function() { 
					_this.login({
						username: user
						,password: password
						,onSuccess: opts.onSuccess
						,onError: function(err){
							alert( _loc('User created but unable to log in: ')+err);
						}
					});
				}
				,onError: function(err){
					alert( _loc('Unable to create user: ')+err);
				}
			});
		};
	}
	
	,_fillDialogWithUserAutoRegistration: function(dialogId, opts_){
		var opts = $n2.extend({
			prompt: null
			,userName: null
			,onSuccess: function(context){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		var $dialog = $('#'+dialogId);
		
		$dialog.empty();
		
		var $form = $('<div>')
			.addClass('n2Auth_create')
			.appendTo($dialog);
		
		// E-mail address
		var $line = $('<div>')
			.addClass('n2Auth_create_email_line')
			.appendTo($form);

		var $input = $('<div>')
			.addClass('n2Auth_create_input')
			.appendTo($line);
		$('<input type="text" autofocus>')
			.addClass('n2Auth_email_input n2Auth_input_field')
			.appendTo($input)
			.keydown(function(e){
				var charCode = null;
				if( null === e ) {
					e = window.event; // IE
				};
				if( null !== e ) {
					if( e.keyCode ) {
						charCode = e.keyCode;
					};
				};
				
				if( 13 === charCode ) {
					performUserRegistration();
				};
			});
		
		if( opts.userName ){
			var $n2AuthEmailInput = $dialog.find('.n2Auth_email_input');
			$n2AuthEmailInput.val( opts.userName );
			$n2AuthEmailInput.addClass('n2_input_detected');
		};

		$('<div>')
			.addClass('n2Auth_create_label')
			.text( _loc('e-mail address') )
			.appendTo($input);
		
		
		// Buttons
		var $line = $('<div>')
			.addClass('n2Auth_create_button_line')
			.appendTo($form);
		$('<button>')
			.addClass('n2Auth_button_create')
			.text( _loc('Create User') )
			.appendTo($line)
			.click(function(){
				performUserRegistration();
				return false;
			});
		
		$dialog.dialog('option','title',_loc('User Registration'));
		
		function performUserRegistration(){
			var $dialog = $('#'+dialogId);

			var email = $dialog.find('.n2Auth_email_input').val();
			
			if( email ) {
				email = $n2.trim(email);
			};
			if( !email ) {
				alert( _loc('E-Mail address must be specified') );
				return false;
			};
			
			var url = _this.options.userServerUrl + 'initUserCreation';
			
			$.ajax({
		    	url: url
		    	,type: 'GET'
		    	,async: true
		    	,traditional: true
		    	,data: {
		    		email: email
		    	}
		    	,dataType: 'json'
		    	,success: function(result) {
		    		if( result.error ) {
						alert( _loc('Unable to register user: ')+result.error);
		    		} else {
		    			reportSuccess();
		    		};
		    	}
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
					alert( _loc('Unable to register user: ')+textStatus);
				}	
			});
		};
		
		function reportSuccess(){
			var $dialog = $('#'+dialogId);

			$dialog.empty();
			
			var $form = $('<div>')
				.addClass('n2Auth_registered')
				.appendTo($dialog);
			
			// E-mail address
			var $line = $('<div>')
				.addClass('n2Auth_registered_line')
				.appendTo($form)
				.text( _loc('User registration initiated. Check for e-mail to complete user creation') );
			
			// Buttons
			var $line = $('<div>')
				.addClass('n2Auth_registered_button_line')
				.appendTo($form);
			$('<button>')
				.addClass('n2Auth_button_ok')
				.text( _loc('OK') )
				.appendTo($line)
				.button({icons:{primary:'ui-icon-check'}})
				.click(function(){
					opts.onSuccess();
					return false;
				});

			$dialog.dialog('option','title',_loc('Registration Initiated'));
		};
	}
	
	,_fillDialogWithPasswordRecovery: function(dialogId, opts_){
		var opts = $n2.extend({
			userName: null
			,onSuccess: function(context){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		var $dialog = $('#'+dialogId);

		$dialog.empty();

		var $form = $('<div>')
			.addClass('n2Auth_recoverPassword')
			.appendTo($dialog);

		// E-mail address
		var $line = $('<div>')
			.addClass('n2Auth_recoverPassword_email_line')
			.appendTo($form);

		var $input = $('<div>')
			.addClass('n2Auth_recoverPassword_input')
			.appendTo($line);
		$('<input type="text" autofocus>')
			.addClass('n2Auth_email_input n2Auth_input_field')
			.appendTo($input)
			.keydown(function(e){
				var charCode = null;
				if( null === e ) {
					e = window.event; // IE
				};
				if( null !== e ) {
					if( e.keyCode ) {
						charCode = e.keyCode;
					};
				};
				
				if( 13 === charCode ) {
					performPasswordRecovery();
				};
			});

		if( opts.userName ){
			var $n2RecoverPasswordInput = $dialog.find('.n2Auth_email_input');
			$n2RecoverPasswordInput.val( opts.userName );
			$n2RecoverPasswordInput.addClass('n2_input_detected');
		};
		
		$('<div>')
			.addClass('n2Auth_recoverPassword_label')
			.text( _loc('e-mail address') )
			.appendTo($input);
		
		// Buttons
		var $line = $('<div>')
			.addClass('n2Auth_recoverPassword_button_line')
			.appendTo($form);
		$('<button>')
			.addClass('n2Auth_button_recover')
			.text( _loc('Reset Password') )
			.appendTo($line)
			.click(function(){
				performPasswordRecovery();
				return false;
			});

		$dialog.dialog('option','title',_loc('Recover Password'));
		
		function performPasswordRecovery(){
			var $dialog = $('#'+dialogId);

			var email = $dialog.find('.n2Auth_email_input').val();
			
			if( email ) {
				email = $n2.trim(email);
			};
			if( !email ) {
				alert( _loc('E-Mail address must be specified') );
				return false;
			};
			
			var url = _this.options.userServerUrl + 'initPasswordRecovery';
			
			$.ajax({
		    	url: url
		    	,type: 'GET'
		    	,async: true
		    	,traditional: true
		    	,data: {
		    		email: email
		    	}
		    	,dataType: 'json'
		    	,success: function(result) {
		    		if( result.error ) {
		    			reportError(result.error);
		    		} else {
		    			reportSuccess();
		    		};
		    	}
		    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
		    		var result = $n2.utils.parseHttpJsonError(XMLHttpRequest, undefined);
	    			reportError(result.error);
				}	
			});
		};
		
		function reportSuccess(){
			var $dialog = $('#'+dialogId);

			$dialog.empty();
			
			var $form = $('<div>')
				.addClass('n2Auth_registered')
				.appendTo($dialog);
			
			// E-mail address
			var $line = $('<div>')
				.addClass('n2Auth_registered_line')
				.appendTo($form)
				.text( _loc('Password recovery initiated. Check for an e-mail to complete password recovery') );
			
			// Buttons
			var $line = $('<div>')
				.addClass('n2Auth_registered_button_line')
				.appendTo($form);
			$('<button>')
				.addClass('n2Auth_button_ok')
				.text( _loc('OK') )
				.appendTo($line)
				.button({icons:{primary:'ui-icon-check'}})
				.click(function(){
					opts.onSuccess();
					return false;
				});

			$dialog.dialog('option','title',_loc('Password Recovery Initiated'));
		};
		
		function reportError(errorMessage){
			var $dialog = $('#'+dialogId);

			$dialog.empty();
			
			var $form = $('<div>')
				.addClass('n2Auth_recoverError')
				.appendTo($dialog);
			
			// Explanation
			$('<div>')
				.addClass('n2Auth_recoverError_line')
				.appendTo($form)
				.text( _loc('Unable to initiate password recovery. Contact your administrator to resolve this issue.') );
			
			// Reported Error
			if( errorMessage ){
				$('<div>')
					.addClass('n2Auth_recoverError_report')
					.appendTo($form)
					.text( errorMessage );
			};
			
			// Buttons
			var $line = $('<div>')
				.addClass('n2Auth_recoverError_button_line')
				.appendTo($form);
			$('<button>')
				.addClass('n2Auth_button_ok')
				.text( _loc('OK') )
				.appendTo($line)
				.button({icons:{primary:'ui-icon-check'}})
				.click(function(){
					_this._fillDialogWithLogin(dialogId, opts);
					return false;
				});

			$dialog.dialog('option','title',_loc('Password Recovery Failure'));
		};
	}

	,showLoginForm: function(opts_) {
		var opts = $.extend({
			prompt: this.options.prompt
			,onSuccess: function(context){}
			,onError: $n2.reportErrorForced
		}, opts_);

		var dialogId = $n2.getUniqueId();
		var $dialog = $('<div id="'+dialogId+'"></div>');
		$(document.body).append($dialog);
		
		this._fillDialogWithLogin(dialogId, {
			prompt: opts.prompt
			,onSuccess: function(context){
				$('#'+dialogId).dialog('close');
				opts.onSuccess(context);
			}
			,onError: function(err){
				$('#'+dialogId).dialog('close');
				opts.onError(err);
			}
		});
		
		var dialogOptions = {
			autoOpen: true
			,modal: true
			,width: 'auto'
			,close: function(event, ui){
				var diag = $('#'+dialogId);
				diag.remove();
			}
		};
		if( opts.prompt ) {
			dialogOptions.title = opts.prompt;
		}
		$dialog.dialog(dialogOptions);
	}
	
	,logout: function(opts_) {
		var opts = $n2.extend({
			onSuccess: function(context){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;

		this.couchServer.getSession().logout({
			onSuccess: onSuccess
			,onError: opts.onError
		});
		
		function onSuccess(result) {

			$n2.log("Logout successful",result);
			
			opts.onSuccess(result);
		
			_this._notifyListeners();
		};
	}
	
	,editUser: function(opts_){
		var opts = $n2.extend({
			userName: null // null means current user
			,onSuccess: function(context){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var userName = opts.userName;
		if( !userName ){
			var context = this._getAuthContext();
			if( context && context.name ){
				// All we have is a name
				userName = context.name;
			};
		};
		
		if( !userName ){
			opts.onError('No user name provided');
			return;
		};
		
		// Get document
		this.couchServer.getUserDb().getUser({
			name: userName
			,onSuccess: userDocLoaded
			,onError: function(err){
				// Create a document.. Should really be done by editor
				var userDoc = {
					_id: 'org.couchdb.user:'+userName
					,name: userName
					,display: ''
					,nunaliit_emails: []
					,roles: []
					,type: 'user'
				};
				userDocLoaded(userDoc);
			}
		});
		
		function userDocLoaded(userDoc){
			var userService = _this._getUserService();
			if( userService ){
				var $dialog = $('<div>')
					.addClass('n2Auth_userEdit')
					.appendTo( $(document.body) );
				var dialogId = $n2.utils.getElementIdentifier($dialog);
				
				userService.startEdit({
					userDoc: userDoc
					,elem: $dialog
					,onSavedFn: function(userDoc){
						var requestService = _this._getRequestService();
						if( requestService && userDoc && userDoc.name ){
							requestService.requestUser(userDoc.name);
						};
					}
					,onFinishedFn: function(){
						var diag = $('#'+dialogId);
						diag.dialog('close');
					}
				});
	
				var dialogOptions = {
					autoOpen: true
					,modal: true
					,width: 'auto'
					,title: _loc('Edit User')
					,close: function(event, ui){
						var diag = $('#'+dialogId);
						diag.remove();
					}
				};
				$dialog.dialog(dialogOptions);
			};
		};
	}
	
	,getCurrentUserName: function() {
		var context = this._getAuthContext();

		if( context && context.name ) {
			return context.name;
		};

		return null;
	}
	
	,getCurrentUserRoles: function() {
		var context = this._getAuthContext();

		if( context && context.roles ) {
			return context.roles;
		};

		return null;
	}
	
	,doRolesContainAdmin: function(roles) {
		var admin = false;
		
		if( roles && roles.length ) {
			if( $.inArray('_admin',roles) >= 0 ) {
				admin = true;
			};
			if( $.inArray('administrator',roles) >= 0 ) {
				admin = true;
			};
			if( typeof(n2atlas) === 'object' 
			 && typeof(n2atlas.name) === 'string' ) {
				var dbAdmin = n2atlas.name + '_administrator';
				if( $.inArray(dbAdmin,roles) >= 0 ) {
					admin = true;
				};
			};
		};

		return admin;
	},
	
	/*
	 * Returns context obtained from CouchDb session
	 */
	_getAuthContext: function() {
		return this.couchServer.getSession().getContext();
	}
	
	,isLoggedIn: function() {
		var authContext = this._getAuthContext();
		if( authContext && authContext.name ) {
			return true;
		};

		return false;
	}
	
	,createAuthWidget: function(opts_){
		var dispatchService = null;
		var customService = null;
		if( this.options.directory ){
			dispatchService = this.options.directory.dispatchService;
			customService = this.options.directory.customService;
		};
		
		var widgetOptions = {
			elemId: null
			,elem: null
			,authService: this
			,dispatchService: dispatchService
		};
		
		if( customService ){
			var label = customService.getOption('authWidgetLoginLabel');
			if( label ) widgetOptions.labelLogin = label;

			label = customService.getOption('authWidgetLogoutLabel');
			if( label ) widgetOptions.labelLogout = label;

			label = customService.getOption('authWidgetWelcomeLabel');
			if( label ) widgetOptions.labelWelcome = label;
		};
		
		var opts = $n2.extend(widgetOptions,opts_);
		
		return new AuthWidget(opts);
	}
	
	,_getDispatcher: function(){
		var d = null;
		if( this.options.directory ){
			d = this.options.directory.dispatchService;
		};
		return d;
	}

	,_getUserService: function(){
		var us = null;
		if( this.options.directory ){
			us = this.options.directory.userService;
		};
		return us;
	}
	
	,_getRequestService: function(){
		var rs = null;
		if( this.options.directory ){
			rs = this.options.directory.requestService;
		};
		return rs;
	}
	
	,_dispatch: function(m){
		var dispatcher = this._getDispatcher();
		if( dispatcher ){
			var h = dispatcher.getHandle('n2.couchAuth');
			dispatcher.send(h,m);
		};
	},
	
	/*
	 * This function is called everytime the CouchDb context is refreshed.
	 * This can happen often, since the CouchDb layer performs this at a set
	 * interval.
	 */
	_handleSessionContextChange: function(sessionContext){
		var _this = this;
		
		var same = $n2.couch.compareSessionContexts(this.lastSessionContext, sessionContext);
		if( !same ){
			this.lastSessionContext = sessionContext;
			this.currentUserDoc = null;
			
			this._notifyListeners();

			// Get current user doc
			if( sessionContext.name ){
				this.couchServer.getUserDb().getUser({
					name: sessionContext.name
					,onSuccess: function(userDoc){
						// Check that it is still valid
						if( userDoc.name === _this.lastSessionContext.name ) {
							_this._handleCurrentUserDoc(userDoc);
						};
					}
					,onError: function(err){
						// No document associated with this user
						// Check that request is still valid
						if( sessionContext.name === _this.lastSessionContext.name ) {
							_this._handleCurrentUserDoc(null);
						};
					}
				});
			};
		};
	},
	
	_handleCurrentUserDoc: function(userDoc){
		this.currentUserDoc = userDoc;

		// Notify DOM classes
		var $body = $('body');
		if( this.currentUserDoc
		 && this.currentUserDoc.nunaliit_options
		 && this.currentUserDoc.nunaliit_options.advanced ){
			$body.addClass('nunaliit_user_advanced');
		} else {
			$body.removeClass('nunaliit_user_advanced');
		};

		if( userDoc ) {
			this._dispatch({
				type: 'authCurrentUserDoc'
				,userDoc: userDoc
			});
		};
		
		// Perform updates to the user document, if needed
		this._updateUserDocWithLoggedIn();
	}
	
	,_handleEvent: function(m){
		if( m && m.type === 'login' ){
			this.login({
				username: m.username
				,password: m.password
			});
			
		} else if( m && m.type === 'loginShowForm' ){
			this.showLoginForm();
			
		} else if( m && m.type === 'logout' ){
			this.logout();

		} else if( m && m.type === 'authIsLoggedIn' ){
			// Synchronous call
			if( this.isLoggedIn() ){
				m.isLoggedIn = true;
				m.context = this.lastSessionContext;
				m.userDoc = this.currentUserDoc;
			};
		};
	}
	
	,_getCustomService: function(){
		var cs = null;
		if( this.options.directory ){
			cs = this.options.directory.customService;
		};
		return cs;
	}
	
	,_shouldDisableCreateUserButton: function(){
		var flag = this.options.disableCreateUserButton;
		
		var customService = this._getCustomService();
		if( customService && !flag ){
			var o = customService.getOption('disableCreateUserButton');
			if( typeof(o) !== 'undefined' ){
				flag = o;
			};
		};

		return flag;
	},
	
	/*
	 * This function verifies if a user is logged in and if so,
	 * updates the user's document to reflect that the user
	 * is accessing the current atlas
	 */
	_updateUserDocWithLoggedIn: function(){
		var userDoc = this.currentUserDoc;
		if( userDoc // logged in and userDoc available 
		 && n2atlas
		 && n2atlas.name ){
			if( userDoc.nunaliit_atlases
			 && userDoc.nunaliit_atlases[n2atlas.name] 
			 && userDoc.nunaliit_atlases[n2atlas.name].auth ) {
				// OK
			} else {
				// Needs updating
				if( !userDoc.nunaliit_atlases ){
					userDoc.nunaliit_atlases = {};
				};
				if( !userDoc.nunaliit_atlases[n2atlas.name] ){
					userDoc.nunaliit_atlases[n2atlas.name] = {
						name: n2atlas.name
					};
				};
				userDoc.nunaliit_atlases[n2atlas.name].auth = true;
				
				this.couchServer.getUserDb().updateDocument({
					data: userDoc
					,onSuccess: function() { 
						// Just fine
					}
					,onError: function(err){
						$n2.log('Unable to save user\'s authentication flag to user db',err);
					}
				});
			};
		};
	}
	
	,_getAtlasName: function(){
		var atlasName = 'atlas';
		
		if( typeof n2atlas === 'object' 
		 && n2atlas.name ){
			atlasName = n2atlas.name;
		};
		
		return atlasName;
	}
});	

//===================================================================================

var AuthWidget = $n2.Class({
	
	authService: null
	
	,elemId: null
	
	,currentUserName: null
	
	,currentUserDisplay: null

	,labelLogin: null
	
	,labelLogout: null
	
	,labelWelcome: null
	
	,initialize: function(options_){
		var opts = $n2.extend({
			elemId: null
			,elem: null
			,authService: null
			,dispatchService: null
			,labelLogin: null
			,labelLogout: null
			,labelWelcome: null
		},options_);
		
		var _this = this;
	
		this.authService = opts.authService;
		this.dispatchService = opts.dispatchService;
		this.labelLogin = opts.labelLogin;
		this.labelLogout = opts.labelLogout;
		this.labelWelcome = opts.labelWelcome;
		
		this.elemId = opts.elemId;
		if( !this.elemId && opts.elem ){
			this.elemId = $n2.utils.getElementIdentifier(opts.elem);
		};
		
		if( this.dispatchService ){
			var f = function(m, addr, d){
				_this._handleDispatch(m, addr, d);
			};
			this.dispatchService.register(DH,'authLoggedIn',f);
			this.dispatchService.register(DH,'authLoggedOut',f);
			this.dispatchService.register(DH,'authCurrentUserDoc',f);
			this.dispatchService.register(DH,'userInfo',f);
			this.dispatchService.register(DH,'userDocument',f);

			// Initialize State
			var m = {
				type: 'authIsLoggedIn'
				,isLoggedIn: false
			};
			this.dispatchService.synchronousCall(DH,m);
			if( m.isLoggedIn ){
				if( m.context && m.context.name ){
					this.currentUserName = m.context.name;
				};
				if( m.userDoc && m.userDoc.display ){
					this.currentUserDisplay = m.userDoc.display;
				};
				
			} else {
				this.currentUserName = null;
				this.currentUserDisplay = null;
			};
			
			this._loginStateChanged();
		};
	}

	,_getElem: function(){
		return $('#'+this.elemId);
	}
	
	,_handleDispatch: function(m, addr, dispatcher){
		// Check if widget still displayed
		var $elem = this._getElem();
		if( $elem.length < 1 ){
			// Deregister
			dispatcher.deregister(addr);
			return;
		};
		
		if( 'authLoggedIn' === m.type ){
			var ctxt = m.user;
			if( this.currentUserName !== ctxt.name ){
				this.currentUserName = ctxt.name;
				this.currentUserDisplay = null;

				this._loginStateChanged();
			};
			
		} else if( 'authLoggedOut' === m.type ){
			this.currentUserName = null;
			this.currentUserDisplay = null;
			this._loginStateChanged();
			
		} else if( 'authCurrentUserDoc' === m.type ){
			var userDoc = m.userDoc;
			if( userDoc
			 && userDoc.display !== this.currentUserDisplay ){
				this.currentUserDisplay = userDoc.display;
				this._loginStateChanged();
			};
			
		} else if( 'userInfo' === m.type ){
			if( m.userInfo 
			 && this.currentUserName === m.userInfo.name ){
				this.currentUserDisplay = m.userInfo.display;
				this._loginStateChanged();
			};

		} else if( 'userDocument' === m.type ){
			if( m.userDoc 
			 && this.currentUserName === m.userDoc.name ){
				this.currentUserDisplay = m.userDoc.display;
				this._loginStateChanged();
			};
		};
	}

	,_loginStateChanged: function() {

		var $login = this._getElem();
		if( $login.length < 1 ) return;
		$login.empty();
		
		var authService = this.authService;
		if( authService ) {
			var href = null;
			var displayName = null;
			var buttonText = null;
			var clickFn = null;
			var greetingFn = null;
			var greetingClass = null;
			if( this.currentUserName ){
				href = 'javascript:Logout';
				displayName = this.currentUserDisplay;
				if( !displayName ) displayName = this.currentUserName;
				greetingClass = 'nunaliit_login_greeting_name';
				buttonText = this.labelLogout ? this.labelLogout : _loc('Logout');
				clickFn = function(){
					authService.logout();
					return false;
				};
				greetingFn = function(){
					authService.editUser({
						userName: null // current user
					});
					return false;
				};
			} else {
				href = 'javascript:Login';
				displayName = this.labelWelcome ? this.labelWelcome : _loc('Welcome');
				greetingClass = 'nunaliit_login_greeting_welcome';
				buttonText = this.labelLogin ? this.labelLogin : _loc('Login');
				clickFn = function(){
					authService.showLoginForm();
					return false;
				};
			};
			
			var aElem = $('<a class="nunaliit_login_link"></a>')
				.attr("href",href)
				.text(buttonText);
			var linkInnerContainer = $('<div class="nunaliit_login_link_inner_container"></div>')
				.append(aElem);
			var linkOuterContainer = $('<div class="nunaliit_login_link_outer_container"></div>')
				.append(linkInnerContainer)
				.click(clickFn);

			var nameElem = $('<span></span>')
				.text(displayName);
			var greetingInner = $('<div class="nunaliit_login_greeting_inner_container"></div>')
				.append(nameElem);
			var greetingOuter = $('<div class="nunaliit_login_greeting_outer_container"></div>')
				.addClass(greetingClass)
				.append(greetingInner);
			if( greetingFn ){
				greetingOuter
					.addClass('nunaliit_login_greeting_with_editor')
					.click(greetingFn);
			};
			
			$login.empty().append(greetingOuter).append(linkOuterContainer);
		};
	}
});

//===================================================================================

$n2.couchAuth = {
	AuthService: AuthService
	,AuthWidget: AuthWidget
};

})(jQuery,nunaliit2);


// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchModule.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

var 
	_loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
	,DH = 'n2.couchModule'
	;

//=========================================================================	

function isSrsNameSupported(srsName){
	if( typeof(OpenLayers) !== 'undefined'
	 && OpenLayers.Projection
	 && OpenLayers.Projection.transforms
	 && OpenLayers.Projection.transforms[srsName] ){
		return true;
	};
	
	if( typeof(Proj4js) !== 'undefined'
	 && Proj4js.Proj ){
		var proj = new Proj4js.Proj(srsName);
		if( proj.readyToUse ){
			return true;
		};
	};
	
	return false;
};

//=========================================================================	
var Module = $n2.Class({
	
	moduleDoc: null,
	
	atlasDb: null,
	
	initialize: function(moduleDoc, atlasDb){
		this.moduleDoc = moduleDoc;
		this.atlasDb = atlasDb;
	},

	getModuleInfo: function(){
		var moduleInfo = null;
		if( this.moduleDoc ){
			moduleInfo = this.moduleDoc.nunaliit_module;
		};
		return moduleInfo;
	},

	getMapInfo: function(){
		var mapInfo = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			mapInfo = moduleInfo.map;
		};
		return mapInfo;
	},

	getCanvasInfo: function(){
		var canvasInfo = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			canvasInfo = moduleInfo.canvas;
		};
		return canvasInfo;
	},

	getDisplayInfo: function(){
		var displayInfo = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			displayInfo = moduleInfo.display;
		};
		return displayInfo;
	},

	getEditInfo: function(){
		var editInfo = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			editInfo = moduleInfo.edit;
		};
		return editInfo;
	},

	getSearchInfo: function(){
		var searchInfo = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			searchInfo = moduleInfo.search;
		};
		return searchInfo;
	},

	getModelInfos: function(){
		var modelInfos = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			modelInfos = moduleInfo.models;
		};
		if( !modelInfos ){
			modelInfos = [];
		};
		return modelInfos;
	},
	
	getUtilityInfos: function(){
		var utilityInfos = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			utilityInfos = moduleInfo.utilities;
		};
		if( !utilityInfos ){
			utilityInfos = [];
		};
		return utilityInfos;
	},

	getWidgetInfos: function(){
		var widgetInfos = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			widgetInfos = moduleInfo.widgets;
		};
		if( !widgetInfos ){
			widgetInfos = [];
		};
		return widgetInfos;
	},

	getModuleCSS: function(){
		var css;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			css = moduleInfo.css;
		};
		return css;
	},
	
	/*
	 * Finds the introduction text associated with the module and inserts it
	 * in the element provided. Once the content of the introduction is loaded
	 * in the DOM, the "onLoaded" function is called.
	 */
	displayIntro: function(opts_){
		var opts = $n2.extend({
			elem: null
			,showService: null
			,dispatchService: null
			,onLoaded: function(){}
		},opts_);
		
		var _this = this;
		var $elem = opts.elem;
		
		var introInfo = null;
		var moduleInfo = this.getModuleInfo();
		if( moduleInfo ){
			introInfo = moduleInfo.introduction;
		};

		// Keep track if we need to empty content area
		var introDisplayed = false;

		// Via the dispatcher, see if a component can display introduction
		if( opts.dispatchService ){
			var msg = {
				type: 'modulePerformIntroduction'
				,performed: false
				,elem: opts.elem
				,module: this
			};
			opts.dispatchService.synchronousCall(DH,msg);
			
			// If an introduction was performed, then no need
			// to empty the element
			if( msg.performed ){
				introDisplayed = true;
			};
		};
		
		if( !introDisplayed && introInfo ){
			if( 'html' === introInfo.type && introInfo.content ) {
				
				$elem.empty();
				var $outer = $('<div>')
					.addClass('n2ModuleIntro n2ModuleIntro_html')
					.appendTo($elem);
				
				var content = _loc(introInfo.content);
				if( content ) {
					$outer.html(content);
					
					if( opts.showService ) {
						opts.showService.fixElementAndChildren($outer, {}, this.moduleDoc);
					};					
				};
				opts.onLoaded();
				introDisplayed = true;
				
			} else if( 'text' === introInfo.type && introInfo.content ) {
				
				$elem.empty();
				var $outer = $('<div>')
					.addClass('n2ModuleIntro n2ModuleIntro_text')
					.appendTo($elem);
				
				var content = _loc(introInfo.content);
				if( content ) {
					var $wrapper = $('<div>')
						.text(content);
					$outer
						.empty()
						.append($wrapper);
					
					if( opts.showService ) {
						$wrapper.addClass('n2s_preserveSpaces');
						opts.showService.fixElementAndChildren($wrapper, {}, this.moduleDoc);
					};
				};
				opts.onLoaded();
				introDisplayed = true;
				
			} else if( 'attachment' === introInfo.type 
			 && introInfo.attachmentName
			 && this.atlasDb
			 ) {
				var displayId = $n2.getUniqueId();
				$elem.empty();
				$('<div>')
					.attr('id', displayId)
					.addClass('n2ModuleIntro n2ModuleIntro_attachment')
					.appendTo($elem);
				introDisplayed = true;
				
				var localeStr = $n2.l10n.getStringForLocale(introInfo.attachmentName);
				if( localeStr.str ) {
					var attUrl = this.atlasDb.getAttachmentUrl(this.moduleDoc,localeStr.str);
					
					$.ajax({
				    	url: attUrl
				    	,type: 'get'
				    	,async: true
				    	,success: function(intro) {
				    		if( localeStr.fallback ){
				    			var $inner = $('<span class="n2_localized_string n2_localize_fallback"></span>');
				    			$('<span class="n2_localize_fallback_lang"></span>')
				    				.text('('+localeStr.lang+')')
				    				.appendTo($inner);
				    			$('<span></span>')
				    				.html(intro)
				    				.appendTo($inner);
			    				$('#'+displayId).empty().append($inner);
				    		} else {
					    		$('#'+displayId).html(intro);
				    		};
							if( opts.showService ) {
								opts.showService.fixElementAndChildren($('#'+displayId), {}, _this.moduleDoc);
							};
							opts.onLoaded();
				    	}
				    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
							$n2.log('Unable to obtain module intro: '+textStatus);
				    	}
					});
				};
			};
		};
		
		if( !introDisplayed ){
			$elem.empty();
			return false;
		};
		
		return true;
	},
	
	getAttachmentUrl: function(attachmentName){
		return this.atlasDb.getAttachmentUrl(this.moduleDoc, attachmentName);
	}
});
	
//=========================================================================	
var ModuleDisplay = $n2.Class({

	config: null,

	moduleId: null,
	
	module: null,
	
	mapControl: null,
	
	displayControl: null,

	titleName: null,

	moduleTitleName: null,
	
	contentName: null,

	mapName: null,
	
	mapInteractionName: null,

	sidePanelName: null,
	
	filterPanelName: null,

	searchPanelName: null,
	
	loginPanelNames: null,
	
	navigationName: null,
	
	navigationDocId: null,

	languageSwitcherName: null,
	
	helpButtonName: null,
	
	helpDialogId: null,
	
	styleMapFn: null,
	
	mapStyles: null,
	
	// Services
	
	dispatchService: null,
	
	navigationService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			moduleName: null
			,moduleDoc: null
			,config: null
			,titleName: 'title'
			,moduleTitleName: 'module_title'
			,contentName: null // specify contentName, or mapName+sidePanelName+mapInteractionName+searchPanelName
			,mapName: 'map'
			,mapInteractionName: 'map_interaction_div'
			,sidePanelName: 'side'
			,filterPanelName: 'filters'
			,searchPanelName: null
			,loginPanelName: 'login'
			,loginPanels: null
			,navigationName: 'navigation'
			,navigationDoc: null
			,languageSwitcherName: null
			,helpButtonName: null
			,styleMapFn: null
			,onSuccess: function(moduleDisplay){}
			,onError: function(err){ $n2.reportErrorForced(errorMsg); }
		},opts_);
		
		var _this = this;
	
		if( !opts.moduleName  && !opts.moduleDoc ) {
			opts.onError('"moduleName" or "moduleDoc" must be specified');
			return;
		};
		
		this.config = opts.config;
		if( !this.config ) {
			opts.onError('"config" must be specified');
			return;
		};
		
		this.contentName = opts.contentName;
		this.mapName = opts.mapName;
		this.mapInteractionName = opts.mapInteractionName;
		this.sidePanelName = opts.sidePanelName;
		this.filterPanelName = opts.filterPanelName;
		this.searchPanelName = opts.searchPanelName;
		this.navigationName = opts.navigationName;
		this.navigationDocId = opts.navigationDoc;
		this.titleName = opts.titleName;
		this.moduleTitleName = opts.moduleTitleName;
		this.languageSwitcherName = opts.languageSwitcherName;
		this.helpButtonName = opts.helpButtonName;
		this.styleMapFn = opts.styleMapFn;
		
		if( this.config && this.config.directory ){
			this.dispatchService = this.config.directory.dispatchService;
			this.navigationService = this.config.directory.navigationService;
		};

		// Login panels
		this.loginPanelNames = [];
		if( opts.loginPanels ){
			$(opts.loginPanels).each(function(){
				var $loginPanel = $(this);
				var id = $loginPanel.attr('id');
				if( !id ){
					id = $n2.getUniqueId();
					$loginPanel.attr('id',id);
				};
				_this.loginPanelNames.push(id);
			});
		} else if( opts.loginPanelName ) {
			this.loginPanelNames.push(opts.loginPanelName);
		};
		
		// Quick access
		var config = this.config;
		var atlasDb = config.atlasDb;
		var atlasDesign = config.atlasDesign;
		var documentSource = config.documentSource;
		var customService = this._getCustomService();
		
		// dispatcher
		var d = this.dispatchService;
		if( d ){
			d.register(DH,'unselected',function(m){
				_this._initSidePanel();
			});
			d.register(DH,'moduleGetCurrent',function(m){
				m.moduleId = _this.getCurrentModuleId();
				
				if( _this.module ){
					m.module = _this.module;
					m.doc = _this.module.moduleDoc;
					m.moduleDisplay = _this;
				};
			});
		};
		
		// Set up login widget
		for(var i=0,e=this.loginPanelNames.length;i<e;++i){
			var loginPanelName = this.loginPanelNames[i];
			config.directory.authService.createAuthWidget({
				elemId: loginPanelName
			});
		};
		
		/*
		 * Get module document, if required.
		 * 
		 * Allow for the module document to be passed in along with the moduleName.
		 * This allows for run-time insertion of layer options (e.g., styling functions).
		 */
		if( ! $n2.isDefined(opts.moduleDoc) ) {
			this.moduleId = opts.moduleName;
			atlasDb.getDocument({
				docId: opts.moduleName
				,onSuccess: moduleDocumentLoaded
				,onError: function(err){ 
					opts.onError('Unable to load module: '+err); 
				}
			});
		} else {
			moduleDocumentLoaded(opts.moduleDoc);
		};
		
		/*
		 * Get navigation document, if required.
		 */
		if( this.navigationDocId ){
			
			var $title = $('#'+this.titleName);
			if( $title.length > 0 ){
				$title.empty();

				if( this.navigationService ){
					this.navigationService.printTitle({
						elem: $title
					});
				};
			};
			
			var $menu = $('#'+this.navigationName);
			if( $menu.length > 0 ){
				$menu.empty();

				if( this.navigationService ){
					this.navigationService.printMenu({
						elem: $menu
					});
				};
			};
			
			if( this.navigationService ){
				this.navigationService.setCurrentNavigation({
					docId: this.navigationDocId
				});
			};
		};
		
		function moduleDocumentLoaded(moduleDoc){
			if( !moduleDoc.nunaliit_module ) {
				opts.onError('Loaded document does not include module information');
				return;
			};

			if( moduleDoc._id ){
				_this.moduleId = moduleDoc._id;
				var safeId = $n2.utils.stringToHtmlId(moduleDoc._id);
				$('body').addClass('nunaliit_module_'+safeId);
				
				// Update any associated navigation items
				$('.n2_nav_module+'+safeId).addClass('n2_nav_currentModule');
			};

			_this.module = new Module(moduleDoc, atlasDb);
			
			_this._sendDispatchMessage({
				type: 'reportModuleDocument'
				,doc: moduleDoc
				,moduleId: moduleDoc._id
				,module: _this.module
				,moduleDisplay: _this
			});
			
			var moduleInfo = _this.module.getModuleInfo();
			var mapInfo = _this.module.getMapInfo();
			var canvasInfo = _this.module.getCanvasInfo();
			var displayInfo = _this.module.getDisplayInfo();
			var searchInfo = _this.module.getSearchInfo();
			var modelInfos = _this.module.getModelInfos();
			var utilityInfos = _this.module.getUtilityInfos();
			
			// Load up CSS, if specified
			var css = _this.module.getModuleCSS();
			if( typeof css === 'string' ){
				$n2.css.setCss({
					css: css
					,name: 'module'
				});
			};
			
			// Create models
			if( modelInfos ){
				for(var i=0,e=modelInfos.length; i<e; ++i){
					var modelInfo = modelInfos[i];

					var msg = {
						type: 'modelCreate'
						,modelType: modelInfo.modelType
						,modelId: modelInfo.modelId
						,modelOptions: modelInfo
						,created: false
						,config: config
						,moduleDisplay: _this
					};
						
					_this._sendSynchronousMessage(msg);
						
					if( ! msg.created ){
						$n2.logError('Model not created: '+modelInfo.modelType+'/'+modelInfo.modelId);
					};
				};
			};
			
			// Create utilities
			var inputChangeDetectorSpecified = false;
			if( utilityInfos ){
				for(var i=0,e=utilityInfos.length; i<e; ++i){
					var utilityInfo = utilityInfos[i];

					if( 'inputChangeDetector' === utilityInfo.utilityType ){
						inputChangeDetectorSpecified = true;
					};
					
					var msg = {
						type: 'utilityCreate'
						,utilityType: utilityInfo.utilityType
						,utilityOptions: utilityInfo
						,created: false
						,config: config
						,moduleDisplay: _this
					};
						
					_this._sendSynchronousMessage(msg);
						
					if( ! msg.created ){
						$n2.logError('Utility not created: '+utilityInfo.utilityType);
					};
				};
			};
			
			// Add utility 'inputChangeDetector', if not already specified
			if( !inputChangeDetectorSpecified ){
				var msg = {
					type: 'utilityCreate'
					,utilityType: 'inputChangeDetector'
					,utilityOptions: {
						type: 'inputChangeDetector'
					}
					,created: false
					,config: config
					,moduleDisplay: _this
				};
					
				_this._sendSynchronousMessage(msg);
					
				if( ! msg.created ){
					$n2.logError('Unable to add utility inputChangeDetector');
				};
			};
			
			// Check if support for canvas is available
			var canvasHandlerAvailable = false;
			if( canvasInfo && canvasInfo.canvasType ) {
				var msg = {
					type: 'canvasIsTypeAvailable'
					,canvasType: canvasInfo.canvasType
					,canvasOptions: canvasInfo
					,isAvailable: false
				};
				
				_this._sendSynchronousMessage(msg);
				
				if( msg.isAvailable ){
					canvasHandlerAvailable = true;
				};
			};
			if( canvasInfo && !canvasHandlerAvailable ){
				$n2.logError('Canvas handler not found for type: '+canvasInfo.canvasType);
				canvasInfo = null;
			};
			
			// Handle content div
			if( _this.contentName ){
				var $contentDiv = $('#'+_this.contentName)
					.empty()
					;
				
				if( mapInfo || canvasInfo ) {
					_this.mapName = $n2.getUniqueId();
					$('<div></div>')
						.attr('id',_this.mapName)
						.addClass('n2_content_map')
						.appendTo($contentDiv);
					$contentDiv.addClass('n2_content_contains_map');

					_this.mapInteractionName = $n2.getUniqueId();
					$('<div></div>')
						.attr('id',_this.mapInteractionName)
						.addClass('n2_content_map_interaction')
						.appendTo($contentDiv);

				} else {
					_this.mapName = null;
					_this.mapInteractionName = null;
					$contentDiv.addClass('n2_content_contains_no_map');
				};
				
				if( searchInfo && searchInfo.disabled ) {
					_this.searchPanelName = null;
					$contentDiv.addClass('n2_content_contains_no_search');
					
				} else if( _this.searchPanelName ) {
					// Search panel is specified. No need to create
					// Therefore, search is not located within the content
					$contentDiv.addClass('n2_content_contains_no_search');

				} else {
					_this.searchPanelName = $n2.getUniqueId();
					$('<div></div>')
						.attr('id',_this.searchPanelName)
						.addClass('n2_content_searchInput')
						.appendTo($contentDiv);
					$contentDiv.addClass('n2_content_contains_search');
				};
				
				_this.sidePanelName = $n2.getUniqueId();
				$('<div></div>')
					.attr('id',_this.sidePanelName)
					.addClass('n2_content_text')
					.appendTo($contentDiv);
				$contentDiv.addClass('n2_content_contains_text');
			};

			// Styles
			if( mapInfo && $n2.isArray(mapInfo.styles) ){
				_this.mapStyles = new $n2.mapStyles.MapStylesAdaptor({
					ruleArray: mapInfo.styles
					,dispatchService: this.dispatchService
				});

			} else if( mapInfo && typeof mapInfo.styles === 'object' ){
				_this.mapStyles = new $n2.mapStyles.MapFeatureStyles(mapInfo.styles);
			
			} else {
				_this.mapStyles = new $n2.mapStyles.MapFeatureStyles(null);
			};
			
			// Title
			if( moduleInfo && moduleInfo.title ) {
				var title = _loc(moduleInfo.title);
				//$('head > title').text('' + moduleInfo.title);
				if( title ) {
					document.title = title; // needed for IE 6
					_this._installModuleTitle($('#'+opts.moduleTitleName), title);
				};
			} else {
				var title = _loc('Nunaliit Atlas');
				//$('head > title').text(title);
				document.title = title; // needed for IE 6
				_this._installModuleTitle($('#'+opts.moduleTitleName), title);
			};
			
			// Language switcher
			if( _this.languageSwitcherName
			 && _this.config.directory.languageService ){
				_this.config.directory.languageService.drawWidget({
					elemId: _this.languageSwitcherName
				});
			};
			
			// Help button
			if( moduleInfo.help && _this.helpButtonName ){
				_this._installHelpButton();
			};
			
			// Display 
			if( displayInfo ){
				var displayFormat = null;
				if( displayInfo.type ){
					displayFormat = displayInfo.type;
				};
				if( !displayFormat && customService ){
					displayFormat = customService.getOption('displayFormat',displayFormat);
				};
				if( !displayFormat ){
					displayFormat = 'classic';
				};
				
				var displayHandlerAvailable = false;
				var msg = {
					type: 'displayIsTypeAvailable'
					,displayType: displayFormat
					,isAvailable: false
					,displayOptions: displayInfo
				};
				_this._sendSynchronousMessage(msg);
				if( msg.isAvailable ){
					displayHandlerAvailable = true;
				};
				
				if( displayHandlerAvailable ){
					_this._sendDispatchMessage({
						type: 'displayRender'
						,displayType: displayFormat
						,displayOptions: displayInfo
						,displayId: _this.sidePanelName
						,config: config
						,moduleDisplay: _this
						,onSuccess: function(displayControl){
							_this.displayControl = displayControl;
							drawCanvas(searchInfo, mapInfo, canvasInfo);
						}
						,onError: opts.onError
					});
				} else {
					drawCanvas(searchInfo, mapInfo, canvasInfo);
				};
			};
		};
			
		function drawCanvas(searchInfo, mapInfo, canvasInfo) {
			var editInfo = _this.module.getEditInfo();

			// Edit logic
			config.couchEditor.setPanelName(_this.sidePanelName);
			var defaultEditSchemaName = 'object';
			if( editInfo && editInfo.defaultSchemaName ){
				defaultEditSchemaName = editInfo.defaultSchemaName;
			};
			config.directory.schemaRepository.getSchema({
				name: defaultEditSchemaName
				,onSuccess: function(schema){
					config.couchEditor.options.defaultEditSchema = schema;
				}
			});
			if( editInfo && editInfo.newDocumentSchemaNames ){
				if( 'ALL_SCHEMAS' === editInfo.newDocumentSchemaNames ){
					config.couchEditor.setSchemas( $n2.couchEdit.Constants.ALL_SCHEMAS );
					
				} else if( editInfo.newDocumentSchemaNames.length ){
					config.directory.schemaRepository.getSchemas({
						names: editInfo.newDocumentSchemaNames
						,onSuccess: function(schemas){
							config.couchEditor.setSchemas( schemas );
						}
						,onError: function(err){
							$n2.log('Error obtaining new edit document schemas: '+err);
						}
					});
				};
			};
			if( editInfo && config.directory.editService ){
				config.directory.editService.configureOptions(editInfo);
			};
			if( editInfo && config.directory.createDocProcess ){
				config.directory.createDocProcess.configureOptions(editInfo);
			};

			// Search
			if( searchInfo && searchInfo.constraint ){
				config.directory.searchService.setConstraint(searchInfo.constraint);
			};
			if( _this.searchPanelName ) {
				config.directory.searchService.installSearchWidget({
					elem: $('#'+_this.searchPanelName)
				});
			};
			
			// Display map
			if( mapInfo ) {
				_this._initializeMap({
					config: config
					,onSuccess: drawWidgets
					,onError: opts.onError
				});
				
			} else if( canvasInfo ) {
				_this._sendDispatchMessage({
					type: 'canvasDisplay'
					,canvasType: canvasInfo.canvasType
					,canvasOptions: canvasInfo
					,canvasId: _this.mapName
					,interactionId: _this.mapInteractionName
					,config: config
					,moduleDisplay: _this
					,onSuccess: drawWidgets
					,onError: opts.onError
				});
				
			} else {
				drawWidgets();
			};
		};
		
		function drawWidgets(){
			var widgetInfos = _this.module.getWidgetInfos();

			// Check for widget support
			var availableWidgets = [];
			if( widgetInfos ){
				for(var i=0,e=widgetInfos.length; i<e; ++i){
					var widgetInfo = widgetInfos[i];
					var widgetHandlerAvailable = false;
					if( widgetInfo && widgetInfo.widgetType ) {
						var msg = {
							type: 'widgetIsTypeAvailable'
							,widgetType: widgetInfo.widgetType
							,widgetOptions: widgetInfo
							,isAvailable: false
						};
						
						_this._sendSynchronousMessage(msg);
						
						if( msg.isAvailable ){
							widgetHandlerAvailable = true;
						};
					};
					if( widgetInfo && !widgetHandlerAvailable ){
						$n2.logError('Widget handler not found for type: '+widgetInfo.widgetType);
					} else {
						availableWidgets.push(widgetInfo);
					};
				};
			};

			// Widgets
			var modelBrowserSpecified = false;
			for(i=0,e=availableWidgets.length; i<e; ++i){
				widgetInfo = availableWidgets[i];
				var widgetDisplayMsg = {
					type: 'widgetDisplay'
					,widgetType: widgetInfo.widgetType
					,widgetOptions: widgetInfo
					,contentId: _this.contentName
					,config: config
					,moduleDisplay: _this
				};

				var widgetDisplayed = false;
				
				// Install at containerId
				if( widgetInfo.containerId ){
					widgetDisplayMsg.containerId = widgetInfo.containerId;
					_this._sendDispatchMessage(widgetDisplayMsg);
					widgetDisplayed = true;
				};
				
				// Install under each containerClass
				if( widgetInfo.containerClass ){
					$('.'+widgetInfo.containerClass).each(function(){
						var containerId = $n2.utils.getElementIdentifier(this);
						widgetDisplayMsg.containerId = containerId;
						_this._sendDispatchMessage(widgetDisplayMsg);
					});
					widgetDisplayed = true;
				};
				
				if( !widgetDisplayed ) {
					// At this point, neither containerId nor containerClass
					// were specified
					widgetDisplayMsg.containerId = _this.contentName;
					_this._sendDispatchMessage(widgetDisplayMsg);
				};
				
				if( 'modelBrowserWidget' === widgetInfo.widgetType ){
					modelBrowserSpecified = true;
				};
			};
			
			// Add model browser widget, if not specified
			if( !modelBrowserSpecified ){
				var $footer = $('.nunaliit_footer');
				if( $footer.length > 0 ){
					var containerId = $n2.utils.getElementIdentifier($footer);
					var widgetDisplayMsg = {
						type: 'widgetDisplay'
						,widgetType: 'modelBrowserWidget'
						,widgetOptions: {
							widgetType: 'modelBrowserWidget'
						}
						,contentId: _this.contentName
						,containerId: containerId
						,config: config
						,moduleDisplay: _this
					};
					_this._sendDispatchMessage(widgetDisplayMsg);
				};
			};

			displayComplete();
		};
		
		function displayComplete(){
			// Side panel
			_this._initSidePanel();

			_this._sendDispatchMessage({
				type:'reportModuleDisplay'
				,moduleDisplay: _this
			});

			opts.onSuccess(_this);
		};
	},
	
	getCurrentModuleId: function(){
		if( this.module && this.module._id ){
			return this.module._id;
		};
		
		return this.moduleId;
	},

	_initializeMap: function(opts_){
		var opts = $n2.extend({
			config: null
			,onSuccess: function(moduleDisplay){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var mapInfo = _this.module.getMapInfo();
		var customService = this._getCustomService();
		
		// Add points only
		var addPointsOnly = false;
		if( mapInfo && mapInfo.addPointsOnly ){
			addPointsOnly = mapInfo.addPointsOnly;
		};
		
		// Toggle click
		var toggleClick = false;
		if( mapInfo && mapInfo.toggleClick ){
			toggleClick = mapInfo.toggleClick;
		};
		
		// Add SRS attribution text
		var showSRSAttribution = false;
		if( mapInfo && mapInfo.showSRSAttribution ){
			showSRSAttribution = mapInfo.showSRSAttribution;
		};
		
		// ScaleLine
		var scaleLine = {
			visible: false
		};
		if( mapInfo && mapInfo.scaleLine && mapInfo.scaleLine.visible ){
			scaleLine = mapInfo.scaleLine;
		};

		// Enable wheel zoom
		var enableWheelZoom = false;
		if( mapInfo && mapInfo.enableWheelZoom ){
			enableWheelZoom = true;
		};
		
		// dbSearchEngine
		var dbSearchEngine = { 
			relMediaPath: './'
		};
		if( mapInfo && mapInfo.dbSearchEngine ){
			dbSearchEngine = mapInfo.dbSearchEngine;
		};
		
		// canvasName
		var canvasName = undefined;
		if( mapInfo && typeof mapInfo.canvasName === 'string' ){
			canvasName = mapInfo.canvasName;
		};
		
		var mapOptions = {
			dbSearchEngine: dbSearchEngine
			,canvasName: canvasName
			,mapIdentifier: _this.mapName
			,mapInteractionDivName: _this.mapInteractionName
			,mapCoordinateSpecifications: {
				initialBounds: null
			}
			,uniqueIdentifier: '_id'
			,addPointsOnly: addPointsOnly
			,overlays: []
			,toggleClick: toggleClick
			,showSRSAttribution: showSRSAttribution
			,scaleLine: scaleLine
			,enableWheelZoom: enableWheelZoom
			,sidePanelName: _this.sidePanelName
			,filterPanelName: _this.filterPanelName
			,saveFeature: _this.config.couchEditor
			,mapDisplay: {}
			,directory: _this.config.directory
			,layerSwitcher: {
				suppress: false
				,initiallyOpened: false
			}
		};
		
		// Layer selector
		if( mapInfo && mapInfo.layerSelector ){
			if( mapInfo.layerSelector.suppress ){
				mapOptions.layerSwitcher.suppress = true;
			};
			
			if( mapInfo.layerSelector.initiallyOpened ){
				mapOptions.layerSwitcher.initiallyOpened = true;
			};
		};
	
		// Initial Bounds, Map coordinates
		var initialBounds = null;
		if( mapInfo && mapInfo.coordinates ){
			initialBounds = mapInfo.coordinates.initialBounds;
			
			if( mapInfo.coordinates.srsName ){
				// Verify if SRS name is supported
				if( false == isSrsNameSupported(mapInfo.coordinates.srsName) ) {
					var msg = _loc('The projection {srsName} is not supported. Atlas may no function properly.',{
						srsName: mapInfo.coordinates.srsName
					});
					alert(msg);
				};
				
				mapOptions.mapDisplay.srsName = mapInfo.coordinates.srsName;
				mapOptions.mapCoordinateSpecifications.srsName = mapInfo.coordinates.srsName;
			} else {
				// Defaults to EPSG:4326
				mapOptions.mapDisplay.srsName = 'EPSG:4326';
				mapOptions.mapCoordinateSpecifications.srsName = 'EPSG:4326';
			};

			
			if( mapInfo.coordinates.mousePositionSrsName ){
				mapOptions.mapCoordinateSpecifications.mousePositionSrsName = 
					mapInfo.coordinates.mousePositionSrsName;
			};
			
			// Detect forced display projections based on background layer
			if( mapInfo.backgrounds ){
				for(var i=0,e=mapInfo.backgrounds.length; i<e; ++i){
					if( 'Google Maps' === mapInfo.backgrounds[i].type ) {
						mapOptions.mapDisplay.srsName = 'EPSG:900913';
						
					} else if( 'osm' === mapInfo.backgrounds[i].type ) {
						mapOptions.mapDisplay.srsName = 'EPSG:900913';
						
					} else if( 'stamen' === mapInfo.backgrounds[i].type ) {
						mapOptions.mapDisplay.srsName = 'EPSG:900913';
					};
				};
			};
		};
		
		// Background Layers
		if( mapInfo && mapInfo.backgrounds ){
			mapOptions.mapDisplay.backgrounds = [];
			for(var i=0,e=mapInfo.backgrounds.length; i<e; ++i){
				var l = $n2.extend({},mapInfo.backgrounds[i]);

				if( l.type === 'image' ){
					if( l.options && l.options.attachmentName ){
						var url = _this.config.atlasDb.getAttachmentUrl(
							this.module.moduleDoc
							,l.options.attachmentName
						);
						l.options.url = url;
					};

					if( l.options 
					 && l.options.extent 
					 && mapOptions.mapDisplay.srsName != mapOptions.mapCoordinateSpecifications.srsName ){
						var defProj = new OpenLayers.Projection(mapOptions.mapCoordinateSpecifications.srsName);
						var mapProj = new OpenLayers.Projection(mapOptions.mapDisplay.srsName);
						var bl = new OpenLayers.Geometry.Point(l.options.extent[0], l.options.extent[1]);
						var tr = new OpenLayers.Geometry.Point(l.options.extent[2], l.options.extent[3]);
						bl.transform(defProj,mapProj);
						tr.transform(defProj,mapProj);
						l.options.extent[0] = bl.x;
						l.options.extent[1] = bl.y;
						l.options.extent[2] = tr.x;
						l.options.extent[3] = tr.y;
					};
				};
				
				mapOptions.mapDisplay.backgrounds.push(l);
			};
		};
	
		// Overlay Layers
		if( mapInfo && mapInfo.overlays ){
			var styleMapFn = _this.styleMapFn;
			if( !styleMapFn && customService ) {
				styleMapFn = customService.getOption('mapGetStyleFunctionForLayer');
				if( typeof styleMapFn !== 'function' ){
					styleMapFn = null;
				};
			};
			if( !styleMapFn ) {
				styleMapFn = function(layerInfo_){ 
					return _this.mapStyles.getStyleMapForLayerInfo(layerInfo_); 
				};
			};
			
			for(var i=0,e=mapInfo.overlays.length; i<e; ++i){
				var layerInfo = mapInfo.overlays[i];
				
				var layerDefinition = {
					id: layerInfo.id
					,name: layerInfo.name
					,type: layerInfo.type
					,visibility: layerInfo.visibility
					,featurePopupHtmlFn: _this.config.popupHtmlFn // legacy
					,featurePopupDelay: 0 // ms
					,styleMapFn: styleMapFn
					,useHoverSound: true
					,clustering: false
				};
				
				if ($n2.isDefined(layerInfo.gutter)) {
					layerDefinition.gutter = layerInfo.gutter;
				};
				if ($n2.isDefined(layerInfo.displayInLayerSwitcher)) {
					layerDefinition.displayInLayerSwitcher = layerInfo.displayInLayerSwitcher;
				};
				
				if( 'couchdb' === layerInfo.type ){
					layerDefinition.options = $n2.extend({
						viewName: 'geom'
						,layerName: null
						,documentSource: _this.config.documentSource
					},layerInfo.options);

					if( !layerDefinition.options.layerName ){
						layerDefinition.options.layerName = layerDefinition.id;
					};
					if( !layerDefinition.id 
					 && layerDefinition.options
					 && layerDefinition.options.layerName ){
						layerDefinition.id = layerDefinition.options.layerName;
					};
					
				} else {
					layerDefinition.options = layerInfo.options;
				};
	
				if( layerInfo.featurePopupDelayMs ){
					layerDefinition.featurePopupDelay = layerInfo.featurePopupDelayMs;
				};
	
				if( typeof(layerInfo.useHoverSound) === 'boolean' ){
					layerDefinition.useHoverSound = layerInfo.useHoverSound;
				};
				
				if( layerInfo.clustering ){
					layerDefinition.clustering = layerInfo.clustering;
				};

				if( typeof layerInfo.minimumLinePixelSize === 'number' ){
					layerDefinition.minimumLinePixelSize = layerInfo.minimumLinePixelSize;
				};

				if( typeof layerInfo.minimumPolygonPixelSize === 'number' ){
					layerDefinition.minimumPolygonPixelSize = layerInfo.minimumPolygonPixelSize;
				};
				
				// Add layer to map
				mapOptions.overlays.push( layerDefinition );
			};
		};
		
		if( mapInfo 
		 && mapInfo.coordinates
		 && mapInfo.coordinates.autoInitialBounds
		 ){
			// Figure out projection for configuration
			var coordinateProjection = undefined;
			if( mapOptions.mapCoordinateSpecifications.srsName ){
				coordinateProjection = new OpenLayers.Projection(mapOptions.mapCoordinateSpecifications.srsName);
			} else {
				coordinateProjection = new OpenLayers.Projection('EPSG:4326');
			};
			
			var autoBounds = undefined;
			if( typeof mapInfo.coordinates.autoInitialBounds === 'object' ){
				// Make a copy of configuration that contains map info
				var instanceConfiguration = $n2.extend({},mapInfo.coordinates.autoInitialBounds);
				instanceConfiguration._mapInfo = mapInfo;
				
				// Initial bounds computed from a configured object
				var m = {
					type: 'instanceCreate'
					,instanceConfiguration: instanceConfiguration
				};
				_this.dispatchService.synchronousCall(DH,m);
				autoBounds = m.instance;
			};
			
			if( !autoBounds ){
				// Default
				var m = {
					type: 'instanceCreate'
					,instanceConfiguration: {
						type: 'mapAutoInitialBoundsCouchDbOverlays'
					}
				};
				_this.dispatchService.synchronousCall(DH,m);
				autoBounds = m.instance;
			};
			
			if( autoBounds 
			 && typeof autoBounds.computeInitialBounds === 'function' ){
				autoBounds.computeInitialBounds({
					mapOptions: mapOptions
					,mapInfo: mapInfo
					,initialBounds: initialBounds
					,coordinateProjection: coordinateProjection
					,onSuccess: function(bounds){
						if( !bounds ){
							initialBoundsComputed(mapOptions, initialBounds);
						} else {
							initialBoundsComputed(mapOptions, bounds);
						};
					}
					,onError: function(err){
						$n2.log('Error while computing initial bounds: '+err);
						initialBoundsComputed(mapOptions, initialBounds);
					}
				});
			} else {
				initialBoundsComputed(mapOptions, initialBounds);
			};

		} else {
			initialBoundsComputed(mapOptions, initialBounds);
		};
		
		function initialBoundsComputed(mapOptions, initialBounds){
			if( !initialBounds ) {
				opts.onError('Initial map extent not specified');
				return;
			};
		
			mapOptions.mapCoordinateSpecifications.initialBounds = initialBounds;
			
			// Map max extent
			var mapInfo = _this.module.getMapInfo();
			if( mapInfo 
			 && mapInfo.coordinates
			 && mapInfo.coordinates.maxExtent
			 ){
				mapOptions.mapCoordinateSpecifications.maxExtent = 
					mapInfo.coordinates.maxExtent;
				
			} else if( mapOptions.mapDisplay.srsName !== null 
			 && mapOptions.mapDisplay.srsName !== 'EPSG:4326' ) {
				mapOptions.mapCoordinateSpecifications.maxExtent =
					mapOptions.mapCoordinateSpecifications.initialBounds;
			};
			
			// Create map control
			try {
				_this.mapControl = nunaliit2.mapAndControls(mapOptions);
				_this.mapControl.contributions = _this.config.contributions;
				_this.mapControl.requests = _this.config.directory.requestService;
			} catch(e) {
				$n2.log('Error while creating map: '+e);
				if( e.stack ) {
					$n2.log('Stack',e.stack);
				};
			};

			$n2.log('module',_this);
			opts.onSuccess(_this);
		};
	}

	,_initSidePanel: function(){
		var _this = this;

		var customService = this._getCustomService();
		
		var $elem = $('#'+this.sidePanelName);
		
		var displayIntroFn = customService.getOption('moduleDisplayIntroFunction', null);
		if( displayIntroFn ){
			displayIntroFn({
				elem: $elem
				,config: this.config
				,moduleDisplay: this
			});
		} else {
			this.module.displayIntro({
				elem: $elem
				,showService: this._getShowService()
				,dispatchService: this.dispatchService
				,onLoaded: function(){
					_this._sendDispatchMessage({type:'loadedModuleContent'});
				}
			});
		};
	}
	
	,_getShowService: function(){
		var ss = null;
		if( this.config.directory ){
			ss = this.config.directory.showService;
		};
		return ss;
	}
	
	,_getCustomService: function(){
		var cs = null;
		if( this.config.directory ){
			cs = this.config.directory.customService;
		};
		return cs;
	}
	
	,_sendDispatchMessage: function(m){
		var d = this.dispatchService;
		if( d ){
			d.send(DH,m);
		};
	}
	
	,_sendSynchronousMessage: function(m){
		var d = this.dispatchService;
		if( d ){
			d.synchronousCall(DH,m);
		};
	}
	
	,_installModuleTitle: function($elem, text){
		var _this = this;
		
		$elem.empty();

		var $a = $('<a class="nunaliit_module_title_link" href="#"></a>')
			.addClass('nunaliit_module_title_link')
			.attr('href','#')
			.text(text)
			.appendTo($elem)
			.click(function(e){
				var d = _this.dispatchService;
				if( d ){
					d.send(DH,{
						type: 'mapResetExtent'
					});
				};
				
				// Follow link
				return true;
			});

		var moduleId = this.moduleId;
		if( moduleId ){
			$a.addClass('n2s_insertModuleName');
			$a.attr('nunaliit-document',moduleId);

			var showService = this._getShowService();
			if( showService ){
				showService.fixElementAndChildren($elem);
			};
		};
	}
	
	,_installHelpButton: function(){
		var _this = this;
		
		var $elem = $('#'+this.helpButtonName);
		if( $elem.length < 1 ) return; // nothing to do
		
		$elem.empty();
		
		// Load help text
		var moduleInfo = this.module.getModuleInfo();
		if( moduleInfo.help 
		 && moduleInfo.help.nunaliit_type === 'reference'
		 && moduleInfo.help.doc ){
			// load up help document
			this.config.atlasDb.getDocument({
				docId: moduleInfo.help.doc
				,onSuccess: function(doc){
					if( doc 
					 && doc.nunaliit_help ){
						$n2.help.InstallHelpInfo('main',doc.nunaliit_help);
						installHelpButton();
					} else {
						$n2.log('Do not know how to interpret help document');
						$elem.attr('n2_error','Do not know how to interpret help document');
					};
				}
				,onError: function(err){
					$n2.log('Unable to load help document',err);
					$elem.attr('n2_error','Unable to load help document'+err);
				}
			});
			
		} else {
			$n2.log('Do not know how to handle help information');
			$elem.attr('n2_error','Do not know how to handle help information');
		};

		function installHelpButton(){
			
			var $a = $('<a class="nunaliit_module_help_button" href="#"></a>');
			$a.text( _loc('Help') );
			
			$('#'+_this.helpButtonName)
				.empty()
				.append($a);
			
			$a.click(function(){
				var $btn = $(this);
				
				$n2.help.ToggleHelp('main', $btn);

				return false;
			});
		};
	}
});

$n2.couchModule = {
	ModuleDisplay: ModuleDisplay
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchNavigation.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2){
"use strict";

var 
	_loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
	,DH = 'n2.couchNavigation'
	;

//=========================================================================
function setNavElementAsCurrentModule($elem){
	$elem.addClass('n2_nav_currentModule');
	$elem.parents('.n2nav_setChildModuleCurrent').addClass('n2_nav_childModuleCurrent');
};
	
//=========================================================================	
var NavigationDisplay = $n2.Class({
	
	dispatchService: null,
	
	showService: null,
	
	navigationDoc: null,
	
	elemId: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,showService: null
			,navigationDoc: null
			,elem: null
		},opts_);
		
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.navigationDoc = opts.navigationDoc;
		
		var $elem = $(opts.elem);
		this.elemId = $n2.utils.getElementIdentifier($elem);
		
		this._display();
	},
	
	_display: function(){
		var $nav = $('#'+this.elemId);
		var doc = this.navigationDoc;
		
		if( this.navigationDoc 
		 && this.navigationDoc.nunaliit_navigation 
		 && $nav.length > 0 ){
			// Get current module identifier
			var msg = {
				type: 'moduleGetCurrent'
			};
			this.dispatchService.synchronousCall(DH,msg);
			var currentModuleId = msg.moduleId;

			// Navigation menu
			$nav.empty();
			
			if( doc.nunaliit_navigation.items 
			 && doc.nunaliit_navigation.items.length > 0 ) {
				var $ul = $('<ul>')
					.addClass('n2nav_setChildModuleCurrent')
					.appendTo($nav);
				
				insertItems($ul, doc.nunaliit_navigation.items, currentModuleId);
			};
			
			if( this.showService ){
				this.showService.fixElementAndChildren($nav);
			};
		};
		
		function insertItems($ul, items, currentModuleId){
			for(var i=0,e=items.length; i<e; ++i){
				var item = items[i];
				
				var $li = $('<li>')
					.addClass('n2nav_setChildModuleCurrent')
					.appendTo($ul);
				
				if( item.key ){
					$li.attr('n2nav-key',item.key);
				};

				if( item.title && item.href ) {
					// Compute module class
					var moduleId = null;
					var url = new $n2.url.Url({
						url: item.href
					});
					if( url ){
						moduleId = url.getParamValue('module',null);
					};
					if( moduleId ){
						$li.attr('n2nav-module',moduleId);
						$li.addClass('n2nav_setModuleCurrent');
					};
					
					if( moduleId && moduleId === currentModuleId ){
						setNavElementAsCurrentModule($li);
					};
					
					var title = _loc(item.title);
					$('<a>')
						.attr('href',item.href)
						.text(title)
						.appendTo($li);
					
				} else if( item.module ) {
						// Compute URL based on current one
					var currentUrl = $n2.url.getCurrentLocation();
					var moduleUrl = currentUrl
						.clone()
						.setHash(null)
						.setParamValue('module',item.module);
				
					// Install module class
					$li.attr('n2nav-module',item.module);
					$li.addClass('n2nav_setModuleCurrent');
					
					if( item.module === currentModuleId ){
						setNavElementAsCurrentModule($li);
					};
					
					var $a = $('<a>')
						.attr('href',moduleUrl.getUrl())
						.appendTo($li);

					if( item.title ){
						var title = _loc(item.title);
						$a.text(title);
					} else {
						// Obtain title from show service
						$a.attr('nunaliit-document',item.module);
						$a.addClass('n2s_insertModuleName');
						$a.text(item.module);
					};
						
				} else if( item.title ) {
					var $span = $('<span></span>');
					var title = _loc(item.title);
					$span.text(title);
					$li.append($span);
				};
				
				if( item.items && item.items.length > 0 ){
					var $innerUl = $('<ul>')
						.addClass('n2nav_setChildModuleCurrent')
						.appendTo($li);
					insertItems($innerUl, item.items, currentModuleId);
				};
			};
		};
	}
});
	
//=========================================================================	
var NavigationService = $n2.Class({
	
	dispatchService: null,
	
	showService: null,
	
	documentSource: null,
	
	currentNavigationDoc: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,showService: null
			,documentSource: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.showService = opts.showService;
		this.documentSource = opts.documentSource;

		// dispatcher
		var d = this.dispatchService;
		if( d ){
			var f = function(m, addr, d){
				_this._handle(m, addr, d);
			};
			
			d.register(DH,'reportModuleDocument',f);
			d.register(DH,'navigationGetCurrent',f);
			d.register(DH,'showPreprocessElement',f);
		};
	},
	
	setCurrentNavigation: function(opts_){
		var opts = $n2.extend({
			docId: null
			,doc: null
		},opts_);
		
		var _this = this;
		
		if( opts.doc 
		 && opts.doc.nunaliit_navigation ){
			this.navigationDoc = opts.doc;
			
			this._fixElements($('body'), this.navigationDoc);
			
			if( this.dispatchService ){
				this.dispatchService.send(DH, {
					type: 'navigationReportCurrent'
					,navigationId: this.navigationDoc._id
					,navigationDoc: this.navigationDoc
				});
			};
			
		} else if( opts.docId ){
			if( this.documentSource ){
				this.documentSource.getDocument({
					docId: opts.docId
					,onSuccess: function(doc){
						_this.setCurrentNavigation({
							doc: doc
						});
					}
				});
			};
		};
	},
	
	printTitle: function(opts_){
		var opts = $n2.extend({
			elem: null
		},opts_);
		
		var $elem = $(opts.elem).addClass('n2nav_insertTitle');
		
		this._fixElements($elem, this.navigationDoc);
	},
	
	printMenu: function(opts_){
		var opts = $n2.extend({
			elem: null
		},opts_);
		
		var $elem = $(opts.elem).addClass('n2nav_insertMenu');
		
		this._fixElements($elem, this.navigationDoc);
	},
	
	_fixElements: function($root, navigationDoc){
		if( !navigationDoc ) return;

		var _this = this;
		
		var $set = $root.find('*').addBack();
		
		// Title
		$set.filter('.n2nav_insertTitle').each(function(){
			var $elem = $(this);
			$elem.removeClass('n2nav_insertTitle').addClass('n2nav_insertedTitle');
			_this._insertTitle($elem, navigationDoc);
		});
		
		// Menu
		$set.filter('.n2nav_insertMenu').each(function(){
			var $elem = $(this);
			$elem.removeClass('n2nav_insertMenu').addClass('n2nav_insertedMenu');
			_this._insertMenu($elem, navigationDoc);
		});
	},
	
	_insertTitle: function($elem, doc){

		var docId = this._associateDocumentToElement(doc, $elem);
		
		if( doc && docId === doc._id ){
			var title = undefined;
			if( doc.nunaliit_navigation ) {
				title = doc.nunaliit_navigation.title;
			};
			if( title ){
				$elem.text( _loc(title) );
			} else {
				$elem.empty();
			};
		};
	},
	
	_insertMenu: function($elem, doc){

		var docId = this._associateDocumentToElement(doc, $elem);
		
		if( doc && docId === doc._id ){
			new NavigationDisplay({
				dispatchService: this.dispatchService
				,showService: this.showService
				,navigationDoc: doc
				,elem: $elem
			});
		};
	},

	_associateDocumentToElement: function(doc, $elem){
		var docId = $elem.attr('nunaliit-document');

		if( !docId 
		 && doc ) {
			if( doc.nunaliit_navigation ){
				docId = doc._id;
			} else {
				docId = this.navigationDoc._id;
			};
		} else if( !docId && !doc ) {
			 docId = this.navigationDoc._id;
		};

		var associated = $elem.hasClass('n2show_documentAssociated');
		
		if( docId && !associated ){
			$elem.attr('nunaliit-document', docId);
			$elem.addClass('n2show_documentAssociated');

			// Ready to receive updates
			var updateClass = 'n2show_documentUpdate_' + $n2.utils.stringToHtmlId(docId);
			$elem.addClass(updateClass);
			
			if( doc && doc._id === docId ){
				// Already have document
			} else {
				// Ready to receive content
				var contentClass = 'n2show_documentContent_' + $n2.utils.stringToHtmlId(docId);
				$elem.addClass(contentClass);

				// Request this document
				this.dispatchService.send(DH,{
					type: 'requestDocument'
					,docId: docId
				});
			};
		};
		
		return docId;
	},
	
	_handle: function(m, addr, d){
		if( 'reportModuleDocument' === m.type ){
			var currentModuleId = m.moduleId;
			$('.n2nav_setModuleCurrent').removeClass('n2_nav_currentModule');
			$('.n2nav_setChildModuleCurrent').removeClass('n2_nav_childModuleCurrent');
			$('.n2nav_setModuleCurrent').each(function(){
				var $elem = $(this);
				var moduleId = $elem.attr('n2nav-module');
				if( moduleId && moduleId === currentModuleId ){
					setNavElementAsCurrentModule($elem);
				};
			});

		} else if( 'navigationGetCurrent' === m.type ){
			// Synchronous call
			if( this.navigationDoc ){
				m.navigationId = this.navigationDoc._id;
				m.navigationDoc = this.navigationDoc;
			};

		} else if( 'showPreprocessElement' === m.type ){
			var $elem = m.elem;
			var doc = m.doc;
			this._fixElements($elem, doc);
		};
	}
});

$n2.couchNavigation = {
	NavigationService: NavigationService
	,NavigationDisplay: NavigationDisplay
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchExport.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); };

// =========================================================================
var ExportApplication = $n2.Class('ExportApplication',{
	
	exportService: null,

	atlasDb: null,

	atlasDesign: null,
	
	config: null,
	
	logger: null,
	
	docIds: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			exportService: null
			,atlasDb: null
			,atlasDesign: null
			,config: null
			,logger: null
			,docIds: null
			,docs: null
		},opts_);

		var _this = this;
		
		this.exportService = opts.exportService;
		this.atlasDb = opts.atlasDb;
		this.atlasDesign = opts.atlasDesign;
		this.config = opts.config;
		this.logger = opts.logger;

		// Accumulate docs and doc ids
		this.docIds = [];
		if( $n2.isArray(opts.docIds) ){
			opts.docIds.forEach(function(docId){
				_this.docIds.push(docId);
			});
		};
		if( $n2.isArray(opts.docs) ){
			opts.docs.forEach(function(doc){
				_this.docIds.push(doc);
			});
		};
		
		if( !this.exportService ){
			throw new Error('In ExportApplication, export service must be supplied');
		} else {
			this.exportService.checkAvailable({
				onAvailable: function(){
					_this._getExportSettings();
				}
				,onNotAvailable: function(){
					_this._reportError( _loc('Export service is not available') );
				}
			});
		};
	},
	
	_reportError: function(message, title){
		new $n2.couchDialogs.AlertDialog({
			title: title ? title : _loc('Export Error')
			,message: message
		});
	},
	
	_logError: function(err){
		if( this.logger ){
			this.logger.reportError(err);
		};
	},
	
	_getExportSettings: function(){
		var _this = this;

		var knownScriptById = {};
		var currentScript = 'function(opts){\n\tvar config = opts.config;\n\tvar doc = opts.doc;\n\tif( doc ){\n\t\tvar record = { _id: doc._id, _geometry: doc._id };\n\t\topts.addRecord(record);\n\t};\n\topts.next();\n}';

		var dialogId = $n2.getUniqueId();
		var $dialog = $('<div id="'+dialogId+'"></div>');

		$('<div>')
			.text( _loc('Exporting') )
			.appendTo($dialog);

		// Method
		var methodId = $n2.getUniqueId();
		var $methodDiv = $('<div>')
			.appendTo($dialog);
		$('<label>')
			.text( _loc('Script:') )
			.attr('for',filterId)
			.appendTo($methodDiv);
		var $methodSelect = $('<select>')
			.attr('id',methodId)
			.appendTo($methodDiv)
			.change(methodChanged);
		$('<option>')
			.val('__custom__')
			.text( _loc('Custom Script') )
			.appendTo($methodSelect);
		
		// Filter
		var filterId = $n2.getUniqueId();
		var $filterDiv = $('<div>')
			.appendTo($dialog);
		$('<label>')
			.text( _loc('Filter:') )
			.attr('for',filterId)
			.appendTo($filterDiv);
		var $filterSelect = $('<select>')
			.attr('id',filterId)
			.appendTo($filterDiv);
		$('<option value="all"></options>')
			.text( _loc('All Geometries') )
			.appendTo($filterSelect);
		$('<option value="points"></options>')
			.text( _loc('Only Point Geometries') )
			.appendTo($filterSelect);
		$('<option value="linestrings"></options>')
			.text( _loc('Only LineString Geometries') )
			.appendTo($filterSelect);
		$('<option value="polygons"></options>')
			.text( _loc('Only Polygon Geometries') )
			.appendTo($filterSelect);

		// Format
		var formatId = $n2.getUniqueId();
		var $formatDiv = $('<div>')
			.appendTo($dialog);
		$('<label>')
			.text( _loc('Format:') )
			.attr('for',formatId)
			.appendTo($formatDiv);
		var $formatSelect = $('<select>')
			.attr('id',formatId)
			.appendTo($formatDiv)
			.change(formatChanged);
		$('<option value="geojson"></options>')
			.text( _loc('geojson') )
			.appendTo($formatSelect);
		$('<option value="csv"></options>')
			.text( _loc('CSV') )
			.appendTo($formatSelect);
		
		// File name
		var fileNameId = $n2.getUniqueId();
		var $fileNameDiv = $('<div>')
			.appendTo($dialog);
		$('<label>')
			.text( _loc('File Name:') )
			.attr('for',fileNameId)
			.appendTo($fileNameDiv);
		$('<input>')
			.attr('type','text')
			.attr('id',fileNameId)
			.addClass('n2_export_fileNameInput')
			.val('export.geojson')
			.appendTo($dialog);
		
		// Script text area
		var scriptAreaId = $n2.getUniqueId();
		var scriptDisplayId = $n2.getUniqueId();
		var $scriptDiv = $('<div>')
			.appendTo($dialog);
		$('<label>')
			.text( _loc('Script:') )
			.attr('for',scriptAreaId)
			.appendTo($scriptDiv);
		$('<textarea>')
			.attr('id',scriptAreaId)
			.addClass('n2_export_scriptArea')
			.appendTo($scriptDiv);
		$('<div>')
			.attr('id',scriptDisplayId)
			.addClass('n2_export_scriptDisplay')
			.appendTo($scriptDiv);

		var $btnLine = $('<div>')
			.appendTo($dialog);
		$('<button>')
			.text( _loc('Export') )
			.appendTo($btnLine)
			.click(function(){
				var filter = $('#'+filterId).val();
				var format = $('#'+formatId).val();
				
				var fileName = $('#'+fileNameId).val();
				if( '' === fileName ) {
					fileName = null;
				};
				
				var scriptText = $('#'+scriptAreaId).val();
				
				$dialog.dialog('close');
				_this._performExportScript({
					filter: filter
					,fileName: fileName
					,format: format
					,script: scriptText
				});
				return false;
			});
		
		var dialogOptions = {
			autoOpen: true
			,title: _loc('Export')
			,modal: true
			,width: 550
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$dialog.dialog(dialogOptions);
		
		formatChanged();
		methodChanged();
		
		// Load up known scripts for export
		if( this.atlasDesign ){
			this.atlasDesign.queryView({
				viewName: 'nunaliit-script'
				,include_docs: true
				,onSuccess: function(rows){
					rows.forEach(function(row){
						var $sel = $('#'+methodId);

						var scriptDoc = row.doc;
						if( scriptDoc 
						 && scriptDoc.nunaliit_script 
						 && scriptDoc.nunaliit_script.type === 'export' 
						 && scriptDoc.nunaliit_script.script ){
							var label = undefined;
							if( scriptDoc.nunaliit_script.label ){
								label = _loc(scriptDoc.nunaliit_script.label);
							} else {
								label = scriptDoc.nunaliit_script.name;
							};
							if( !label ){
								label = scriptDoc._id;
							};
							
							$('<option>')
								.val(scriptDoc._id)
								.text( label )
								.appendTo($sel);

							knownScriptById[scriptDoc._id] = scriptDoc.nunaliit_script.script;
						};
					});
				}
				,onError: function(err){
					var errMessage = _loc('Unable to obtain list of export scripts')+': '+err;
					_this._reportError(errMessage);
					_this._logError(errMessage);
				}
			});
		};
		
		function formatChanged(){
			var extension = $('#'+formatId).val();
			var name = $('#'+fileNameId).val();
			var i = name.lastIndexOf('.');
			if( i >= 0 ){
				name = name.substr(0,i);
			};
			name = name + '.' + extension;
			$('#'+fileNameId).val(name);
		};
		
		function methodChanged(){
			var method = $('#'+methodId).val();

			var scriptText = knownScriptById[method];
			if( scriptText ){
				currentScript = scriptText;
			};

			var $scriptArea = $('#'+scriptAreaId);
			var $scriptDisplay = $('#'+scriptDisplayId);
			
			$scriptArea.text(currentScript);
			$scriptDisplay.text(currentScript);
			
			if( '__custom__' === method ){
				$scriptArea
					.removeAttr('disabled')
					.css('display','');
				$scriptDisplay
					.css('display','none');
			} else {
				$scriptArea
					.attr('disabled','disabled')
					.css('display','none');
				$scriptDisplay
					.css('display','');
			};
			
			return true;
		};
	},
	
	_performExportScript: function(opts_){
		var opts = $n2.extend({
			filter: 'all'
			,fileName: 'export'
			,format: 'geojson'
			,script: null
		},opts_);
		
		var _this = this;
		
		if( typeof opts.script !== 'string' ){
			throw new Error('Script is not a string');
		};
		
		// Initialize with all doc ids
		var docIdsRemaining = [];
		for(var i=0,e=this.docIds.length; i<e; ++i){
			docIdsRemaining.push( this.docIds[i] );
		};
		var totalCount = docIdsRemaining.length;
		var processedCount = 0;
		var errorCount = 0;
		var opCancelled = false;
		var records = [];
		
		// Create a copy of the configuration so that user
		// can save temporary objects to it
		var my_scriptConfig = $n2.extend({},this.config);

		// Compile script
		var scriptFn = null;
		//$n2.log('Script',opts.script);
		try {
			scriptFn = eval('('+opts.script+');');
		} catch(e) {
			this._reportError(_loc('Error')+': '+e);
			this._logError('Unable to evaluate script: '+e,opts.script);
			return;
		};
		if( typeof(scriptFn) !== 'function' ) {
			this._reportError( _loc('You must enter a valid function') );
			return;
		};
		
		var progressDialog = new $n2.couchDialogs.ProgressDialog({
			title: _loc('Compiling records')
			,onCancelFn: function(){
				opCancelled = true;
			}
		});
		
		processNextDocument();
		
		function processNextDocument(){
			if( opCancelled ) {
				cancel();
				return;
			};

			if(docIdsRemaining.length < 1){
				progressDialog.updateHtmlMessage('<span>100%</span>');

				// Do not include document to indicate that the export
				// is completed. This allows the script to perform record
				// operations before performing export
				scriptFn({
					config: my_scriptConfig
					,addRecord: addRecord
					,next: onFinish
				});
				
				
			} else {
				if( totalCount ) {
					var percent = Math.floor((processedCount) * 100 / totalCount);
					var html = ['<div>'];
					html.push('<span>Percent: '+percent+'%</span><br/>');
					html.push('<span>Processed: '+processedCount+'</span><br/>');
					html.push('<span>Error: '+errorCount+'</span><br/>');
					html.push('</div>');
					progressDialog.updateHtmlMessage( html.join('') );
				} else {
					progressDialog.updateHtmlMessage('<span>0%</span>');
				};
				
				var docId = docIdsRemaining.pop();
				if( typeof docId === 'string' ){
					_this.atlasDb.getDocument({
						docId: docId
						,onSuccess: retrievedDocument
						,onError: function(err){
							var locStr = _loc('Failure to fetch {docId}',{
								docId: docId
							});
							_this._logError(locStr);
							errorCount += 1;
							processNextDocument();
						}
					});
				} else if( typeof docId === 'object' ){
					// This is the document. Use setTimeout to save running out of stack
					window.setTimeout(function(){
						retrievedDocument(docId);
					},0);

				} else {
					window.setTimeout(function(){
						_this._logError(_loc('Invalid document'));
						errorCount += 1;
						processNextDocument();
					},0);
				};
			};
		};
		
		function retrievedDocument(doc){
			if( opCancelled ) {
				cancel();
				return;
			};

			scriptFn({
				doc: doc
				,config: my_scriptConfig
				,addRecord: addRecord
				,next: next
			});
		};
		
		function addRecord(record){
			records.push(record);
		};
		
		function next(){
			processedCount += 1;

			processNextDocument();
		};

		function onFinish(){
			progressDialog.updateHtmlMessage('<span>Sending records to server</span>');
			
			// Open a new window to get results
			// open('about:blank', windowId);
			var windowId = $n2.getUniqueId();
			$('<iframe>')
				.attr('name',windowId)
				.attr('src','javascript:false')
				.css({
					visibility: 'hidden'
					,display: 'none'
				})
				.appendTo( $('body') );
			
			_this.exportService.exportByRecords({
				records: records
				,targetWindow: windowId
				,filter: opts.filter
				,contentType: 'application/binary'
				,fileName: opts.fileName
				,format: opts.format
				,onError: function(err){
					alert(_loc('Error during export')+': '+err);
				}
			});

			progressDialog.close();
			
			new $n2.couchDialogs.AlertDialog({
				title: _loc('Warning')
				,message: _loc('Please, wait until download starts. It might take a while.')
			});
		};
		
		function cancel(){
			_this._logError(_loc('Operation cancelled by user'));
			progressDialog.close();
		};
	}
});

//=========================================================================
var ExportService = $n2.Class('ExportService',{
	
	serverUrl: null,
	
	atlasDb: null,

	atlasDesign: null,

	config: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			url: null
			,atlasDb: null
			,atlasDesign: null
			,config: null
		},opts_);
		
		this.serverUrl = opts.url;
		this.atlasDb = opts.atlasDb;
		this.atlasDesign = opts.atlasDesign;
		this.config = opts.config;
	},

	checkAvailable: function(opts_){
		var opts = $n2.extend({
			onAvailable: function(){}
			,onNotAvailable: function(){}
		},opts_);
		
		if( !this.serverUrl ){
			opts.onNotAvailable();
			return;
		};
		
		$.ajax({
			url: this.serverUrl+'welcome'
			,type: 'GET'
			,dataType: 'json'
			,success: function(data, textStatus, jqXHR){
				if( data && data.ok ) {
					opts.onAvailable(data);
				} else {
					opts.onNotAvailable();
				};
			}
			,error: function(jqXHR, textStatus, errorThrown){
				opts.onNotAvailable();
			}
		});
	},
	
	createExportApplication: function(opts_){
		var opts = $n2.extend({
			docIds: null
			,atlasDb: this.atlasDb
			,atlasDesign: this.atlasDesign
			,config: this.config
			,logger: null
		}, opts_);
		
		opts.exportService = this;
		
		return new ExportApplication(opts);
	},
	
	exportByRecords: function(opts_){
		var opts = $n2.extend({
			records: null
			,targetWindow: null
			,contentType: null
			,fileName: null
			,format: null
			,onError: $n2.reportError
		},opts_);
		
		if( !$n2.isArray(opts.records) ) {
			throw new Error('records must be provided as an array when exporting by records');
		};
		
		var url = this.serverUrl + 'records/';
		if( opts.fileName ){
			url = url + opts.fileName;
		} else {
			url = url + 'export';
		};
		var $form = $('<form>')
			.attr('action',url)
			.attr('method','POST')
			.attr('enctype','multipart/form-data')
			.css({
				display: 'none'
				,visibility: 'hidden'
			});

		// Target window
		if( opts.targetWindow ){
			$form.attr('target',opts.targetWindow);
		};
		
		if( opts.contentType ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','contentType')
				.val(opts.contentType)
				.appendTo($form);
		};

		if( opts.filter ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','filter')
				.val(opts.filter)
				.appendTo($form);
		} else {
			$('<input>')
				.attr('type','hidden')
				.attr('name','filter')
				.val('all')
				.appendTo($form);
		};

		if( opts.format ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','format')
				.val(opts.format)
				.appendTo($form);
		} else {
			$('<input>')
				.attr('type','hidden')
				.attr('name','format')
				.val('geojson')
				.appendTo($form);
		};
		
		// Data
		$('<input type="hidden" name="data"></input>')
			.val( JSON.stringify(opts.records) )
			.appendTo($form);

		$('body').append($form);
		
		$form.submit();
	},
	
	exportByDocIds: function(opts_){
		var opts = $n2.extend({
			docIds: null
			,targetWindow: null
			,filter: 'all'
			,contentType: null
			,fileName: null
			,format: null
			,onError: $n2.reportError
		},opts_);
		
		if( !opts.docIds ) {
			onError('docIds must be provided when exporting by docIds');
		};
		
		var url = this.serverUrl + 'definition/';
		if( opts.fileName ){
			url = url + opts.fileName;
		} else {
			url = url + 'export';
		};
		var $form = $('<form>')
			.attr('action',url)
			.attr('method','POST')
			.css({
				display: 'none'
				,visibility: 'hidden'
			});

		// Target window
		if( opts.targetWindow ){
			$form.attr('target',opts.targetWindow);
		};
		
		$('<input type="hidden" name="method" value="doc-id"></input>').appendTo($form);

		if( opts.contentType ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','contentType')
				.val(opts.contentType)
				.appendTo($form);
		};

		if( opts.filter ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','filter')
				.val(opts.filter)
				.appendTo($form);
		} else {
			$('<input>')
				.attr('type','hidden')
				.attr('name','filter')
				.val('all')
				.appendTo($form);
		};

		if( opts.format ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','format')
				.val(opts.format)
				.appendTo($form);
		} else {
			$('<input>')
				.attr('type','hidden')
				.attr('name','format')
				.val('geojson')
				.appendTo($form);
		};
		
		for(var i=0,e=opts.docIds.length; i<e; ++i){
			var docId = opts.docIds[i];
			$('<input type="hidden" name="name"></input>')
				.val(docId)
				.appendTo($form);
		};
		
		$('body').append($form);
		
		$form.submit();
	},
	
	exportBySchemaName: function(opts_){
		var opts = $n2.extend({
			schemaName: null
			,targetWindow: null
			,filter: 'all'
			,contentType: null
			,fileName: null
			,format: null
			,onError: $n2.reportError
		},opts_);
		
		if( !opts.schemaName ) {
			opts.onError('schemaName must be provided when exporting by schema name');
		};
		
		opts.docIds = undefined;
		opts.layerId = undefined;

		if( opts.targetWindow ){
			this._exportByForm(opts);
		} else {
			this._exportByAjax(opts);
		};
	},
	
	exportByLayerId: function(opts_){
		var opts = $n2.extend({
			layerId: null
			,targetWindow: null
			,filter: 'all'
			,contentType: null
			,fileName: null
			,format: null
			,onError: $n2.reportError
		},opts_);
		
		if( !opts.layerId ) {
			opts.onError('layerId must be provided when exporting by layer identifier');
		};
		
		opts.docIds = undefined;
		opts.schemaName = undefined;

		if( opts.targetWindow ){
			this._exportByForm(opts);
		} else {
			this._exportByAjax(opts);
		};
	},
	
	_exportByForm: function(opts_){
		var opts = $n2.extend({
			docIds: null
			,schemaName: null
			,layerId: null
			,targetWindow: null
			,filter: 'all'
			,contentType: 'application/binary'
			,fileName: null
			,format: null
			,onError: $n2.reportError
		},opts_);
		
		var url = this.serverUrl + 'export/definition/';
		if( opts.fileName ){
			url = url + opts.fileName;
		} else {
			url = url + 'export';
		};
		var $form = $('<form>')
			.attr('action',url)
			.attr('method','POST')
			.css({
				display: 'none'
				,visibility: 'hidden'
			});

		// Target window
		if( opts.targetWindow ){
			$form.attr('target',opts.targetWindow);
		};

		if( opts.docIds ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','method')
				.attr('value','doc-id')
				.appendTo($form);

			for(var i=0,e=opts.docIds.length; i<e; ++i){
				var docId = opts.docIds[i];
				$('<input>')
					.attr('type','hidden')
					.attr('name','name')
					.val(docId)
					.appendTo($form);
			};

		} else if( opts.schemaName ) {
			$('<input>')
				.attr('type','hidden')
				.attr('name','method')
				.attr('value','schema')
				.appendTo($form);
			$('<input>')
				.attr('type','hidden')
				.attr('name','name')
				.val(opts.schemaName)
				.appendTo($form);

		} else if( opts.layerId ) {
			$('<input>')
				.attr('type','hidden')
				.attr('name','method')
				.attr('value','layer')
				.appendTo($form);
			$('<input>')
				.attr('type','hidden')
				.attr('name','name')
				.val(opts.layerId)
				.appendTo($form);

		} else {
			opts.onError('Unrecognized export method');
		};

		if( opts.contentType ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','contentType')
				.val(opts.contentType)
				.appendTo($form);
		};

		if( opts.filter ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','filter')
				.val(opts.filter)
				.appendTo($form);
		} else {
			$('<input>')
				.attr('type','hidden')
				.attr('name','filter')
				.val('all')
				.appendTo($form);
		};

		if( opts.format ){
			$('<input>')
				.attr('type','hidden')
				.attr('name','format')
				.val(opts.format)
				.appendTo($form);
		} else {
			$('<input>')
				.attr('type','hidden')
				.attr('name','format')
				.val('geojson')
				.appendTo($form);
		};
		
		$('body').append($form);
		
		$form.submit();
	},
	
	_exportByAjax: function(opts_){
		var opts = $n2.extend({
			docIds: null
			,schemaName: null
			,layerId: null
			,filter: 'all'
			,format: null
			,onSuccess: function(result){}
			,onError: $n2.reportError
		},opts_);
		
		var url = this.serverUrl + 'export/definition/export';

		var data = {};
		if( opts.docIds ){
			data.method = 'doc-id';
			data.name = opts.docIds;

		} else if( opts.schemaName ) {
			data.method = 'schema';
			data.name = opts.schemaName;

		} else if( opts.layerId ) {
			data.method = 'layer';
			data.name = opts.layerId;

		} else {
			opts.onError('Unrecognized export method');
		};

		if( opts.contentType ){
			data.contentType = 'text/plain';
		};

		if( opts.filter ){
			data.filter = opts.filter;
		} else {
			data.filter = 'all';
		};

		if( opts.format ){
			data.format = opts.format;
		} else {
			data.format = 'geojson';
		};
		
		$.ajax({
			url: url
			,type: 'POST'
			,data: data
			,traditional: true
			,dataType: 'text'
			,success: function(res, textStatus, jqXHR){
				opts.onSuccess(res);
			}
			,error: function(jqXHR, textStatus, httpError){
				var error = $n2.utils.parseHttpJsonError(jqXHR,textStatus);
				opts.onError(error.error,error);
			}
		});
	}
});
	
$n2.couchExport = {
	ExportService: ExportService
	,ExportApplication: ExportApplication
};

})(jQuery,nunaliit2);
// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDispatchSupport.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
,DH = 'n2.couchDispatchSupport'
;

var DispatchSupport = $n2.Class('DispatchSupport',{
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		if( this.dispatchService ) {
			var f = function(m){
				_this._handleDispatch(m);
			};
			
			this.dispatchService.register(DH, 'editClosed', f);
		};
		
		// Window resize event
		$(window).resize(function() {
			_this._windowResized();
		});
	},

	_handleDispatch: function(m){
		if( 'editClosed' === m.type ) {
//			var dispatcher = this.dispatchService;
//			if( dispatcher ) {
//				if( m.deleted ) {
//					dispatcher.send(DH,{
//						type: 'unselected'
//					});
//				} else if( m.cancelled ) {
//					dispatcher.send(DH,{
//						type: 'historyBack'
//					});
//				} else {
//					dispatcher.send(DH,{
//						type: 'selected'
//						,docId: m.doc._id
//						,doc: m.doc
//					});
//				};
//			};
		};
	},

	_windowResized: function(){
		var d = this.dispatchService;
		if( d ){
			d.send(DH,{
				type: 'windowResized'
			});
		};
	}
});

$n2.couchDispatchSupport = {
	DispatchSupport: DispatchSupport
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchEvents.js

/*
Copyright (c) 2012, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };
var DH = 'n2.couchEvents';

//==========================================================
/*
 * This is an abstract class. An instance of this class allows an atlas designer 
 * to change the default behaviour associated with user selections and focus. 
 * Because the logic of focus translation is closely related to pop-ups found in canvas,
 * this class also deals with modifying the default content found in pop-ups.
 * 
 * Since this is an abstract class, its default behaviour does nothing worth noticing:
 * - it translates the event 'userSelect' to 'selected'; and, 
 * - it translates the event 'userFocusOn' to 'focusOn'.
 * 
 * To take advantage of the logic provided by this class, an atlas designer should
 * subclass this class and re-implement the following methods:
 * - translateUserSelection (required)
 * - generatePopupHtmlFromDocuments (optional)
 *
 * To use this logic, an atlas designer should create a new instance of this class (really,
 * a subclass) within the configuration function in nunaliit_custom.js. The abstract logic
 * has the ability of installing itself in the right locations.
 */
var SelectionRedirector = $n2.Class('SelectionRedirector',{

	dispatchService: null,
	
	eventService: null,
	
	atlasDb: null,

	customService: null,

	showService: null,
	
	originalEventHandler: null,
	
	currentSelectionNumber: null,
	
	currentFocusNumber: null,
	
	popupMaxLines: null,

	/**
	 * If set, when a selection translation returns empty,
	 * then do not send an empty selection. Simply ignore.
	 */
	suppressEmptySelection: null,

	/**
	 * By default, if a selection translation returns empty, then
	 * focus event is not sent. If this is set, force the focus event.
	 */
	forceEmptyFocus: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,eventService: null
			,atlasDb: null
			,customService: null
			,showService: null
			,popupMaxLines: 12
			,suppressEmptySelection: false
			,forceEmptyFocus: false
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.eventService = opts.eventService;
		this.atlasDb = opts.atlasDb;
		this.customService = opts.customService;
		this.showService = opts.showService;
		this.popupMaxLines = opts.popupMaxLines;
		
		this.suppressEmptySelection = false;
		if( opts.suppressEmptySelection ){
			this.suppressEmptySelection = true;
		};
		
		this.forceEmptyFocus = false;
		if( opts.forceEmptyFocus ){
			this.forceEmptyFocus = true;
		};
		
		if( !this.dispatchService ){
			throw new Error('SelectionRedirector requires dispatchService');
		};
		if( !this.eventService ){
			throw new Error('SelectionRedirector requires eventService');
		};
		if( !this.atlasDb ){
			throw new Error('SelectionRedirector requires atlasDb');
		};
		
		// Keep track of current selection
		this.currentSelectionNumber = 0;
		this.currentFocusNumber = 0;
		
		// Install on event service
		this.originalEventHandler = this.eventService.getHandler();
		this.eventService.register('userSelect');
		this.eventService.register('userFocusOn');
		this.eventService.setHandler(function(m, addr, dispatcher){
			_this._handleEvent(m, addr, dispatcher);
		});
		
		// Install map pop-up replacement
		if( this.customService && this.showService ){
			this.customService.setOption('mapFeaturePopupCallback', function(opts_){
				_this._handleMapFeaturePopup(opts_);
			});
		};
	},
	
	_retrieveDocuments: function(opts_){
		var opts = $n2.extend({
			docId: null
			,docIds: null
			,doc: null
			,docs: null
			,onSuccess: function(docs){}
			,onError: function(err){}
		}, opts_);
		
		var _this = this;
		
		if( opts.doc ){
			opts.onSuccess([opts.doc]);

		} else if( opts.docs ){
			opts.onSuccess( opts.docs );

		} else if( opts.docId ){
			retrieveDocumentFromIds([opts.docId]);

		} else if( opts.docIds ){
			retrieveDocumentFromIds(opts.docIds);
		};
		
		function retrieveDocumentFromIds(docIds){
			// Look up cache
			var docs = [];
			var missingDocIds = [];
			docIds.forEach(function(docId){
				var doc = undefined;
				
				if( _this.dispatchService ){
					var m = {
						type: 'cacheRetrieveDocument'
						,docId: docId
					};
					_this.dispatchService.synchronousCall(DH,m);
					doc = m.doc;
				};
				
				if( doc ){
					docs.push(doc);
				} else {
					missingDocIds.push(docId);
				};
			});

			if( missingDocIds.length < 1 ){
				// Got everything from cache
				opts.onSuccess(docs);
			} else {
				// Need to get documents from database
				_this.atlasDb.getDocuments({
					docIds: missingDocIds
					,onSuccess: function(missingDocs){
						missingDocs.forEach(function(doc){
							docs.push(doc);
						});
						opts.onSuccess(docs);
					}
					,onError: function(errorMsg){
						opts.onError(errorMsg);
					}
				});
			};
		};
	},
	
	_handleUserSelect: function(m, addr, dispatcher, selectionNumber){
		var _this = this;

		this._getDocumentsFromSelectedDocument({
			docId: m.docId
			,docIds: m.docIds
			,doc: m.doc
			,docs: m.docs
			,isSelect: true
			,onSuccess: function(selectedDocs, supplementDocIds){
				if( selectionNumber === _this.currentSelectionNumber ){
					var msg = {};
					
					// Copy attributes from original message
					for(var name in m){
						var value = m[name];
						msg[name] = value;
					};
					
					if( selectedDocs.length > 1 ){
						delete msg.docId;
						delete msg.docIds;
						delete msg.doc;
						delete msg.docs;

						msg.type = 'selected';
						msg.docIds = [];
						msg.docs = [];
						for(var i=0,e=selectedDocs.length; i<e; ++i){
							var doc = selectedDocs[i];
							msg.docs.push(doc);
							msg.docIds.push(doc._id);
						};
						_this.dispatchService.send(DH,msg);

					} else if ( selectedDocs.length > 0 ){
						delete msg.docId;
						delete msg.docIds;
						delete msg.doc;
						delete msg.docs;

						msg.type = 'selected';
						msg.doc = selectedDocs[0];
						msg.docId = selectedDocs[0]._id;
						_this.dispatchService.send(DH,msg);

					} else {
						// At this point, no document was found associated with
						// the initial selection. By default, simply continue with 
						// selection.
						if( _this.suppressEmptySelection ){
							// ignore
						} else {
							msg.type = 'selected';
							_this.dispatchService.send(DH,msg);
						};
					};
					
					if( supplementDocIds && selectedDocs.length > 0 ){
						supplementDocIds.forEach(function(supplementDocId){
							_this.dispatchService.send(DH,{
								type: 'selectedSupplement'
								,docId: supplementDocId
								,origin: selectedDocs[0]._id
							});
						});
					};
				};
			}
			,onError: function(err){
				// On error, perform default behaviour
				if( selectionNumber === _this.currentSelectionNumber ){
					this._performOriginalHandler(m, addr, dispatcher);
				};
			}
		});
	},
	
	_handleUserFocus: function(m, addr, dispatcher, focusNumber){
		var _this = this;

		this._getDocumentsFromSelectedDocument({
			docId: m.docId
			,docIds: m.docIds
			,doc: m.doc
			,docs: m.docs
			,isFocus: true
			,onSuccess: function(selectedDocs, supplementDocIds){
				if( focusNumber === _this.currentFocusNumber ){
					var msg = {};
					
					// Copy attributes from original message
					for(var name in m){
						var value = m[name];
						msg[name] = value;
					};

					if( selectedDocs.length > 1 ){
						delete msg.docId;
						delete msg.docIds;
						delete msg.doc;
						delete msg.docs;

						msg.type = 'focusOn';
						msg.docIds = [];
						msg.docs = [];
						for(var i=0,e=selectedDocs.length; i<e; ++i){
							var doc = selectedDocs[i];
							msg.docs.push(doc);
							msg.docIds.push(doc._id);
						};
						_this.dispatchService.send(DH,msg);

					} else if ( selectedDocs.length > 0 ){
						delete msg.docId;
						delete msg.docIds;
						delete msg.doc;
						delete msg.docs;

						msg.type = 'focusOn';
						msg.doc = selectedDocs[0];
						msg.docId = selectedDocs[0]._id;
						_this.dispatchService.send(DH,msg);

					} else {
						// At this point, no document was found associated
						// with the focus. By default, ignore.
						if( _this.forceEmptyFocus ){
							msg.type = 'focusOn';
							_this.dispatchService.send(DH,msg);
						};
					};
					
					if( supplementDocIds && selectedDocs.length > 0 ){
						supplementDocIds.forEach(function(supplementDocId){
							_this.dispatchService.send(DH,{
								type: 'focusOnSupplement'
								,docId: supplementDocId
								,origin: selectedDocs[0]._id
							});
						});
					};
				};
			}
			,onError: function(err){
				// On error, perform default behaviour
				if( focusNumber === _this.currentFocusNumber ){
					this._performOriginalHandler(m, addr, dispatcher);
				};
			}
		});
	},
	
	_getDocumentsFromSelectedDocument: function(opts_){
		var opts = $n2.extend({
			docId: null
			,docIds: null
			,doc: null
			,docs: null
			,isSelect: false
			,isFocus: false
			,onSuccess: function(selectedDocs, supplementDocids){}
			,onError: function(err){}
		},opts_);

		var _this = this;

		this._retrieveDocuments({
			docId: opts.docId
			,docIds: opts.docIds
			,doc: opts.doc
			,docs: opts.docs
			,onSuccess: function(docs){
				
				_this.translateUserSelection({
					docs: docs
					,isSelect: opts.isSelect
					,isFocus: opts.isFocus
					,onSuccess: opts.onSuccess
					,onError: opts.onError
				});
			}
			,onError: function(err){
				// On error, continue with original selection
				$n2.log('Error while retrieving selected documents',err);
				opts.onError(err);
			}
		});
	},

	/*
	 * This is the work horse of the class. It defines the translation of selecting
	 * a document into another one.
	 * 
	 * Basically, this methods accepts a number of documents (full document contents)
	 * and must return a number of documents that should be selected instead of the
	 * ones given in argument. Optionally, a number of supplemental document identifiers
	 * can be provided in the results.
	 * 
	 * Supplemental selection/focus are useful to colour elements in a canvas to draw attention
	 * to it given a selection.
	 * 
	 * For example, if an atlas is built in such a way that a geometry is drawn on a map
	 * representing a place, but a number of names are associated with that geometry. In that
	 * atlas, when the geometry is clicked, the atlas designer wants the associated name
	 * documents to be selected. Also, when a name document is selected, the associated map
	 * geometry is highlighted. In this example, this method should:
	 * 1. when presented with a geometry document, return a list of name documents
	 * 2. when presented with a name document, return the name document and a list of
	 *    supplemental document identifiers that represent the geometries
	 */
	translateUserSelection: function(opts_){
		var opts = $n2.extend({
			docs: null
			,isSelect: false
			,isFocus: false
			,onSuccess: function(selectedDocs, supplementDocids){}
			,onError: function(err){}
		},opts_);

		// Default behaviour is to perform no translation
		opts.onSuccess(opts.docs,[]);
	},
	
	_handleEvent: function(m, addr, dispatcher){
		var eventHandled = false;
		
		if( 'userSelect' === m.type ){
			this.currentSelectionNumber = this.currentSelectionNumber + 1;
			this._handleUserSelect(m, addr, dispatcher, this.currentSelectionNumber);
			eventHandled = true;

		} else if( 'userFocusOn' === m.type ){
			this.currentFocusNumber = this.currentFocusNumber + 1;
			this._handleUserFocus(m, addr, dispatcher, this.currentFocusNumber);
			eventHandled = true;
		};
		
		if( !eventHandled ){
			this._performOriginalHandler(m, addr, dispatcher);
		};
	},
	
	_performOriginalHandler: function(m, addr, dispatcher){
		this.originalEventHandler(m, addr, dispatcher);
	},
	
	_handleMapFeaturePopup: function(opts_){
		var opts = $n2.extend({
			feature: null
			,layerInfo: null
			,onSuccess: function(html){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		var feature = opts.feature;
		
		var selectedDocs = [];
		
		if( feature.cluster ){
			feature.cluster.forEach(function(cf){
				var doc = cf.data;
				if( doc ){
					selectedDocs.push(doc);
				};
			});
		} else {
			var doc = feature.data;
			if( doc ){
				selectedDocs.push(doc);
			};
		};

		this._getDocumentsFromSelectedDocument({
			docs: selectedDocs
			,onSuccess: function(selectedDocs, supplementDocids){
				if( selectedDocs.length > 0 ) {
					showDocs(selectedDocs);
				} else {
					// display the geometry
					showDefault();
				};
			}
			,onError: showDefault // ignore errors
		});

		function showDefault(){
			var $div = $('<div></div>');
			var doc = feature.data;
			_this.showService.displayBriefDescription($div,{},doc);
			var html = $div.html();
			opts.onSuccess(html);
		};
		
		function showDocs(docs){
			var html = _this.generatePopupHtmlFromDocuments(docs);
			opts.onSuccess(html);
		};
	},
	
	generatePopupHtmlFromDocuments: function(docs){
		var _this = this;

		// Now that everything is categorized, print popup
		var maxLines = this.popupMaxLines;
		var $div = $('<div>');

		// Count lines that will be printed
		var numLines = docs.length;
		var numLinesNotPrinted = 0;
		if( numLines > maxLines ){
			--maxLines;
			numLinesNotPrinted = numLines - maxLines;
		};
		
		// Print briefs
		docs.forEach(function(doc){
			if( maxLines > 0 ){
				--maxLines;
				
				var $line = $('<div>')
					.addClass('n2redirect_popup_line n2redirect_popup_doc')
					.appendTo($div);
				_this.showService.displayBriefDescription($line,{},doc);
			};
		});
		
		// Print number of lines not printed
		if( numLinesNotPrinted > 0 ){
			var $line = $('<div>')
				.addClass('n2redirect_popup_line n2redirect_popup_overflow')
				.text( _loc('More lines... ({num})',{num:numLinesNotPrinted}) )
				.appendTo($div);
		};
		
		var html = $div.html();
		return html;
	}
});

//==========================================================
var EventSupport = $n2.Class('EventSupport',{
	options: null

	,dispatchCallback: null
	
	,handler: null
	
	,registeredEvents: null
	
	,initialize: function(opts_){
		this.options = $n2.extend({
			directory: null
		},opts_);
		
		var _this = this;
	
		this.registeredEvents = {};
		
		this.handler = function(m, addr, dispatcher){
			_this._defaultHandler(m, addr, dispatcher);
		};
		
		this.dispatchCallback = function(m, addr, dispatcher){
			_this.handler(m, addr, dispatcher);
		};
		
		this.register('userSelect');
		this.register('userUnselect');
		this.register('userFocusOn');
		this.register('userFocusOff');
	}

	,register: function(type){
		if( !this.registeredEvents[type] ) {
			var d = this._getDispatcher();
			if( d ){
				d.register(DH,type,this.dispatchCallback);
			};
			this.registeredEvents[type] = true;
		};
	}
	
	,setHandler: function(handler){
		if( typeof(handler) === 'function' ){
			this.handler = handler;
		};
	}
	
	,getHandler: function(){
		return this.handler;
	}
	
	,_getDispatcher: function(){
		var d = null;
		if( this.options.directory ){
			d = this.options.directory.dispatchService;
		};
		return d;
	}
	
	,_dispatch: function(m){
		var d = this._getDispatcher();
		if( d ){
			d.send(DH,m);
		};
	}

	,_defaultHandler: function(m, addr, dispatcher){
		if( 'userSelect' === m.type ) {
			var forwardAllowed = true;
			var d = this._getDispatcher();
			if( d ){
				var c = {
					type: 'historyIsHashChangePermitted'
					,permitted: true
				};
				d.synchronousCall(DH,c);
				
				if( !c.permitted ){
					forwardAllowed = false;
				};
			};
			
			if( forwardAllowed ){
				var forward = {
					type:'selected'
				};
				for(var key in m){
					if( 'type' === key ){
						forward.type = 'selected';
					} else {
						forward[key] = m[key];
					};
				};
				this._dispatch(forward);
			} else {
				this._dispatch({
					type:'userSelectCancelled'
				});
			};
			
		} else if( 'userUnselect' === m.type ) {
			var forward = {};
			for(var key in m){
				forward[key] = m[key];
			};
			forward.type = 'unselected';
			this._dispatch(forward);
			
		} else if( 'userFocusOn' === m.type ) {
			this._dispatch({
				type:'focusOn'
				,docId: m.docId
				,doc: m.doc
				,docIds: m.docIds
				,docs: m.docs
				,feature: m.feature
			});
			
		} else if( 'userFocusOff' === m.type ) {
			this._dispatch({
				type:'focusOff'
				,docId: m.docId
				,doc: m.doc
				,docIds: m.docIds
				,docs: m.docs
				,feature: m.feature
			});
		};
	}
});

//==========================================================
$n2.couchEvents = {
	EventSupport: EventSupport
	,SelectionRedirector: SelectionRedirector
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchUser.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

function isKeyEditingAllowed(obj, selectors, data) {
	
	if( !selectors ) return false;
	
	if( selectors[0] === '_id' ) return false;
	if( selectors[0] === '_rev' ) return false;
	
	return true;
}

function isValueEditingAllowed(obj, selectors, data) {
	
	if( !selectors ) return false;

	if( selectors[0] === '_id' ) return false;
	if( selectors[0] === '_rev' ) return false;
	
	return true;
};

function isKeyDeletionAllowed(obj, selectors, data) {
	
	if( !selectors ) return false;

	if( selectors[0] === '_id' ) return false;
	if( selectors[0] === '_rev' ) return false;
	
	return true;
};

function _parseError(XMLHttpRequest, textStatus){
	var err = $n2.utils.parseHttpJsonError(XMLHttpRequest, textStatus);
	if( err.tokenExpired ){
		return _loc('The information is expired.');
	};
	if( err.userUpdated ){
		return _loc('Unable to complete operation because the user information has been updated.');
	};
	return _loc('Unable to complete operation : {err}',{
		err: err.error
	});
};

/*
 * ==============================================================================
 * User Editor
 */
var UserEditor = $n2.Class({
	
	userDoc: null
	
	,userSchema: null
	
	,schemaEditorService: null
	
	,configService: null
	
	,originalDoc: null
	
	,userDb: null
	
	,elemId: null
	
	,schemaEditor: null
	
	,treeEditor: null
	
	,onPreSaveFn: null
	
	,onSavedFn: null

	,onPreDeleteFn: null
	
	,onDeletedFn: null
	
	,onCancelledFn: null
	
	,onFinishedFn: null
	
	,showServerRoles: null
	
	,initialize: function(opts_){
		var opts = $n2.extend({
			userDoc: null
			,userDb: null
			,elem: null
			,elemId: null
			,userSchema: null
			,schemaRepository: null
			,schemaEditorService: null
			,configService: null
			,onPreSaveFn: function(userDoc){ return true; }
			,onSavedFn: function(userDoc){}
			,onPreDeleteFn: function(userDoc){ return true; }
			,onDeletedFn: function(userDoc){}
			,onCancelledFn: function(userDoc){}
			,onFinishedFn: function(userDoc){}
			,showServerRoles: false
		},opts_);
		
		var _this = this;
		
		this.userDoc = opts.userDoc;
		this.userDb = opts.userDb;
		this.onPreSaveFn = opts.onPreSaveFn;
		this.onSavedFn = opts.onSavedFn;
		this.onPreDeleteFn = opts.onPreDeleteFn;
		this.onDeletedFn = opts.onDeletedFn;
		this.onCancelledFn = opts.onCancelledFn;
		this.onFinishedFn = opts.onFinishedFn;
		this.schemaEditorService = opts.schemaEditorService;
		this.configService = opts.configService;
		this.showServerRoles = opts.showServerRoles;
		
		// Keep version of original document
		this.originalDoc = $n2.extend(true,{},this.userDoc);
		
		// Fix user document
		if( !this.userDoc.nunaliit_emails ){
			this.userDoc.nunaliit_emails = [];
		};
		
		// id
		this.elemId = opts.elemId;
		if( opts.elem ){
			var $elem = $(opts.elem);
			var id = $elem.attr('id');
			if( !id ){
				id = $n2.getUniqueId();
				$elem.attr('id',id);
			};
			this.elemId = id;
		};
		
		// User schema
		if( opts.userSchema ){
			userSchemaLoaded(opts.userSchema);
			
		} else if( opts.schemaRepository ){
			opts.schemaRepository.getSchema({
				name: 'user'
				,onSuccess: function(schema){
					userSchemaLoaded(schema);
				}
				,onError: function(){
					userSchemaLoaded(null);
				}
			});

		} else {
			userSchemaLoaded(null);
		};
		
		function userSchemaLoaded(userSchema){
			_this.userSchema = userSchema;
			
			_this._display();
		};
	}

	,documentUpdated: function(){
		this._refresh();
	}

	,_getElem: function(){
		return $('#'+this.elemId);
	}
	
	,_getCouchServer: function(){
		return this.userDb.getServer();
	}

	,_display: function(){
		var _this = this;
		
		var doc = this.userDoc;
		
		var $elem = this._getElem();
		$elem.empty();
		
		var $editor = $('<div class="n2UserEdit_editor"></div>')
			.appendTo($elem);
		
		var $editorsContainer = $('<div class="n2UserEdit_editorContainer"></div>')
			.appendTo($editor);
		
		var usingAccordion = false;
		
		if( this.userSchema && this.schemaEditorService ){
			usingAccordion = true;

			$('<h3><a href="#">'+_loc('Form View')+'</a></h3>').appendTo($editorsContainer);
			var $schemaContainer = $('<div class="n2UserEdit_schemaEditor"></div>')
				.appendTo($editorsContainer);

			this.schemaEditor = this.schemaEditorService.editDocument({
				doc: doc
				,schema: this.userSchema
				,$div: $schemaContainer
				,onChanged: function(){
					if( _this.treeEditor ) {
						_this.treeEditor.refresh();
					};
				}
			});
		};
		
		// Tree editor
		if( usingAccordion ){
			$('<h3><a href="#">'+_loc('Tree View')+'</a></h3>').appendTo($editorsContainer);
		};
		var $treeContainer = $('<div class="n2UserEdit_treeEditor"></div>')
			.appendTo($editorsContainer);
		var objectTree = new $n2.tree.ObjectTree($treeContainer,doc);
		this.treeEditor = new $n2.tree.ObjectTreeEditor(objectTree,doc,{
			onObjectChanged: function() {
				if( _this.schemaEditor ) {
					_this.schemaEditor.refresh();
				};
			}
			,isKeyEditingAllowed: isKeyEditingAllowed
			,isValueEditingAllowed: isValueEditingAllowed
			,isKeyDeletionAllowed: isKeyDeletionAllowed
		});

		if( usingAccordion ){
			$editorsContainer.accordion({
				heightStyle: 'content',
	            autoHeight: false,
		        clearStyle: true	
			});
		};

		var $buttons = $('<div class="n2UserEdit_buttons"></div>')
			.appendTo($editor);

		// Save button
		$('<input type="button"/>')
			.addClass('n2UserEdit_saveButton')
			.val( _loc('Save') )
			.appendTo($buttons)
			.click(function(){
				_this._save();
				return false;
			});

		// Delete button
		$('<input type="button"/>')
			.addClass('n2UserEdit_deleteButton')
			.val( _loc('Delete') )
			.appendTo($buttons)
			.click(function(){
				_this._delete();
				return false;
			});

		// Roles button
		$('<input type="button"/>')
			.addClass('n2UserEdit_rolesButton')
			.val( _loc('Roles') )
			.appendTo($buttons)
			.click(function(e){
				_this._rolesDialog(doc,function(roles){
					if( roles.length > 0 ){
						doc.roles = roles;
					} else if( doc.roles ) {
						delete doc.roles;
					};
					_this.treeEditor.refresh();
				});
				return false;
			});

		// Password button
		$('<input type="button"/>')
			.addClass('n2UserEdit_passwordButton')
			.val( _loc('Set Password') )
			.appendTo($buttons)
			.click(function(e){
				_this._passwordDialog();
				return false;
			});

		// Cancel button
		$('<input type="button"/>')
			.addClass('n2UserEdit_cancelButton')
			.val( _loc('Cancel') )
			.appendTo($buttons)
			.click(function(e){
				_this._cancel();
				return false;
			});
	}
	
	,_refresh: function(){
		this.treeEditor.refresh();
	}
	
	,_rolesDialog: function(userDoc, selectedRolesFn){
		var diagId = $n2.getUniqueId();
		var $rolesDialog = $('<div id="'+diagId+'" class="n2_roles_dialog"></div>');

		$('<div class="n2_roles_list"></div>')
			.appendTo($rolesDialog)
			.append( $('<div class="olkit_wait"></div>') )
			;

		var $buttons = $('<div class="n2_roles_buttons"></div>')
			.appendTo($rolesDialog)
			;

		// OK button
		$('<input type="button"/>')
			.val( _loc('OK') )
			.appendTo($buttons)
			.click(function(){
				var $dialog = $('#'+diagId);
				
				var roles = [];
				$dialog.find('input[type=checkbox]:checked').each(function(){
					var $input = $(this);
					roles.push( $input.attr('name') );
				});
				
				selectedRolesFn(roles);
				
				$dialog.dialog('close');
			})
			;

		// Cancel button
		$('<input type="button"/>')
			.val( _loc('Cancel') )
			.appendTo($buttons)
			.click(function(){
				$('#'+diagId).dialog('close');
			})
			;
		
		var dialogOptions = {
			autoOpen: true
			,title: _loc('Select Roles')
			,modal: true
			,width: 740
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$rolesDialog.dialog(dialogOptions);
		
		if( this.configService
		 && this.showServerRoles ){
			this.configService.getNunaliitServerRoles({
				onSuccess: function(roles){
					loadedRoles(roles);
				}
				,onError: function(err){
					loadedRoles([]);
				}
			});

		} else if( this.configService ){
			this.configService.getAtlasRoles({
				onSuccess: function(roles){
					loadedRoles(roles);
				}
				,onError: function(err){
					loadedRoles([]);
				}
			});
		} else {
			loadedRoles([]);
		};
		
		function loadedRoles(roles){
			var roleMap = {};
			for(var i=0,e=roles.length;i<e;++i){
				roleMap[roles[i]] = false;
			};
			
			if( userDoc.roles ){
				for(var i=0,e=userDoc.roles.length;i<e;++i){
					roleMap[userDoc.roles[i]] = true;
				};
			};
			
			roles = [];
			for(var role in roleMap){
				roles.push(role);
			};
			roles.sort();
			
			var $list = $('#'+diagId).find('.n2_roles_list');
			$list.empty();
			
			for(var i=0,e=roles.length;i<e;++i){
				var role = roles[i];
				
				var $div = $('<div></div>');
				
				var id = $n2.getUniqueId();
				
				var $input = $('<input type="checkbox"/>')
					.attr('name',role)
					.attr('id',id)
					.appendTo($div)
					;
				if( roleMap[role] ){
					$input.attr('checked',"checked");
				};
				
				$('<label/>')
					.attr('for',id)
					.text(role)
					.appendTo($div)
					;
				
				$list.append($div);
			};
		};
	}
	
	,_passwordDialog: function(){
		var _this = this;
		
		var diagId = $n2.getUniqueId();
		var $passwordDialog = $('<div id="'+diagId+'" class="n2User_setPassword_dialog"></div>');

		var $passwordInputs = $('<div class="n2User_setPassword_inputs"></div>')
			.appendTo($passwordDialog);
		
		// Password
		var id = $n2.getUniqueId();
		var $div = $('<div></div>')
			.appendTo($passwordInputs);
		$('<label/>')
			.attr('for',id)
			.text( _loc('Enter password:') )
			.appendTo($div);
		$('<input type="password" name="password"/>')
			.attr('id',id)
			.appendTo($div);

		// Confirm
		var id = $n2.getUniqueId();
		var $div = $('<div></div>')
			.appendTo($passwordInputs);
		$('<label/>')
			.attr('for',id)
			.text( _loc('Confirm password:') )
			.appendTo($div);
		$('<input type="password" name="confirm"/>')
			.attr('id',id)
			.appendTo($div);

		// Buttons
		var $buttons = $('<div class="n2User_setPassword_buttons"></div>')
			.appendTo($passwordDialog);

		// OK button
		$('<input type="button"/>')
			.val( _loc('OK') )
			.appendTo($buttons)
			.click(function(){
				var $dialog = $('#'+diagId);
				
				var pw1 = $dialog.find('input[name=password]').val();
				var pw2 = $dialog.find('input[name=confirm]').val();
				
				if( pw1 != pw2 ) {
					alert( _loc('Passwords do not match') );
				} else if( pw1.length < 6 ) {
					alert( _loc('Password is too short') );
				} else {
					_this.userDb.computeUserPassword({
						userDoc: _this.userDoc
						,password: pw1
						,onSuccess: function() {
							_this._refresh();
							$dialog.dialog('close');
						} 
						,onError: function(errMsg){
							alert( _loc('Unable to set password: ') + errMsg);
						}
					});
				};
			});

		// Cancel button
		$('<input type="button"/>')
			.val( _loc('Cancel') )
			.appendTo($buttons)
			.click(function(){
				$('#'+diagId).dialog('close');
			})
			;
		
		var dialogOptions = {
			autoOpen: true
			,title: _loc('Change Password')
			,modal: true
			,width: 740
			,close: function(event, ui){
				var diag = $(event.target);
				diag.dialog('destroy');
				diag.remove();
			}
		};
		$passwordDialog.dialog(dialogOptions);
	}
	
	,_save: function(){
		var _this = this;
		
		this.onPreSaveFn(this.userDoc);

		this.userDb.updateUser({
			user: this.userDoc
			,onSuccess: function(docInfo) {
				_this.userDoc._rev = docInfo.rev;
				
				_this.originalDoc = $n2.extend(true,{},_this.userDoc);
				
				_this._refresh();
				_this.onSavedFn(_this.userDoc);
				_this.onFinishedFn(_this.userDoc);
			} 
			,onError: function(errMsg) {
				alert( _loc('Unable to save user document: ') + errMsg );
			}
		});
	}
	
	,_delete: function(){
		var _this = this;

		if( false == confirm('You are about delete a user configuration object. Do you wish to proceed?') ) {
			return;
		};
		this.onPreDeleteFn(this.userDoc);
		this.userDb.deleteUser({
			user: this.userDoc
			,onSuccess: function() {
				var $elem = _this._getElem();
				$elem.empty();
				_this.onDeletedFn(_this.userDoc);
				_this.onFinishedFn(_this.userDoc);
			} 
			,onError: function(errMsg) {
				alert( _loc('Unable to delete user document: ') + errMsg );
			}
		});
	}
	
	,_cancel: function(){
		// Check if there are changes
		var patch = patcher.computePatch(this.originalDoc,this.userDoc);
		if( patch ){
			// Document was changed
			if( false == confirm( _loc('Document was modified and changes will be lost. Do you wish to continue?') ) ){
				return;
			};
		};
		
		var $elem = this._getElem();
		$elem.empty();

		this.onCancelledFn(this.userDoc);
		this.onFinishedFn(this.userDoc);
	}
});

/*
 * ==============================================================================
 * User Service
 */
var UserService = $n2.Class({
	
	userDb: null
	
	,userServerUrl: null

	,userSchema: null
	
	,schemaRepository: null
	
	,schemaEditorService: null

	,configService: null
	
	,showServerRoles: null
	
	,initialize: function(opts_){
		var opts = $n2.extend({
			userDb: null
			,userServerUrl: null
			,configService: null
			,userSchema: null // optional
			,schemaRepository: null // optional
			,schemaEditorService: null // optional
			,customService: null // optional
		},opts_);
		
		this.showServerRoles = false;
		
		this.userDb = opts.userDb;
		this.userServerUrl = opts.userServerUrl;
		this.configService = opts.configService;
		this.userSchema = opts.userSchema;
		this.schemaRepository = opts.schemaRepository;
		this.schemaEditorService = opts.schemaEditorService;
		
		if( opts.customService ){
			var showServerRoles = opts.customService.getOption('userShowServerRoles',false);
			if( showServerRoles ){
				this.showServerRoles = true;
			};
		};
	}

	,startEdit: function(opts_){
		var opts = $n2.extend(
			{
				userSchema: this.userSchema
				,schemaRepository: this.schemaRepository
				,schemaEditorService: this.schemaEditorService
				,showServerRoles: this.showServerRoles
			}
			,opts_
			,{
				userDb: this.userDb
				,configService: this.configService
			}
		);
		
		return new UserEditor(opts);
	}

	,initiateUserCreation: function(opts_){
		var opts = $n2.extend({
			emailAddress: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'initUserCreation';
		
		$.ajax({
	    	url: url
	    	,type: 'GET'
	    	,async: true
	    	,traditional: true
	    	,data: {
	    		email: opts.emailAddress
	    	}
	    	,dataType: 'json'
	    	,success: function(result) {
	    		if( result.error ) {
	    			opts.onError(result.error);
	    		} else {
	    			opts.onSuccess(result);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}
	
	,validateUserCreation: function(opts_){
		var opts = $n2.extend({
			token: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'validateUserCreation';
		
		$.ajax({
	    	url: url
	    	,type: 'GET'
	    	,async: true
	    	,traditional: true
	    	,data: {
	    		token: opts.token
	    	}
	    	,dataType: 'json'
	    	,success: function(result) {
	    		if( result.error ) {
	    			opts.onError(result.error);
	    		} else {
	    			opts.onSuccess(result);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}
	
	,completeUserCreation: function(opts_){
		var opts = $n2.extend({
			token: null
			,displayName: null
			,password: null
			,sendEmailPasswordReminder: false
			,userAgreement: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'completeUserCreation';
		
		$.ajax({
	    	url: url
	    	,type: 'POST'
	    	,async: true
	    	,traditional: true
	    	,data: {
	    		token: opts.token
				,display: opts.displayName
				,password: opts.password
				,emailPassword: opts.sendEmailPasswordReminder
				,userAgreement: opts.userAgreement
	    	}
	    	,dataType: 'json'
	    	,success: function(result) {
	    		if( result.error ) {
	    			opts.onError(result.error);
	    		} else {
	    			opts.onSuccess(result);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}

	,initiatePasswordRecovery: function(opts_){
		var opts = $n2.extend({
			emailAddress: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'initPasswordRecovery';
		
		$.ajax({
	    	url: url
	    	,type: 'GET'
	    	,async: true
	    	,traditional: true
	    	,data: {
	    		email: opts.emailAddress
	    	}
	    	,dataType: 'json'
	    	,success: function(result) {
	    		if( result.error ) {
	    			opts.onError(result.error);
	    		} else {
	    			opts.onSuccess(result);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}
	
	,validatePasswordRecovery: function(opts_){
		var opts = $n2.extend({
			token: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'validatePasswordRecovery';
		
		$.ajax({
	    	url: url
	    	,type: 'GET'
	    	,async: true
	    	,traditional: true
	    	,data: {
	    		token: opts.token
	    	}
	    	,dataType: 'json'
	    	,success: function(result) {
	    		if( result.error ) {
	    			opts.onError(result.error);
	    		} else {
	    			opts.onSuccess(result);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}

	,completePasswordRecovery: function(opts_){
		var opts = $n2.extend({
			token: null
			,password: null
			,sendEmailPasswordReminder: false
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'completePasswordRecovery';
		
		$.ajax({
	    	url: url
	    	,type: 'GET'
	    	,async: true
	    	,traditional: true
	    	,data: {
	    		token: opts.token
				,password: opts.password
				,emailPassword: opts.sendEmailPasswordReminder
	    	}
	    	,dataType: 'json'
	    	,success: function(result) {
	    		if( result.error ) {
	    			opts.onError(result.error);
	    		} else {
	    			opts.onSuccess(result);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}

	,generatePassword: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(password){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'generatePassword';
		
		$.ajax({
	    	url: url
	    	,type: 'GET'
	    	,async: true
	    	,traditional: true
	    	,data: {}
	    	,dataType: 'json'
	    	,success: function(result) {
	    		if( result.error ) {
	    			opts.onError(result.error);
	    		} else {
	    			opts.onSuccess(result.password);
	    		};
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}

	,acceptUserAgreement: function(opts_){
		var opts = $n2.extend({
			userAgreement: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var url = this.userServerUrl + 'acceptUserAgreement';
		
		$.ajax({
	    	url: url
	    	,type: 'POST'
	    	,async: true
	    	,traditional: true
	    	,data: {
	    		userAgreement: opts.userAgreement
	    	}
	    	,dataType: 'json'
	    	,success: function(result) {
    			opts.onSuccess();
	    	}
	    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
	    		var err = _parseError(XMLHttpRequest, textStatus);
	    		opts.onError(err);
	    	}
		});
	}
});

$n2.couchUser = {
	UserEditor: UserEditor
	,UserService: UserService
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchHelp.js

/*
Copyright (c) 2013, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };
	
// ============================================================================
var LoadHelpDocument = function(opts_){
	var opts = $n2.extend({
		db: null
		,id: null
		,onSuccess: function(helpDoc){}
		,onError: function(err){}
	},opts_);
	
	if( !opts.db ){
		opts.onError( _loc('A database must be provided') );
	};
	if( !opts.id ){
		opts.onError( _loc('A document identifier must be provided') );
	};
	
	opts.db.getDocument({
		docId: opts.id
		,onSuccess: function(doc){
			if( doc && doc.nunaliit_help ){
				if( 'html' === doc.nunaliit_help.type ){
					opts.onSuccess(doc.nunaliit_help);
					
				} else if( 'text' === doc.nunaliit_help.type ){
					opts.onSuccess(doc.nunaliit_help);
					
				} else if( 'attachment' === doc.nunaliit_help.type ){
					getAttachment(doc);
					
				} else {
					opts.onError( _loc('Unknown type for help document: {docId}',{docId: opts.id}) );
				};
				
			} else {
				opts.onError( _loc('Invalid help document: {docId}',{docId: opts.id}) );
			};
		}
		,onError: function(errorMsg){
			opts.onError( _loc('Unable to access help document: {docId}',{docId: opts.id}) );
		}
	});
	
	function getAttachment(doc){
		
		if( doc.nunaliit_help.attachmentName ){
			var localeStr = $n2.l10n.getStringForLocale(doc.nunaliit_help.attachmentName);
			if( localeStr.str ) {
				var attUrl = opts.db.getAttachmentUrl(doc,localeStr.str);
				
				$.ajax({
			    	url: attUrl
			    	,type: 'get'
			    	,async: true
			    	,success: function(intro) {
			    		var html = intro;
			    		
			    		if( localeStr.fallback ){
			    			var $outer = $('<span class="n2_localized_string n2_localize_fallback"></span>');
			    			$('<span class="n2_localize_fallback_lang"></span>')
			    				.text('('+localeStr.lang+')')
			    				.appendTo($outer);
			    			$('<span></span>')
			    				.html(intro)
			    				.appendTo($outer);
		    				html = $outer.html();
			    		};
			    		
			    		doc.nunaliit_help.type = 'html';
			    		doc.nunaliit_help.content = html;
			    		
			    		opts.onSuccess(doc.nunaliit_help);
			    	}
			    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
						opts.onError( _loc('Error fetching attachment from help document') );
			    	}
				});
				
				// do not trigger error
				return;
			};
		};
		
		opts.onError( _loc('Invalid attachment in help document') );
	};
};

//============================================================================

function InstallHelpDocument(opts_){
	var opts = $n2.extend({
		db: null
		,id: null
		,key: null
		,onSuccess: function(){}
		,onError: function(err){}
	},opts_);
	
	LoadHelpDocument({
		db: opts.db
		,id: opts.id
		,onSuccess: function(helpInfo){
			$n2.help.InstallHelpInfo(opts.key, helpInfo);
			opts.onSuccess();
		}
		,onError: opts.onError
	});
};

// ============================================================================
var CheckBrowserCompliance = function(opts_){
	var opts = $n2.extend({
		db: null
		,helpDocumentId: 'help.browsers'
	},opts_);
	
	var browserInfo = $n2.utils.getBrowserInfo();
	if( browserInfo && browserInfo.browser === 'Explorer' ){
		// Welcome to Microsoft IE. Your mileage might vary.
		if( typeof(browserInfo.version) === 'number' ){
			if( browserInfo.version == 9 || browserInfo.version < 8 ){
				// IE6-7 and IE9 are not supported
				reportUnsupportedBrowser(opts);
			};
		};
	};

	function reportUnsupportedBrowser(opts){
		InstallHelpDocument({
			db: opts.db
			,id: opts.helpDocumentId
			,key: 'browsers'
			,onSuccess: function(){
				$n2.help.ShowHelp('browsers');
			}
			,onError: error
		});
		
		function error(){
			alert( _loc('Your browser is not supported by this web site.') );
		};
	};
};

// ============================================================================
	
$n2.couchHelp = {
	LoadHelpDocument: LoadHelpDocument
	,InstallHelpDocument: InstallHelpDocument
	,CheckBrowserCompliance: CheckBrowserCompliance
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDocument.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
,DH = 'n2.couchDocument'
;

var g_dispatcher;

//*******************************************************
function adjustDocument(doc) {

	// Get user name
	var userName = null;
	if( g_dispatcher ){
		var isLoggedInMsg = {
			type: 'authIsLoggedIn'
		};
		g_dispatcher.synchronousCall(DH,isLoggedInMsg);
		
		var sessionContext = isLoggedInMsg.context;
		if( sessionContext ) {
			userName = sessionContext.name;
		};
	};
	
	// Get now
	var nowTime = (new Date()).getTime();
	
	if( userName ) {
		if( ! doc.nunaliit_created 
		 && ! doc._rev) {
			doc.nunaliit_created = {
				nunaliit_type: 'actionstamp'
				,name: userName
				,time: nowTime
				,action: 'created'
			};
		};
		
		doc.nunaliit_last_updated = {
			nunaliit_type: 'actionstamp'
			,name: userName
			,time: nowTime
			,action: 'updated'
		};
	};
	
	// Fix dates
	var dates = [];
	$n2.couchUtils.extractSpecificType(doc, 'date', dates);
	for(var i=0,e=dates.length; i<e; ++i){
		var d = dates[i];
		if( d.date ) {
			try {
				var dateInt = $n2.date.parseUserDate(d.date);
				d.min = dateInt.min;
				d.max = dateInt.max;
			} catch(e) {
				if( d.min ) delete d.min;
				if( d.max ) delete d.max;
			};
		};
	};
};

//*******************************************************
var Notifier = $n2.Class({

	dispatchService: null,
	
	documentSource: null,
	
	dbChangeNotifier: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			atlasDb: null
			,dispatchService: null
			,documentSource: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.documentSource = opts.documentSource;
		
		if( opts.atlasDb ){
			opts.atlasDb.getChangeNotifier({
				onSuccess: function(notifier){
					_this.dbChangeNotifier = notifier;
					if( _this.dbChangeNotifier ){
						_this.dbChangeNotifier.addListener(function(changes){
							_this._dbChanges(changes);
						});
					};
				}
			});
		};
	},

	_dbChanges: function(changes){
		var _this = this;
		
		$n2.log('update',changes);
		var results = changes.results;
		
		if( this.dispatchService ){
			for(var i=0,e=results.length; i<e; ++i){
				var updateRecord = results[i];
	
				var isAdded = false;
				var latestRev = null;
	
				if(updateRecord.changes) {
					for(var l=0,k=updateRecord.changes.length; l<k; ++l){
						latestRev = updateRecord.changes[l].rev;
						if( latestRev.substr(0,2) === '1-' ) {
							isAdded = true;
						};
					};
				};
				
				if( latestRev ){
					// Send 'documentVersion' before create/update so
					// that caches can invalidate before document is
					// requested
					this.dispatchService.send(DH,{
						type: 'documentVersion'
						,docId: updateRecord.id
						,rev: latestRev
					});
				};
				
				if( updateRecord.deleted ){
					this.dispatchService.send(DH,{
						type: 'documentDeleted'
						,docId: updateRecord.id
					});
					
				} else if( isAdded ){
					this.dispatchService.send(DH,{
						type: 'documentCreated'
						,docId: updateRecord.id
					});

					this.documentSource.getDocument({
						docId: updateRecord.id
						,onSuccess: function(doc){
							_this._docUploaded(doc,true);
						}
					});
					
				} else {
					// Updated
					this.dispatchService.send(DH,{
						type: 'documentUpdated'
						,docId: updateRecord.id
					});

					this.documentSource.getDocument({
						docId: updateRecord.id
						,onSuccess: function(doc){
							_this._docUploaded(doc,false);
						}
					});
				};
			};
		};
	},
	
	_docUploaded: function(doc,created){
		if( this.dispatchService ){
			var type = created ? 'documentContentCreated' : 'documentContentUpdated';

			this.dispatchService.send(DH, {
				type: type
				,docId: doc._id
				,doc: doc
			});
		};
	}
});

// *******************************************************
var CouchDocumentSource = $n2.Class('CouchDocumentSource',$n2.document.DocumentSource, {
	
	db: null,
	
	designDoc: null,
	
	dispatchService: null,
	
	attachmentService: null,
	
	geometryRepository: null,
	
	isDefaultDocumentSource: null,
	
	notifier: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
				id: null
				,db: null
				,dispatchService: null
				,attachmentService: null
				,isDefaultDocumentSource: false
			}
			,opts_
		);
		
		var _this = this;
		
		$n2.document.DocumentSource.prototype.initialize.call(this,opts);

		this.db = opts.db;
		this.attachmentService = opts.attachmentService;
		this.dispatchService = opts.dispatchService;
		if( this.dispatchService ){
			// to make adjustDocument() work
			g_dispatcher = this.dispatchService;
		};
		this.isDefaultDocumentSource = opts.isDefaultDocumentSource;
		
		this.designDoc = this.db.getDesignDoc({ddName:'atlas'});
		
		this.geometryRepository = new GeometryRepository({
			db: this.db
			,designDoc: this.designDoc
			,dispatchService: this.dispatchService
		});
		
		if( this.dispatchService ){
			var f = function(m, addr, d){
				_this._handle(m, addr, d);
			};
			
			this.dispatchService.register(DH,'documentSourceFromDocument',f);
		};
		
		this.notifier = new Notifier({
			atlasDb: this.db
			,dispatchService: this.dispatchService
			,documentSource: this
		});
	},

	adoptDocument: function(doc){
		doc.__n2Source = this.getId();
	},

	createDocument: function(opts_){
		var opts = $n2.extend({
				doc: {}
				,onSuccess: function(doc){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,opts_
		);
		
		var _this = this;

		var doc = opts.doc;

		adjustDocument(doc);

		this.db.createDocument({
			data: doc
			,onSuccess: function(docInfo){
				doc._id = docInfo.id;
				doc._rev = docInfo.rev;
				
				_this.adoptDocument(doc);
				
				_this._dispatch({
					type: 'documentVersion'
					,docId: docInfo.id
					,rev: docInfo.rev
				});
				_this._dispatch({
					type: 'documentCreated'
					,docId: docInfo.id
				});
				_this._dispatch({
					type: 'documentContentCreated'
					,docId: doc._id
					,doc: doc
				});
				
				opts.onSuccess(doc);
			}
			,onError: opts.onError
		});
	},

	getDocument: function(opts_){
		var opts = $n2.extend({
				docId: null
				,rev: null
				,revs_info: false
				,revisions: false
				,conflicts: false
				,deleted_conflicts: false
				,onSuccess: function(doc){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		var _this = this;
		
		this.db.getDocument({
			docId: opts.docId
			,rev: opts.rev
			,revs_info: opts.revs_info
			,revisions: opts.revisions
			,conflicts: opts.conflicts
			,deleted_conflicts: opts.deleted_conflicts
			,onSuccess: function(doc){
				_this.adoptDocument(doc);
				opts.onSuccess(doc);
			}
			,onError: opts.onError
		});
	},

	getDocuments: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,onSuccess: function(docs){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		var _this = this;
		
		this.db.getDocuments({
			docIds: opts.docIds
			,onSuccess: function(docs){
				for(var i=0,e=docs.length; i<e; ++i){
					var doc = docs[i];
					_this.adoptDocument(doc);
				};
				opts.onSuccess(docs);
			}
			,onError: opts.onError
		});
	},

	getDocumentAttachments: function(doc){
		return this.attachmentService.getAttachments(doc, this);
	},

	getDocumentAttachment: function(doc, attachmentName){
		return this.attachmentService.getAttachment(doc, attachmentName, this);
	},

	getDocumentAttachmentUrl: function(doc, attachmentName){
		return this.db.getAttachmentUrl(doc, attachmentName);
	},

	verifyDocumentExistence: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,onSuccess: function(info){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		var docIds = opts.docIds;
		
		this.db.getDocumentRevisions({
			docIds: docIds
			,onSuccess: function(info){
				var result = {};
				for(var id in info){
					result[id] = {
						rev: info[id]
					};
				};
				
				opts.onSuccess(result);
			}
			,onError: opts.onError
		});
	},

	updateDocument: function(opts_){
		var opts = $n2.extend({
				doc: null
				,originalDoc: null // Optional. Needed in case of conflict
				,onSuccess: function(doc){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		var _this = this;

		var doc = opts.doc;

		adjustDocument(doc);

		var copy = {};
		for(var key in doc){
			if( key === '__n2Source' ){
				// Do not copy
			} else {
				copy[key] = doc[key];
			};
		};
		
		this.db.updateDocument({
			data: copy
			,onSuccess: updateSuccess
			,onError: function(err){
				// Check if this is a conflict error. If so, attempt to deal with
				// the conflict if the caller provided an original document
				if( opts.originalDoc 
				 && $n2.error.checkErrorCondition(err, 'couchDb_conflict') ){
					loadConflictingDocument(true);
				} else {
					updateFailure(err);
				};
			}
		});
		
		function loadConflictingDocument(retryAllowed){
			_this.db.getDocument({
				docId: doc._id
				,skipCache: true
				,onSuccess: function(conflictingDoc) {
					patchConflictingDocument(conflictingDoc, retryAllowed);
				}
				,onError: function(cause){
					var err = $n2.error.fromString( 
						_loc('Unable to reload conflicting document')
						,cause
					);
					updateFailure(err);
				}
			});
		};
		
		function patchConflictingDocument(conflictingDoc, retryAllowed){
			var patch = patcher.computePatch(opts.originalDoc,doc);
			
			$n2.log('Conflict detected. Applying patch.',patch);
			
			// Apply patch to conflicting document
			patcher.applyPatch(conflictingDoc, patch);
			
			// If the patch contains changes to the geometry, then we must
			// erase the "simplified" structure in the geometry since
			// it needs to be recomputed by the server
			if( patch.nunaliit_geom 
			 && conflictingDoc.nunaliit_geom 
			 && conflictingDoc.nunaliit_geom.simplified ){
				delete conflictingDoc.nunaliit_geom.simplified;
			};

			// Attempt to update the patched document
			_this.db.updateDocument({
				data: conflictingDoc
				,onSuccess: updateSuccess
				,onError: function(err){
					if( retryAllowed 
					 && $n2.error.checkErrorCondition(err, 'couchDb_conflict') ){
						// We have two conflicts in a row. Assume we are sitting
						// behind a bad proxy server.
						$n2.couch.setBadProxy(true);
						$n2.debug.setBadProxy(true);

						$n2.log('Assuming that operations are behind a bad proxy');
						
						// Retry one last time
						loadConflictingDocument(false);
					} else {
						updateFailure(err);
					};
				}
			});
		};
		
		function updateSuccess(docInfo){
			doc._id = docInfo.id;
			doc._rev = docInfo.rev;
			
			_this.adoptDocument(doc);

			_this._dispatch({
				type: 'documentVersion'
				,docId: docInfo.id
				,rev: docInfo.rev
			});
			_this._dispatch({
				type: 'documentUpdated'
				,docId: docInfo.id
			});
			_this._dispatch({
				type: 'documentContentUpdated'
				,docId: doc._id
				,doc: doc
			});
			
			opts.onSuccess(doc);
		};
		
		function updateFailure(cause){
			var err = $n2.error.fromString(
				_loc('Error while updating document {id}',{id:doc._id})
				,cause
			);
			opts.onError(err);
		};
	},

	deleteDocument: function(opts_){
		var opts = $n2.extend({
				doc: null
				,onSuccess: function(){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,opts_
		);
		
		var _this = this;

		var doc = opts.doc;
		var copy = {};
		for(var key in doc){
			if( key === '__n2Source' ){
				// Do not copy
			} else {
				copy[key] = doc[key];
			};
		};
		
		this.db.deleteDocument({
			data: copy
			,onSuccess: documentDeleted
			,onError: function(err){
				// Check if this error is due to a database conflict
				if( $n2.error.checkErrorCondition(err, 'couchDb_conflict') ){
					$n2.log('Conflict document detected during deletion');
					reloadAndDelete(true);
				} else {
					deletionFailure(err);
				};
			}
		});
		
		function reloadAndDelete(retry){
			_this.db.getDocument({
				docId: doc._id
				,onSuccess: function(conflictingDoc) {
					// Delete latest revision
					_this.db.deleteDocument({
						data: conflictingDoc
						,onSuccess: documentDeleted
						,onError: function(err){
							if( retry 
							 && $n2.error.checkErrorCondition(err, 'couchDb_conflict') ){
								$n2.log('Conflict document detected during deletion');
								// We have two conflicts in a row. Assume we are sitting
								// behind a bad proxy server.
								$n2.couch.setBadProxy(true);
								$n2.debug.setBadProxy(true);

								$n2.log('Assuming that operations are behind a bad proxy');
								
								// Retry one last time
								reloadAndDelete(false);
							} else {
								deletionFailure(err);
							};
						}
					});
				}
				,onError: function(err2){
					var e = $n2.error.fromString(
						_loc('Error reloading conflicting document during deletion')
						,err2
					);
					opts.onError(e);
				}
			});
		};
		
		function documentDeleted(){
			_this._dispatch({
				type: 'documentDeleted'
				,docId: doc._id
			});
			opts.onSuccess();
		};
		
		function deletionFailure(err){
			var e = $n2.error.fromString(
				_loc('Unable to delete document {id}',{
					id: doc._id
				})
				,err
			);
			opts.onError(e);
		};
	},

	getLayerDefinitions: function(opts_){
		var opts = $n2.extend({
				layerIds: null
				,fullDocuments: false
				,onSuccess: function(layerDefinitions){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		var keys = undefined;
		if( opts.layerIds ){
			keys = [];
			opts.layerIds.forEach(function(layerId){
				keys.push(layerId);
			});
		};
		
		this.designDoc.queryView({
			viewName: 'layer-definitions'
			,include_docs: true
			,keys: keys
			,onSuccess: function(rows){
				var layerIdentifiers = [];
				for(var i=0,e=rows.length;i<e;++i){
					var doc = rows[i].doc;
					if( opts.fullDocuments ){
						layerIdentifiers.push(doc);
					} else if( doc.nunaliit_layer_definition ){
						var d = doc.nunaliit_layer_definition;
						if( !d.id ){
							d.id = doc._id;
						};
						layerIdentifiers.push(d);
					};
				};
				opts.onSuccess(layerIdentifiers);
			}
			,onError: opts.onError
		});
	},

	getDocumentInfoFromIds: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,onSuccess: function(docInfos){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		this.designDoc.queryView({
			viewName: 'info'
			,keys: opts.docIds
			,onSuccess: function(rows){
				var infos = [];
				for(var i=0,e=rows.length;i<e;++i){
					infos.push(rows[i].value);
				};
				opts.onSuccess(infos);
			}
			,onError: opts.onError
		});
	},

	getReferencesFromId: function(opts_){
		var opts = $n2.extend({
				docId: null
				,onSuccess: function(referenceIds){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		this.designDoc.queryView({
			viewName: 'link-references'
			,startkey: opts.docId
			,endkey: opts.docId
			,onSuccess: function(rows){
				var refIdMap = {};
				for(var i=0,e=rows.length;i<e;++i){
					refIdMap[rows[i].id] = true;
				};
				
				var refIds = [];
				for(var refId in refIdMap){
					refIds.push(refId);
				};
				opts.onSuccess(refIds);
			}
			,onError: opts.onError
		});
	},

	getProductFromId: function(opts_){
		var opts = $n2.extend({
				docId: null
				,onSuccess: function(referenceIds){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		this.designDoc.queryView({
			viewName: 'nunaliit-source'
			,startkey: opts.docId
			,endkey: opts.docId
			,onSuccess: function(rows){
				var refIdMap = {};
				for(var i=0,e=rows.length;i<e;++i){
					refIdMap[rows[i].id] = true;
				};
				
				var refIds = [];
				for(var refId in refIdMap){
					refIds.push(refId);
				};
				opts.onSuccess(refIds);
			}
			,onError: opts.onError
		});
	},

	getDocumentsFromGeographicFilter: function(opts_){
		var opts = $n2.extend({
			docIds: null
			,layerId: null
			,bbox: null
			,projectionCode: null
			,onSuccess: function(docs){}
			,onError: function(errorMsg){}
		},opts_);
		
		var _this = this;
		
		// Intercept onSuccess to apply __n2Source attribute
		var callerSuccess = opts.onSuccess;
		opts.onSuccess = function(docs){
			for(var i=0,e=docs.length; i<e; ++i){
				var doc = docs[i];
				_this.adoptDocument(doc);
			};
			callerSuccess(docs);
		};
		
		this.geometryRepository.getDocumentsFromGeographicFilter(opts);
	},

	getGeographicBoundingBox: function(opts_){
		this.geometryRepository.getGeographicBoundingBox(opts_);
	},

	getReferencesFromOrigin: function(opts_){
		var opts = $n2.extend({
				docId: null
				,onSuccess: function(originReferenceIds){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		this.designDoc.queryView({
			viewName: 'nunaliit-origin'
			,startkey: opts.docId
			,endkey: opts.docId
			,onSuccess: function(rows){
				var refIdMap = {};
				for(var i=0,e=rows.length;i<e;++i){
					refIdMap[rows[i].id] = true;
				};
				
				var refIds = [];
				for(var refId in refIdMap){
					refIds.push(refId);
				};
				opts.onSuccess(refIds);
			}
			,onError: opts.onError
		});
	},
	
	/*
	 * This needs to be a global unique identifier. It is not a sufficient
	 * guarantee if the identifier is unique within a session. Therefore, it
	 * should be based on the database which can track between sessions.
	 */
	getUniqueIdentifier: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(uuid){}
			,onError: function(errorMsg){}
		},opts_);
		
		var server = this.db.getServer();
		
		server.getUniqueId(opts);
	},
	
	_dispatch: function(m){
		if( this.dispatchService ){
			this.dispatchService.send(DH,m);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'documentSourceFromDocument' === m.type ){
			var doc = m.doc;
			if( doc && doc.__n2Source === this.getId() ){
				m.documentSource = this;
			} else if( doc 
			 && !doc.__n2Source 
			 && this.isDefaultDocumentSource ){
				m.documentSource = this;
			};
		};
	}
});

//*******************************************************

var GeometryRepository = $n2.Class('GeometryRepository',{
	
	db: null,
	
	designDoc: null,
	
	dispatchService: null,
	
	dbProjection: null,
	
	poles: null, // cache the poles in various projections
	
	mapProjectionMaxWidth: null, // cache max width computation
	
	initialize: function(opts_){
		var opts = $n2.extend({
			db: null
			,designDoc: null
			,dispatchService: null
		},opts_);
		
		this.db = opts.db;
		this.designDoc = opts.designDoc;
		this.dispatchService = opts.dispatchService;
		
		this.dbProjection = new OpenLayers.Projection('EPSG:4326');
		
		// Set-up caches
		this.poles = {
			n:{}
			,s:{}
		};
		this.mapProjectionMaxWidth = {};
	},
	
	getDocumentsFromGeographicFilter: function(opts_){
		var opts = $n2.extend({
				docIds: null
				,layerId: null
				,bbox: null
				,projectionCode: null
				,onSuccess: function(docs){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
	
		var _this = this;
		
		var viewQuery = {
			viewName: 'geom'
			,onSuccess: handleDocs
			,onError: opts.onError
		};
		
		// Add BBOX tiling
		var bounds = opts.bbox;
		var fids = opts.docIds;
		var layerName = ('string' === typeof(opts.layerId) ? opts.layerId : null);
		
		if( bounds 
		 && opts.projectionCode 
		 && opts.projectionCode != this.dbProjection.getCode() ){
			var mapProjection = new OpenLayers.Projection(opts.projectionCode);
			
			var mapBounds = new OpenLayers.Bounds(bounds[0],bounds[1],bounds[2],bounds[3]);
			var dbBounds = mapBounds.clone().transform(mapProjection, this.dbProjection);
			
			// Verify if north pole is included
			var np = this._getPole(true, mapProjection);
			if( np 
			 && mapBounds.contains(np.x,np.y) ){
				var northBoundary = new OpenLayers.Bounds(-180, 90, 180, 90);
				dbBounds.extend(northBoundary);
			};
			
			// Verify if south pole is included
			var sp = this._getPole(false, mapProjection);
			if( sp 
			 && mapBounds.contains(sp.x,sp.y) ){
				var southBoundary = new OpenLayers.Bounds(-180, -90, 180, -90);
				dbBounds.extend(southBoundary);
			};
			
			bounds = [dbBounds.left,dbBounds.bottom,dbBounds.right,dbBounds.top];
			
			var maxWidth = this._getMapMaxWidth(mapProjection);
			if( maxWidth 
			 && maxWidth <= (mapBounds.right - mapBounds.left) ){
				// Assume maximum database bounds (do not wrap around)
				bounds[0] = -180;
				bounds[2] = 180;
			};
		};
	
		// Switch view name and add keys for bounds, layer name and feature ids
		$n2.couchGeom.selectTileViewFromBounds(viewQuery, bounds, layerName, fids);
		
		this.designDoc.queryView(viewQuery);
		
		function handleDocs(rows){

	    	var docIds = [];
	    	var docs = [];
	    	while( rows.length > 0 ){
	    		var row = rows.pop();
	    		var docId = row.id;
	    		
	    		if( _this.dispatchService ) {
	    			var m = {
	    				type: 'cacheRetrieveDocument'
	    				,docId: docId
	    				,doc: null
	    			};
	    			_this.dispatchService.synchronousCall(DH, m);
	    			if( m.doc ){
	    				docs.push(m.doc);
	    			} else {
	    				// must request
	    				docIds.push(docId);
	    			};
	    		} else {
	        		docIds.push(docId);
	    		};
	    	};
	    	
	    	if( docIds.length > 0 ) {

	        	_this.db.getDocuments({
	    			docIds: docIds
	    			,onSuccess: function(docs_){
	    				for(var i=0,e=docs_.length; i<e; ++i){
	    					docs.push(docs_[i]);
	    				};
	    				opts.onSuccess(docs);
	    			}
	        		,onError: opts.onError
	        	});
	    	} else {
	    		// nothing to request
	    		opts.onSuccess(docs);
	    	};
		};
	},

	getGeographicBoundingBox: function(opts_){
		var opts = $n2.extend({
				layerId: null
				,bbox: null
				,onSuccess: function(bbox){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		this.designDoc.queryView({
			viewName: 'geom-layer-bbox'
			,startkey: opts.layerId
			,endkey: opts.layerId
			,onlyRows: true
			,reduce: true
			,onSuccess: function(rows){
				if( rows.length > 0 ) {
					opts.onSuccess(rows[0].value);
				} else {
					opts.onSuccess(null);
				};
			}
			,onError: opts.onError
		});
	},

	_getPole: function(isNorth, mapProjection){
		
		var projCode = mapProjection.getCode();
		
		var label = isNorth ? 'n' : 's';
		if( this.poles[label][projCode] ) return this.poles[label][projCode];
		
		if( isNorth ){
			var p = new OpenLayers.Geometry.Point(0,90);
		} else {
			var p = new OpenLayers.Geometry.Point(0,-90);
		};
		
		// Catch transform errors
		var error = false;
		var previousFn = null;
		if( typeof(Proj4js) !== 'undefined' ){
			previousFn = Proj4js.reportError;
			Proj4js.reportError = function(m){
				error = true;
			};
		};
		
		p.transform(this.dbProjection,mapProjection);
		
		if( error ){
			p = null;
		};
		
		// Re-instate normal error reporting
		if( previousFn ){
			Proj4js.reportError = previousFn;
		};
		
		this.poles[label][projCode] = p;
		
		return p;
	},
	
    _getMapMaxWidth: function(proj){
		
		var projCode = proj.getCode();
    	
    	if( this.mapProjectionMaxWidth[projCode] ){
    		return this.mapProjectionMaxWidth[projCode];
    	};
    	
    	if( proj
    	 && proj.proj 
    	 && proj.proj.projName === 'merc' ){
        	var w = new OpenLayers.Geometry.Point(-180,0);
       		var e = new OpenLayers.Geometry.Point(180,0);

       		// Catch transform errors
        	var error = false;
        	var previousFn = null;
        	if( typeof(Proj4js) !== 'undefined' ){
        		previousFn = Proj4js.reportError;
        		Proj4js.reportError = function(m){
        			error = true;
        		};
        	};
        	
        	w.transform(this.dbProjection,proj);
        	e.transform(this.dbProjection,proj);
        	
        	if( error ){
        		w = null;
        		e = null;
        	};

        	// Re-instate normal error reporting
        	if( previousFn ){
        		Proj4js.reportError = previousFn;
        	};
        	
        	if( e && w ){
        		this.mapProjectionMaxWidth[projCode] = w.x - e.x;
        	};
    	};
    	
    	return this.mapProjectionMaxWidth[projCode];
    }
});

//*******************************************************
var CouchDocumentSourceWithSubmissionDb = $n2.Class('CouchDocumentSourceWithSubmissionDb', CouchDocumentSource, {
	
	submissionDb: null,
	
	submissionServerUrl: null,
	
	submissionServerDb: null,
	
	isSubmissionDataSource: null,
	
	deviceId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			submissionDb: null
			,submissionServletUrl: null
			,deviceId: undefined
		},opts_);
		
		CouchDocumentSource.prototype.initialize.call(this,opts);

		var _this = this;
		
		this.isSubmissionDataSource = true;
		
		this.submissionDb = opts.submissionDb;
		this.submissionServerUrl = opts.submissionServerUrl;
		this.deviceId = opts.deviceId;
		
		var submissionServer = $n2.couch.getServer({
			pathToServer: this.submissionServerUrl
			,skipSessionInitialization: true
			,userDbName: '_users'
			,onSuccess: function(server){
				_this.submissionServerDb = server.getDb({
					dbName: 'submissionDb'
				});
			}
			,onError: function(err){
				$n2.log("Unable to initialize submission server",err);
				alert( _loc('Unable to initialize submission database') );
			}
		});
		
	},
	
	/*
	 * When creating a document, send a submission request
	 */
	createDocument: function(opts_){
		var opts = $n2.extend({
				doc: {}
				,onSuccess: function(doc){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,opts_
		);
		
		var _this = this;
		
		if( !opts.doc ){
			opts.onError('Document must be provided');
		};

		// Compute document id
		if( opts.doc._id ){
			onUuidComputed(opts.doc._id);
		} else {
			var server = this.db.getServer();
			if( server ){
				server.getUniqueId({
					onSuccess: onUuidComputed
					,onError: opts.onError
				});
			} else {
				opts.onError('No server associated with database');
			};
		};
		
		function onUuidComputed(docId){
			// create a submission request
			var doc = opts.doc;
			doc._id = docId;
			
			adjustDocument(doc);

			_this.submissionServerDb.createDocument({
				data: doc
				,deviceId: _this.deviceId
				,onSuccess: function(docInfo){
					_this._warnUser();
					_this.adoptDocument(doc);
					opts.onSuccess(doc);
				}
				,onError: opts.onError
			});
		};
	},

	/*
	 * When updating a document, make a submission request
	 */
	updateDocument: function(opts_){
		var opts = $n2.extend({
				doc: null
				,onSuccess: function(doc){}
				,onError: function(errorMsg){}
			}
			,opts_
		);
		
		var _this = this;
		
		var doc = opts.doc;
		
		adjustDocument(doc);
		
		var copy = {};
		for(var key in doc){
			if( key === '__n2Source' ){
				// Do not copy
			} else {
				copy[key] = doc[key];
			};
		};
		
		this.submissionServerDb.updateDocument({
			data: copy
			,deviceId: _this.deviceId
			,onSuccess: function(docInfo){
				_this._warnUser();
				opts.onSuccess(doc);
			}
			,onError: opts.onError
		});
	},

	/*
	 * When deleting a document, make a submission request
	 */
	deleteDocument: function(opts_){
		var opts = $n2.extend({
				doc: null
				,onSuccess: function(){}
				,onError: function(errorMsg){ $n2.reportErrorForced(errorMsg); }
			}
			,opts_
		);
		
		var _this = this;
		
		var doc = opts.doc;
		
		this.submissionServerDb.deleteDocument({
			data: doc
			,deviceId: _this.deviceId
			,onSuccess: function(docInfo){
				_this._warnUser();
				opts.onSuccess(doc);
			}
			,onError: opts.onError
		});
	},
	
	_warnUser: function(){
		var shouldWarnUser = true;
		var c = $n2.cookie.getCookie('nunaliit_submissions');
		if( c ){
			shouldWarnUser = false;
		};
		
		if( shouldWarnUser ){
			var diagId = $n2.getUniqueId();
			var $diag = $('<div>')
				.attr('id',diagId)
				.addClass('n2_submission_warning_dialog');

			var $text = $('<div>')
				.addClass('n2_submission_warning_text')
				.appendTo($diag);
			
			$('<span>')
				.text( _loc('Submissions to the database will not appear until they are approved') )
				.appendTo($diag);
			
			var $mem = $('<div>')
				.addClass('n2_submission_warning_memory')
				.appendTo($diag);
			
			
			var cbId = $n2.getUniqueId();
			$('<input type="checkbox">')
				.attr('id', cbId)
				.appendTo($mem);

			$('<label>')
				.attr('for', cbId)
				.text( _loc('Do not show this warning again') )
				.appendTo($mem);
			
			var $buttons = $('<div>')
				.addClass('n2_submission_warning_buttons')
				.appendTo($diag);
			
			$('<button>')
				.addClass('n2_button_ok')
				.appendTo($buttons)
				.text( _loc('OK') )
				.click(function(){
					var $diag = $('#'+diagId);
					$diag.dialog('close');
				});
			
			$diag.dialog({
				autoOpen: true
				,title: _loc('Warning on Database Submissions')
				,modal: true
				,width: 'auto'
				,close: function(event, ui){
					var $diag = $('#'+diagId);
					
					var $cb = $diag.find('input[type=checkbox]');
					var disable = false;
					if( $cb.length > 0 ){
						disable = $cb.is(':checked')
					};
					
					$diag.remove();
					
					if( disable ){
						$n2.cookie.setCookie({
							name: 'nunaliit_submissions'
							,value: 'do not warn'
							,end: (60 * 60 * 24 * 365) // max-age in seconds
							,path: '/'
						});
					};
				}
			});
		};
	}
});

//*******************************************************
$n2.couchDocument = {
	CouchDocumentSource: CouchDocumentSource
	,CouchDocumentSourceWithSubmissionDb: CouchDocumentSourceWithSubmissionDb
	,adjustDocument: adjustDocument
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDocumentList.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/
;(function($,$n2){
"use strict";

// Localization
var 
	_loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
	,DH = 'n2.couchDocumentList'
	;

//*******************************************************
var modelTrackersByModelId = {};

//*******************************************************
/**
 * An instance of this class is used to keep track of the state of a model
 * and translate the state into a list of documents acceptable for the
 * show service document list.
 */
var ModelTracker = $n2.Class({
	sourceModelId: null,

	dispatchService: null,
	
	docsById: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			sourceModelId: null
			,dispatchService: null
		},opts_);
		
		this.sourceModelId = opts.sourceModelId;
		this.dispatchService = opts.dispatchService;
		
		this.docsById = {};

		var _this = this;
		
		// Register to events
		if( this.dispatchService ){
			var f = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'modelStateUpdated', f);
		};
		
		this.refresh();
	},
	
	refresh: function(){
		if( this.sourceModelId ){
			// Get current state
			var state = $n2.model.getModelState({
				dispatchService: this.dispatchService
				,modelId: this.sourceModelId
			});
			if( state ){
				this._sourceModelUpdated(state);
			};
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'modelStateUpdated' === m.type ){
			// Does it come from our source?
			if( this.sourceModelId === m.modelId ){
				this._sourceModelUpdated(m.state);
			};
		};
	},
	
	_sourceModelUpdated: function(sourceState){
		// Loop through all added documents
		if( sourceState.added ){
			for(var i=0,e=sourceState.added.length; i<e; ++i){
				var doc = sourceState.added[i];
				var docId = doc._id;
				
				this.docsById[docId] = doc;
			};
		};
		
		// Loop through all updated documents
		if( sourceState.updated ){
			for(var i=0,e=sourceState.updated.length; i<e; ++i){
				var doc = sourceState.updated[i];
				var docId = doc._id;
				
				this.docsById[docId] = doc;
			};
		};
		
		// Loop through all removed documents
		if( sourceState.removed ){
			for(var i=0,e=sourceState.removed.length; i<e; ++i){
				var doc = sourceState.removed[i];
				var docId = doc._id;
				
				if( this.docsById[docId] ){
					delete this.docsById[docId];
				};
			};
		};

		// Prepare an event to report document list result
		var m = {
			type: 'documentListResults'
			,listType: 'model'
			,listName: this.sourceModelId
			,docIds: []
			,docs: []
		};
		
		for(var docId in this.docsById){
			var doc = this.docsById[docId];
			m.docIds.push(docId);
			m.docs.push(doc);
		};
		
		// Send event
		this.dispatchService.send(DH,m);
	}
});

//*******************************************************
var DocumentListService = $n2.Class({
	
	atlasDesign: null,
	
	dispatchService: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			atlasDesign: null
			,dispatchService: null
		},opts_);
		
		var _this = this;
		
		this.atlasDesign = opts.atlasDesign;
		this.dispatchService = opts.dispatchService;
		
		if( this.dispatchService ){
			var fn = function(m, addr, dispatcher){
				_this._handle(m, addr, dispatcher);
			};
			this.dispatchService.register(DH, 'documentListQuery', fn);
		};
	},
	
	_handle: function(m, addr, dispatcher){
		if( 'documentListQuery' === m.type ){
			if( 'layer' === m.listType ){
				this._handleLayerQuery(m);
			} else if( 'schema' === m.listType ){
				this._handleSchemaQuery(m);
			} else if( 'model' === m.listType ){
				this._handleModelQuery(m);
			};
		};
	},
	
	_handleLayerQuery: function(m){
		var _this = this;
		
		var keys = [];
		if( m.listName ){
			keys = m.listName.split(',');
			for(var i=0,e=keys.length; i<e; ++i){
				keys[i] = $n2.trim( keys[i] );
			};
		};
		
		if( this.dispatchService 
		 && this.atlasDesign 
		 && keys.length > 0 ){
			this.atlasDesign.queryView({
				viewName: 'layers'
				,keys: keys
				,include_docs: true
				,onSuccess: function(rows){
					var docIds = [];
					var docs = [];
					for(var i=0,e=rows.length; i<e; ++i){
						docIds.push( rows[i].id );
						docs.push( rows[i].doc );
					};
					_this.dispatchService.send(DH,{
						type: 'documentListResults'
						,listType: m.listType
						,listName: m.listName
						,docIds: docIds
						,docs: docs
					});
				}
				,onError: function(err){
					$n2.log('Unable to retrieve document list ('+m.listType+'/'+m.listName+')',err);
				}
			});
		};
	},
	
	_handleSchemaQuery: function(m){
		var _this = this;
		
		var keys = [];
		if( m.listName ){
			keys = m.listName.split(',');
			for(var i=0,e=keys.length; i<e; ++i){
				keys[i] = $n2.trim( keys[i] );
			};
		};
		
		if( this.dispatchService 
		 && this.atlasDesign 
		 && keys.length > 0 ){
			this.atlasDesign.queryView({
				viewName: 'nunaliit-schema'
				,keys: keys
				,include_docs: true
				,onSuccess: function(rows){
					var docIds = [];
					var docs = [];
					for(var i=0,e=rows.length; i<e; ++i){
						docIds.push( rows[i].id );
						docs.push( rows[i].doc );
					};
					_this.dispatchService.send(DH,{
						type: 'documentListResults'
						,listType: m.listType
						,listName: m.listName
						,docIds: docIds
						,docs: docs
					});
				}
				,onError: function(err){
					$n2.log('Unable to retrieve document list ('+m.listType+'/'+m.listName+')',err);
				}
			});
		};
	},
	
	_handleModelQuery: function(m){
		var _this = this;
		
		var modelId = m.listName;
		
		var modelTracker = modelTrackersByModelId[modelId];
		if( modelTracker ){
			modelTracker.refresh();
		} else {
			modelTracker = new ModelTracker({
				sourceModelId: modelId
				,dispatchService: this.dispatchService
			});
			modelTrackersByModelId[modelId] = modelTracker;
		};
	}
});

//*******************************************************
$n2.couchDocumentList = {
	DocumentListService: DocumentListService
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchAttachment.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); },
DH = 'n2.couchAttachment';

//========================================================================

var Attachment = $n2.Class({
	doc: null,
	
	documentSource: null,
	
	attName: null,
	
	mediaRelativePath: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			doc: null
			,attName: null
			,mediaRelativePath: null
			,documentSource: null
		},opts_);
		
		this.doc = opts.doc;
		this.attName = opts.attName;
		this.mediaRelativePath = opts.mediaRelativePath;
		this.documentSource = opts.documentSource;
	},
	
	getName: function(){
		return this.attName;
	},
	
	getStatus: function(){
		var att = this._getAtt();
		return att.status;
	},
	
	isAttached: function(){
		if( 'attached' !== this.getStatus() ){
			return false;
		};
		
		// Check that file is actually attached
		if( this.doc 
		 && this.doc._attachments 
		 && this.doc._attachments[this.attName] ){
			return true;
		};
		
		return false;
	},
	
	getFileClass: function(){
		var att = this._getAtt();
		return att.fileClass;
	},
	
	getMediaFileUrl: function(){
		var att = this._getAtt();
		if( att 
		 && att.mediaFile 
		 && this.mediaRelativePath ){
			return this.mediaRelativePath + att.mediaFile;
		};
		return null;
	},
	
	getStructure: function(){
		return this._getAtt();
	},
	
	isSource: function(){
		var att = this._getAtt();
		return !att.source;
	},
	
	getThumbnailAttachment: function(){
		var thumbAtt = null;
		
		var att = this._getAtt();
		if( att ){
			var thumbName = att.thumbnail;
			if( thumbName ) {
				var otherAtt = this._getAtt(thumbName);
				if( otherAtt ) {
					thumbAtt = new Attachment({
						doc: this.doc
						,attName: thumbName
						,mediaRelativePath: this.mediaRelativePath
						,documentSource: this.documentSource
					});
				};
			};
		};
		
		return thumbAtt;
	},
	
	getOriginalAttachment: function(){
		var originalAtt = null;
		
		var att = this._getAtt();
		if( att ){
			var originalName = att.originalAttachment;
			if( originalName ) {
				var otherAtt = this._getAtt(originalName);
				if( otherAtt ) {
					originalAtt = new Attachment({
						doc: this.doc
						,attName: originalName
						,mediaRelativePath: this.mediaRelativePath
						,documentSource: this.documentSource
					});
				};
			};
		};
		
		return originalAtt;
	},
	
	getSourceAttachment: function(){
		var originalAtt = null;
		
		var att = this._getAtt();
		if( att ){
			var sourceName = att.source;
			if( sourceName ) {
				var otherAtt = this._getAtt(sourceName);
				if( otherAtt ) {
					originalAtt = new Attachment({
						doc: this.doc
						,attName: sourceName
						,mediaRelativePath: this.mediaRelativePath
						,documentSource: this.documentSource
					});
				};
			};
		};
		
		return originalAtt;
	},
	
	changeStatus: function(status){
		var att = this._getAtt();
		if( att ) {
			
			att.status = status;
			
			var thumbName = att.thumbnail;
			if( null != thumbName ) {
				var thumbAtt = this._getAtt(thumbName);
				if( thumbAtt ) {
					thumbAtt.status = status;
				};
			};
			
			var originalName = att.originalAttachment;
			if( null != originalName ) {
				var originalAtt = this._getAtt(originalName);
				if( originalAtt ) {
					originalAtt.status = status;
				};
			};
		};
	},
	
	computeUrl: function(){
		var url = undefined;

		var att = this._getAtt();
		if( att ){
			if( !this.documentSource ){
				throw new Error('Can not compute URL since document source is not set');
			};
			
			url = this.documentSource.getDocumentAttachmentUrl(this.doc, this.attName);
		};
		
		return url;
	},
	
	_getAtt: function(name){
		name = name ? name : this.attName;
		if( this.doc
		 && this.doc.nunaliit_attachments
		 && this.doc.nunaliit_attachments.files
		 && this.doc.nunaliit_attachments.files[name] ) {
			
			return this.doc.nunaliit_attachments.files[name];
		};
		
		return null;
	}
});

//========================================================================

/*
 * Returns the attachment structure associated with the attachment name.
 * Returns null if nothing is found.
 */
function getAttachmentFromName(doc, attachmentName, mediaRelativePath, documentSource){
	var att = null;
	
	if( doc
	 && doc.nunaliit_attachments
	 && doc.nunaliit_attachments.files
	 && doc.nunaliit_attachments.files[attachmentName] ) {
		
		att = new Attachment({
			doc: doc
			,attName: attachmentName
			,mediaRelativePath: mediaRelativePath
			,documentSource: documentSource
		});
	};
	
	return att;
};
//========================================================================

/*
 * Returns a list of attachment structures associated with the document.
 */
function getAttachments(doc, mediaRelativePath, documentSource){
	var result = [];
	
	if( doc
	 && doc.nunaliit_attachments
	 && doc.nunaliit_attachments.files ) {
		
		for(var attName in doc.nunaliit_attachments.files){
			var att = new Attachment({
				doc: doc
				,attName: attName
				,mediaRelativePath: mediaRelativePath
				,documentSource: documentSource
			});
			
			if( att ){
				result.push(att);
			};
		};
	};
	
	return result;
};

// ========================================================================

var AttachmentService = $n2.Class({
	
	mediaRelativePath: null,

	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			mediaRelativePath: null
			,dispatchService: null
		},opts_);
		
		this.mediaRelativePath = opts.mediaRelativePath;
		this.dispatchService = opts.dispatchService;
	},

	getAttachments: function(doc, documentSource){
		if( !documentSource ){
			// Document source is not specified. Look for it.
			var m = {
				type: 'documentSourceFromDocument'
				,doc: doc
				,documentSource: null
			};
			this.dispatchService.synchronousCall(DH,m);
			if( m.documentSource ){
				documentSource = m.documentSource;
			};
		};

		if( !documentSource ){
			// At this point, we are not able to find an appropriate document
			// source. Create a fake one. It might work, but most likely, it will not.
			documentSource = new $n2.document.DocumentSource({
				doc: doc
				,dispatchService: this.dispatchService
				,dispatchHandle: DH
			});
		};
		
		return getAttachments(doc, this.mediaRelativePath, documentSource);
	},

	getAttachment: function(doc, attachmentName, documentSource){
		if( !documentSource ){
			// Document source is not specified. Look for it.
			var m = {
				type: 'documentSourceFromDocument'
				,doc: doc
				,documentSource: null
			};
			this.dispatchService.synchronousCall(DH,m);
			if( m.documentSource ){
				documentSource = m.documentSource;
			};
		};

		if( !documentSource ){
			// At this point, we are not able to find an appropriate document
			// source. Create a fake one. It might work, but most likely, it will not.
			documentSource = new $n2.document.DocumentSource({
				doc: doc
				,dispatchService: this.dispatchService
				,dispatchHandle: DH
			});
		};
		
		return getAttachmentFromName(doc, attachmentName, this.mediaRelativePath, documentSource);
	} 
});

//========================================================================

$n2.couchAttachment = {
	AttachmentService: AttachmentService
	,getAttachments: getAttachments
	,getAttachmentFromName: getAttachmentFromName
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDisplayBox.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

//=========================================================================

var DisplayImageSourceFactory = $n2.Class({
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
		},opts_);
		
		this.dispatchService = opts.dispatchService;
	},

	getImageSourceForDoc: function(opts_){
		var opts = $n2.extend({
			doc: null
			,attName: null
			,showService: null
			,onSuccess: function(imageSource, doc){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var doc = opts.doc;
		
		var documentSource = $n2.document.getDocumentSourceFromDocument({
			doc: doc
			,dispatchService: this.dispatchService
		});

		// Map to accumulate all references
		var docIdMap = {};
		
		// Forward references
		var references = [];
		$n2.couchUtils.extractLinks(doc, references);
		for(var i=0, e=references.length; i<e; ++i){
			var linkDocId = references[i].doc;
			docIdMap[linkDocId] = true;
		};

		// Obtain reverse references
		documentSource.getReferencesFromId({
			docId: doc._id
			,onSuccess: function(referenceIds){
				for(var i=0, e=referenceIds.length; i<e; ++i){
					var linkDocId = referenceIds[i];
					docIdMap[linkDocId] = true;
				};
				
				loadProductIds();
			}
			,onError: function(errorMsg){
				opts.onError(errorMsg);
			}
		});
		
		function loadProductIds(){
			
			// If we have a source, load all documents with the same source
			if( doc.nunaliit_source 
			 && doc.nunaliit_source.doc ){
				documentSource.getProductFromId({
					docId: doc.nunaliit_source.doc
					,onSuccess: function(docIds){
						for(var i=0, e=docIds.length; i<e; ++i){
							var productDocId = docIds[i];
							docIdMap[productDocId] = true;
						};
						getDocuments();
					}
					,onError: function(errorMsg){
						opts.onError(errorMsg);
					}
				});
			} else {
				getDocuments();
			};
		};
		
		function getDocuments() {
			// Convert map to array
			var refDocIds = [];
			for(var docId in docIdMap) {
				if( docId !== doc._id ) {
					refDocIds.push(docId);
				};
			};
			
			documentSource.getDocuments({
				docIds: refDocIds
				,onSuccess: loadedDocs
				,onError: function(errorMsg){
					opts.onError(errorMsg);
				}
			});
		};
		
		function loadedDocs(docs){
			// Create an image source
			var imageSource = new $n2.displayBox.DisplayImageSourceDoc({
				showService: opts.showService
				,dispatchService: _this.dispatchService
			});
			imageSource.addDocument(doc, opts.attName);
			
			// Go over all documents and look for viable attachments
			for(var i=0,e=docs.length; i<e; ++i){
				var refDoc = docs[i];
				var atts = documentSource.getDocumentAttachments(refDoc);
				for(var j=0,k=atts.length; j<k; ++j){
					var att = atts[j];
					if( 'image' === att.getFileClass() 
					 && 'attached' === att.getStatus()
					 && att.isSource() ){
						var refAttName = att.getName();
						imageSource.addDocument(refDoc, refAttName);
					};
				};
			};
			
			opts.onSuccess(imageSource, doc);
		};
	}
});

// =========================================================================

$n2.couchDisplayBox = {
	DisplayImageSourceFactory: DisplayImageSourceFactory
};	
	
})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchImportProfile.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

/*

The concept of using profiles to import data is designed to help importing a set
of data to create an initial set of documents that can be updated later wen re-importing
a newer version of the external data.

In this design, "external data" refers to a set of data obtained by a party wishing to
import information to a Nunaliit atlas. The external data can be a spreadsheet, a JSON file,
a GeoJSON file, etc.

An import profile is used to keep track of a data set that is imported. An import profile is
a document with a structure that follows:

{
	"nunaliit_import_profile": {
	   "id": "demo",
	   "nunaliit_type": "import_profile",
	   "label": {
	       "nunaliit_type": "localized",
	       "en": "Demo"
	   },
	   "type": "json",
	   "options": {
	       "idAttribute": "id"
	   },
	   "operations": [
	       "copyAllAndFixNames(demo_doc)"
	   ],
	   "layerName": "public",
	   "schemaName": "demo_doc"
	}
}

The main responsibility of an import profile is to indicate how an external data set is
broken into entries with unique identifiers. For each entry generated from the external
data, a document is created with the following structure:

{
	"nunaliit_import": {
		"id": "123"
		,"profile": "demo"
		,"data": {
			"id": "123"
			,"a": "abc"
			,"b": "def"
		}
	}
	,"demo_doc": {
		"id": "123"
		,"a": "abc"
		,"b": "def"
	}
	,"nunaliit_layers": [
		"public"
	]
	,"nunaliit_schema": "demo_doc"
}

 */


;(function($,$n2) {
"use strict";

var GEOM_PROP_NAME = '__geometry__';

// Localization
var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); },
DH = 'n2.couchImportProfile';

//=========================================================================
var operationPatterns = [];

function addOperationPattern(pattern, aClass){
	operationPatterns.push({
		pattern: pattern
		,supportingClass: aClass
	});
};

function createOperation(opts_){
	var opts = $n2.extend({
		operationString: null
		,atlasDb: null
		,atlasDesign: null
	},opts_);
	
	for(var i=0,e=operationPatterns.length; i<e; ++i){
		var opPattern = operationPatterns[i];
		var matches = opPattern.pattern.test(opts.operationString);
		if( matches ){
			var op = new opPattern.supportingClass(opts);
			return op;
		};
	};
	
	// At this point, we are looking for an operation which is supported by the
	// JISON parser
	try {
		var program = $n2.importProfileOperation.parse(opts.operationString);
		var op = new ImportProfileOperationParsed({
			operationString: opts.operationString
			,program: program
			,atlasDb: opts.atlasDb
			,atlasDesign: opts.atlasDesign
		});
		
		$n2.log('ImportProfileOperationParsed',op);
		
		return op;

	} catch(err) {
		$n2.logError("Error while parsing operation string: "+opts.operationString, err);
	};
	
	return null;
};

//=========================================================================
// Copy operation
/*
{
  	// Array of strings: names of properties involved in copy
	propertyNames: [],
	
	// Value that would replace current one
	computedValue: importValue,
	
	// Selector for place where in document value would be installed
	targetSelector: targetSelector,
	
	// Current value found in document
	targetValue: targetValue,
	
	// Boolean. True if current value and computed value are the same
	isEqual: <boolean>,
	
	// True if the target has changed since the last time it was imported
	changedSinceLastImport: <boolean>
}
 */


//=========================================================================
// Instances of this class are used by the class Change to track which
// copy operations require resolution before updating the document. It also
// keeps the result of the resolution
var CollisionOperation = $n2.Class({
	
	collisionId: null,
	
	copyOperation: null,
	
	resolution: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			copyOperation: undefined
		},opts_);
		
		this.collisionId = $n2.getUniqueId();
		
		this.resolution = undefined;
		
		this.copyOperation = opts.copyOperation;
	},
	
	getCollisionId: function(){
		return this.collisionId;
	},
	
	getCopyOperation: function(){
		return this.copyOperation;
	},
	
	isResolved: function(){
		if( this.resolution ){
			return true;
		};
		return false;
	},
	
	isKeepCurrentValue: function(){
		return 'currentValue' === this.resolution;
	},
	
	setKeepCurrentValue: function(){
		this.resolution = 'currentValue';
	},
	
	isUpdateValue: function(){
		return 'updateValue' === this.resolution;
	},
	
	setUpdateValue: function(){
		this.resolution = 'updateValue';
	},
	
	shouldPerformCopyOperation: function(){
		if( 'updateValue' === this.resolution ) {
			return true;
		};
		return false;
	}
});

//=========================================================================
// Instances of this class are used to track which properties have changed
// since the last import.
var ModifiedImportValue = $n2.Class({
	
	propertyName: null,

	lastImportedValue: null,

	currentImportedValue: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			propertyName: undefined,
			lastImportedValue: undefined,
			currentImportedValue: undefined
		},opts_);
		
		this.propertyName = opts.propertyName;
		this.lastImportedValue = opts.lastImportedValue;
		this.currentImportedValue = opts.currentImportedValue;
	},
	
	getPropertyName: function(){
		return this.propertyName;
	}
});

//=========================================================================
// Instances of this class carry information about a document change (modification)
// given the changes found in the import entries. At a high level, it informs
// if a document should be added, deleted or removed given an entry.
//
// A user generally approves a change. At this point the change is carried out. It
// might include multiple modifications to the document.
var Change = $n2.Class({
	
	/**
	 * Unique to this change. Useful when displaying.
	 */
	changeId: null,

	/**
	 * Identifier for import entry
	 */
	importId: null,

	isAddition: null,
	
	isModification: null,
	
	isDeletion: null,
	
	type: null,
	
	/**
	 * True if this change can be applied without user intervention
	 */
	auto: null,
	
	/**
		array of objects with the following structure:
		{
			property: <name of the import property>
			,lastImportValue: <value during last import>
			,externalValue: <value from this import>
			,collisions: []
		}
		The collisions array contains collisions pertinent to
		this property. It is an array of objects with the following
		structure:
		{
			source: <name of the import property>
			,sourceValue: <value during last import>
			,target: <string that represent the selector for where the data should go>
			,targetValue: <value currently found by selector>
		}
	 */
	modifiedProperties: null,
	
	modifiedImportValueByName: null,
	
	copyOperations: null,

	collisionOperationsById: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			importId: undefined,
			isAddition: false,
			isModification: false,
			isDeletion: false,
			isAuto: undefined,
			modifiedProperties: undefined
		},opts_);
		
		var _this = this;
	
		this.changeId = $n2.getUniqueId();
		this.modifiedProperties = [];
		this.modifiedImportValueByName = {};
		this.copyOperations = [];
		this.collisionOperationsById = {};
		
		this.importId = opts.importId;
		this.isAddition = opts.isAddition;
		this.isModification = opts.isModification;
		this.isDeletion = opts.isDeletion;
		this.auto = opts.isAuto;
		
		if( this.isAddition ){
			this.type = 'addition';
		};
		if( this.isModification ){
			if( this.type ){
				throw new Error('Only one of isAddition, isModification or isDeletion can be set');
			};
			this.type = 'modification';
		};
		if( this.isDeletion ){
			if( this.type ){
				throw new Error('Only one of isAddition, isModification or isDeletion can be set');
			};
			this.type = 'deletion';
		};
		
		if( typeof this.importId !== 'string' 
		 && typeof this.importId !== 'number' ){
			throw new Error('importId must be set as a string');
		};
		
		if( opts.modifiedProperties === undefined ){
			// OK, no specified
		} else if( $n2.isArray(opts.modifiedProperties) ){
			opts.modifiedProperties.forEach(function(name){
				_this.modifiedProperties.push(name);
			});
		} else {
			throw new Error('Unexpected value for modifiedProperties');
		};
	},
	
	getId: function(){
		return this.changeId;
	},
	
	isAuto: function(){
		if( undefined !== this.auto ){
			return this.auto;
		};

		if( this.isAddition ){
			return true;
		} else if( this.isDeletion ) {
			return false;
		};
		
		for(var collisionId in this.collisionOperationsById){
			return false;
		};
		
		return true;
	},
	
	addModifiedImportValue: function(modifiedImportValue){
		var name = modifiedImportValue.getPropertyName();
		this.modifiedImportValueByName[name] = modifiedImportValue;
	},

	getModifiedImportValueNames: function(){
		var names = [];
		for(var name in this.modifiedImportValueByName){
			names.push(name);
		};
		names.sort();
		return names;
	},

	getModifiedImportValueFromName: function(name){
		return this.modifiedImportValueByName[name];
	},
	
	hasAnyValueChangedSinceLastImport: function(propertyNames){
		for(var i=0,e=propertyNames.length; i<e; ++i){
			var propertyName = propertyNames[i];
			if( this.modifiedImportValueByName[propertyName] ){
				return true;
			};
		}
		
		return false;
	},
	
	addCopyOperation: function(copyOperation){
		this.copyOperations.push(copyOperation);
	},
	
	addCollisionOperation: function(copyOperation){
		var collision = new CollisionOperation({
			copyOperation: copyOperation
		});
		
		this.auto = false;
		
		this.collisionOperationsById[collision.getCollisionId()] = collision;
	},
	
	getCopyOperations: function(){
		var _this = this;

		var ops = [];
		
		this.copyOperations.forEach(function(op){
			var propNames = op.propertyNames;
			if( propNames.length < 1 ){
				// Copy operation independent of the import
				// data
				ops.push(op);
			} else if( _this.hasAnyValueChangedSinceLastImport(propNames) ){
				ops.push(op);
			};
		});
		
		return ops;
	},
	
	getEffectiveCopyOperations: function(){
		var _this = this;

		var ops = [];
		
		this.copyOperations.forEach(function(op){
			var propNames = op.propertyNames;
			if( propNames.length < 1 ){
				// Copy operation independent of the import
				// data
				ops.push(op);
			} else if( _this.hasAnyValueChangedSinceLastImport(propNames) ){
				ops.push(op);
			};
		});

		for(var collisionId in this.collisionOperationsById){
			var collision = this.collisionOperationsById[collisionId];
			if( collision.shouldPerformCopyOperation() ){
				ops.push( collision.getCopyOperation() );
			};
		};
		
		return ops;
	},
	
	getCollisionOperations: function(){
		var collisions = [];
		for(var collisionId in this.collisionOperationsById){
			var collision = this.collisionOperationsById[collisionId];
			collisions.push(collision);
		};
		return collisions;
	},
	
	getCollisionFromId: function(collisionId){
		return this.collisionOperationsById[collisionId];
	},
	
	isResolved: function(){
		for(var collisionId in this.collisionOperationsById){
			var collision = this.collisionOperationsById[collisionId];
			if( !collision.isResolved() ){
				return false;
			};
		};
		return true;
	}
});

//=========================================================================
// An instance of this class is used to report all changes that would occur
// if an import was performed. This allows a user to peruse changes before
// applying them to the database.
var ImportAnalysis = $n2.Class({
	
	profile: null,
	
	changesById: null,

	dbDocIdByImportId: null,
	
	dbDocsByImportId: null,
	
	entriesByImportId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			profile: null
		},opts_);
		
		this.profile = opts.profile;
		
		this.changesById = {};
		this.dbDocsByImportId = {};
		this.dbDocIdByImportId = {};
		this.entriesByImportId = {};
		
		this.modificationCount = 0;
		this.additionCount = 0;
		this.deletionCount = 0;
	},
	
	getImportProfile: function(){
		return this.profile;
	},
	
	getChange: function(changeId){
		return this.changesById[changeId];
	},
	
	getChanges: function(){
		var changes = [];
		for(var changeId in this.changesById){
			changes.push( this.changesById[changeId] );
		};
		return changes;
	},
	
	removeChange: function(changeId){
		delete this.changesById[changeId];
	},
	
	addDbDocIdForImportId: function(docId, importId){
		this.dbDocIdByImportId[importId] = docId;
	},
	
	getDbDocIds: function(){
		var docIds = [];
		for(var importId in this.dbDocIdByImportId){
			var docId = this.dbDocIdByImportId[importId];
			docIds.push(docId);
		};
		return docIds;
	},
	
	getDbDoc: function(importId){
		return this.dbDocsByImportId[importId];
	},
	
	getDbDocs: function(){
		var dbDocs = [];
		for(var importId in this.dbDocsByImportId){
			var dbDoc = this.dbDocsByImportId[importId];
			dbDocs.push(dbDoc);
		};
		return dbDocs;
	},
	
	getImportEntry: function(importId){
		return this.entriesByImportId[importId];
	},
	
	getImportEntries: function(){
		var entries = [];
		for(var importId in this.entriesByImportId){
			var entry = this.entriesByImportId[importId];
			entries.push(entry);
		};
		return entries;
	},
	
	addChange: function(opts_){
		var opts = $n2.extend({
			change: undefined,
			importEntry: undefined,
			dbDoc: undefined
		},opts_);
		
		var change = opts.change;
		var importId = change.importId;
		
		var importEntry = opts.importEntry;
		if( importEntry ){
			this.entriesByImportId[importId] = importEntry;
		};
		
		var dbDoc = opts.dbDoc;
		if( dbDoc ){
			this.dbDocsByImportId[importId] = dbDoc;
		};

		if( change.isAddition ){
			++this.additionCount;
		};
		if( change.isModification ){
			++this.modificationCount;
		};
		if( change.isDeletion){
			++this.deletionCount;
		};

		this.changesById[change.getId()] = change;
	}
});

//=========================================================================
// Instances of this class are used to create an analysis about an import.
var ImportAnalyzer = $n2.Class({
	
	profile: null,
	
	atlasDesign: null,
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			profile: null
			,atlasDesign: null
			,dispatchService: null
		},opts_);
		
		this.profile = opts.profile;
		this.atlasDesign = opts.atlasDesign;
		this.dispatchService = opts.dispatchService;
	},

	analyzeEntries: function(opts_){
		var opts = $n2.extend({
			entries: null
			,onSuccess: function(analysis){}
			,onError: function(err){}
		},opts_);

		var _this = this;
		var profileId = this.profile.getId();
		var analysis = new ImportAnalysis({
			profile: this.profile
		});
		var dbDocsByImportId = {};
		var entriesLeft = [];

		// Verify import entries and store them in a dictionary
		// for easy access by import id
		var importEntriesById = {};
		var collidingIdMap = {};
		var noIdCount = 0;
		if( opts.entries ){
			for(var i=0,e=opts.entries.length; i<e; ++i){
				var entry = opts.entries[i];
				var id = entry.getId();
				
				if( typeof id === 'undefined' || null === id){
					noIdCount++;
					entriesLeft.push( entry );

				} else if( importEntriesById[id] ){
					if( !collidingIdMap[id] ){
						collidingIdMap[id] = 2;
					} else {
						collidingIdMap[id] = collidingIdMap[id] + 1;
					};

				} else {
					importEntriesById[id] = entry;
					entriesLeft.push( entry );
				};
			};
			
			if( noIdCount > 0 ){
				if( this.profile.ignoreId ){
					// Ok
				} else {
					opts.onError( _loc('Number of imported entries without an id attribute: {count}',{count:noIdCount}) );
					return;
				};
			};
			
			var collidingIds = [];
			for(var collidingId in collidingIdMap){
				collidingIds.push(collidingId);
			};
			if( collidingIds.length > 0 ){
				opts.onError( _loc('Colliding id attributes: {ids}',{
					ids: collidingIds.join(',')
				}) );
				return;
			};
		};
		
		// Load documents previously imported using the same profile
		this.atlasDesign.queryView({
			viewName: 'nunaliit-import'
			,reduce: false
			,include_docs: true
			,startkey: [profileId,null]
			,endkey: [profileId,{}]
			,onSuccess: function(rows){
				var count = 0;
				for(var i=0,e=rows.length; i<e; ++i){
					var doc = rows[i].doc;
					if( doc 
					 && doc.nunaliit_import 
					 && typeof doc.nunaliit_import.id !== 'undefined'
					 && null !== doc.nunaliit_import.id ) {
						++count;
						dbDocsByImportId[doc.nunaliit_import.id] = doc;
						analysis.addDbDocIdForImportId(doc._id, doc.nunaliit_import.id);
					};
				};
				
				dbDocumentsLoaded();
			}
			,onError: function(err){
				opts.onError( _loc('Error loading documents from database: {err}',{err:err}) );
			}
		});
		
		function dbDocumentsLoaded(){
			// Discover deletions
			for(var id in dbDocsByImportId){
				if( importEntriesById[id] ) {
					// OK
				} else {
					var change = new Change({
						isDeletion: true
						,importId: id
					});
					
					analysis.addChange({
						change: change
						,dbDoc: dbDocsByImportId[id]
					});
				};
			};
			
			processEntries();
		};
			
		function processEntries(){
			if( entriesLeft.length < 1 ){
				opts.onSuccess(analysis);
				return;
			};
			
			var entry = entriesLeft.shift();
			var id = entry.getId();

			if( dbDocsByImportId[id] ){
				// Already exists in database
				// Check if modified
				_this._compare({
					importEntry: entry
					,doc: dbDocsByImportId[id]
					,onSuccess: function(change){
						if( change ){
							analysis.addChange({
								change: change
								,dbDoc: dbDocsByImportId[id]
								,importEntry: entry
							});
						};
						
						// Next entry
						window.setTimeout(processEntries,0); // Do not blow stack on large files
					}
					,onError: function(err){
						opts.onError( _loc('Unable to analyze change: {err}',{err:''+err}) );
					}
				});
				
			} else {
				// New to database

				// If no import id, associate one so that we can refer to it
				if( !id ){
					id = $n2.getUniqueId();
				};
				
				var change = new Change({
					isAddition: true
					,importId: id
				});

				var allPropertyNames = [];
				var props = entry.getProperties();
				for(var propName in props){
					allPropertyNames.push(propName);
					
					var externalValue = props[propName];

					var modImportValue = new ModifiedImportValue({
						propertyName: propName,
						lastImportedValue: undefined,
						currentImportedValue: externalValue
					});
					change.addModifiedImportValue(modImportValue);
				};
				
				var geomWkt = entry.getGeometry();
				if( geomWkt ){
					var modImportValue = new ModifiedImportValue({
						propertyName: GEOM_PROP_NAME,
						lastImportedValue: undefined,
						currentImportedValue: geomWkt
					});
					change.addModifiedImportValue(modImportValue);
				};

				// Use null last import entry for creating document
				var lastImportEntry = new ImportEntryFromDoc({doc:undefined});

				_this.profile.reportCopyOperations({
					doc: opts.doc
					,importEntry: entry
					,lastImportEntry: lastImportEntry
					,allPropertyNames: allPropertyNames
					,onSuccess: function(copyOperations){
						copyOperations.forEach(function(copyOperation){
							change.addCopyOperation(copyOperation);
						});
						
						analysis.addChange({
							change: change
							,importEntry: entry
						});
						
						// Next entry
						window.setTimeout(processEntries,0); // Do not blow stack on large files
					}
				});
				
			};
		};
	},
	
	_compare: function(opts_){
		var opts = $n2.extend({
			importEntry: null
			,doc: null
			,onSuccess: function(change){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var importEntry = opts.importEntry;
		var importData = importEntry.getProperties();

		// Testing new code
		this._retrieveLastEntryFromDoc({
			doc: opts.doc
			,onSuccess: retrievedLastImportEntry
			,onError: function(err){
				opts.onError( new Error('Error while retrieving last import entry: ' + err) );
			}
		});

		function retrievedLastImportEntry(lastImportEntry){
			var lastImportData = lastImportEntry.getProperties();
			var lastImportGeometry = lastImportEntry.getGeometry();
			var importId = lastImportEntry.getId();
			
			var change = new Change({
				importId:importId
				,isModification: true
			});
			
			// Create a map of all property names
			var allPropNamesMap = {};
			for(var propName in importData){
				allPropNamesMap[propName] = true;
			};
			for(var propName in lastImportData){
				allPropNamesMap[propName] = true;
			};
			
			// Geometry
			var isGeometryModified = false;
			var externalGeom = importEntry.getGeometry();
			if( externalGeom ){
				if( lastImportGeometry ){
					if( externalGeom !== lastImportGeometry ){
						// Geometry modified
						isGeometryModified = true;
					};
				} else {
					// Geometry added
					isGeometryModified = true;
				};
			} else if( lastImportGeometry ){
				// Deleted
				isGeometryModified = true;
			};
			if( isGeometryModified ){
				var modImportValue = new ModifiedImportValue({
					propertyName: GEOM_PROP_NAME,
					lastImportedValue: lastImportGeometry,
					currentImportedValue: externalGeom
				});
				change.addModifiedImportValue(modImportValue);
			};
			
			// Look at values that have changed since the last import
			var modificationsByPropName = {};
			var allPropertyNames = [];
			for(var propName in allPropNamesMap){
				var lastImportValue = lastImportData[propName];
				var externalValue = importData[propName];
				
				allPropertyNames.push(propName);
				
				if( externalValue !== lastImportValue ){
					var mod = {
						property: propName
						,lastImportValue: lastImportValue
						,externalValue: externalValue
						,collisions: []
						,copyOperations: []
					};
					
					modificationsByPropName[propName] = mod;
					
					change.modifiedProperties.push(mod);
					
					var modImportValue = new ModifiedImportValue({
						propertyName: propName,
						lastImportedValue: lastImportValue,
						currentImportedValue: externalValue
					});
					change.addModifiedImportValue(modImportValue);
				};
			};
			
			// Get all copy operations that are to be executed on import
			_this.profile.reportCopyOperations({
				doc: opts.doc
				,importEntry: importEntry
				,lastImportEntry: lastImportEntry
				,allPropertyNames: allPropertyNames
				,onSuccess: function(copyOperations){
					var atLeastOneCopyOperation = false;

					// Look at each copy operation and retain the ones that are relevant.
					// In other words, keep the operations that are affected by the change
					// in property values
					copyOperations.forEach(function(copyOperation){
						var propertyNames = copyOperation.propertyNames;
						if( change.hasAnyValueChangedSinceLastImport(propertyNames) ){
							// The copy operation is marked equal if the current target
							// value and the updated computed value are the same
							if( copyOperation.isEqual ){
								// Nothing to do
							} else {
								atLeastOneCopyOperation = true;
								if( copyOperation.changedSinceLastImport ){
									// Changed by external entity and changed on
									// the database. Collision
									change.addCollisionOperation(copyOperation);
								} else {
									// Changed by external entity but it has not
									// changed since last import. Automatic copy
									change.addCopyOperation(copyOperation);
								};
							};
						} else if( propertyNames.length < 1 ) {
							if( copyOperation.isEqual ){
								// Nothing to do
							} else {
								// This is a change that is not dependent on import data.
								// If not equal, add
								atLeastOneCopyOperation = true;
								change.addCopyOperation(copyOperation);
							};
						};
					});
					
					if( !atLeastOneCopyOperation ){
						change = undefined;
					};
					
					opts.onSuccess(change);
				}
			});
		};
	},
	
	_retrieveLastEntryFromDoc: function(opts_){
		var opts = $n2.extend({
			doc: null
			,onSuccess: function(lastEntry){}
			,onError: function(err){}
		},opts_);
		
		var doc = opts.doc;
	
		if( !doc ){
			var lastImportEntry = new ImportEntryFromDoc({ doc: undefined });
			opts.onSuccess(lastImportEntry);
			return;
		};

		if( doc.nunaliit_import.dataAttachmentName ){
			var attName = doc.nunaliit_import.dataAttachmentName;

			if( doc._attachments
			 && doc._attachments[attName] ){
				// Compute URL
				var documentSource;
				// Document source is not specified. Look for it.
				var m = {
					type: 'documentSourceFromDocument'
					,doc: doc
					,documentSource: null
				};
				this.dispatchService.synchronousCall(DH,m);
				if( m.documentSource ){
					documentSource = m.documentSource;
				};
				
				var attUrl = documentSource.getDocumentAttachmentUrl(doc, attName);
				$.ajax({
					url: attUrl
					,type: 'GET'
					,dataType: 'json'
					,success: function(importAtt, textStatus, jqXHR){
						//$n2.log('Import Attachment', nunaliit_import);
						var lastImportEntry = new ImportEntryFromDoc({
							doc: doc
							,data: importAtt.data
							,geometryWkt: importAtt.wkt
						});
						opts.onSuccess(lastImportEntry);
					}
					,error: function(jqXHR, textStatus, errorThrown){
						var err = $n2.utils.parseHttpJsonError(jqXHR, textStatus);
						opts.onError(err);
					}
				});

			} else {
				var err = new Error('Attachment for import data can not be found');
				opts.onError(err);
			};

		} else {
			// Legacy import data
			var data = doc.nunaliit_import.data;
			var geometryWkt = undefined;
			if( doc.nunaliit_import.geometry ){
				geometryWkt = doc.nunaliit_import.geometry.wkt;
			};
			var lastImportEntry = new ImportEntryFromDoc({
				doc: doc
				,data: data
				,geometryWkt: geometryWkt
			});
			opts.onSuccess(lastImportEntry);
		};
	}
});

//=========================================================================
var AnalysisReport = $n2.Class({
	elemId: null,
	analysis: null,
	logFn: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			elem: null
			,elemId: null
			,analysis: null
			,logFn: null
		},opts_);
		
		var _this = this;
		
		this.elemId = opts.elemId;
		if( !this.elemId && opts.elem ){
			var $elem = $(opts.elem);
			this.elemId = $elem.attr('id');
			if( !this.elemId ){
				this.elemId = $n2.getUniqueId();
				$elem.attr('id',this.elemId);
			};
		};
		
		this.analysis = opts.analysis;
		this.logFn = opts.logFn;
		
		var $elem = _this._getElem();
		$elem.empty();
		
		// Title
		$('<div class="title">')
			.appendTo($elem)
			.text( _loc('Verification') );
		
		$('<div class="changes">')
			.appendTo($elem);
		
		this._reportChanges();
	},

	_getElem: function(){
		return $('#'+this.elemId);
	},
	
	_log: function(str){
		if( this.logFn ){
			this.logFn(str);
		};
	},
	
	_reportChanges: function(){
		var _this = this;
		
		var $changes = this._getElem().find('.changes')
			.empty();
		
		var analysis = this.analysis;
		var changes = analysis.getChanges();
		
		if( changes.length < 1 ){
			$changes.text( _loc('No changes detected in the import data') );
			return;
		};
		
		if( analysis.getDbDocIds().length < 1 ){
			var proceedDivId = $n2.getUniqueId();
			var $div = $('<div>')
				.attr('id',proceedDivId)
				.addClass('prompt')
				.appendTo($changes);
			$div.text( _loc('This appears to be the first time that you are importing this profile. Accept all?') );
			$('<button>')
				.text( _loc('Proceed') )
				.appendTo($div)
				.click(function(){
					_this._proceedAll({
						onSuccess: function(){ $('#'+proceedDivId).remove(); }
					});
				});
			$('<button>')
				.text( _loc('Discard') )
				.appendTo($div)
				.click(function(){
					var $button = $(this);
					var $promptElem = $button.parents('.prompt');
					$promptElem.remove();
				});
			
		} else {
			var autoChanges = [];
			for(var changeIndex=0;changeIndex<changes.length;++changeIndex){
				var change = changes[changeIndex];
				if( change.isAuto() ){
					autoChanges.push(change);
				};
			};
			if( autoChanges.length > 0 ){
				var autoDivId = $n2.getUniqueId();
				var $div = $('<div>')
					.attr('id',autoDivId)
					.addClass('prompt')
					.appendTo($changes);
				$div.text( _loc('It appears that {count} changes can be completed automatically. Accept automatic changes?',{
					count: autoChanges.length
				}));
				$('<button>')
					.text( _loc('Proceed') )
					.appendTo($div)
					.click(function(){
						_this._proceedAutomatics({
							onSuccess: function(){ $('#'+autoDivId).remove(); }
						});
					});
				$('<button>')
					.text( _loc('Discard') )
					.appendTo($div)
					.click(function(){
						var $button = $(this);
						var $promptElem = $button.parents('.prompt');
						$promptElem.remove();
					});
			};
		};

		changes.sort(function(a,b){
			if( a.isAddition && !b.isAddition ){
				return -1;
			};
			if( !a.isAddition && b.isAddition ){
				return 1;
			};
			if( a.isDeletion && !b.isDeletion ){
				return 1;
			};
			if( !a.isDeletion && b.isDeletion ){
				return -1;
			};
			if( a.importId && b.importId ){
				if( a.importId < b.importId ){
					return -1;
				};
				if( a.importId > b.importId ){
					return 1;
				};
			};
			return 0;
		});
		
		// Loop over changes
		for(var i=0,e=changes.length; i<e; ++i){
			var change = changes[i];

			// Create div to report this change
			var $div = $('<div>')
				.attr('id',change.changeId)
				.addClass('operation')
				.appendTo($changes);

			this._refreshChangeDiv(change, $div);
		};
	},
	
	_refreshChangeDiv: function(change, $div){
		var _this = this;

		var proceedClickFn = function(){
			var $btn = $(this);
			_this._proceed($btn);
			return false;
		};
		var discardClickFn = function(){
			var $btn = $(this);
			_this._discard($btn);
			return false;
		};
		var collisionRadioButtonClickFn = function(){
			var $btn = $(this);
			_this._collisionSelectionClicked($btn);
			return true;
		};

		var analysis = this.analysis;

		$div.empty();
		
		if( change.isModification 
		 || change.isAddition ) {
			// Report modifications
			var importId = change.importId;
			var doc = analysis.getDbDoc(importId);
			var importEntry = analysis.getImportEntry(importId);

			// Detect collisions
			var collisionDetected = false;
			var collisionOperations = change.getCollisionOperations();
			if( collisionOperations.length > 0 ){
				collisionDetected = true;
			};

			// Go through all the properties that need to be modified
			var modifiedPropertyNames = change.getModifiedImportValueNames();

			if( change.isModification ){
				$div.addClass('modify');
			} else if( change.isAddition ){
				$div.addClass('addition');
			};

			if( collisionDetected ){
				$div.addClass('collision');
			};
			if( change.isAuto() ){
				$div.addClass('autoOperation');
			};
			
			// Buttons
			$('<button>')
				.addClass('discard')
				.text( _loc('Discard') )
				.appendTo($div)
				.click(discardClickFn);
			
			var $proceedButton = $('<button>')
				.attr('id',change.changeId + '_proceed')
				.addClass('proceed')
				.text( _loc('Modify Document') )
				.appendTo($div)
				.click(proceedClickFn);
			if( change.isAddition ){
				$proceedButton.text( _loc('Create new document') );
			};
			if( !change.isResolved() ) {
				$proceedButton.attr('disabled','disabled');
			};
			
			// Explanation
			var explanation = _loc('Modify existing document');
			if( change.isAddition ){
				explanation = _loc('Create new document');
			};
			if( change.isAuto() ){
				explanation += ' ' +_loc('AUTO');
			};
			if( collisionDetected ){
				explanation += ' ' + _loc('COLLISION');
			};
			$('<div>')
				.addClass('explanation')
				.text( explanation )
				.appendTo($div);
			$('<div>')
				.addClass('geoJsonId')
				.text( 'Import ID: '+importId )
				.appendTo($div);
			if( doc && doc._id ){
				$('<div>')
					.addClass('docId')
					.text( 'Database ID: '+doc._id )
					.appendTo($div);
			};
			var $properties = $('<div>')
				.addClass('properties')
				.appendTo($div);
			
			// Modified properties
			for(var propNameIndex=0,propNameEnd=modifiedPropertyNames.length; propNameIndex<propNameEnd; ++propNameIndex){
				var propName = modifiedPropertyNames[propNameIndex];
				var mod = change.getModifiedImportValueFromName(propName);
				var $prop = $('<div>')
					.addClass('property')
					.appendTo($properties);
				$('<div>')
					.addClass('propertyName')
					.text(propName)
					.appendTo($prop);
				$('<div>')
					.addClass('previousValue')
					.text( this._printValue(mod.lastImportedValue) )
					.appendTo($prop);
				$('<div>')
					.addClass('newValue')
					.text( this._printValue(mod.currentImportedValue) )
					.appendTo($prop);
			};
			
			// Report collisions
			if( collisionOperations.length > 0 ){
				var $collisions = $('<div>')
					.addClass('collisions')
					.appendTo($div);
				collisionOperations.forEach(function(collisionOperation){
					var copyOperation = collisionOperation.getCopyOperation();
					
					var $collision = $('<div>')
						.addClass('collision')
						.appendTo($collisions);
					$('<div>')
						.addClass('selector')
						.text( _loc('Collision on selector {selector}',{
							selector: copyOperation.targetSelector.getSelectorString()
						}) )
						.appendTo($collision);

					var collisionId = collisionOperation.getCollisionId();
					
					var updatedId = $n2.getUniqueId();
					var $updatedValueDiv = $('<div>')
						.appendTo($collision);
					var $updateBtn = $('<input>')
						.attr('type','radio')
						.attr('id',updatedId)
						.attr('name',collisionId)
						.attr('value','updateValue')
						.attr('data-changeId',change.getId())
						.click(collisionRadioButtonClickFn)
						.appendTo($updatedValueDiv);
					$('<label>')
						.attr('for',updatedId)
						.text( _this._printValue(copyOperation.computedValue) )
						.appendTo($updatedValueDiv);
					if( collisionOperation.isUpdateValue() ){
						$updateBtn.prop("checked", true);
					};
					
					var currentId = $n2.getUniqueId();
					var $currentValueDiv = $('<div>')
						.appendTo($collision);
					var $currentBtn = $('<input>')
						.attr('type','radio')
						.attr('id',currentId)
						.attr('name',collisionId)
						.attr('value','current')
						.attr('data-changeId',change.getId())
						.click(collisionRadioButtonClickFn)
						.appendTo($currentValueDiv);
					$('<label>')
						.attr('for',currentId)
						.text( _this._printValue(copyOperation.targetValue) )
						.appendTo($currentValueDiv);
					if( collisionOperation.isKeepCurrentValue() ){
						$currentBtn.prop("checked", true);
					};
				});
			};
			
			// Report copy operations
			var copyOperations = change.getCopyOperations();
			if( copyOperations.length > 0 ){
				var $copyOperations = $('<div>')
					.addClass('copyOperations')
					.appendTo($div);
				copyOperations.forEach(function(copyOperation){
					var $copy = $('<div>')
						.addClass('copyOperation')
						.appendTo($copyOperations);

					$('<div>')
						.addClass('selector')
						.text( copyOperation.targetSelector.getSelectorString() )
						.appendTo($copy);

					$('<div>')
						.addClass('currentValue')
						.text( _this._printValue(copyOperation.targetValue) )
						.appendTo($copy);

					$('<div>')
						.addClass('updatedValue')
						.text( _this._printValue(copyOperation.computedValue) )
						.appendTo($copy);
				});
			};

		} else if( change.isDeletion ) {
			// Report deletions
			var importId = change.importId;
			var doc = analysis.getDbDoc(importId);
			var $del = $('<div>')
				.attr('id',change.changeId)
				.addClass('delete operation')
				.appendTo($div);
			if( change.isAuto() ){
				$del.addClass('autoOperation');
			};
			
			$('<button>')
				.addClass('discard')
				.text( _loc('Discard') )
				.appendTo($del)
				.click(discardClickFn);
			$('<button>')
				.addClass('proceed')
				.text( _loc('Delete Database Document') )
				.appendTo($del)
				.click(proceedClickFn);

			var explanation = _loc('Delete existing document');
			if( change.isAuto() ){
				explanation += ' ' +_loc('AUTO');
			};
			$('<div>')
				.addClass('explanation')
				.text( explanation )
				.appendTo($del);
			$('<div>')
				.addClass('geoJsonId')
				.text( 'Import ID: '+importId )
				.appendTo($del);
			$('<div>')
				.addClass('docId')
				.text( 'Database ID: '+doc._id )
				.appendTo($del);
			var $properties = $('<div>')
				.addClass('properties')
				.appendTo($del);
		};
	},
	
	_printValue: function(value){
		if( value === null ){
			return 'null';
			
		} else if( typeof value === 'undefined' ){
			return 'undefined';

		} else if( typeof value === 'string' ){
			return '"'+value+'"';

		} else if( typeof value === 'number' ){
			return ''+value;

		} else if( typeof value === 'boolean' ){
			return ''+value;

		} else if( typeof value === 'object' ){
			if( typeof value.wkt === 'string' ){
				// Geometry
				return value.wkt;
			};
		};
		
		return '<?>';
	},
	
	_proceed: function($button){
		var $opsElem = $button.parents('.operation');
		this._proceedWithOperationElement({
			elem: $opsElem
		});
	},

	_proceedAll: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		this._proceedElementsWithSelector({
			selector: '.operation'
			,onSuccess: opts.onSuccess
			,onError: opts.onError
		});
	},

	_proceedAutomatics: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		this._proceedElementsWithSelector({
			selector: '.autoOperation'
			,onSuccess: opts.onSuccess
			,onError: opts.onError
		});
	},

	_proceedElementsWithSelector: function(opts_){
		var opts = $n2.extend({
			selector: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);

		var _this = this;

		// Open dialog
		var dialogId = $n2.getUniqueId();
		var $diag = $('<div>')
			.attr('id',dialogId);
		$('<span>')
			.addClass('n2ImportProfile_progressDialog_text')
			.appendTo($diag);
		$diag.dialog({
			autoOpen: true
			,title: _loc('Proceed with Import Operations')
			,modal: true
			,width: 'auto'
			,close: function(event, ui){
				var $diag = $('#'+dialogId);
				$diag.remove();
			}
		});
		
		// Remember count
		var count = undefined;

		processNext();
		
		function processNext(){
			var $elem = _this._getElem();
			var $changes = $elem.find('.changes');
			var $ops = $changes.find(opts.selector);
			
			if( typeof count === 'undefined' ){
				count = $ops.length;
			};
			
			if( $ops.length > 0 ){
				var index = count - $ops.length + 1;
				$('#'+dialogId).find('.n2ImportProfile_progressDialog_text')
					.text( _loc('Operation {index} of {count}',{
						index: index
						,count: count
					}) );
				
				_this._proceedWithOperationElement({
					elem: $ops.first()
					,onSuccess: processNext
					,onError: opts.onError
				});
			} else {
				// Done
				$('#'+dialogId).dialog('close');
				opts.onSuccess();
			};
		};
	},
	
	_proceedWithOperationElement: function(opts_){
		var opts = $n2.extend({
			elem: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var $opsElem = opts.elem;
		
		var changeId = $opsElem.attr('id');
		var change = this.analysis.getChange(changeId);
		if( change.isAddition ){
			// Create doc
			this._createDocument({
				change:change
				,onSuccess: opts.onSuccess
				,onError: opts.onError
			});
			
		} else if( change.isModification ){
			// Modify document
			this._modifyDocument({
				change:change
				,onSuccess: opts.onSuccess
				,onError: opts.onError
			});
			
		} else if( change.isDeletion ){
			// Delete database document
			this._deleteDocument({
				change:change
				,onSuccess:opts.onSuccess
				,onError: opts.onError
			});
			
		} else {
			alert( _loc('Operation not recognized') );
			opts.onError('Operation not recognized');
		};
	},

	_discard: function($button){
		var $opsElem = $button.parents('.operation');
		var elemId = $opsElem.attr('id');
		this._completed(elemId);
	},
	
	_collisionSelectionClicked: function($btn){
		var analysis = this.analysis;
		var changes = analysis.getChanges();
		var collisionId = $btn.attr('name');
		var changeId = $btn.attr('data-changeId');
		
		var change = analysis.getChange(changeId);
		var collision = change.getCollisionFromId(collisionId);
		
		var value = $btn.val();
		if( 'current' === value ){
			collision.setKeepCurrentValue();
		} else if( 'updateValue' === value ) {
			collision.setUpdateValue();
		} else {
			throw Error('Unexpected value: '+value);
		};
		
		// Refresh display
		var $div = $('#'+change.getId());
		this._refreshChangeDiv(change, $div);
	},

	_completed: function(elemId){
		this.analysis.removeChange(elemId);
		$('#'+elemId).remove();
	},
	
	_createDocument: function(opts_){
		var opts = $n2.extend({
			change: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var change = opts.change;
		
		var changeId = change.importId;
		var importEntry = this.analysis.getImportEntry(changeId);
		var importProfile = this.analysis.getImportProfile();
		var schema = importProfile.getSchema();
		var layerName = importProfile.getLayerName();
		
		// Use null last import entry for creating document
		var lastImportEntry = new ImportEntryFromDoc({doc:undefined});
		
		var doc = null;
		if( schema ){
			doc = schema.createObject();
			
			// Remove attachment instructions
			if( doc.nunaliit_attachments ){
				delete doc.nunaliit_attachments;
			};

		} else {
			doc = {};
		};
		
		// Schema name
		if( !doc.nunaliit_schema
		 && schema ) {
			doc.nunaliit_schema = schema.name;
		};
		
		// Layer id
		if( layerName ) {
			if( !doc.nunaliit_layers ){
				doc.nunaliit_layers = [];
			};
			if( doc.nunaliit_layers.indexOf(layerName) < 0 ){
				doc.nunaliit_layers.push(layerName);
			};
		};
		
		// Install import entry data to attachment
		this._updateImportAttachment(doc, importProfile, importEntry);
		
		// Perform copy operations
		var copyOperations = change.getEffectiveCopyOperations();
		importProfile.performCopyOperations(doc, copyOperations, importEntry);
			
		// Adjust document with created, last updated
		if( $n2.couchMap
		 && $n2.couchMap.adjustDocument ) {
			$n2.couchMap.adjustDocument(doc);
		};
		
		// Save
		var atlasDb = importProfile.getAtlasDb();
		atlasDb.createDocument({
			data: doc
			,onSuccess: function(docInfo){
				_this._log( _loc('Created document with id: {id}',{id:docInfo.id}) );
				_this._completed(change.changeId);
				opts.onSuccess();
			}
			,onError: function(errorMsg){ 
				//reportError(errorMsg);
				alert( _loc('Unable to create document. Are you logged in?') );
				opts.onError(errorMsg);
			}
		});
	},
	
	_modifyDocument: function(opts_){
		var opts = $n2.extend({
			change: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var change = opts.change;
		
		var importId = change.importId;
		var doc = this.analysis.getDbDoc(importId);
		var importEntry = this.analysis.getImportEntry(importId);
		var importProfile = this.analysis.getImportProfile();
		var schema = importProfile.getSchema();

		// Install import entry data to attachment
		this._updateImportAttachment(doc, importProfile, importEntry);
		
		// Schema name
		if( !doc.nunaliit_schema
		 && schema ) {
			doc.nunaliit_schema = schema.name;
		};
		
		// Check that all collisions are resolved
		if( !change.isResolved() ){
			throw 'Invalid state for change since some collision is not resolved';
		};

		// Perform copy operations
		var copyOperations = change.getEffectiveCopyOperations();
		importProfile.performCopyOperations(doc, copyOperations, importEntry);
		
		// Adjust document with created, last updated
		if( $n2.couchMap
		 && $n2.couchMap.adjustDocument ) {
			$n2.couchMap.adjustDocument(doc);
		};
		
		// Save
		var atlasDb = importProfile.getAtlasDb();
		atlasDb.updateDocument({
			data: doc
			,onSuccess: function(docInfo){
				_this._log( _loc('Updated document with id: {id}',{id:docInfo.id}) );
				_this._completed(change.changeId);
				opts.onSuccess();
			}
			,onError: function(errorMsg){ 
				// reportError(errorMsg);
				alert( _loc('Unable to update document. Are you logged in?') );
				opts.onError(errorMsg);
			}
		});
	},
	
	_deleteDocument: function(opts_){
		var opts = $n2.extend({
			change: null
			,onSuccess: function(){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;

		var change = opts.change;
		
		var importId = change.importId;
		var doc = this.analysis.getDbDoc(importId);
		var importProfile = this.analysis.getImportProfile();
		
		// Delete
		var atlasDb = importProfile.getAtlasDb();
		atlasDb.deleteDocument({
			data: doc
			,onSuccess: function(docInfo){
				_this._log( _loc('Deleted document with id: {id}',{id:docInfo.id}) );
				_this._completed(change.changeId);
				opts.onSuccess();
			}
			,onError: function(errorMsg){ 
				// reportError(errorMsg);
				alert( _loc('Unable to delete document. Are you logged in?') );
				opts.onError(errorMsg);
			}
		});
	},
	
	_updateImportAttachment: function(doc, importProfile, importEntry){
		if( !doc.nunaliit_import ){
			doc.nunaliit_import = {
				id: importEntry.getId()
				,profile: importProfile.getId()
				,dataAttachmentName: 'nunaliit_import'
			};
		};

		// For legacy documents
		if( doc.nunaliit_import.data ){
			delete doc.nunaliit_import.data;
		};
		if( doc.nunaliit_import.wkt ){
			delete doc.nunaliit_import.wkt;
		};

		// Make up attachment
		var att = {
			data: {},
			wkt: undefined
		};
		att.id = importEntry.getId();
		att.profile = importProfile.getId();
		var geom = importEntry.getGeometry();
		if( geom ){
			att.wkt = geom;
		};
		var importProperties = importEntry.getProperties();
		for(var propName in importProperties){
			var propValue = importProperties[propName];
			att.data[propName] = propValue;
		};
		
		// Inline attachments are Base64 encoded
		var jsonAtt = JSON.stringify(att);
		var b64JsonAtt = $n2.Base64.encode(jsonAtt);
		if( !doc._attachments ){
			doc._attachments = {};
		};
		doc._attachments['nunaliit_import'] = {
			content_type: 'text/json'
			,data: b64JsonAtt
		};
	}
});

//=========================================================================
var ImportProfileOperation = $n2.Class({
	initialize: function(){
		
	},
	
	reportCopyOperations: function(opts_){
		throw 'Subclasses of ImportProfileOperation must implement "reportCopyOperations()"';
	},
	
	performCopyOperation: function(opts_){
		throw 'Subclasses of ImportProfileOperation must implement "performCopyOperation()"';
	}
});

//=========================================================================
var OPERATION_COPY_ALL = /^\s*copyAll\((.*)\)\s*$/;

var ImportProfileOperationCopyAll = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.operationString = opts.operationString;
		
		var matcher = OPERATION_COPY_ALL.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationCopyAll: '+operationString;
		};
		
		this.targetSelector = $n2.objectSelector.parseSelector(matcher[1]);
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);

		
		var copyOperations = [];
		
		var importData = opts.importEntry.getProperties();
		var lastImportData = opts.lastImportEntry.getProperties();
		
		for(var i=0,e=opts.allPropertyNames.length; i<e; ++i){
			var key = opts.allPropertyNames[i];
			
			var targetSelector = this.targetSelector.getChildSelector(key);
			var targetValue = targetSelector.getValue(opts.doc);
			
			var importValue = importData[key];
			var lastImportValue = lastImportData[key];
			
			var changedSinceLastImport = true;
			if( lastImportValue === targetValue ){
				changedSinceLastImport = false;
			};

			var isEqual = false;
			if( importValue === targetValue ){
				isEqual = true;
			};
			
			copyOperations.push({
				propertyNames: [key]
				,computedValue: importValue
				,targetSelector: targetSelector
				,targetValue: targetValue
				,isEqual: isEqual
				,changedSinceLastImport: changedSinceLastImport
			});
		};
		
		opts.onSuccess(copyOperations);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var key = opts.copyOperation.propertyNames[0];
		var targetSelector = opts.copyOperation.targetSelector;
		var importData = opts.importEntry.getProperties();
		var importValue = importData[key];
		
		if( typeof importValue === 'undefined' ){
			targetSelector.removeValue(opts.doc);
		} else {
			targetSelector.setValue(opts.doc, importValue, true);
		};
	}
});

addOperationPattern(OPERATION_COPY_ALL, ImportProfileOperationCopyAll);

//=========================================================================
var OPERATION_COPY_ALL_AND_FIX_NAMES = /^\s*copyAllAndFixNames\((.*)\)\s*$/;

var ImportProfileOperationCopyAllAndFixNames = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.operationString = opts.operationString;
		
		var matcher = OPERATION_COPY_ALL_AND_FIX_NAMES.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationCopyAllAndFixNames: '+operationString;
		};
		
		this.targetSelector = $n2.objectSelector.parseSelector(matcher[1]);
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);

		
		var copyOperations = [];
		
		var importData = opts.importEntry.getProperties();
		var lastImportData = opts.lastImportEntry.getProperties();
		
		for(var i=0,e=opts.allPropertyNames.length; i<e; ++i){
			var key = opts.allPropertyNames[i];
			
			var fixedKey = this._fixKey(key);
			
			var targetSelector = this.targetSelector.getChildSelector(fixedKey);
			var targetValue = targetSelector.getValue(opts.doc);
			
			var importValue = importData[key];
			var lastImportValue = lastImportData[key];
			
			var changedSinceLastImport = true;
			if( lastImportValue === targetValue ){
				changedSinceLastImport = false;
			};

			var isEqual = false;
			if( importValue === targetValue ){
				isEqual = true;
			};
			
			copyOperations.push({
				propertyNames: [key]
				,computedValue: importValue
				,targetSelector: targetSelector
				,targetValue: targetValue
				,isEqual: isEqual
				,changedSinceLastImport: changedSinceLastImport
			});
		};
		
		opts.onSuccess(copyOperations);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var key = opts.copyOperation.propertyNames[0];
		var targetSelector = opts.copyOperation.targetSelector;
		var importData = opts.importEntry.getProperties();
		var importValue = importData[key];
		
		if( typeof importValue === 'undefined' ){
			targetSelector.removeValue(opts.doc);
		} else {
			targetSelector.setValue(opts.doc, importValue, true);
		};
	},
	
	_fixKey: function(key){
		var fixedKey = [];
		var specialChars = " _.(){}[]!@#$%^&*-+=:;,'\"\\/~`<>";
		
		var lastCharWasUnderscore = false;
		for(var i=0,e=key.length; i<e; ++i){
			var c = key[i];
			
			if( specialChars.indexOf(c) >= 0 ) {
				if( !lastCharWasUnderscore ){ 
					fixedKey.push('_');
					lastCharWasUnderscore = true;
				};
			} else {
				fixedKey.push(c); 
				lastCharWasUnderscore = false;
			};
		};
		
		return fixedKey.join('');
	}
});

addOperationPattern(OPERATION_COPY_ALL_AND_FIX_NAMES, ImportProfileOperationCopyAllAndFixNames);

//=========================================================================
// assign(demo_doc.title,'title')
var OPERATION_ASSIGN = /^\s*assign\((.*),\s*'([^']*)'\s*\)\s*$/;

var ImportProfileOperationAssign = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	sourceName: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.operationString = opts.operationString;
		
		var matcher = OPERATION_ASSIGN.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationAssign: '+operationString;
		};
		
		this.targetSelector = $n2.objectSelector.parseSelector(matcher[1]);
		this.sourceName = matcher[2];
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var copyOperations = [];

		var importData = opts.importEntry.getProperties();
		var lastImportData = opts.lastImportEntry.getProperties();

		if( opts.allPropertyNames.indexOf(this.sourceName) >= 0 ){
			var importValue = importData[this.sourceName];
			var lastImportValue = lastImportData[this.sourceName];

			var targetValue = this.targetSelector.getValue(opts.doc);
			
			var changedSinceLastImport = true;
			if( lastImportValue === targetValue ){
				changedSinceLastImport = false;
			};

			var isEqual = false;
			if( importValue === targetValue ){
				isEqual = true;
			};
			
			copyOperations.push({
				propertyNames: [this.sourceName]
				,computedValue: importValue
				,targetSelector: this.targetSelector
				,targetValue: targetValue
				,isEqual: isEqual
				,changedSinceLastImport: changedSinceLastImport
			});
		};
		
		opts.onSuccess(copyOperations);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var importData = opts.importEntry.getProperties();
		var importValue = importData[this.sourceName];
		if( typeof importValue === 'undefined' ){
			// Must delete
			this.targetSelector.removeValue(opts.doc);
		} else {
			this.targetSelector.setValue(opts.doc, importValue, true);
		};
	}
});

addOperationPattern(OPERATION_ASSIGN, ImportProfileOperationAssign);

//=========================================================================
var OPERATION_LONGLAT = /^\s*longLat\(\s*'([^']*)'\s*,\s*'([^']*)'\s*\)\s*$/;

var ImportProfileOperationLongLat = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	longName: null,
	
	latName: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
	
		this.operationString = opts.operationString;
		
		var matcher = OPERATION_LONGLAT.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationLongLat: '+operationString;
		};
		
		this.longName = matcher[1];
		this.latName = matcher[2];
		
		this.targetSelector = $n2.objectSelector.parseSelector('nunaliit_geom');
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var copyOperations = [];

		var importData = opts.importEntry.getProperties();
		var lastImportData = opts.lastImportEntry.getProperties();

		if( opts.allPropertyNames.indexOf(this.longName) >= 0 
		 && opts.allPropertyNames.indexOf(this.latName) >= 0 ){

			// Compute new value
			var longValue = importData[this.longName];
			var latValue = importData[this.latName];
			var importWkt = this._computeWKT(longValue, latValue);
			var importGeom = this._computeGeometry(importWkt);

			// Compute last imported value
			var lastLongValue = lastImportData[this.longName];
			var lastLatValue = lastImportData[this.latName];
			var lastImportWkt = this._computeWKT(lastLongValue, lastLatValue);
			var lastImportGeom = this._computeGeometry(lastImportWkt);

			var targetGeom = this.targetSelector.getValue(opts.doc);
			var targetWkt = undefined;
			if( targetGeom ){
				targetWkt = targetGeom.wkt;
			};
			
			var changedSinceLastImport = true;
			if( lastImportWkt === targetWkt ){
				changedSinceLastImport = false;
			};

			var isEqual = false;
			if( importWkt === targetWkt ){
				isEqual = true;
			};
			
			copyOperations.push({
				propertyNames: [this.longName, this.latName]
				,computedValue: importGeom
				,targetSelector: this.targetSelector
				,targetValue: targetGeom
				,isEqual: isEqual
				,changedSinceLastImport: changedSinceLastImport
			});
		};
		
		opts.onSuccess(copyOperations);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var doc = opts.doc;
		
		var computedValue = opts.copyOperation.computedValue;
		
		if( typeof computedValue === 'undefined' ){
			// Must delete
			if( doc.nunaliit_geom ){
				delete doc.nunaliit_geom;
			};
		} else {
			doc.nunaliit_geom = computedValue;
		};
	},
	
	getGeometry: function(importData){
		var longValue = importData[this.longName];
		var latValue = importData[this.latName];
		
		var importValue = this._computeWKT(longValue, latValue);
		
		return importValue;
	},

	_computeGeometry: function(wkt){

		var nunaliit_geom = undefined;
		
		// Geometry
		if( wkt ){
			nunaliit_geom = {
				nunaliit_type: 'geometry'
			};
			nunaliit_geom.wkt = wkt;

			var olWkt = new OpenLayers.Format.WKT();
			var vectorFeature = olWkt.read(wkt);
			var bounds = vectorFeature.geometry.getBounds();
			nunaliit_geom.bbox = [ 
				bounds.left
				,bounds.bottom
				,bounds.right
				,bounds.top
			];
		};
		
		return nunaliit_geom;
	},
	
	_computeWKT: function(longValue, latValue){
		var wkt = undefined;
		if( typeof longValue !== 'undefined' 
		 && typeof latValue !== 'undefined' ){
			longValue = 1 * longValue;
			latValue = 1 * latValue;
			wkt = 'MULTIPOINT(('+longValue+' '+latValue+'))';
		};
		
		return wkt;
	}
});

addOperationPattern(OPERATION_LONGLAT, ImportProfileOperationLongLat);

//=========================================================================
var OPERATION_REF = /^\s*reference\(([^,]*),\s*'([^']*)'\s*\)\s*$/;

var ImportProfileOperationReference = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	refKey: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.operationString = opts.operationString;
		
		var matcher = OPERATION_REF.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationReference: '+operationString;
		};
		
		this.targetSelector = $n2.objectSelector.parseSelector(matcher[1]);
		this.refKey = matcher[2];
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var copyOperations = [];

		var importData = opts.importEntry.getProperties();
		var lastImportData = opts.lastImportEntry.getProperties();

		if( opts.allPropertyNames.indexOf(this.refKey) >= 0 ){
			var refId = importData[this.refKey];
			var lastRefId = lastImportData[this.refKey];
			
			var importValue = undefined;
			if( refId ){
				importValue = {
					nunaliit_type: 'reference'
					,doc: refId
				};
			};
			
			var targetValue = this.targetSelector.getValue(opts.doc);

			var targetRefId = undefined;
			if( typeof targetValue === 'object' 
			 && 'reference' === targetValue.nunaliit_type ){
				targetRefId = targetValue.doc;
			};

			var changedSinceLastImport = true;
			if( lastRefId === targetRefId ){
				changedSinceLastImport = false;
			};

			var isEqual = false;
			if( refId === targetRefId ){
				isEqual = true;
			};
			
			copyOperations.push({
				propertyNames: [this.refKey]
				,computedValue: importValue
				,targetSelector: this.targetSelector
				,targetValue: targetValue
				,isEqual: isEqual
				,changedSinceLastImport: changedSinceLastImport
			});
		};
		
		opts.onSuccess(copyOperations);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var doc = opts.doc;
		
		var importData = opts.importEntry.getProperties();
		var refId = importData[this.refKey];
		
		var importValue = undefined;
		if( refId ){
			importValue = {
				nunaliit_type: 'reference'
				,doc: refId
			};
		};

		if( typeof importValue === 'undefined' ){
			// Must delete
			this.targetSelector.removeValue(doc);
		} else {
			this.targetSelector.setValue(doc, importValue, true);
		};
	}
});

addOperationPattern(OPERATION_REF, ImportProfileOperationReference);

//=========================================================================
var OPERATION_IMPORT_REF = /^\s*importReference\(([^,]*),\s*'([^']*)'\s*,\s*'([^']*)'\s*\)\s*$/;

var ImportProfileOperationImportReference = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	atlasDesign: null,
	
	profileId: null,
	
	importId: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.operationString = opts.operationString;
		this.atlasDesign = opts.atlasDesign;
		
		var matcher = OPERATION_IMPORT_REF.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationImportReference: '+operationString;
		};
		
		this.targetSelector = $n2.objectSelector.parseSelector(matcher[1]);
		this.profileId = matcher[2];
		this.importId = matcher[3];
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var _this = this;

		var importData = opts.importEntry.getProperties();
		var lastImportData = opts.lastImportEntry.getProperties();
		
		var computedRefId = undefined;

		if( opts.allPropertyNames.indexOf(this.importId) >= 0 ){
			var importId = importData[this.importId];
	
			this._getDocIdFromImportId({
				importId: importId
				,onSuccess: setComputedReference
				,onError: function(err){
					setComputedReference(undefined);
				}
			});
			
		} else {
			// entry does not have data for import id
			setComputedReference(undefined);
		};
		
		function setComputedReference(refId){
			computedRefId = refId;

			if( opts.allPropertyNames.indexOf(_this.importId) >= 0 ){
				var lastImportId = lastImportData[_this.importId];
		
				this._getDocIdFromImportId({
					importId: lastImportId
					,onSuccess: setLastReference
					,onError: function(err){
						setLastReference(undefined);
					}
				});
				
			} else {
				// entry does not have data for import id
				setLastReference(undefined);
			};
		};
		
		function setLastReference(lastRefId){

			var copyOperations = [];
			
			var importValue = undefined;
			if( computedRefId ){
				importValue = {
					nunaliit_type: 'reference'
					,doc: computedRefId
				};
			};
			
			var targetValue = _this.targetSelector.getValue(opts.doc);
			
			var targetRefId = undefined;
			if( typeof targetValue === 'object' 
			 && 'reference' === targetValue.nunaliit_type ){
				targetRefId = targetValue.doc;
			};

			var changedSinceLastImport = true;
			if( lastRefId === targetRefId ){
				changedSinceLastImport = false;
			};

			var isEqual = false;
			if( computedRefId === targetRefId ){
				isEqual = true;
			};
			
			copyOperations.push({
				propertyNames: [_this.importId]
				,computedValue: importValue
				,targetSelector: _this.targetSelector
				,targetValue: targetValue
				,isEqual: isEqual
				,changedSinceLastImport: changedSinceLastImport
			});
			
			opts.onSuccess(copyOperations);
		};
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var doc = opts.doc;
		
		var importData = opts.importEntry.getProperties();
		var refId = importData[this.refKey];
		
		var importValue = undefined;
		if( opts.copyOperation 
		 && opts.copyOperation.computedValue ){
			importValue = opts.copyOperation.computedValue;
		};

		if( typeof importValue === 'undefined' ){
			// Must delete
			this.targetSelector.removeValue(doc);
		} else {
			this.targetSelector.setValue(doc, importValue, true);
		};
	},
	
	_getDocIdFromImportId: function(opts_){
		var opts = $n2.extend({
			importId: undefined
			,onSuccess: function(docId){}
			,onError: function(err){}
		},opts_);

		var importId = opts.importId;
		if( undefined === importId ){
			opts.onSuccess(undefined);
		} else {
			this.atlasDesign.queryView({
				viewName: 'nunaliit-import'
				,startkey: [this.profileId, importId]
				,endkey: [this.profileId, importId]
				,onSuccess: function(rows){
					var refId = undefined;
					for(var i=0,e=rows.length; i<e; ++i){
						var row = rows[i];
						refId = row.id;
					};
					opts.onSuccess(refId);
				}
				,onError: function(err){
					opts.onError(err);
				}
			});
		};
	}
});

addOperationPattern(OPERATION_IMPORT_REF, ImportProfileOperationImportReference);

//=========================================================================
var OPERATION_SET_VALUE = /^\s*setValue\((.*),\s*(.*)\s*\)\s*$/;

var ImportProfileOperationSetValue = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	value: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.operationString = opts.operationString;
		
		var matcher = OPERATION_SET_VALUE.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationSetValue: '+operationString;
		};
		
		this.targetSelector = $n2.objectSelector.parseSelector(matcher[1]);
		var value = matcher[2];
		if( value.length > 2 
		 && value[0] === '\'' 
		 && value[value.length-1] === '\'' ){
			this.value = value.substr(1,value.length-2);
		} else if( 'null' === value ){
			this.value = null;
		} else if( 'true' === value ){
			this.value = true;
		} else if( 'false' === value ){
			this.value = false;
		} else {
			this.value = 1 * value;
		};
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var copyOperations = [];

		var targetValue = this.targetSelector.getValue(opts.doc);

		var changedSinceLastImport = true;
		if( this.value === targetValue ){
			changedSinceLastImport = false;
		};

		var isEqual = false;
		if( this.value === targetValue ){
			isEqual = true;
		};
		
		copyOperations.push({
			propertyNames: []
			,computedValue: this.value
			,targetSelector: this.targetSelector
			,targetValue: targetValue
			,isEqual: isEqual
			,changedSinceLastImport: changedSinceLastImport
		});
		
		opts.onSuccess(copyOperations);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		if( this.value === undefined ){
			// Must delete
			this.targetSelector.removeValue(opts.doc);
		} else {
			this.targetSelector.setValue(opts.doc, this.value, true);
		};
	}
});

addOperationPattern(OPERATION_SET_VALUE, ImportProfileOperationSetValue);

//=========================================================================
// findReference(<target-selector>,<key-selection>,<reference-selection>)
var OPERATION_FIND_REF = /^\s*findReference\(([^,]*),\s*'([^']*)'\s*,\s*'([^']*)'\s*\)\s*$/;

var ImportProfileOperationFindReference = $n2.Class(ImportProfileOperation, {
	
	operationString: null,
	
	atlasDesign: null,
	
	profileId: null,
	
	importId: null,
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: null
			,atlasDb: null
			,atlasDesign: null
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.operationString = opts.operationString;
		this.atlasDesign = opts.atlasDesign;
		
		var matcher = OPERATION_IMPORT_REF.exec(this.operationString);
		if( !matcher ) {
			throw 'Invalid operation string for ImportProfileOperationImportReference: '+operationString;
		};
		
		this.targetSelector = $n2.objectSelector.parseSelector(matcher[1]);
		this.profileId = matcher[2];
		this.importId = matcher[3];
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var _this = this;

		var importData = opts.importEntry.getProperties();
		var lastImportData = opts.lastImportEntry.getProperties();

		var computedRefId = undefined;

		if( opts.allPropertyNames.indexOf(this.importId) >= 0 ){
			var importId = importData[this.importId];
			
			this._getDocIdFromImportId({
				importId: importId
				,onSuccess: setComputedReference
				,onError: function(err){
					setComputedReference(undefined);
				}
			});
			
		} else {
			// entry does not have data for import id
			setComputedReference(undefined);
		};
		
		function setComputedReference(refId){
			computedRefId = refId;

			if( opts.allPropertyNames.indexOf(_this.importId) >= 0 ){
				var lastImportId = lastImportData[_this.importId];
				
				_this._getDocIdFromImportId({
					importId: lastImportId
					,onSuccess: setLastReference
					,onError: function(err){
						setLastReference(undefined);
					}
				});
				
			} else {
				// entry does not have data for import id
				setLastReference(undefined);
			};
		};
		
		function setLastReference(lastRefId){
			var copyOperations = [];
			
			var importValue = undefined;
			if( refId ){
				importValue = {
					nunaliit_type: 'reference'
					,doc: refId
				};
			};
			
			var targetValue = _this.targetSelector.getValue(opts.doc);
			
			var targetRefId = undefined;
			if( typeof targetValue === 'object' 
			 && 'reference' === targetValue.nunaliit_type ){
				targetRefId = targetValue.doc;
			};

			var changedSinceLastImport = true;
			if( lastRefId === targetRefId ){
				changedSinceLastImport = false;
			};

			var isEqual = false;
			if( computedRefId === targetRefId ){
				isEqual = true;
			};

			copyOperations.push({
				propertyNames: [_this.importId]
				,computedValue: importValue
				,targetSelector: _this.targetSelector
				,targetValue: targetValue
				,isEqual: isEqual
				,changedSinceLastImport: changedSinceLastImport
			});
			
			opts.onSuccess(copyOperations);
		};
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var doc = opts.doc;
		
		var importData = opts.importEntry.getProperties();
		var refId = importData[this.refKey];
		
		var importValue = undefined;
		if( opts.copyOperation 
		 && opts.copyOperation.computedValue ){
			importValue = opts.copyOperation.computedValue;
		};

		if( typeof importValue === 'undefined' ){
			// Must delete
			this.targetSelector.removeValue(doc);
		} else {
			this.targetSelector.setValue(doc, importValue, true);
		};
	},
	
	_getDocIdFromImportId: function(opts_){
		var opts = $n2.extend({
			importId: undefined
			,onSuccess: function(docId){}
			,onError: function(err){}
		},opts_);

		var importId = opts.importId;
		if( undefined === importId ){
			opts.onSuccess(undefined);
		} else {
			this.atlasDesign.queryView({
				viewName: 'nunaliit-import'
				,startkey: [this.profileId, importId]
				,endkey: [this.profileId, importId]
				,onSuccess: function(rows){
					var refId = undefined;
					for(var i=0,e=rows.length; i<e; ++i){
						var row = rows[i];
						refId = row.id;
					};
					opts.onSuccess(refId);
				}
				,onError: function(err){
					opts.onError(err);
				}
			});
		};
	}
});

addOperationPattern(OPERATION_FIND_REF, ImportProfileOperationFindReference);

//=========================================================================

var ImportProfileOperationParsed = $n2.Class('ImportProfileOperationParsed', ImportProfileOperation, {

	operationString: null,

	program: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			operationString: undefined
			,program: undefined
			,atlasDb: undefined
			,atlasDesign: undefined
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);

		this.operationString = opts.operationString;
		this.program = opts.program;
		
		this.program.configure(opts);
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		this.program.reportCopyOperations(opts);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		this.program.performCopyOperation(opts);
	}
});

//=========================================================================
// This operation is used by the GeoJSON import profile for handling the
// geometry
var ImportProfileOperationGeoJSON = $n2.Class('ImportProfileOperationGeoJSON', ImportProfileOperation, {
	
	targetSelector: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
		},opts_);
		
		ImportProfileOperation.prototype.initialize.call(this);
		
		this.targetSelector = new $n2.objectSelector.ObjectSelector(['nunaliit_geom']);
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var _this = this;

		var importWkt = opts.importEntry.getGeometry();
		var lastImportWkt = opts.lastImportEntry.getGeometry();

		var importValue = undefined;
		if( importWkt ){
			importValue = this._computeGeometry(importWkt);
		};

		var lastImportValue = undefined;
		if( lastImportWkt ){
			lastImportValue = this._computeGeometry(lastImportWkt);
		};
		
		var targetValue = this.targetSelector.getValue(opts.doc);
		
		var targetWkt = undefined;
		if( typeof targetValue === 'object' 
		 && 'geometry' === targetValue.nunaliit_type ){
			targetWkt = targetValue.wkt;
		};

		var changedSinceLastImport = true;
		if( lastImportWkt === targetWkt ){
			changedSinceLastImport = false;
		};

		var isEqual = false;
		if( importWkt === targetWkt ){
			isEqual = true;
		};

		var copyOperations = [];
		copyOperations.push({
			propertyNames: [GEOM_PROP_NAME]
			,computedValue: importValue
			,targetSelector: this.targetSelector
			,targetValue: targetValue
			,isEqual: isEqual
			,changedSinceLastImport: changedSinceLastImport
		});
		
		opts.onSuccess(copyOperations);
	},
	
	performCopyOperation: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,copyOperation: null
		},opts_);
		
		var doc = opts.doc;
		
		var importValue = undefined;
		if( opts.copyOperation 
		 && opts.copyOperation.computedValue ){
			importValue = opts.copyOperation.computedValue;
		};

		if( typeof importValue === 'undefined' ){
			// Must delete
			this.targetSelector.removeValue(doc);
		} else {
			this.targetSelector.setValue(doc, importValue, true);
		};
	},
	
	_computeGeometry: function(importWkt){

		var nunaliit_geom = undefined;
		
		// Geometry
		if( importWkt ){
			nunaliit_geom = {
				nunaliit_type: 'geometry'
			};
			nunaliit_geom.wkt = importWkt;

			var olWkt = new OpenLayers.Format.WKT();
			var vectorFeature = olWkt.read(importWkt);
			var bounds = vectorFeature.geometry.getBounds();
			nunaliit_geom.bbox = [ 
				bounds.left
				,bounds.bottom
				,bounds.right
				,bounds.top
			];
		};
		
		return nunaliit_geom;
	}
});

//=========================================================================
var ImportEntry = $n2.Class({
	initialize: function(){
		
	},
	
	getId: function(){
		throw 'Subclasses to ImportEntry must implement getId()';
	},
	
	getProperties: function(){
		throw 'Subclasses to ImportEntry must implement getProperties()';
	},
	
	/**
	 * Returns WKT of geometry
	 */
	getGeometry: function(){
		throw 'Subclasses to ImportEntry must implement getGeometry()';
	}
});

//=========================================================================
var ImportProfile = $n2.Class({
	id: null,
	
	sessionId: null,
	
	label: null,
	
	unrelated: null,
	
	layerName: null,
	
	schema: null,
	
	operations: null,
	
	operationsById: null,

	atlasDb: null,

	atlasDesign: null,

	dispatchService: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			id: undefined
			,label: undefined
			,unrelated: false
			,layerName: undefined
			,schema: undefined
			,operations: undefined
			,atlasDb: undefined
			,atlasDesign: undefined
			,dispatchService: undefined
		},opts_);
		
		this.id = opts.id;
		this.label = opts.label;
		this.unrelated = opts.unrelated;
		this.layerName = opts.layerName;
		this.schema = opts.schema;
		this.atlasDb = opts.atlasDb;
		this.atlasDesign = opts.atlasDesign;
		this.dispatchService = opts.dispatchService;

		this.operations = [];
		this.operationsById = {};
		if( $n2.isArray(opts.operations) ) {
			for(var i=0,e=opts.operations.length; i<e; ++i){
				var operation = opts.operations[i];
				this._addOperation(operation);
			};
		};
		
		this.sessionId = this.id + '_' +  (new Date()).toISOString();
	},
	
	getType: function(){
		throw 'getType() must be implemented by all subclasses of ImportProfile';
	},
	
	parseEntries: function(opts){
		throw 'parseEntries() must be implemented by all subclasses of ImportProfile';
	},
	
	getId: function(){
		// unrelated means that this import does not relate
		// to any other import. Therefore, assign a session id
		// instead of a profile id. This way, next time this profile
		// is used, it will not relate to anything that was imported
		// previously
		if( this.unrelated ){
			return this.sessionId;
		};

		return this.id;
	},
	
	getLabel: function(){
		return this.label;
	},
	
	getLayerName: function(){
		return this.layerName;
	},
	
	getSchema: function(){
		return this.schema;
	},
	
	getAtlasDb: function(){
		return this.atlasDb;
	},
	
	performImportAnalysis: function(opts_){
		var opts = $n2.extend({
			entries: null
			,onSuccess: function(analysis){}
			,onError: function(err){}
		},opts_);
		
		var analyzer = new ImportAnalyzer({
			profile: this
			,atlasDesign: this.atlasDesign
			,dispatchService: this.dispatchService
		});
		analyzer.analyzeEntries({
			entries: opts.entries
			,onSuccess: opts.onSuccess
			,onError: opts.onError
		});
	},
	
	reportCopyOperations: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importEntry: null
			,lastImportEntry: null
			,allPropertyNames: null
			,onSuccess: function(copyOperations){}
		},opts_);
		
		var copyOperations = [];
		
		var operations = this.operations.slice(0); // clone
		
		report();
		
		function report(){
			if( operations.length < 1 ){
				opts.onSuccess(copyOperations);
				return;
			};
			
			var op = operations.shift(); // remove first element

			op.reportCopyOperations({
				doc: opts.doc
				,importEntry: opts.importEntry
				,lastImportEntry: opts.lastImportEntry
				,allPropertyNames: opts.allPropertyNames
				,onSuccess: function(copies){
					if( copies && copies.length ){
						copies.forEach(function(copy){
							copy._n2OpId = op._n2OpId;
							
							copyOperations.push(copy);
						});
					};
					
					// Perform next one
					window.setTimeout(report,0); // Do not blow stack on large operations
				}
			});
		};
	},
	
	performCopyOperations: function(doc, copyOperations, importEntry){
		var _this = this;

		copyOperations.forEach(function(copy){
			var opId = copy._n2OpId;
			var op = _this.operationsById[opId];
			
			if( op ){
				op.performCopyOperation({
					doc: doc
					,importEntry: importEntry
					,copyOperation: copy
				});
			};
		});
	},
	
	_addOperation: function(operation){
		var opId = operation._n2OpId;
		if( !opId ){
			opId = $n2.getUniqueId();
			operation._n2OpId = opId;
		};
		this.operations.push(operation);
		this.operationsById[opId] = operation;
	}
});

//=========================================================================
var ImportEntryFromDoc = $n2.Class('ImportEntryFromDoc', ImportEntry, {

	id: null,
	
	data: null,
	
	geometryWkt: null,
	
	initialize: function(opts_){
		
		ImportEntry.prototype.initialize.call(this,opts_);
		
		var opts = $n2.extend({
			doc: undefined
			,data: undefined
			,geometryWkt: undefined
		},opts_);
		
		this.id = undefined;
		this.data = opts.data ? opts.data : {};
		this.geometryWkt = opts.geometryWkt;
		
		var doc = opts.doc;
		if( doc 
		 && doc.nunaliit_import ){
			this.id = doc.nunaliit_import.id;
		};
	},

	getId: function(){
		return this.id;
	},
	
	getProperties: function(){
		return this.data;
	},
	
	/**
	 * Returns WKT of geometry
	 */
	getGeometry: function(){
		return this.geometryWkt;
	}
});

//=========================================================================
var ImportEntryJson = $n2.Class(ImportEntry, {
	
	data: null,
	
	profile: null,
	
	initialize: function(opts_){
		
		ImportEntry.prototype.initialize.call(this,opts_);
		
		var opts = $n2.extend({
			data: null
			,profile: null
		},opts_);
		
		this.data = opts.data;
		this.profile = opts.profile;
	},
	
	getId: function(){
		if( this.profile.ignoreId ){
			return undefined;
		};

		var idAttribute = this.profile.idAttribute;
		return this.data[idAttribute];
	},
	
	getProperties: function(){
		return this.data;
	},
	
	getGeometry: function(){
		return undefined;
	}
});

//=========================================================================
var ImportProfileJson = $n2.Class(ImportProfile, {
	
	idAttribute: null,

	ignoreId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			idAttribute: undefined
			,ignoreId: false
		},opts_);
		
		if( opts.ignoreId ){
			opts_.unrelated = true;
		};
		
		ImportProfile.prototype.initialize.call(this, opts_);

		this.idAttribute = opts.idAttribute;
		this.ignoreId = opts.ignoreId;
		
		if( this.ignoreId ){
			// Ignoring ids. Import all data
		} else if( !this.idAttribute ){
			throw 'Option "ignoreId" is set or "idAttribute" must be specified for ImportProfileJson';
		};
	},
	
	getType: function(){
		return 'json';
	},
	
	parseEntries: function(opts_){
		var opts = $n2.extend({
			importData: null
			,onSuccess: function(entries){}
			,onError: function(err){}
		},opts_);

		var importData = opts.importData;
		if( !importData ){
			opts.onError( _loc('Import data must be provided') );
			return;
		};
		
		// Parse JSON input
		var jsonObj = null;
		try {
			jsonObj = JSON.parse(importData);
		} catch(e) {
			opts.onError( _loc('Unable to parse import data: {err}',{err:e}) );
			return;
		};
		
		
		if( !$n2.isArray(jsonObj) ){
			opts.onError( _loc('JSON definition must be an array') );
			return;
		}
		
		var entries = [];
		for(var i=0,e=jsonObj.length; i<e; ++i){
			var jsonEntry = jsonObj[i];
			
			var props = {};
			for(var key in jsonEntry){
				if( !key ){
					// skip
				} else if( $n2.trim(key) === '' ) {
					// skip
				} else {
					props[key] = jsonEntry[key];
				};
			};
			
			var entry = new ImportEntryJson({
				data: props
				,profile: this
			});
			entries.push(entry);
		};
		
		opts.onSuccess(entries);
	}
});

//=========================================================================
var ImportEntryGeoJson = $n2.Class(ImportEntry, {
	
	id: null,
	
	data: null,
	
	profile: null,
	
	geom: undefined,
	
	initialize: function(opts_){
		
		ImportEntry.prototype.initialize.call(this,opts_);
		
		var opts = $n2.extend({
			id: null
			,data: null
			,geom: undefined
			,profile: null
		},opts_);
		
		this.id = opts.id;
		this.data = opts.data;
		this.geom = opts.geom;
		this.profile = opts.profile;
	},
	
	getId: function(){
		return this.id;
	},
	
	getProperties: function(){
		return this.data;
	},
	
	/**
	 * Returns WKT of geometry
	 */
	getGeometry: function(){
		return this.geom;
	}
});

//=========================================================================
var ImportProfileGeoJson = $n2.Class(ImportProfile, {
	
	idAttribute: null,
	
	olGeoJsonFormat: null,
	
	olWktFormat: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			idAttribute: undefined
		},opts_);
		
		ImportProfile.prototype.initialize.call(this, opts_);

		this.idAttribute = opts.idAttribute;
		
		if(OpenLayers 
		 && OpenLayers.Format 
		 && OpenLayers.Format.GeoJSON ){
			this.olGeoJsonFormat = new OpenLayers.Format.GeoJSON({
				ignoreExtraDims: true
			});
		};
		if(OpenLayers 
		 && OpenLayers.Format 
		 && OpenLayers.Format.WKT ){
			this.olWktFormat = new OpenLayers.Format.WKT();
		};
		if( !this.olGeoJsonFormat || !this.olWktFormat ){
			throw 'OpenLayers is required for ImportProfileGeoJson';
		};
		
		var geoJsonGeometry = new ImportProfileOperationGeoJSON();
		this._addOperation(geoJsonGeometry);
	},
	
	getType: function(){
		return 'geojson';
	},
	
	parseEntries: function(opts_){
		var opts = $n2.extend({
			importData: null
			,onSuccess: function(entries){}
			,onError: function(err){}
		},opts_);

		var importData = opts.importData;
		if( !importData ){
			opts.onError( _loc('Import data must be provided') );
			return;
		};
		
		// Deal with computed idAttribute values
		var idAttributeFn = undefined;
		if( typeof this.idAttribute === 'string'
		 && this.idAttribute.length > 0 
		 && this.idAttribute[0] === '=' ){
			idAttributeFn = $n2.styleRuleParser.parse(this.idAttribute.substr(1));
		};
		
		// Parse GeoJSON input
		var jsonObj = null;
		try {
			jsonObj = JSON.parse(importData);
		} catch(e) {
			opts.onError( _loc('Unable to parse import data: {err}',{err:e}) );
			return;
		};
		
		if( jsonObj.type !== 'FeatureCollection' ){
			opts.onError( _loc('GeoJSON import is supported only for type "FeatureCollection"') );
			return;
		};
		if( !$n2.isArray(jsonObj.features) ){
			opts.onError( _loc('GeoJSON definition must include an array named "features"') );
			return;
		}
		
		var entries = [];
		for(var i=0,e=jsonObj.features.length; i<e; ++i){
			var feature = jsonObj.features[i];
			
			var id = undefined;
			if( feature.id ){
				id = feature.id;
			};
			
			var props = {};
			if( feature.properties ){
				for(var key in feature.properties){
					if( !key ){
						// skip
					} else if( $n2.trim(key) === '' ) {
						// skip
					} else {
						props[key] = feature.properties[key];
					};
					
					if( key === this.idAttribute && !id ){
						id = feature.properties[key];
					};
				};
			};
			
			// Compute id from formula?
			if( typeof id === 'undefined'
			 && idAttributeFn
			 && typeof idAttributeFn.getValue === 'function' ){
				id = idAttributeFn.getValue(feature);
			};

			var geom = null;
			if( feature.geometry 
			 && this.olGeoJsonFormat ){
				var olGeom = this.olGeoJsonFormat.parseGeometry(feature.geometry);
				geom = this.olWktFormat.extractGeometry(olGeom);
			};
			
			var entry = new ImportEntryGeoJson({
				id: id
				,data: props
				,geom: geom
				,profile: this
			});
			entries.push(entry);
		};
		
		opts.onSuccess(entries);
	}
});

//=========================================================================
var ImportProfileCsv = $n2.Class(ImportProfile, {
	
	idAttribute: null,
	
	ignoreId: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			idAttribute: undefined
			,ignoreId: false
		},opts_);
		
		if( opts.ignoreId ){
			opts_.unrelated = true;
		};
		
		ImportProfile.prototype.initialize.call(this, opts_);

		this.idAttribute = opts.idAttribute;
		this.ignoreId = opts.ignoreId;

		if( this.ignoreId ){
			// Ignoring ids. Import all data
		} else if( !this.idAttribute ){
			throw 'Option "ignoreId" is set or "idAttribute" must be specified for ImportProfileCsv';
		};
	},
	
	getType: function(){
		return 'csv';
	},
	
	parseEntries: function(opts_){
		var opts = $n2.extend({
			importData: null
			,onSuccess: function(entries){}
			,onError: function(err){}
		},opts_);

		var importData = opts.importData;
		if( !importData ){
			opts.onError( _loc('Import data must be provided') );
			return;
		};
		
		// Parse CSV input
		var jsonObj = null;
		try {
			jsonObj = $n2.csv.Parse({csv:importData});
		} catch(e) {
			opts.onError( _loc('Unable to parse import data: {err}',{err:e}) );
			return;
		};
		
		
		if( !$n2.isArray(jsonObj) ){
			opts.onError( _loc('CSV definition should yield an array') );
			return;
		}
		
		var entries = [];
		for(var i=0,e=jsonObj.length; i<e; ++i){
			var jsonEntry = jsonObj[i];
			
			var props = {};
			for(var key in jsonEntry){
				if( !key ){
					// skip
				} else if( $n2.trim(key) === '' ) {
					// skip
				} else {
					props[key] = jsonEntry[key];
				};
			};
			
			var entry = new ImportEntryJson({
				data: props
				,profile: this
			});
			entries.push(entry);
		};
		
		opts.onSuccess(entries);
	}
});

//=========================================================================
var ReferencesFromSchema = $n2.Class('ReferencesFromSchema',{

	atlasDesign: null,

	docsbySchemaName: null,
	
	initialize: function(opts_){
		var opts= $n2.extend({
			atlasDesign: undefined
			,globalContext: undefined
		},opts_);

		var _this = this;

		this.atlasDesign = opts.atlasDesign;
		
		this.docsbySchemaName = {};
		
		if( opts.globalContext ){
			opts.globalContext.referencesFromSchema = function(){
				var ctxt = this;
				_this._getReferences(ctxt, schemaName, expression);
			};
		};
	},

	_getReferences: function(ctxt, cb, schemaName, expression){
		
	}
});

//=========================================================================
var ImportProfileService = $n2.Class({
	
	schemaRepository: null,

	atlasDb: null,

	atlasDesign: null,
	
	profileClasses: null,
	
	dispatchService: null,
	
	initialize: function(opts_){
		var opts= $n2.extend({
			atlasDb: null
			,atlasDesign: null
			,schemaRepository: null
			,dispatchService: null
		},opts_);
		
		this.atlasDb = opts.atlasDb;
		this.atlasDesign = opts.atlasDesign;
		this.schemaRepository = opts.schemaRepository;
		this.dispatchService = opts.dispatchService;
		
		this.profileClasses = {};
		
		this.addImportProfileClass('json',ImportProfileJson);
		this.addImportProfileClass('geojson',ImportProfileGeoJson);
		this.addImportProfileClass('csv',ImportProfileCsv);
		
		if( $n2.importProfileOperation 
		 && typeof $n2.importProfileOperation.getGlobalContext === 'function' ){
			var globalContext = $n2.importProfileOperation.getGlobalContext();

			globalContext.test = function(success, error, x){
				success(2 * x);
			};
		};
	},
	
	addImportProfileClass: function(type, aClass){
		this.profileClasses[type] = aClass;
	},
	
	loadImportProfiles: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(profiles){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		this.atlasDesign.queryView({
			viewName: 'nunaliit-import-profile'
			,include_docs: true
			,onSuccess: function(rows){
				var profiles = [];
				var waiting = rows.length + 1;
				for(var i=0,e=rows.length; i<e; ++i){
					var doc = rows[i].doc;
					if( doc ){
						_this._parseImportProfile({
							doc: doc
							,onSuccess: function(profile){
								profiles.push(profile);
								check();
							}
							,onError: function(err){
								$n2.log('Unable to load profile: '+err);
								check();
							}
						});
					} else {
						--waiting;
					};
				};
				check();
				
				function check(){
					--waiting;
					if( waiting <= 0 ){
						opts.onSuccess(profiles);
					};
				};
			}
			,onError: function(err){
				opts.onError( _loc('Unable to load import profiles: {err}',{err:err}) );
			}
		});
	},
	
	_parseImportProfile: function(opts_){
		var opts = $n2.extend({
			doc: null
			,importProfile: null
			,onSuccess: function(profile){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;
		
		var importProfile = opts.importProfile;
		if( !importProfile && opts.doc ){
			if( opts.doc.nunaliit_import_profile ){
				importProfile = opts.doc.nunaliit_import_profile;
			};
		};
		if( !importProfile ){
			opts.onError('Import profile must be provided');
			return;
		};
		
		var profileClass = null;
		
		if( !importProfile.type ){
			opts.onError('Import profile must contain a type');
		} else {
			var type = importProfile.type;
			profileClass = this.profileClasses[type];
			if( !profileClass ){
				opts.onError( _loc('Unknown import profile type: {type}',{type:type}) );
				return;
			} else {
				var classOpts = {};
				
				if( typeof importProfile.options === 'object' ){
					for(var key in importProfile.options){
						var value = importProfile.options[key];
						classOpts[key] = value;
					};
				};
				
				classOpts.id = importProfile.id;
				classOpts.label = importProfile.label;
				classOpts.layerName = importProfile.layerName;
				classOpts.atlasDb = this.atlasDb;
				classOpts.atlasDesign = this.atlasDesign;
				classOpts.dispatchService = this.dispatchService;
				classOpts.schema = undefined;
				
				if( importProfile.schemaName ){
					this.schemaRepository.getSchema({
						name:importProfile.schemaName
						,onSuccess: function(schema){
							classOpts.schema = schema;
							parseOperations(classOpts);
						}
						,onError: function(err){
							opts.onError( _loc('Unknown schema: {name}',{name:importProfile.schemaName}) );
						}
					});
				} else {
					parseOperations(classOpts);
				};
			};
		};
		
		function parseOperations(classOpts){
			var operations = [];
			classOpts.operations = operations;
			
			if( importProfile.operations ){
				for(var i=0,e=importProfile.operations.length; i<e; ++i){
					var opString = importProfile.operations[i];
					var op = createOperation({
						operationString: opString
						,atlasDb: _this.atlasDb
						,atlasDesign: _this.atlasDesign
					});
					if( !op ){
						opts.onError( _loc('Error creating import profile. Unknown operation string: {string}',{string:opString}) );
						return;
					};
					operations.push(op);
				};
			};
			
			done(classOpts);
		};
		
		function done(classOpts){
			try {
				var profile = new profileClass(classOpts);
				opts.onSuccess(profile);
			} catch(err) {
				opts.onError( _loc('Error creating import profile: {err}',{err:err}) );
			};
		};
	}
});

// =========================================================================

$n2.couchImportProfile = {
	ImportProfileService: ImportProfileService
	,AnalysisReport: AnalysisReport
};	
	
})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchImportProfileOperation.js

/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var importProfileOperation = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,7],$V2=[1,8],$V3=[5,7,9,10,12,13,14,15,16,17,18,19,25,26,27,28,29,30,31,33,34],$V4=[1,10],$V5=[1,11],$V6=[1,13],$V7=[1,14],$V8=[1,15],$V9=[1,16],$Va=[1,19],$Vb=[1,20],$Vc=[1,21],$Vd=[1,22],$Ve=[1,23],$Vf=[1,24],$Vg=[1,25],$Vh=[1,26],$Vi=[1,27],$Vj=[1,28],$Vk=[1,29],$Vl=[1,30],$Vm=[1,31],$Vn=[5,9,10,13,14,15,16,17,18,19,25,26,27,28,29,30,34],$Vo=[5,9,10,13,30,34],$Vp=[5,9,10,13,14,15,16,17,18,19,30,34],$Vq=[5,9,10,13,14,15,16,17,18,19,25,26,30,34];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"program":3,"operation":4,"EOF":5,"identifier":6,"=":7,"value":8,"&&":9,"||":10,"!":11,"(":12,")":13,"==":14,"!=":15,">=":16,"<=":17,">":18,"<":19,"arguments":20,"true":21,"false":22,"NUMBER":23,"STRING":24,"+":25,"-":26,"*":27,"/":28,"%":29,",":30,".":31,"VAR_NAME":32,"[":33,"]":34,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",7:"=",9:"&&",10:"||",11:"!",12:"(",13:")",14:"==",15:"!=",16:">=",17:"<=",18:">",19:"<",21:"true",22:"false",23:"NUMBER",24:"STRING",25:"+",26:"-",27:"*",28:"/",29:"%",30:",",31:".",32:"VAR_NAME",33:"[",34:"]"},
productions_: [0,[3,2],[4,3],[8,3],[8,3],[8,2],[8,3],[8,3],[8,3],[8,3],[8,3],[8,3],[8,3],[8,3],[8,4],[8,1],[8,1],[8,1],[8,1],[8,1],[8,3],[8,3],[8,3],[8,3],[8,3],[20,3],[20,1],[6,3],[6,4],[6,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2:

        	this.$ = new OpAssignment($$[$0-2],$$[$0]);
        
break;
case 3:

        	this.$ = new Expression($$[$0-2],'&&',$$[$0]);
        
break;
case 4:

        	this.$ = new Expression($$[$0-2],'||',$$[$0]);
        
break;
case 5:

        	this.$ = new Expression($$[$0],'!');
        
break;
case 6:

    		this.$ = $$[$0-1];
    	
break;
case 7:

        	this.$ = new Comparison($$[$0-2],$$[$0],'==');
        
break;
case 8:

        	this.$ = new Comparison($$[$0-2],$$[$0],'!=');
        
break;
case 9:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>=');
        
break;
case 10:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<=');
        
break;
case 11:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>');
        
break;
case 12:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<');
        
break;
case 13:

        	this.$ = new FunctionCall($$[$0-2],null);
        
break;
case 14:

        	this.$ = new FunctionCall($$[$0-3],$$[$0-1]);
        
break;
case 15:

        	this.$ = $$[$0];
        
break;
case 16:

    		this.$ = new Literal(true);
    	
break;
case 17:

    		this.$ = new Literal(false);
    	
break;
case 18:

    		this.$ = new Literal(1 * $$[$0]);
    	
break;
case 19:

    		this.$ = new Literal($$[$0]);
    	
break;
case 20:

    		this.$ = new MathOp($$[$0-2],$$[$0],'+');
    	
break;
case 21:

    		this.$ = new MathOp($$[$0-2],$$[$0],'-');
    	
break;
case 22:

    		this.$ = new MathOp($$[$0-2],$$[$0],'*');
    	
break;
case 23:

    		this.$ = new MathOp($$[$0-2],$$[$0],'/');
    	
break;
case 24:

    		this.$ = new MathOp($$[$0-2],$$[$0],'%');
    	
break;
case 25:

        	this.$ = new Arguments($$[$0-2],$$[$0]);
        
break;
case 26:

        	this.$ = new Arguments($$[$0]);
        
break;
case 27:

        	var id = new Literal($$[$0]);
        	this.$ = new ObjectSelector(id,$$[$0-2]);
        
break;
case 28:

        	this.$ = new ObjectSelector($$[$0-1],$$[$0-3]);
        
break;
case 29:

        	this.$ = new Variable($$[$0]);
        
break;
}
},
table: [{3:1,4:2,6:3,32:$V0},{1:[3]},{5:[1,5]},{7:[1,6],31:$V1,33:$V2},o($V3,[2,29]),{1:[2,1]},{6:12,8:9,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{32:[1,17]},{6:12,8:18,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{5:[2,2],9:$Va,10:$Vb,14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm},{6:12,8:32,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:33,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},o($Vn,[2,15],{12:[1,34],31:$V1,33:$V2}),o($Vn,[2,16]),o($Vn,[2,17]),o($Vn,[2,18]),o($Vn,[2,19]),o($V3,[2,27]),{9:$Va,10:$Vb,14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm,34:[1,35]},{6:12,8:36,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:37,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:38,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:39,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:40,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:41,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:42,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:43,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:44,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:45,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:46,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:47,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{6:12,8:48,11:$V4,12:$V5,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},o($Vn,[2,5]),{9:$Va,10:$Vb,13:[1,49],14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm},{6:12,8:52,11:$V4,12:$V5,13:[1,50],20:51,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},o($V3,[2,28]),o($Vo,[2,3],{14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vo,[2,4],{14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vp,[2,7],{25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vp,[2,8],{25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vp,[2,9],{25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vp,[2,10],{25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vp,[2,11],{25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vp,[2,12],{25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm}),o($Vq,[2,20],{27:$Vk,28:$Vl,29:$Vm}),o($Vq,[2,21],{27:$Vk,28:$Vl,29:$Vm}),o($Vn,[2,22]),o($Vn,[2,23]),o($Vn,[2,24]),o($Vn,[2,6]),o($Vn,[2,13]),{13:[1,53]},{9:$Va,10:$Vb,13:[2,26],14:$Vc,15:$Vd,16:$Ve,17:$Vf,18:$Vg,19:$Vh,25:$Vi,26:$Vj,27:$Vk,28:$Vl,29:$Vm,30:[1,54]},o($Vn,[2,14]),{6:12,8:52,11:$V4,12:$V5,20:55,21:$V6,22:$V7,23:$V8,24:$V9,32:$V0},{13:[2,25]}],
defaultActions: {5:[2,1],55:[2,25]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
    function _parseError (msg, hash) {
        this.message = msg;
        this.hash = hash;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
//    return true;
}};


function compare(obj1, obj2){
	// Deals with null == null, undefined == undefined, same
	// strings or numbers
	if( obj1 === obj2 ) return 0;

	// Testing for different types
	if( typeof obj1 !== typeof obj2 ){
		if( typeof obj1 < typeof obj2 ) return -1;
		return 1;
	};
	
	// From this point, both objects have the same type and are not identical
	
	if( typeof obj1 === 'string' 
	 || typeof obj1 === 'number' ){
	 	if( obj1 < obj2 ) return -1;
	 	return 1;
	};

	if( typeof obj1 === 'boolean'){
	 	if( obj2 ) return -1;
	 	return 1;
	};

	if( typeof obj1 === 'function'){
		var src1 = obj1.toString();
		var src2 = obj2.toString();
	 	if( src1 < src2 ) return -1;
	 	if( src1 > src2 ) return 1;
	 	return 0;
	};
	
	// Deal with arrays
	if( $n2.isArray(obj1) && $n2.isArray(obj2) ){
		var refSets = true;
		obj1.forEach(function(elem){
			if( !elem ) {
				refSets = false;
			} else if( elem.nunaliit_type !== 'reference' ) {
				refSets = false;
			};
		});
		obj2.forEach(function(elem){
			if( !elem ) {
				refSets = false;
			} else if( elem.nunaliit_type !== 'reference' ) {
				refSets = false;
			};
		});
		
		if( refSets ){
			return compareReferenceSets(obj1, obj2);
		};
		
		return compareArrays(obj1, obj2)
		
	} else if( $n2.isArray(obj1) && !$n2.isArray(obj2) ){
		return -1;
	} else if( !$n2.isArray(obj1) && $n2.isArray(obj2) ){
		return 1;
	};
	
	// At this point, we should be left with two objects
	
	if( obj1.nunaliit_type === 'reference'
	 && obj2.nunaliit_type === 'reference' ){
	 	return compareReferences(obj1,obj2);
	};

	// Compare properties
	var propNameMap = {};
	for(var key in obj1){
		propNameMap[key] = true;
	};
	for(var key in obj2){
		propNameMap[key] = true;
	};
	var propNames = [];
	for(var key in propNameMap){
		propNames.push(key);
	};
	propNames.sort();
	for(var i=0; i<propNames.length; ++i){
		var propName = propNames[i];
		var prop1 = obj1[propName];
		var prop2 = obj2[propName];
		var c = compare(prop1, prop2);
		if( 0 !== c ){
			return c;
		};
	};
	
	return 0; 
};

function compareArrays(arr1, arr2){
	if( arr1.length > arr2.length ){
		return 1;
	} else if( arr1.length < arr2.length ){
		return -1;
	};
	
	for(var i=0; i<arr1.length; ++i){
		var c = compare(arr1[i], arr2[i]);
		if( 0 !== c ){
			return c;
		};
	};
	
	return 0;
};

function compareReferences(ref1, ref2){
	if( ref1 === ref2 ) return 0; // null == null and undefined == undefined
	if( !ref1 ) return -1;
	if( !ref2 ) return 1;
	if( ref1.doc === ref2.doc ) return 0;
	if( typeof ref1.doc === 'undefined' || ref1.doc === null ) return -1; 
	if( typeof ref2.doc === 'undefined' || ref2.doc === null ) return 1;
	if( ref1.doc < ref2.doc ) return -1; 
	if( ref1.doc > ref2.doc ) return 1;
	return 0; 
};

function compareReferenceSets(set1, set2){
	if( set1 === set2 ) return 0; // null == null and undefined == undefined
	if( !set1 ) return -1;
	if( !set2 ) return 1;
	
	var map1 = {};
	set1.forEach(function(ref){
		if( ref
		 && typeof ref.doc === 'string' ){
			map1[ref.doc] = true;
		};
	});

	var map2 = {};
	set2.forEach(function(ref){
		if( ref
		 && typeof ref.doc === 'string' ){
			map2[ref.doc] = true;
		};
	});
	
	for(var docId in map1){
		if( !map2[docId] ){
			return -1;
		};
	};

	for(var docId in map2){
		if( !map1[docId] ){
			return 1;
		};
	};

	return 0; 
};

// Functions in the global space receives the context object
// as 'this'.
var global = {
};
parser.global = global;

// -----------------------------------------------------------
var OpAssignment = function(leftop, rightop){
	this.leftop = leftop;
	this.rightop = rightop;
};
OpAssignment.prototype.configure = function(opts){
	if( this.identifier 
	 && typeof this.identifier.configure === 'function' ){
	 	this.identifier.configure(opts);
	};
	if( this.rightop 
	 && typeof this.rightop.configure === 'function' ){
	 	this.rightop.configure(opts);
	};
};
OpAssignment.prototype.reportCopyOperations = function(opts){
	var _this = this;
	
	var importData = opts.importEntry.getProperties();
	var lastImportData = opts.lastImportEntry.getProperties();

	var propertyNameMap = {};
	var updatedValue = undefined;
	var lastValue = undefined;
	var targetValue = undefined;
	var targetSelector = undefined;

	// compute new value	
	var ctxt = {
		variables:{
			doc: opts.doc,
			'import': importData
		},
		propertyNameMap: propertyNameMap
	};
	this.rightop.getValue(ctxt, receiveUpdatedValue, processError);

	function processError(err){
		// On error, do not add any copy operations
		opts.onSuccess([]);
	};

	function receiveUpdatedValue(v){
		// save
		updatedValue = v;

		// recompute last imported value
		var ctxt2 = {
			variables:{
				doc: opts.doc,
				'import': lastImportData // based on last import
			}
		};
		_this.rightop.getValue(ctxt2, receiveLastValue, processError);
	};

	function receiveLastValue(v){
		// save
		lastValue = v;

		// get current target value
		var ctxt3 = {
			variables:{
				doc: opts.doc
				// do not include import data, as it should not
				// influence getting the current value
			}
		};
		_this.leftop.getValue(ctxt3, receiveTargetValue, processError);
	};

	function receiveTargetValue(v){
		// save
		targetValue = v;

		// get target selector
		var ctxt3 = {
			variables:{
				doc: opts.doc
				// do not include import data, as it should not
				// influence getting the target selector
			}
		};
		_this.leftop.getObjectSelector(ctxt3, receiveTargetSelector, processError);
	};

	function receiveTargetSelector(v){
		// save
		targetSelector = v;

		var isEqual = false;
		if( 0 === compare(targetValue, updatedValue) ){
			isEqual = true;
		};

		var changedSinceLastImport = true;
		if( 0 === compare(targetValue, lastValue) ){
			changedSinceLastImport = false;
		};
	
		var inputPropertyNames = [];
		for(var propertyName in propertyNameMap){
			inputPropertyNames.push(propertyName);
		};
	
		var copyOperation = {
			propertyNames: inputPropertyNames
			,computedValue: updatedValue
			,targetSelector: targetSelector
			,targetValue: targetValue
			,isEqual: isEqual
			,changedSinceLastImport: changedSinceLastImport
		};	
	
		opts.onSuccess([copyOperation]);
	};
};
OpAssignment.prototype.performCopyOperation = function(opts_){
	var opts = $n2.extend({
		doc: null
		,importEntry: null
		,copyOperation: null
	},opts_);
	
	var doc = opts.doc;
	var copyOperation = opts.copyOperation;
	var computedValue = copyOperation.computedValue;
	var targetSelector = copyOperation.targetSelector;
	
	if( typeof computedValue === 'undefined' ){
		targetSelector.removeValue(doc);
	} else {
		targetSelector.setValue(doc, computedValue, true);
	};
};

// -----------------------------------------------------------
var FunctionCall = function(value, args){
	this.value = value;
	this.args = args;
};
FunctionCall.prototype.getValue = function(ctxt, success, error){
	var _this = this;

	// Accumulate all the values from arguments
	var argValues = [onComplete, error];
	if( this.args ){
		this.args.pushValuesOnArray(ctxt, argValues, getFunction, error);
	} else {
		// No arguments, go directly to function
		getFunction();
	};

	function getFunction(){
		_this.value.getValue(
			ctxt,
			function(value){
				if( typeof value === 'function' ){
					value.apply(ctxt, argValues);
				} else {
					// Not a function. Return undefined
					onComplete(undefined);
				};
			},
			error
		);
	};
	
	function onComplete(res){
		success(res);
	};
};

// -----------------------------------------------------------
// Arguments
var Arguments = function(a1, a2){
	this.valueNode = a1;
	if( a2 ){
		this.nextArgument = a2;
	} else {
		this.nextArgument = null;
	};
};
Arguments.prototype.pushValuesOnArray = function(ctxt, array, success, error){
	var _this = this;

	this.valueNode.getValue(
		ctxt,
		function(value){
			array.push(value);
			
			if( _this.nextArgument ){
				_this.nextArgument.pushValuesOnArray(ctxt, array, success, error);
			} else {
				success();
			};
		},
		error
	);
};

// -----------------------------------------------------------
var Expression = function(n1, op, n2){
	this.n1 = n1;
	this.n2 = n2;
	this.op = op;
};
Expression.prototype.getValue = function(ctxt, success, error){
	var _this = this;
	this.n1.getValue(
		ctxt,
		function(r1){
			if( _this.n2 ){
				this.n2.getValue(
					ctxt,
					function(r2){
						compute(r1,r2);
					},
					error
				);
			} else {
				compute(r1,undefined);
			};
		},
		error
	);
	
	function compute(r1,r2){
		if( '!' === this.op ){
			success( !r1 );
			
		} else if( '&&' === this.op ){
			success(r1 && r2);
			
		} else if( '||' === this.op ){
			success(r1 || r2);

		} else {
			success(false);
		};
	};
};

// -----------------------------------------------------------
var Literal = function(value){
	this.value = value;
};
Literal.prototype.getValue = function(ctxt, success, error){
	success(this.value);
};

// -----------------------------------------------------------
var Comparison = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
Comparison.prototype.getValue = function(ctxt, success, error){
	var _this = this;

	this.leftNode.getValue(
		ctxt,
		function(left){
			_this.rightNode.getValue(
				ctxt,
				function(right){
					if( '==' === _this.op ){
						success(left == right);
				
					} else if( '!=' === _this.op ){
						success(left != right);
				
					} else if( '>=' === _this.op ){
						success(left >= right);
				
					} else if( '<=' === _this.op ){
						success(left <= right);
				
					} else if( '>' === _this.op ){
						success(left > right);
				
					} else if( '<' === _this.op ){
						success(left < right);
		
					} else {
						success(false);
					};
				},
				error
			);
		},
		error
	);
};

// -----------------------------------------------------------
var MathOp = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
MathOp.prototype.getValue = function(ctxt, success, error){
	var _this = this;

	this.leftNode.getValue(
		ctxt,
		function(left){
			_this.rightNode.getValue(
				ctxt,
				function(right){
					if( '+' === _this.op ){
						success(left + right);
				
					} else if( '-' === _this.op ){
						success(left - right);
				
					} else if( '*' === _this.op ){
						success(left * right);
				
					} else if( '/' === _this.op ){
						success(left / right);
				
					} else if( '%' === _this.op ){
						success(left % right);
		
					} else {
						success(0);
					};
				},
				error
			);
		},
		error
	);
};

// -----------------------------------------------------------
var ObjectSelector = function(id, previousSelector){
	this.idNode = id;
	this.previousSelector = previousSelector;
};
ObjectSelector.prototype.getValue = function(ctxt, success, error){
	var _this = this;
	this.previousSelector.getValue(
		ctxt, 
		function(obj){
			if( typeof obj === 'object' ){
				_this.idNode.getValue(
					ctxt,
					function(id){
						if( typeof id === 'undefined' ){
							success(undefined);
						} else {
							// Capture references to 'import' data
							if( _this.previousSelector.isVariable 
							 && _this.previousSelector.variableName === 'import' ){
							 	if( ctxt.propertyNameMap ){
							 		ctxt.propertyNameMap[id] = true;
							 	};
							};
							
							success( obj[id] );
						};
						
					},
					error
				);
			} else {
				success(undefined);
			};
		},
		error
	);
};
ObjectSelector.prototype.getObjectSelector = function(ctxt, success, error){
	var _this = this;
	this.previousSelector.getObjectSelector(
		ctxt,
		function(parentSel){
			_this.idNode.getValue(
				ctxt,
				function(id){
					var childSel = parentSel.getChildSelector(id);
					success(childSel);
				},
				error
			);
		},
		error
	);
};

// -----------------------------------------------------------
var Variable = function(variableName){
	this.isVariable = true; // marker
	this.variableName = variableName;
};
Variable.prototype.getValue = function(ctxt, success, error){
	var obj = undefined;
	
	if( ctxt 
	 && ctxt.variables 
	 && ctxt.variables[this.variableName] ) {
		obj = ctxt.variables[this.variableName];
		
	} else if( global && global[this.variableName] ) {
		obj = global[this.variableName];
	};
	
	success(obj);
};
Variable.prototype.getObjectSelector = function(ctxt, success, error){
	var sel = new $n2.objectSelector.ObjectSelector([]);
	success( sel );
};


/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: /* skip whitespace */ 
break;
case 1: return 21; 
break;
case 2: return 22; 
break;
case 3: return 23; 
break;
case 4: return 32; 
break;
case 5: yy_.yytext = yy_.yytext.substr(1,yy_.yytext.length-2); return 24; 
break;
case 6: return 14; 
break;
case 7: return 15; 
break;
case 8: return 16; 
break;
case 9: return 17; 
break;
case 10: return 18; 
break;
case 11: return 19; 
break;
case 12: return 12; 
break;
case 13: return 13; 
break;
case 14: return '{'; 
break;
case 15: return '}'; 
break;
case 16: return 33; 
break;
case 17: return 34; 
break;
case 18: return 30; 
break;
case 19: return 31; 
break;
case 20: return 11; 
break;
case 21: return 25; 
break;
case 22: return 26; 
break;
case 23: return 27; 
break;
case 24: return 28; 
break;
case 25: return 29; 
break;
case 26: return 7; 
break;
case 27: return 9; 
break;
case 28: return 10; 
break;
case 29: return 5; 
break;
case 30: return 'INVALID'; 
break;
}
},
rules: [/^(?:\s+)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:[_a-zA-Z][_a-zA-Z0-9]*)/,/^(?:'(\\'|[^'])*')/,/^(?:==)/,/^(?:!=)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:\()/,/^(?:\))/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?:\.)/,/^(?:!)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:=)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = importProfileOperation;
exports.Parser = importProfileOperation.Parser;
exports.parse = function () { return importProfileOperation.parse.apply(importProfileOperation, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}	
//--------------------------------------------------------------------------
function parse(){
	return importProfileOperation.parse.apply(importProfileOperation, arguments);
};

//--------------------------------------------------------------------------
function getGlobalContext(){
	return importProfileOperation.global;
};
	
//--------------------------------------------------------------------------
$n2.importProfileOperation = {
	parse: parse
	,getGlobalContext: getGlobalContext
};

})(nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchDbPerspective.js

/*
Copyright (c) 2014, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var
	_loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); }
	,DH = 'n2.couchDbPerspective'
	,NOT_VALID_NOT_VISIBLE = { valid:false, visible:false }
	,VALID_NOT_VISIBLE     = { valid:true,  visible:false }
	,VALID_VISIBLE         = { valid:true,  visible:true }
	;

//--------------------------------------------------------------------------
var DbSelector = $n2.Class({
	initialize: function(opts_){
		var opts = $n2.extend({
		}, opts_);
		
	},
	
	load: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(docs){}
			,onError: function(err){}
		}, opts_);
		
		throw 'Subclasses of DbSelector must implement function load()';
	},
	
	isDocValid: function(doc){
		throw 'Subclasses of DbSelector must implement function isValidDoc()';
	},
	
	getLabel: function(){
		throw 'Subclasses of DbSelector must implement function getLabel()';
	}
});

//--------------------------------------------------------------------------
var CouchLayerDbSelector = $n2.Class(DbSelector, {
	layerId: null,
	
	name: null,
	
	atlasDesign: null,
	
	documentSource: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			layer: null
			,name: null
			,atlasDesign: null
			,documentSource: null
		}, opts_);

		DbSelector.prototype.initialize.call(this, opts_);
		
		this.layerId = opts.layer;
		this.name = opts.name;
		this.atlasDesign = opts.atlasDesign;
		this.documentSource = opts.documentSource;
	},
	
	load: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(docs){}
			,onError: function(err){}
		}, opts_);
		
		var _this = this;
		
		this.atlasDesign.queryView({
			viewName: 'layers'
			,include_docs: true
			,startkey: this.layerId
			,endkey: this.layerId
			,onSuccess: function(rows){
				var docs = [];
				for(var i=0,e=rows.length; i<e; ++i){
					var doc = rows[i].doc;
					if( doc && _this.isDocValid(doc) ){
						// Associate document source
						if( _this.documentSource ){
							_this.documentSource.adoptDocument(doc);
						};
						
						docs.push(doc);
					};
				};
				opts.onSuccess(docs);
			}
			,onError: opts.onError
		});
	},
	
	isDocValid: function(doc){
		if( doc && doc.nunaliit_layers ){
			if( doc.nunaliit_layers.indexOf(this.layerId) >= 0 ){
				return true;
			};
		};
		
		return false;
	},
	
	getLabel: function(){
		if( this.name ){
			return this.name;
		};
		
		return this.layerId;
	}
});

//--------------------------------------------------------------------------
var CouchSchemaDbSelector = $n2.Class(DbSelector, {
	schemaName: null,
	
	name: null,
	
	atlasDesign: null,
	
	documentSource: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			schemaName: null
			,name: null
			,atlasDesign: null
			,documentSource: null
		}, opts_);

		DbSelector.prototype.initialize.call(this, opts_);
		
		this.schemaName = opts.schemaName;
		this.name = opts.name;
		this.atlasDesign = opts.atlasDesign;
		this.documentSource = opts.documentSource;
	},
	
	load: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(docs){}
			,onError: function(err){}
		}, opts_);
		
		var _this = this;
		
		this.atlasDesign.queryView({
			viewName: 'nunaliit-schema'
			,include_docs: true
			,startkey: this.schemaName
			,endkey: this.schemaName
			,onSuccess: function(rows){
				var docs = [];
				for(var i=0,e=rows.length; i<e; ++i){
					var doc = rows[i].doc;
					if( doc && _this.isDocValid(doc) ){
						// Associate document source
						if( _this.documentSource ){
							_this.documentSource.adoptDocument(doc);
						};
						
						docs.push(doc);
					};
				};
				opts.onSuccess(docs);
			}
			,onError: opts.onError
		});
	},
	
	isDocValid: function(doc){
		if( doc 
		 && this.schemaName === doc.nunaliit_schema ){
			return true;
		};
		
		return false;
	},
	
	getLabel: function(){
		if( this.name ){
			return this.name;
		};
		
		return this.schemaName;
	}
});

//--------------------------------------------------------------------------
/**
 * This class accepts a number of instances of DbSelector and manages the content
 * found from the database, via those selectors. It also accepts listeners
 * and provide them with updates from the database. On each updates, the
 * created, updated and removed documents are provided.
 * 
 * The database perspective also offers caching of documents, via events from the
 * dispatcher.
 */
var DbPerspective = $n2.Class({
	dispatchService: null,
	
	atlasDesign: null,
	
	siteDesign: null,
	
	documentSource: null,
	
	modelId: null,
	
	dbSelectors: null,
	
	selectorListeners: null,
	
	docInfosByDocId: null,
	
	docListeners: null,
	
	loadingCount: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,atlasDesign: null
			,siteDesign: null
			,documentSource: null
			,modelId: null
		}, opts_);

		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.atlasDesign = opts.atlasDesign;
		this.siteDesign = opts.siteDesign;
		this.documentSource = opts.documentSource;
		this.modelId = opts.modelId;
		
		this.dbSelectors = [];
		this.selectorListeners = [];
		this.docInfosByDocId = {};
		this.docListeners = [];
		this.loadingCount = 0;
		
		if( !this.modelId ){
			this.modelId = $n2.getUniqueId();
		};
		
		if( this.dispatchService ) {
			var fn = function(m){
				_this._handleMessage(m);
			};
			
			this.dispatchService.register(DH, 'documentContentCreated', fn);
			this.dispatchService.register(DH, 'documentContentUpdated', fn);
			this.dispatchService.register(DH, 'documentDeleted', fn);
//			this.dispatchService.register(DH, 'findIsAvailable', fn);
			this.dispatchService.register(DH, 'documentVersion', fn);
			this.dispatchService.register(DH, 'cacheRetrieveDocument', fn);
			this.dispatchService.register(DH, 'modelGetInfo', fn);
			this.dispatchService.register(DH, 'modelGetState', fn);
		};
		
		$n2.log('DbPerspective',this);
	},
	
	addDbSelector: function(dbSelector, opts_){
		var opts = $n2.extend({
			visibility: true
		},opts_);
		
		var _this = this;
		
		var dbSelectorInfo = {
			selector: dbSelector
			,visible: opts.visibility
			,id: $n2.getUniqueId()
		};
		this.dbSelectors.push(dbSelectorInfo);
		
		++this.loadingCount;
		this._reportStateUpdate([], [], []);
		
		dbSelector.load({
			onSuccess: function(docs){
				--_this.loadingCount;
				_this._docsLoaded(docs);
			},
			onError: function(err){
				--_this.loadingCount;
				_this._reportStateUpdate([], [], []);
			}
		});
	},
	
	addDbSelectorFromConfigObject: function(selectorConfig){
		var dbSelector = null;
		
		if( selectorConfig ){
			if( 'couchDbLayer' === selectorConfig.type ){
				var dbSelectorOptions = {
					layer: null
					,atlasDesign: this.atlasDesign
					,documentSource: this.documentSource
				};
				
				if( selectorConfig.options 
				 && selectorConfig.options.layerId ){
					dbSelectorOptions.layer = selectorConfig.options.layerId;
				} else {
					$n2.log('DbPerspective unable to create selector. "layerId" required for "couchDbLayer"');
					return null;
				};

				if( selectorConfig.name ){
					dbSelectorOptions.name = selectorConfig.name;
				};
				
				dbSelector = new CouchLayerDbSelector(dbSelectorOptions);
				
			} else if( 'couchDbSchema' === selectorConfig.type ){
					var dbSelectorOptions = {
						schemaName: null
						,atlasDesign: this.atlasDesign
						,documentSource: this.documentSource
					};
					
					if( selectorConfig.options 
					 && selectorConfig.options.schemaName ){
						dbSelectorOptions.schemaName = selectorConfig.options.schemaName;
					} else {
						$n2.log('DbPerspective unable to create selector. "schemaName" required for "couchDbSchema"');
						return null;
					};

					if( selectorConfig.name ){
						dbSelectorOptions.name = selectorConfig.name;
					};
					
					dbSelector = new CouchSchemaDbSelector(dbSelectorOptions);
				
			} else {
				$n2.log('Unknown DbPerspective selector type: '+selectorConfig.type);
			};
		};

		if( dbSelector ){
			this.addDbSelector(dbSelector, selectorConfig);
		};
		
		return dbSelector;
	},
	
	addSelectorListener: function(listener){
		this.selectorListeners.push(listener);
		
		var selectorInfos = this.getDbSelectorInfos();
		listener(selectorInfos);
	},
	
	getDbSelectorInfos: function(){
		var infos = [];
		
		for(var i=0,e=this.dbSelectors.length; i<e; ++i){
			var selectorInfo = this.dbSelectors[i];
			var selector = selectorInfo.selector;
			var s = {
				id: selectorInfo.id
				,visible: selectorInfo.visible
				,name: selector.getLabel()
			};
			infos.push(s);
		};
		
		return infos;
	},
	
	setDbSelectorVisibility: function(selectorId, visibility){
		var changed = false;
		for(var i=0,e=this.dbSelectors.length; i<e; ++i){
			var selectorInfo = this.dbSelectors[i];
			if( selectorInfo.id === selectorId ){
				if( visibility !== selectorInfo.visible ){
					selectorInfo.visible = visibility;
					changed = true;
				};
			};
		};
		
		if( changed ){
			this._selectorVisibilityChanged();

			var selectorInfos = this.getDbSelectorInfos();
			for(var i=0,e=this.selectorListeners.length; i<e; ++i){
				var listener = this.selectorListeners[i];
				listener(selectorInfos);
			};
		};
	},
	
	addListener: function(listener){
		this.docListeners.push(listener);
		
		var added = [];
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;
			var visibilityStatus = this._getDocVisibility(doc);
			if( visibilityStatus.visible ){
				added.push(doc);
			};
		};

		if( added.length > 0 ){
			listener({
				added: added
				,updated: []
				,removed: []
			});
		};
	},

	isDocValid: function(doc){
		for(var i=0,e=this.dbSelectors.length; i<e; ++i){
			var selectorInfo = this.dbSelectors[i];
			var s = selectorInfo.selector;
			if( s.isDocValid(doc) ){
				return true;
			};
		};

		return false;
	},
	
	isLoading: function(){
		return (this.loadingCount > 0);
	},
	
	_selectorVisibilityChanged: function(){
		var added = [];
		var updated = [];
		var removed = [];
		
		for(var docId in this.docInfosByDocId){
			var docInfo = this.docInfosByDocId[docId];
			var doc = docInfo.doc;
			
			var visibilityStatus = this._getDocVisibility(doc);
			
			if( !docInfo.visible && visibilityStatus.visible ){
				added.push(doc);
			
			} else if( docInfo.visible && !visibilityStatus.visible ){
				removed.push(doc);
			};
			
			docInfo.visible = visibilityStatus.visible;
		};
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_getDocVisibility: function(doc){
		var status = NOT_VALID_NOT_VISIBLE;
		
		for(var i=0,e=this.dbSelectors.length; i<e; ++i){
			var selectorInfo = this.dbSelectors[i];
			var s = selectorInfo.selector;
			if( s.isDocValid(doc) ){
				status = VALID_NOT_VISIBLE;
				
				if( selectorInfo.visible ){
					return VALID_VISIBLE;
				};
			};
		};

		return status;
	},

	_docsLoaded: function(loadedDocs){
		var added = [];
		var updated = [];
		var removed = [];
		
		for(var i=0,e=loadedDocs.length; i<e; ++i){
			var loadedDoc = loadedDocs[i];
			
			var visibilityStatus = this._getDocVisibility(loadedDoc);
			
			var docInfo = this.docInfosByDocId[loadedDoc._id];
			
			if( !docInfo && visibilityStatus.valid ){
				// Not previously in cache, but now valid: add
				this.docInfosByDocId[loadedDoc._id] = {
					doc: loadedDoc
					,cacheValid: true
					,visible: visibilityStatus.visible
				};
				
				// Call listeners only if document is visible
				if( visibilityStatus.visible ){
					added.push(loadedDoc);
				};

			} else if( docInfo && !visibilityStatus.valid ) {
				// Previously in cache, but no longer valid
				delete this.docInfosByDocId[loadedDoc._id];

				// If listeners were previously informed of this document,
				// report removal
				if( docInfo.visible ) {
					removed.push(docInfo.doc);
				};

			} else if( docInfo && visibilityStatus.valid ) {
				// Previously in cache. Still valid. Update.
				
				// It is not an update if the reported document is the
				// same version as the one in cache
				var revUpdated = false;
				if( docInfo.doc._rev !== loadedDoc._rev ) {
					// Updated. Keep track of this new version of the document.
					// Assume that it is valid
					docInfo.doc = loadedDoc;
					docInfo.cacheValid = true;
					revUpdated = true;
				};

				if( docInfo.visible && visibilityStatus.visible ){
					if( revUpdated ){
						updated.push(loadedDoc);
					};

				} else if( !docInfo.visible && visibilityStatus.visible ){
					added.push(loadedDoc);
					docInfo.visible = true;
				
				} else if( docInfo.visible && !visibilityStatus.visible ){
					removed.push(loadedDoc);
					docInfo.visible = false;
				};
			};
		};
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_handleMessage: function(m){
		if( 'documentContentCreated' === m.type 
		 || 'documentContentUpdated' === m.type ){
			if( m.doc ){
				this._docsLoaded([m.doc]);
			};

		} else if( 'documentDeleted' === m.type ){
			var docId = m.docId;
			var docInfo = this.docInfosByDocId[docId];
			if( docInfo ){
				delete this.docInfosByDocId[docId];
				
				var removed = [docInfo.doc];
				this._reportStateUpdate([], [], removed);
			};

		} else if( 'documentVersion' === m.type ) {
			var docInfo = this.docInfosByDocId[m.docId];
			if( docInfo 
			 && docInfo.doc 
			 && docInfo.cacheValid 
			 && docInfo.doc._rev !== m.rev ){
				docInfo.cacheValid = false;
			};

		} else if( 'cacheRetrieveDocument' === m.type ) {
			var docInfo = this.docInfosByDocId[m.docId];
			if( docInfo 
			 && docInfo.doc 
			 && docInfo.cacheValid ){
				m.doc = docInfo.doc;
			};
			
		} else if( 'modelGetInfo' === m.type ) {
			if( m.modelId === this.modelId ){
				m.modelInfo = {
					modelId: this.modelId
					,modelType: 'couchDb'
					,parameters: {}
					,_instance: this
				};
			};
			
		} else if( 'modelGetState' === m.type ) {
			if( m.modelId === this.modelId ){
				var added = [];
				for(var docId in this.docInfosByDocId){
					var docInfo = this.docInfosByDocId[docId];
					if( docInfo.visible ){
						var doc = docInfo.doc;
						added.push(doc);
					};
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.isLoading()
				};
			};
		};
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.isLoading()
		};

		for(var i=0,e=this.docListeners.length; i<e; ++i){
			var listener = this.docListeners[i];
			listener(stateUpdate);
		};
		
		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	}
});

//--------------------------------------------------------------------------
/**
 * This class is a document source (document model that fetches documents
 * remoetly) that loads documents given a specified view.
 */
var ModelCouchDbView = $n2.Class({
	dispatchService: null,
	
	atlasDesign: null,
	
	siteDesign: null,
	
	modelId: null,
	
	viewName: null,

	isSiteView: null,

	includeValues: null,
	
	designDoc: null,
	
	atlasDb: null,

	cacheByDocId: null,

	docsById: null,
	
	loadingCount: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,atlasDesign: null
			,modelId: null
			,view: null
			,isSiteView: false
			,includeValues: true
		}, opts_);

		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.atlasDesign = opts.atlasDesign;
		this.siteDesign = opts.siteDesign;
		this.modelId = opts.modelId;
		this.viewName = opts.view;
		this.isSiteView = opts.isSiteView;
		this.includeValues = opts.includeValues;
		
		if( typeof this.viewName !== 'string' ){
			throw new Error('Model "couchDbView" requires a string parameter "view"');
		};
		
		this.designDoc = this.atlasDesign;
		if( this.isSiteView ){
			this.designDoc = this.siteDesign;
		};
		
		this.atlasDb = this.designDoc.getDatabase();
		
		this.docsById = {};
		this.cacheByDocId = {};
		this.loadingCount = 0;
		
		if( !this.modelId ){
			this.modelId = $n2.getUniqueId();
		};
		
		if( this.dispatchService ) {
			var fn = function(m){
				_this._handleMessage(m);
			};
			
			this.dispatchService.register(DH, 'documentContentCreated', fn);
			this.dispatchService.register(DH, 'documentContentUpdated', fn);
			this.dispatchService.register(DH, 'documentDeleted', fn);
//			this.dispatchService.register(DH, 'findIsAvailable', fn);
			this.dispatchService.register(DH, 'documentVersion', fn);
			this.dispatchService.register(DH, 'cacheRetrieveDocument', fn);
			this.dispatchService.register(DH, 'modelGetInfo', fn);
			this.dispatchService.register(DH, 'modelGetState', fn);
		};
		
		this._loadView();
		
		$n2.log('ModelCouchDbView',this);
	},
	
	
	isLoading: function(){
		return (this.loadingCount > 0);
	},
	
	_loadView: function(opts_){
		var opts = $n2.extend({
			onSuccess: function(docInfoByDocId){}
			,onError: function(err){}
		},opts_);
		
		var _this = this;

		++this.loadingCount;
		this._reportStateUpdate([],[],[]);
		
		this.designDoc.queryView({
			viewName: this.viewName
			,include_docs: false
			,onSuccess: function(rows){
				var docMap = {};

				rows.forEach(function(row){
					var docId = row.id;
					if( !docMap[docId] ){
						docMap[docId] = [];
					};
					docMap[docId].push(row);
				});

				loadDocsFromMap(docMap);
			}
			,onError: function(err){
				$n2.log('Unable to load CouchDb view: '+_this.viewName, err);
				--this.loadingCount;
				this._reportStateUpdate([],[],[]);
			}
		});
		
		function loadDocsFromMap(docMap){
			// Make array of docIds from map
			var docIds = [];
			for(var docId in docMap){
				docIds.push(docId);
			};

			_this.atlasDb.getDocuments({
				docIds: docIds
				,onSuccess: function(docs){
					_this.cacheByDocId = {};
					var docInfoByDocId = {};
					docs.forEach(function(doc){
						var docId = doc._id;

						_this.cacheByDocId[docId] = doc;

						// Clone document to add view information
						var values = docMap[docId];
						var clone = _this._computeClone(doc, values);
						docInfoByDocId[docId] = {
							doc: doc
							,clone: clone
							,values: values
						};
					});

					--this.loadingCount;

					_this._docInfoMapLoaded(docInfoByDocId);
				}
				,onError: function(err){
					$n2.log('Unable to fetch documents for CouchDb view: '+_this.viewName, err);
					--this.loadingCount;
					this._reportStateUpdate([],[],[]);
				}
			});
		};
	},
	
	_computeClone: function(doc, values){
		if( this.includeValues ){
			var clone = $n2.extend({},doc);
			clone.__view = {};
			clone.__view[this.viewName] = values;
			return clone;
		} else {
			return doc;
		};
	},

	_docInfoMapLoaded: function(docInfoMap){
		var added = [];
		var updated = [];
		var removed = [];
		
		// Detect updated and removed documents
		for(var docId in this.docsById){
			var oldDoc;
			if( this.docsById[docId] ){
				oldDoc = this.docsById[docId].clone;
			};
			var newDoc;
			if( docInfoMap[docId] ){
				newDoc = docInfoMap[docId].clone;
			};

			if( newDoc ){
				// This document persists. Check if revision changed
				if( newDoc._rev === oldDoc._rev ){
					// Nothing changed
				} else {
					// This document has changed
					updated.push(newDoc);
				};
				
			} else {
				// This is a removed document
				removed.push(oldDoc);
			};
		};
		
		// Detect added documents
		for(var docId in docInfoMap){
			var oldDoc;
			if( this.docsById[docId] ){
				oldDoc = this.docsById[docId].clone;
			};
			var newDoc;
			if( docInfoMap[docId] ){
				newDoc = docInfoMap[docId].clone;
			};

			if( !oldDoc ){
				// This was added
				added.push(newDoc);
			};
		};
		
		// Swap to new map
		this.docsById = docInfoMap;
		
		this._reportStateUpdate(added, updated, removed);
	},
	
	_handleMessage: function(m){
		if( 'documentContentCreated' === m.type 
		 || 'documentContentUpdated' === m.type ){
			if( m.doc ){
				var docId = m.docId;
				if( this.cacheByDocId[docId] ){
					this.cacheByDocId[docId] = m.doc;
				};
				
				// Need to reload view
				this._loadView();
			};

		} else if( 'documentDeleted' === m.type ){
			var docId = m.docId;
			if( this.cacheByDocId[docId] ){
				delete this.cacheByDocId[docId];
			};

			var docInfo = this.docsById[docId];
			if( docInfo ){
				delete this.docsById[docId];
				
				var removed = [docInfo.clone];
				this._reportStateUpdate([], [], removed);
			};

		} else if( 'documentVersion' === m.type ) {
			var cachedDoc = this.cacheByDocId[m.docId];
			if( cachedDoc 
			 && cachedDoc._rev !== m.rev ){
				delete this.cacheByDocId[m.docId];
			};

		} else if( 'cacheRetrieveDocument' === m.type ) {
			var cachedDoc = this.cacheByDocId[m.docId];
			if( cachedDoc ){
				m.doc = cachedDoc;
			};
			
		} else if( 'modelGetInfo' === m.type ) {
			if( m.modelId === this.modelId ){
				m.modelInfo = {
					modelId: this.modelId
					,modelType: 'couchDbView'
					,parameters: {}
					,_instance: this
				};
			};
			
		} else if( 'modelGetState' === m.type ) {
			if( m.modelId === this.modelId ){
				var added = [];
				for(var docId in this.docsById){
					var docInfo = this.docsById[docId];
					var doc = docInfo.clone;
					added.push(doc);
				};

				m.state = {
					added: added
					,updated: []
					,removed: []
					,loading: this.isLoading()
				};
			};
		};
	},
	
	_reportStateUpdate: function(added, updated, removed){
		var stateUpdate = {
			added: added
			,updated: updated
			,removed: removed
			,loading: this.isLoading()
		};

		if( this.dispatchService ){
			this.dispatchService.send(DH,{
				type: 'modelStateUpdated'
				,modelId: this.modelId
				,state: stateUpdate
			});
		};
	}
});

//--------------------------------------------------------------------------
function handleModelCreate(m){
	if( 'couchDb' === m.modelType 
	 || 'couchDbDataSource' === m.modelType ){

		var options = {
			modelId: m.modelId
		};
		
		if( m && m.config ){
			options.atlasDesign = m.config.atlasDesign;
			options.siteDesign = m.config.siteDesign;
			options.documentSource = m.config.documentSource;
			
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		var dbPerspective = new DbPerspective(options);
		
		// Load layers
		if( m.modelOptions 
		 && m.modelOptions.selectors ){
			var selectors = m.modelOptions.selectors;
			for(var i=0,e=selectors.length; i<e; ++i){
				var selectorConfig = selectors[i];
				dbPerspective.addDbSelectorFromConfigObject(selectorConfig);
			};
		};
		
		m.model = dbPerspective;
		m.created = true;

	} else if( 'couchDbView' === m.modelType  ){

		var options = {};
		
		if( m.modelOptions ){
			for(var key in m.modelOptions){
				options[key] = m.modelOptions[key];
			};
		};

		options.modelId = m.modelId;
		
		if( m.config ){
			options.atlasDesign = m.config.atlasDesign;
			options.siteDesign = m.config.siteDesign;
			
			if( m.config.directory ){
				options.dispatchService = m.config.directory.dispatchService;
			};
		};
		
		m.model = new ModelCouchDbView(options);
		
		m.created = true;
	};
};

//--------------------------------------------------------------------------
var DbPerspectiveChooser = $n2.Class({
	
	elemId: null,
	
	dispatchService: null,
	
	sourceModelId: null,
	
	dbPerspective: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,sourceModelId: null
			,containerId: null
		},opts_);
		
		var _this = this;
		
		this.dispatchService = opts.dispatchService;
		this.sourceModelId = opts.sourceModelId;

		if( this.dispatchService ){
			var m = {
				type: 'modelGetInfo'
				,modelId: this.sourceModelId
			};
			
			this.dispatchService.synchronousCall(DH,m);
			
			if( m.modelInfo ){
				this.dbPerspective = m.modelInfo._instance;
			};
		};
		
		var containerId = opts.containerId;
		if( !containerId ){
			throw new Error('containerId must be specified');
		};
		
		this.elemId = $n2.getUniqueId();
		var $outer = $('<div>')
			.attr('id',this.elemId)
			.addClass('n2dbPerspective_chooser')
			.appendTo( $('#'+containerId) );
		
		if( opts.style ){
			for(var name in opts.style){
				var value = opts.style[name];
				if( value ){
					$outer.css(name,value);
				};
			};
		};
		
		$('<div>')
			.addClass('n2dbPerspective_chooser_button')
			.appendTo($outer).
			click(function(){
				_this._togglePanel();
			});
		
		$('<div>')
			.addClass('n2dbPerspective_chooser_panel')
			.appendTo($outer);
		
		this._hidePanel();
		
		//this._refresh();
		
		if( this.dbPerspective ){
			this.dbPerspective.addSelectorListener(function(selectorInfos){
				_this._refresh();
			});
		};
	},
	
	_refresh: function(){
		var $elem = this._getElem();
		var $panel = $elem.find('.n2dbPerspective_chooser_panel');
		$panel.empty();
		
		if( this.dbPerspective ){
			var selectorInfos = this.dbPerspective.getDbSelectorInfos();
			for(var i=0,e=selectorInfos.length; i<e; ++i){
				var selectorInfo = selectorInfos[i];
				this._addSelector($panel, selectorInfo);
			};
		};
	},
	
	_addSelector: function($elem, selectorInfo){
		var _this = this;
		var elemId = $n2.getUniqueId();
		var name = $n2.getUniqueId();
		var $div = $('<div>')
			.attr('id',elemId)
			.addClass('n2dbPerspective_chooser_line')
			.appendTo($elem);
		
		// Checkbox
		var $inputDiv = $('<div>')
			.addClass('n2dbPerspective_chooser_line_input')
			.appendTo($div);
		var $input = $('<input>')
			.attr('type','checkbox')
			.attr('id',name)
			.appendTo($inputDiv)
			.change(function(){
				var selected = $('#'+elemId).find('input').is(':checked');
				_this.dbPerspective.setDbSelectorVisibility(selectorInfo.id,selected);
			});
		if( selectorInfo.visible ){
			$input.attr('checked','checked');
		};
		
		// Label
		var label = _loc(selectorInfo.name);
		var $labelDiv = $('<div>')
			.addClass('n2dbPerspective_chooser_line_label')
			.appendTo($div);
		$('<label>')
			.attr('for',name)
			.text(label)
			.appendTo($labelDiv);
	},
	
	_togglePanel: function(){
		var $elem = this._getElem();
		var $panel = $elem.find('.n2dbPerspective_chooser_panel');
		
		if( $panel.hasClass('n2dbPerspective_chooser_panel_on') ){
			this._hidePanel();
		} else {
			this._showPanel();
		};
	},
	
	_showPanel: function(){
		var $elem = this._getElem();
		var $panel = $elem.find('.n2dbPerspective_chooser_panel');
		$panel.removeClass('n2dbPerspective_chooser_panel_off');
		$panel.addClass('n2dbPerspective_chooser_panel_on');
	},
	
	_hidePanel: function(){
		var $elem = this._getElem();
		var $panel = $elem.find('.n2dbPerspective_chooser_panel');
		$panel.removeClass('n2dbPerspective_chooser_panel_on');
		$panel.addClass('n2dbPerspective_chooser_panel_off');
	},
	
	_getElem: function(){
		return $('#'+this.elemId);
	}
});

//--------------------------------------------------------------------------
function HandleWidgetAvailableRequests(m){
	if( m.widgetType === 'couchDbSelector' ){
      m.isAvailable = true;
	};
};

//--------------------------------------------------------------------------
function HandleWidgetDisplayRequests(m){
	if( m.widgetType === 'couchDbSelector' ){
		var widgetOptions = m.widgetOptions;
		var contentId = m.contentId;
		var containerId = m.containerId;
		var config = m.config;
		
		var options = {};
		
		if( widgetOptions ){
			for(var key in widgetOptions){
				var value = widgetOptions[key];
				options[key] = value;
			};
		};

		options.contentId = contentId;
		options.containerId = containerId;
		
		if( config && config.directory ){
			options.dispatchService = config.directory.dispatchService;
		};
		
		new DbPerspectiveChooser(options);
	};
};

//--------------------------------------------------------------------------
$n2.couchDbPerspective = {
	DbPerspective: DbPerspective
	,DbSelector: DbSelector
	,CouchLayerDbSelector: CouchLayerDbSelector
	,handleModelCreate: handleModelCreate
	,DbPerspectiveChooser: DbPerspectiveChooser
	,HandleWidgetAvailableRequests: HandleWidgetAvailableRequests
	,HandleWidgetDisplayRequests: HandleWidgetDisplayRequests
};

})(jQuery,nunaliit2);

// *** File: /home/dzhang/selfdev/nunaliit/nunaliit/nunaliit2-js/src/main/js/nunaliit2/n2.couchSimplifiedGeometries.js

/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/

;(function($,$n2){
"use strict";

// Localization
//var _loc = function(str,args){ return $n2.loc(str,'nunaliit2-couch',args); };

var DH = 'n2.couchSimplifiedGeometry';
	
//*******************************************************
var SimplifiedGeometryService = $n2.Class({

	url: null,

	dispatchService: null,
	
	customService: null,
	
	documentCache: null,
	
	dbName: null,

	dbProjection: null,

	pendingRequests: null,

	/*
	 * Boolean. True when communicating with server
	 */
	sendingRequests: null,

	initialize: function(opts_){
		var opts = $n2.extend({
			url: null
			,dispatchService: null
			,customService: null
			,indexedDbService: null
			,dbName: null
		},opts_);
		
		var _this = this;

		this.url = opts.url;
		this.dispatchService = opts.dispatchService;
		this.customService = opts.customService;
		this.dbName = opts.dbName;

		if( opts.indexedDbService ){
			this.documentCache = opts.indexedDbService.getDocumentCache();
		};
		
		this.sendingRequests = false;
		this.pendingRequests = {};
		
		this.dbProjection = null;
		if( typeof OpenLayers !== 'undefined' && OpenLayers.Projection ){
			this.dbProjection = new OpenLayers.Projection('EPSG:4326');
		};
		
		if( this.dispatchService ){
			var f = function(m, address, dispatchService){
				_this._handleDispatch(m, address, dispatchService);
			};
			
			this.dispatchService.register(DH, 'simplifiedGeometryRequest', f);
		};
	},
	
	_handleDispatch: function(m, address, dispatchService){
		if( 'simplifiedGeometryRequest' === m.type ){
			var requesterId = m.requester;
			// Structure for the requests:
			// {
			//    id: <string - docId>
			//    ,attName: <string - attachment name>
			// }
			if( !$n2.isArray(m.geometriesRequested) ){
				throw new Error('Event simplifiedGeometryRequest should have an array for "geometriesRequested"');
			};
			m.geometriesRequested.forEach(function(geometryRequest){
				if( typeof geometryRequest !== 'object' ){
					throw new Error('In event simplifiedGeometryRequest, geometriesRequested[*] should be an object');
				};
				if( typeof geometryRequest.id !== 'string' ){
					throw new Error('In event simplifiedGeometryRequest, geometriesRequested[*].id should be a string');
				};
				if( typeof geometryRequest.attName !== 'string' ){
					throw new Error('In event simplifiedGeometryRequest, geometriesRequested[*].attName should be a string');
				};
			});
			this._handleRequest(requesterId, m.geometriesRequested);
		};
	},
	
	_handleRequest: function(requesterId, geometriesRequested){
		this.pendingRequests[requesterId] = geometriesRequested;
		
		var count = 0;
		for(var id in this.pendingRequests){
			count += this.pendingRequests[id].length;
		};
		//$n2.log('Pending simplified geometry requests: '+count);
		
		this._sendRequests();
	},
		
	_sendRequests: function(){
		var _this = this;
		
		var outstandingRequests;
		var serverRequests;
		var cacheResults;
		
		if( this.sendingRequests ) return;

		this.sendingRequests = true;
		
		next();

		// This function turns the pending requests into an array of requests
		// stored in "outstandingRequests"
		function next(){
			var requested = {};
			outstandingRequests = [];
			
			for(var id in _this.pendingRequests){
				var geomRequests = _this.pendingRequests[id];
				
				for(var i=0,e=geomRequests.length; i<e; ++i){
					var geomRequest = geomRequests[i];
					
					var attNames = requested[geomRequest.id];
					if( !attNames ){
						attNames = {};
						requested[geomRequest.id] = attNames;
					};

					if( attNames[geomRequest.attName] ){
						// Already in this request
					} else {
						attNames[geomRequest.attName] = true;
						
						var geometryRequest = {
							id: geomRequest.id
							,attName: geomRequest.attName
						};
						
						outstandingRequests.push(geometryRequest);
					};
				};
			};
			
			if( outstandingRequests.length <= 0 ){
				// Nothing left to do
				_this.sendingRequests = false;

			} else {
				if( _this.documentCache && _this.dbName ){
					serverRequests = [];
					cacheResults = [];
					checkDocumentCache();
				} else {
					// Fallback on server
					serverRequests = outstandingRequests;
					processServerRequests();
				};
			};
		};
		
		// This function checks the document cache for the requests. It consumes the requests
		// from outstandingRequests and populates serverRequests (destined for the remote
		// server) and cacheResults with already known attachments
		function checkDocumentCache(){
			if( outstandingRequests.length <= 0 || serverRequests.length >= 100 ){
				// Clean up requests pending
				_this._cleanUpPendingRequests(cacheResults);

				// Done
				if( cacheResults.length > 0 ){
					_this.dispatchService.send(DH,{
						type: 'simplifiedGeometryReport'
						,simplifiedGeometries: cacheResults
					});
					
					cacheResults = [];
				};
				
				// Continue sending requests to the server
				processServerRequests();

			} else {
				var request = outstandingRequests.shift();
				
				_this.documentCache.getAttachment({
					dbName: _this.dbName
					,docId: request.id
					,attName: request.attName
					,onSuccess: function(att, rev){
						if( att ){
							var simplifiedGeometry = {
		        				id: request.id
		        				,rev: rev
		        				,attName: request.attName
		        				,wkt: att
							};

							if( _this.dbProjection ){
		        				simplifiedGeometry.proj = _this.dbProjection;
		        			};
							
		        			cacheResults.push(simplifiedGeometry);
							
						} else {
							// Not in cache. Request to server
							serverRequests.push(request);
						};

						// Go to next one
						checkDocumentCache();
					}
					,onError: function(err){
						// Problem accessing the cache... send to server
						serverRequests.push(request);
						
						checkDocumentCache();
					}
				});
			};
		};

		function processServerRequests(){
			var serverRequest = {
				geometryRequests: serverRequests
			};
			
			// Cut of to 100 to make the request of a manageable size
			if( serverRequest.geometryRequests.length > 100 ){
				serverRequest.geometryRequests = serverRequest.geometryRequests.slice(0,100);
			};

			// sizeLimit
			if( _this.customService ){
				var sizeLimit = _this.customService.getOption('simplifiedGeometriesSizeLimit');
				if( typeof sizeLimit === 'number' ){
					serverRequest.sizeLimit = sizeLimit;
				};
			};

			// timeLimit
			if( _this.customService ){
				var timeLimit = _this.customService.getOption('simplifiedGeometriesTimeLimit');
				if( typeof timeLimit === 'number' ){
					serverRequest.timeLimit = timeLimit;
				};
			};
			
			if( serverRequest.geometryRequests.length > 0 ){
				$.ajax({
			    	url: _this.url + 'getAttachments'
			    	,type: 'post'
			    	,async: true
			    	,data: JSON.stringify(serverRequest)
			    	,contentType: 'application/json'
			    	,dataType: 'json'
			    	,success: function(jsonResp) {
			    		if( jsonResp && jsonResp.geometries ) {
			    			receiveSimplifiedGeometries(jsonResp.geometries);
			    		} else {
			    			// Did not receive anything
			    			next();
			    		};
			    	}
			    	,error: function(XMLHttpRequest, textStatus, errorThrown) {
						$n2.log('Unable to get simplified geometries',serverRequest);
						
						// Remove one request
						var id = undefined;
						for(id in _this.pendingRequests){
							break;
						};
						if( id ){
							delete _this.pendingRequests[id];
						};
						
						next();
			    	}
				});
			} else {
				next();
			};
		};
		
		function receiveSimplifiedGeometries(geometries){
			var simplifiedGeometries = [];
			for(var i=0,e=geometries.length; i<e; ++i){
				var geomResp = geometries[i];
				
				if( geomResp.att && geomResp.att.length > 0 ){
	    			var simplifiedGeometry = {
        				id: geomResp.id
        				,rev: geomResp.rev
        				,attName: geomResp.attName
        				,wkt: geomResp.att
        			};
        			
        			if( _this.dbProjection ){
        				simplifiedGeometry.proj = _this.dbProjection;
        			};
        			
        			simplifiedGeometries.push(simplifiedGeometry);
				};
			};
			
			// Cache simplified geometries with indexed db service
			if( _this.dbName && _this.documentCache ){
				var changes = [];
				geometries.forEach(function(geomResp){
					var change = {
						dbName: _this.dbName
        				,id: geomResp.id
        				,rev: geomResp.rev
        				,attachments: {}
					};
					change.attachments[geomResp.attName] = geomResp.att;
					changes.push(change);
				});
				_this.documentCache.performChanges(changes);
			};
			
			// Clean up requests pending
			_this._cleanUpPendingRequests(simplifiedGeometries);
			
			if( simplifiedGeometries.length > 0 ){
				_this.dispatchService.send(DH,{
					type: 'simplifiedGeometryReport'
					,simplifiedGeometries: simplifiedGeometries
				});
			};
			
			next();
		};
	},
	
	_cleanUpPendingRequests: function(simplifiedGeometries){
		// Make a map of what we have received
		var received = {};
		simplifiedGeometries.forEach(function(simplifiedGeometry){
			var docId = simplifiedGeometry.id;
			var attName = simplifiedGeometry.attName;

			var attNames = received[docId];
			if( !attNames ){
				attNames = {};
				received[docId] = attNames;
			};

			attNames[attName] = true;
		});

		// Clean up pending requests based on responses
		for(var requesterId in this.pendingRequests){
			var currentRequests = this.pendingRequests[requesterId];
			var pendingRequests = [];
			currentRequests.forEach(function(r){
				if( received[r.id] && received[r.id][r.attName] ){
					// No longer pending
				} else {
					pendingRequests.push(r);
				};
			});
			
			this.pendingRequests[requesterId] = pendingRequests;
		};
	}
});

//*******************************************************
$n2.couchSimplifiedGeometries = {
	Service: SimplifiedGeometryService	
};

})(jQuery,nunaliit2);

